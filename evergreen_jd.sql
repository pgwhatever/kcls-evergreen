--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: acq; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA acq;


ALTER SCHEMA acq OWNER TO postgres;

--
-- Name: action; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA action;


ALTER SCHEMA action OWNER TO postgres;

--
-- Name: action_trigger; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA action_trigger;


ALTER SCHEMA action_trigger OWNER TO postgres;

--
-- Name: actor; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA actor;


ALTER SCHEMA actor OWNER TO postgres;

--
-- Name: SCHEMA actor; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA actor IS '
Holds all tables pertaining to users and libraries (org units).
';


--
-- Name: asset; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA asset;


ALTER SCHEMA asset OWNER TO postgres;

--
-- Name: auditor; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA auditor;


ALTER SCHEMA auditor OWNER TO postgres;

--
-- Name: authority; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA authority;


ALTER SCHEMA authority OWNER TO postgres;

--
-- Name: biblio; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA biblio;


ALTER SCHEMA biblio OWNER TO postgres;

--
-- Name: booking; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA booking;


ALTER SCHEMA booking OWNER TO postgres;

--
-- Name: config; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA config;


ALTER SCHEMA config OWNER TO postgres;

--
-- Name: SCHEMA config; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA config IS '
The config schema holds static configuration data for the
Evergreen installation.
';


--
-- Name: container; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA container;


ALTER SCHEMA container OWNER TO postgres;

--
-- Name: evergreen; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA evergreen;


ALTER SCHEMA evergreen OWNER TO postgres;

--
-- Name: extend_reporter; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA extend_reporter;


ALTER SCHEMA extend_reporter OWNER TO postgres;

--
-- Name: metabib; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA metabib;


ALTER SCHEMA metabib OWNER TO postgres;

--
-- Name: money; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA money;


ALTER SCHEMA money OWNER TO postgres;

--
-- Name: offline; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA offline;


ALTER SCHEMA offline OWNER TO postgres;

--
-- Name: permission; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA permission;


ALTER SCHEMA permission OWNER TO postgres;

--
-- Name: query; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA query;


ALTER SCHEMA query OWNER TO postgres;

--
-- Name: SCHEMA query; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA query IS '
Contains tables designed to represent user-defined queries for
reports and the like.
';


--
-- Name: reporter; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA reporter;


ALTER SCHEMA reporter OWNER TO postgres;

--
-- Name: search; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA search;


ALTER SCHEMA search OWNER TO postgres;

--
-- Name: serial; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA serial;


ALTER SCHEMA serial OWNER TO postgres;

--
-- Name: staging; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA staging;


ALTER SCHEMA staging OWNER TO postgres;

--
-- Name: stats; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA stats;


ALTER SCHEMA stats OWNER TO postgres;

--
-- Name: unapi; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA unapi;


ALTER SCHEMA unapi OWNER TO postgres;

--
-- Name: url_verify; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA url_verify;


ALTER SCHEMA url_verify OWNER TO postgres;

--
-- Name: vandelay; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA vandelay;


ALTER SCHEMA vandelay OWNER TO postgres;

--
-- Name: plperlu; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperlu;


ALTER PROCEDURAL LANGUAGE plperlu OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA public;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- Name: xml2; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS xml2 WITH SCHEMA public;


--
-- Name: EXTENSION xml2; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION xml2 IS 'XPath querying and XSLT';


SET search_path = acq, pg_catalog;

--
-- Name: flat_lineitem_detail; Type: TYPE; Schema: acq; Owner: postgres
--

CREATE TYPE flat_lineitem_detail AS (
	lineitem integer,
	holding integer,
	attr text,
	data text
);


ALTER TYPE acq.flat_lineitem_detail OWNER TO postgres;

--
-- Name: flat_lineitem_holding_subfield; Type: TYPE; Schema: acq; Owner: postgres
--

CREATE TYPE flat_lineitem_holding_subfield AS (
	lineitem integer,
	holding integer,
	subfield text,
	data text
);


ALTER TYPE acq.flat_lineitem_holding_subfield OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: circ_chain_summary; Type: TYPE; Schema: action; Owner: postgres
--

CREATE TYPE circ_chain_summary AS (
	num_circs integer,
	start_time timestamp with time zone,
	checkout_workstation text,
	last_renewal_time timestamp with time zone,
	last_stop_fines text,
	last_stop_fines_time timestamp with time zone,
	last_renewal_workstation text,
	last_checkin_workstation text,
	last_checkin_time timestamp with time zone,
	last_checkin_scan_time timestamp with time zone
);


ALTER TYPE action.circ_chain_summary OWNER TO postgres;

--
-- Name: circ_matrix_test_result; Type: TYPE; Schema: action; Owner: postgres
--

CREATE TYPE circ_matrix_test_result AS (
	success boolean,
	fail_part text,
	buildrows integer[],
	matchpoint integer,
	circulate boolean,
	duration_rule integer,
	recurring_fine_rule integer,
	max_fine_rule integer,
	hard_due_date integer,
	renewals integer,
	grace_period interval,
	limit_groups integer[]
);


ALTER TYPE action.circ_matrix_test_result OWNER TO postgres;

SET search_path = config, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: circ_matrix_matchpoint; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    grp integer NOT NULL,
    circ_modifier text,
    copy_location integer,
    marc_type text,
    marc_form text,
    marc_bib_level text,
    marc_vr_format text,
    copy_circ_lib integer,
    copy_owning_lib integer,
    user_home_ou integer,
    ref_flag boolean,
    juvenile_flag boolean,
    is_renewal boolean,
    usr_age_lower_bound interval,
    usr_age_upper_bound interval,
    item_age interval,
    circulate boolean,
    duration_rule integer,
    recurring_fine_rule integer,
    max_fine_rule integer,
    hard_due_date integer,
    renewals integer,
    grace_period interval,
    script_test text,
    total_copy_hold_ratio double precision,
    available_copy_hold_ratio double precision
);


ALTER TABLE config.circ_matrix_matchpoint OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: found_circ_matrix_matchpoint; Type: TYPE; Schema: action; Owner: postgres
--

CREATE TYPE found_circ_matrix_matchpoint AS (
	success boolean,
	matchpoint config.circ_matrix_matchpoint,
	buildrows integer[]
);


ALTER TYPE action.found_circ_matrix_matchpoint OWNER TO postgres;

--
-- Name: hold_stats; Type: TYPE; Schema: action; Owner: postgres
--

CREATE TYPE hold_stats AS (
	hold_count integer,
	copy_count integer,
	available_count integer,
	total_copy_ratio double precision,
	available_copy_ratio double precision
);


ALTER TYPE action.hold_stats OWNER TO postgres;

--
-- Name: matrix_test_result; Type: TYPE; Schema: action; Owner: postgres
--

CREATE TYPE matrix_test_result AS (
	success boolean,
	matchpoint integer,
	fail_part text
);


ALTER TYPE action.matrix_test_result OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: org_unit_custom_tree_purpose; Type: TYPE; Schema: actor; Owner: postgres
--

CREATE TYPE org_unit_custom_tree_purpose AS ENUM (
    'opac'
);


ALTER TYPE actor.org_unit_custom_tree_purpose OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: marc21_physical_characteristics; Type: TYPE; Schema: biblio; Owner: postgres
--

CREATE TYPE marc21_physical_characteristics AS (
	id integer,
	record bigint,
	ptype text,
	subfield integer,
	value integer
);


ALTER TYPE biblio.marc21_physical_characteristics OWNER TO postgres;

--
-- Name: record_ff_map; Type: TYPE; Schema: biblio; Owner: postgres
--

CREATE TYPE record_ff_map AS (
	record bigint,
	ff_name text,
	ff_value text
);


ALTER TYPE biblio.record_ff_map OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: usr_activity_group; Type: TYPE; Schema: config; Owner: postgres
--

CREATE TYPE usr_activity_group AS ENUM (
    'authen',
    'authz',
    'circ',
    'hold',
    'search'
);


ALTER TYPE config.usr_activity_group OWNER TO postgres;

SET search_path = evergreen, pg_catalog;

--
-- Name: barcode_set; Type: TYPE; Schema: evergreen; Owner: postgres
--

CREATE TYPE barcode_set AS (
	type text,
	id bigint,
	barcode text
);


ALTER TYPE evergreen.barcode_set OWNER TO postgres;

--
-- Name: patch; Type: TYPE; Schema: evergreen; Owner: postgres
--

CREATE TYPE patch AS (
	patch text
);


ALTER TYPE evergreen.patch OWNER TO postgres;

SET search_path = metabib, pg_catalog;

--
-- Name: field_entry_template; Type: TYPE; Schema: metabib; Owner: postgres
--

CREATE TYPE field_entry_template AS (
	field_class text,
	field integer,
	facet_field boolean,
	search_field boolean,
	browse_field boolean,
	source bigint,
	value text
);


ALTER TYPE metabib.field_entry_template OWNER TO postgres;

--
-- Name: rec_desc_type; Type: TYPE; Schema: metabib; Owner: postgres
--

CREATE TYPE rec_desc_type AS (
	item_type text,
	item_form text,
	bib_level text,
	control_type text,
	char_encoding text,
	enc_level text,
	audience text,
	lit_form text,
	type_mat text,
	cat_form text,
	pub_status text,
	item_lang text,
	vr_format text,
	date1 text,
	date2 text
);


ALTER TYPE metabib.rec_desc_type OWNER TO postgres;

SET search_path = search, pg_catalog;

--
-- Name: search_args; Type: TYPE; Schema: search; Owner: postgres
--

CREATE TYPE search_args AS (
	id integer,
	field_class text,
	field_name text,
	table_alias text,
	term text,
	term_type text
);


ALTER TYPE search.search_args OWNER TO postgres;

--
-- Name: search_result; Type: TYPE; Schema: search; Owner: postgres
--

CREATE TYPE search_result AS (
	id bigint,
	rel numeric,
	record integer,
	total integer,
	checked integer,
	visible integer,
	deleted integer,
	excluded integer
);


ALTER TYPE search.search_result OWNER TO postgres;

SET search_path = vandelay, pg_catalog;

--
-- Name: authority_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE authority_queue_queue_type AS ENUM (
    'authority'
);


ALTER TYPE vandelay.authority_queue_queue_type OWNER TO postgres;

--
-- Name: bib_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE bib_queue_queue_type AS ENUM (
    'bib',
    'acq'
);


ALTER TYPE vandelay.bib_queue_queue_type OWNER TO postgres;

--
-- Name: compile_profile; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE compile_profile AS (
	add_rule text,
	replace_rule text,
	preserve_rule text,
	strip_rule text
);


ALTER TYPE vandelay.compile_profile OWNER TO postgres;

--
-- Name: flat_marc; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE flat_marc AS (
	tag character(3),
	ind1 text,
	ind2 text,
	subfield text,
	value text
);


ALTER TYPE vandelay.flat_marc OWNER TO postgres;

--
-- Name: match_set_test_result; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE match_set_test_result AS (
	record bigint,
	quality integer
);


ALTER TYPE vandelay.match_set_test_result OWNER TO postgres;

--
-- Name: tcn_data; Type: TYPE; Schema: vandelay; Owner: postgres
--

CREATE TYPE tcn_data AS (
	tcn text,
	tcn_source text,
	used boolean
);


ALTER TYPE vandelay.tcn_data OWNER TO postgres;

SET search_path = acq, pg_catalog;

--
-- Name: attribute_debits(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION attribute_debits() RETURNS void
    LANGUAGE plpgsql
    AS $$
/*
Function to attribute expenditures and encumbrances to funding source credits,
and thereby to funding sources.

Read the debits in chonological order, attributing each one to one or
more funding source credits.  Constraints:

1. Don't attribute more to a credit than the amount of the credit.

2. For a given fund, don't attribute more to a funding source than the
source has allocated to that fund.

3. Attribute debits to credits with deadlines before attributing them to
credits without deadlines.  Otherwise attribute to the earliest credits
first, based on the deadline date when present, or on the effective date
when there is no deadline.  Use funding_source_credit.id as a tie-breaker.
This ordering is defined by an ORDER BY clause on the view
acq.ordered_funding_source_credit.

Start by truncating the table acq.debit_attribution.  Then insert a row
into that table for each attribution.  If a debit cannot be fully
attributed, insert a row for the unattributable balance, with the 
funding_source_credit and credit_amount columns NULL.
*/
DECLARE
	curr_fund_source_bal RECORD;
	seqno                INT;     -- sequence num for credits applicable to a fund
	fund_credit          RECORD;  -- current row in temp t_fund_credit table
	fc                   RECORD;  -- used for loading t_fund_credit table
	sc                   RECORD;  -- used for loading t_fund_credit table
	--
	-- Used exclusively in the main loop:
	--
	deb                 RECORD;   -- current row from acq.fund_debit table
	curr_credit_bal     RECORD;   -- current row from temp t_credit table
	debit_balance       NUMERIC;  -- amount left to attribute for current debit
	conv_debit_balance  NUMERIC;  -- debit balance in currency of the fund
	attr_amount         NUMERIC;  -- amount being attributed, in currency of debit
	conv_attr_amount    NUMERIC;  -- amount being attributed, in currency of source
	conv_cred_balance   NUMERIC;  -- credit_balance in the currency of the fund
	conv_alloc_balance  NUMERIC;  -- allocated balance in the currency of the fund
	attrib_count        INT;      -- populates id of acq.debit_attribution
BEGIN
	--
	-- Load a temporary table.  For each combination of fund and funding source,
	-- load an entry with the total amount allocated to that fund by that source.
	-- This sum may reflect transfers as well as original allocations.  We will
	-- reduce this balance whenever we attribute debits to it.
	--
	CREATE TEMP TABLE t_fund_source_bal
	ON COMMIT DROP AS
		SELECT
			fund AS fund,
			funding_source AS source,
			sum( amount ) AS balance
		FROM
			acq.fund_allocation
		GROUP BY
			fund,
			funding_source
		HAVING
			sum( amount ) > 0;
	--
	CREATE INDEX t_fund_source_bal_idx
		ON t_fund_source_bal( fund, source );
	-------------------------------------------------------------------------------
	--
	-- Load another temporary table.  For each fund, load zero or more
	-- funding source credits from which that fund can get money.
	--
	CREATE TEMP TABLE t_fund_credit (
		fund        INT,
		seq         INT,
		credit      INT
	) ON COMMIT DROP;
	--
	FOR fc IN
		SELECT DISTINCT fund
		FROM acq.fund_allocation
		ORDER BY fund
	LOOP                  -- Loop over the funds
		seqno := 1;
		FOR sc IN
			SELECT
				ofsc.id
			FROM
				acq.ordered_funding_source_credit AS ofsc
			WHERE
				ofsc.funding_source IN
				(
					SELECT funding_source
					FROM acq.fund_allocation
					WHERE fund = fc.fund
				)
    		ORDER BY
    		    ofsc.sort_priority,
    		    ofsc.sort_date,
    		    ofsc.id
		LOOP                        -- Add each credit to the list
			INSERT INTO t_fund_credit (
				fund,
				seq,
				credit
			) VALUES (
				fc.fund,
				seqno,
				sc.id
			);
			--RAISE NOTICE 'Fund % credit %', fc.fund, sc.id;
			seqno := seqno + 1;
		END LOOP;     -- Loop over credits for a given fund
	END LOOP;         -- Loop over funds
	--
	CREATE INDEX t_fund_credit_idx
		ON t_fund_credit( fund, seq );
	-------------------------------------------------------------------------------
	--
	-- Load yet another temporary table.  This one is a list of funding source
	-- credits, with their balances.  We shall reduce those balances as we
	-- attribute debits to them.
	--
	CREATE TEMP TABLE t_credit
	ON COMMIT DROP AS
        SELECT
            fsc.id AS credit,
            fsc.funding_source AS source,
            fsc.amount AS balance,
            fs.currency_type AS currency_type
        FROM
            acq.funding_source_credit AS fsc,
            acq.funding_source fs
        WHERE
            fsc.funding_source = fs.id
			AND fsc.amount > 0;
	--
	CREATE INDEX t_credit_idx
		ON t_credit( credit );
	--
	-------------------------------------------------------------------------------
	--
	-- Now that we have loaded the lookup tables: loop through the debits,
	-- attributing each one to one or more funding source credits.
	-- 
	truncate table acq.debit_attribution;
	--
	attrib_count := 0;
	FOR deb in
		SELECT
			fd.id,
			fd.fund,
			fd.amount,
			f.currency_type,
			fd.encumbrance
		FROM
			acq.fund_debit fd,
			acq.fund f
		WHERE
			fd.fund = f.id
		ORDER BY
			fd.id
	LOOP
		--RAISE NOTICE 'Debit %, fund %', deb.id, deb.fund;
		--
		debit_balance := deb.amount;
		--
		-- Loop over the funding source credits that are eligible
		-- to pay for this debit
		--
		FOR fund_credit IN
			SELECT
				credit
			FROM
				t_fund_credit
			WHERE
				fund = deb.fund
			ORDER BY
				seq
		LOOP
			--RAISE NOTICE '   Examining credit %', fund_credit.credit;
			--
			-- Look up the balance for this credit.  If it's zero, then
			-- it's not useful, so treat it as if you didn't find it.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_credit_bal
			FROM t_credit
			WHERE
				credit = fund_credit.credit
				AND balance > 0;
			--
			IF curr_credit_bal IS NULL THEN
				--
				-- This credit is exhausted; try the next one.
				--
				CONTINUE;
			END IF;
			--
			--
			-- At this point we have an applicable credit with some money left.
			-- Now see if the relevant funding_source has any money left.
			--
			-- Look up the balance of the allocation for this combination of
			-- fund and source.  If you find such an entry, but it has a zero
			-- balance, then it's not useful, so treat it as unfound.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_fund_source_bal
			FROM t_fund_source_bal
			WHERE
				fund = deb.fund
				AND source = curr_credit_bal.source
				AND balance > 0;
			--
			IF curr_fund_source_bal IS NULL THEN
				--
				-- This fund/source doesn't exist or is already exhausted,
				-- so we can't use this credit.  Go on to the next one.
				--
				CONTINUE;
			END IF;
			--
			-- Convert the available balances to the currency of the fund
			--
			conv_alloc_balance := curr_fund_source_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			conv_cred_balance := curr_credit_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			--
			-- Determine how much we can attribute to this credit: the minimum
			-- of the debit amount, the fund/source balance, and the
			-- credit balance
			--
			--RAISE NOTICE '   deb bal %', debit_balance;
			--RAISE NOTICE '      source % balance %', curr_credit_bal.source, conv_alloc_balance;
			--RAISE NOTICE '      credit % balance %', curr_credit_bal.credit, conv_cred_balance;
			--
			conv_attr_amount := NULL;
			attr_amount := debit_balance;
			--
			IF attr_amount > conv_alloc_balance THEN
				attr_amount := conv_alloc_balance;
				conv_attr_amount := curr_fund_source_bal.balance;
			END IF;
			IF attr_amount > conv_cred_balance THEN
				attr_amount := conv_cred_balance;
				conv_attr_amount := curr_credit_bal.balance;
			END IF;
			--
			-- If we're attributing all of one of the balances, then that's how
			-- much we will deduct from the balances, and we already captured
			-- that amount above.  Otherwise we must convert the amount of the
			-- attribution from the currency of the fund back to the currency of
			-- the funding source.
			--
			IF conv_attr_amount IS NULL THEN
				conv_attr_amount := attr_amount * acq.exchange_ratio(
					deb.currency_type, curr_credit_bal.currency_type );
			END IF;
			--
			-- Insert a row to record the attribution
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				attr_amount,
				curr_credit_bal.credit,
				conv_attr_amount
			);
			--
			-- Subtract the attributed amount from the various balances
			--
			debit_balance := debit_balance - attr_amount;
			curr_fund_source_bal.balance := curr_fund_source_bal.balance - conv_attr_amount;
			--
			IF curr_fund_source_bal.balance <= 0 THEN
				--
				-- This allocation is exhausted.  Delete it so
				-- that we don't waste time looking at it again.
				--
				DELETE FROM t_fund_source_bal
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			ELSE
				UPDATE t_fund_source_bal
				SET balance = balance - conv_attr_amount
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			END IF;
			--
			IF curr_credit_bal.balance <= 0 THEN
				--
				-- This funding source credit is exhausted.  Delete it
				-- so that we don't waste time looking at it again.
				--
				--DELETE FROM t_credit
				--WHERE
				--	credit = curr_credit_bal.credit;
				--
				DELETE FROM t_fund_credit
				WHERE
					credit = curr_credit_bal.credit;
			ELSE
				UPDATE t_credit
				SET balance = curr_credit_bal.balance
				WHERE
					credit = curr_credit_bal.credit;
			END IF;
			--
			-- Are we done with this debit yet?
			--
			IF debit_balance <= 0 THEN
				EXIT;       -- We've fully attributed this debit; stop looking at credits.
			END IF;
		END LOOP;       -- End loop over credits
		--
		IF debit_balance <> 0 THEN
			--
			-- We weren't able to attribute this debit, or at least not
			-- all of it.  Insert a row for the unattributed balance.
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				debit_balance,
				NULL,
				NULL
			);
		END IF;
	END LOOP;   -- End of loop over debits
END;
$$;


ALTER FUNCTION acq.attribute_debits() OWNER TO postgres;

--
-- Name: audit_acq_lineitem_func(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION audit_acq_lineitem_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_lineitem_history
                SELECT	nextval('acq.acq_lineitem_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_lineitem_func() OWNER TO postgres;

--
-- Name: audit_acq_purchase_order_func(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION audit_acq_purchase_order_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_purchase_order_history
                SELECT	nextval('acq.acq_purchase_order_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_purchase_order_func() OWNER TO postgres;

--
-- Name: create_acq_auditor(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM acq.create_acq_seq(sch, tbl);
    PERFORM acq.create_acq_history(sch, tbl);
    PERFORM acq.create_acq_func(sch, tbl);
    PERFORM acq.create_acq_update_trigger(sch, tbl);
    PERFORM acq.create_acq_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION acq.create_acq_auditor(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_acq_func(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE FUNCTION acq.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO acq.$$ || sch || $$_$$ || tbl || $$_history
                SELECT	nextval('acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_func(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_acq_history(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE acq.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_history(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_acq_lifecycle(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE VIEW acq.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT	-1, now() as audit_time, '-' as audit_action, *
              FROM	$$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT	*
              FROM	acq.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_lifecycle(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_acq_seq(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_seq(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_acq_update_trigger(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION create_acq_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE acq.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_update_trigger(sch text, tbl text) OWNER TO postgres;

--
-- Name: exchange_ratio(text, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION exchange_ratio(from_ex text, to_ex text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    rat NUMERIC;
BEGIN
    IF from_ex = to_ex THEN
        RETURN 1.0;
    END IF;

    SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = from_ex AND to_currency = to_ex;

    IF FOUND THEN
        RETURN rat;
    ELSE
        SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = to_ex AND to_currency = from_ex;
        IF FOUND THEN
            RETURN 1.0/rat;
        END IF;
    END IF;

    RETURN NULL;

END;
$$;


ALTER FUNCTION acq.exchange_ratio(from_ex text, to_ex text) OWNER TO postgres;

--
-- Name: exchange_ratio(text, text, numeric); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION exchange_ratio(text, text, numeric) RETURNS numeric
    LANGUAGE sql
    AS $_$
    SELECT $3 * acq.exchange_ratio($1, $2);
$_$;


ALTER FUNCTION acq.exchange_ratio(text, text, numeric) OWNER TO postgres;

--
-- Name: extract_holding_attr_table(integer, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION extract_holding_attr_table(lineitem integer, tag text) RETURNS SETOF flat_lineitem_holding_subfield
    LANGUAGE plpgsql
    AS $$
DECLARE
    counter INT;
    lida    acq.flat_lineitem_holding_subfield%ROWTYPE;
BEGIN

    SELECT  COUNT(*) INTO counter
      FROM  oils_xpath_table(
                'id',
                'marc',
                'acq.lineitem',
                '//*[@tag="' || tag || '"]',
                'id=' || lineitem
            ) as t(i int,c text);

    FOR i IN 1 .. counter LOOP
        FOR lida IN
            SELECT  * 
              FROM  (   SELECT  id,i,t,v
                          FROM  oils_xpath_table(
                                    'id',
                                    'marc',
                                    'acq.lineitem',
                                    '//*[@tag="' || tag || '"][position()=' || i || ']/*/@code|' ||
                                        '//*[@tag="' || tag || '"][position()=' || i || ']/*[@code]',
                                    'id=' || lineitem
                                ) as t(id int,t text,v text)
                    )x
        LOOP
            RETURN NEXT lida;
        END LOOP;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_holding_attr_table(lineitem integer, tag text) OWNER TO postgres;

--
-- Name: extract_provider_holding_data(integer); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION extract_provider_holding_data(lineitem_i integer) RETURNS SETOF flat_lineitem_detail
    LANGUAGE plpgsql
    AS $$
DECLARE
    prov_i  INT;
    tag_t   TEXT;
    lida    acq.flat_lineitem_detail%ROWTYPE;
BEGIN
    SELECT provider INTO prov_i FROM acq.lineitem WHERE id = lineitem_i;
    IF NOT FOUND THEN RETURN; END IF;

    SELECT holding_tag INTO tag_t FROM acq.provider WHERE id = prov_i;
    IF NOT FOUND OR tag_t IS NULL THEN RETURN; END IF;

    FOR lida IN
        SELECT  lineitem_i,
                h.holding,
                a.name,
                h.data
          FROM  acq.extract_holding_attr_table( lineitem_i, tag_t ) h
                JOIN acq.provider_holding_subfield_map a USING (subfield)
          WHERE a.provider = prov_i
    LOOP
        RETURN NEXT lida;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_provider_holding_data(lineitem_i integer) OWNER TO postgres;

--
-- Name: fap_limit_100(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION fap_limit_100() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
--
total_percent numeric;
--
BEGIN
    SELECT
        sum( percent )
    INTO
        total_percent
    FROM
        acq.fund_allocation_percent AS fap
    WHERE
        fap.funding_source = NEW.funding_source;
    --
    IF total_percent > 100 THEN
        RAISE EXCEPTION 'Total percentages exceed 100 for funding_source %',
            NEW.funding_source;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION acq.fap_limit_100() OWNER TO postgres;

--
-- Name: find_bad_fy(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION find_bad_fy() RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	first_row  BOOLEAN;
	curr_year  RECORD;
	prev_year  RECORD;
	return_rec RECORD;
BEGIN
	first_row := true;
	FOR curr_year in
		SELECT
			id,
			calendar,
			year,
			year_begin,
			year_end
		FROM
			acq.fiscal_year
		ORDER BY
			calendar,
			year_begin
	LOOP
		--
		IF first_row THEN
			first_row := FALSE;
		ELSIF curr_year.calendar    = prev_year.calendar THEN
			IF curr_year.year_begin > prev_year.year_end THEN
				-- This ugly kludge works around the fact that older
				-- versions of PostgreSQL don't support RETURN QUERY SELECT
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Gap between fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year_begin < prev_year.year_end THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Overlapping fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year < prev_year.year THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Fiscal years out of order'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			END IF;
		END IF;
		--
		prev_year := curr_year;
	END LOOP;
	--
	RETURN;
END;
$$;


ALTER FUNCTION acq.find_bad_fy() OWNER TO postgres;

--
-- Name: fund_alloc_percent_val(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION fund_alloc_percent_val() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
--
DECLARE
--
dummy int := 0;
--
BEGIN
    SELECT
        1
    INTO
        dummy
    FROM
        acq.fund
    WHERE
        org = NEW.org
        AND code = NEW.fund_code
        LIMIT 1;
    --
    IF dummy = 1 then
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'No fund exists for org % and code %', NEW.org, NEW.fund_code;
    END IF;
END;
$$;


ALTER FUNCTION acq.fund_alloc_percent_val() OWNER TO postgres;

--
-- Name: po_org_name_date_unique(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION po_org_name_date_unique() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	collision INT;
BEGIN
	--
	-- If order_date is not null, then make sure we don't have a collision
	-- on order_date (truncated to day), org, and name
	--
	IF NEW.order_date IS NULL THEN
		RETURN NEW;
	END IF;
	--
	-- In the WHERE clause, we compare the order_dates without regard to time of day.
	-- We use a pair of inequalities instead of comparing truncated dates so that the
	-- query can do an indexed range scan.
	--
	SELECT 1 INTO collision
	FROM acq.purchase_order
	WHERE
		ordering_agency = NEW.ordering_agency
		AND name = NEW.name
		AND order_date >= date_trunc( 'day', NEW.order_date )
		AND order_date <  date_trunc( 'day', NEW.order_date ) + '1 day'::INTERVAL
		AND id <> NEW.id;
	--
	IF collision IS NULL THEN
		-- okay, no collision
		RETURN NEW;
	ELSE
		-- collision; nip it in the bud
		RAISE EXCEPTION 'Colliding purchase orders: ordering_agency %, date %, name ''%''',
			NEW.ordering_agency, NEW.order_date, NEW.name;
	END IF;
END;
$$;


ALTER FUNCTION acq.po_org_name_date_unique() OWNER TO postgres;

--
-- Name: propagate_funds_by_org_tree(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_id      INT;
old_fund    RECORD;
org_found   BOOLEAN;
--
BEGIN
	--
	-- Sanity checks
	--
	IF old_year IS NULL THEN
		RAISE EXCEPTION 'Input year argument is NULL';
	ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
		RAISE EXCEPTION 'Input year is out of range';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'Input user id argument is NULL';
	END IF;
	--
	IF org_unit_id IS NULL THEN
		RAISE EXCEPTION 'Org unit id argument is NULL';
	ELSE
		SELECT TRUE INTO org_found
		FROM actor.org_unit
		WHERE id = org_unit_id;
		--
		IF org_found IS NULL THEN
			RAISE EXCEPTION 'Org unit id is invalid';
		END IF;
	END IF;
	--
	-- Loop over the applicable funds
	--
	FOR old_fund in SELECT * FROM acq.fund
	WHERE
		year = old_year
		AND propagate
		AND ( ( include_desc AND org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND org = org_unit_id ) )
    
	LOOP
		BEGIN
			INSERT INTO acq.fund (
				org,
				name,
				year,
				currency_type,
				code,
				rollover,
				propagate,
				balance_warning_percent,
				balance_stop_percent
			) VALUES (
				old_fund.org,
				old_fund.name,
				old_year + 1,
				old_fund.currency_type,
				old_fund.code,
				old_fund.rollover,
				true,
				old_fund.balance_warning_percent,
				old_fund.balance_stop_percent
			)
			RETURNING id INTO new_id;
		EXCEPTION
			WHEN unique_violation THEN
				--RAISE NOTICE 'Fund % already propagated', old_fund.id;
				CONTINUE;
		END;
		--RAISE NOTICE 'Propagating fund % to fund %',
		--	old_fund.code, new_id;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean) OWNER TO postgres;

--
-- Name: propagate_funds_by_org_unit(integer, integer, integer); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.propagate_funds_by_org_tree( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION acq.propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) OWNER TO postgres;

--
-- Name: purchase_order_name_default(); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION purchase_order_name_default() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.name IS NULL THEN
		NEW.name := NEW.id::TEXT;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION acq.purchase_order_name_default() OWNER TO postgres;

--
-- Name: rollover_funds_by_org_tree(integer, integer, integer, boolean, boolean); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_fund    INT;
new_year    INT := old_year + 1;
org_found   BOOL;
perm_ous    BOOL;
xfer_amount NUMERIC := 0;
roll_fund   RECORD;
deb         RECORD;
detail      RECORD;
roll_distrib_forms BOOL;
--
BEGIN
	--
	-- Sanity checks
	--
	IF old_year IS NULL THEN
		RAISE EXCEPTION 'Input year argument is NULL';
    ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
        RAISE EXCEPTION 'Input year is out of range';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'Input user id argument is NULL';
	END IF;
	--
	IF org_unit_id IS NULL THEN
		RAISE EXCEPTION 'Org unit id argument is NULL';
	ELSE
		--
		-- Validate the org unit
		--
		SELECT TRUE
		INTO org_found
		FROM actor.org_unit
		WHERE id = org_unit_id;
		--
		IF org_found IS NULL THEN
			RAISE EXCEPTION 'Org unit id % is invalid', org_unit_id;
		ELSIF encumb_only THEN
			SELECT INTO perm_ous value::BOOL FROM
			actor.org_unit_ancestor_setting(
				'acq.fund.allow_rollover_without_money', org_unit_id
			);
			IF NOT FOUND OR NOT perm_ous THEN
				RAISE EXCEPTION 'Encumbrance-only rollover not permitted at org %', org_unit_id;
			END IF;
		END IF;
	END IF;
	--
	-- Loop over the propagable funds to identify the details
	-- from the old fund plus the id of the new one, if it exists.
	--
	FOR roll_fund in
	SELECT
	    oldf.id AS old_fund,
	    oldf.org,
	    oldf.name,
	    oldf.currency_type,
	    oldf.code,
		oldf.rollover,
	    newf.id AS new_fund_id
	FROM
    	acq.fund AS oldf
    	LEFT JOIN acq.fund AS newf
        	ON ( oldf.code = newf.code )
	WHERE
 		    oldf.year = old_year
		AND oldf.propagate
        AND newf.year = new_year
		AND ( ( include_desc AND oldf.org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND oldf.org = org_unit_id ) )
	LOOP
		--RAISE NOTICE 'Processing fund %', roll_fund.old_fund;
		--
		IF roll_fund.new_fund_id IS NULL THEN
			--
			-- The old fund hasn't been propagated yet.  Propagate it now.
			--
			INSERT INTO acq.fund (
				org,
				name,
				year,
				currency_type,
				code,
				rollover,
				propagate,
				balance_warning_percent,
				balance_stop_percent
			) VALUES (
				roll_fund.org,
				roll_fund.name,
				new_year,
				roll_fund.currency_type,
				roll_fund.code,
				true,
				true,
				roll_fund.balance_warning_percent,
				roll_fund.balance_stop_percent
			)
			RETURNING id INTO new_fund;
		ELSE
			new_fund = roll_fund.new_fund_id;
		END IF;
		--
		-- Determine the amount to transfer
		--
		SELECT amount
		INTO xfer_amount
		FROM acq.fund_spent_balance
		WHERE fund = roll_fund.old_fund;
		--
		IF xfer_amount <> 0 THEN
			IF NOT encumb_only AND roll_fund.rollover THEN
				--
				-- Transfer balance from old fund to new
				--
				--RAISE NOTICE 'Transferring % from fund % to %', xfer_amount, roll_fund.old_fund, new_fund;
				--
				PERFORM acq.transfer_fund(
					roll_fund.old_fund,
					xfer_amount,
					new_fund,
					xfer_amount,
					user_id,
					'Rollover'
				);
			ELSE
				--
				-- Transfer balance from old fund to the void
				--
				-- RAISE NOTICE 'Transferring % from fund % to the void', xfer_amount, roll_fund.old_fund;
				--
				PERFORM acq.transfer_fund(
					roll_fund.old_fund,
					xfer_amount,
					NULL,
					NULL,
					user_id,
					'Rollover into the void'
				);
			END IF;
		END IF;
		--
		IF roll_fund.rollover THEN
			--
			-- Move any lineitems from the old fund to the new one
			-- where the associated debit is an encumbrance.
			--
			-- Any other tables tying expenditure details to funds should
			-- receive similar treatment.  At this writing there are none.
			--
			UPDATE acq.lineitem_detail
			SET fund = new_fund
			WHERE
    			fund = roll_fund.old_fund -- this condition may be redundant
    			AND fund_debit in
    			(
        			SELECT id
        			FROM acq.fund_debit
        			WHERE
            			fund = roll_fund.old_fund
            			AND encumbrance
    			);
			--
			-- Move encumbrance debits from the old fund to the new fund
			--
			UPDATE acq.fund_debit
			SET fund = new_fund
			wHERE
				fund = roll_fund.old_fund
				AND encumbrance;
		END IF;

		-- Rollover distribution formulae funds
		SELECT INTO roll_distrib_forms value::BOOL FROM
			actor.org_unit_ancestor_setting(
				'acq.fund.rollover_distrib_forms', org_unit_id
			);

		IF roll_distrib_forms THEN
			UPDATE acq.distribution_formula_entry 
				SET fund = roll_fund.new_fund_id
				WHERE fund = roll_fund.old_fund;
		END IF;

		--
		-- Mark old fund as inactive, now that we've closed it
		--
		UPDATE acq.fund
		SET active = FALSE
		WHERE id = roll_fund.old_fund;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean, include_desc boolean) OWNER TO postgres;

--
-- Name: rollover_funds_by_org_unit(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.rollover_funds_by_org_tree( $1, $2, $3, $4, FALSE );
$_$;


ALTER FUNCTION acq.rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean) OWNER TO postgres;

--
-- Name: transfer_fund(integer, numeric, integer, numeric, integer, text); Type: FUNCTION; Schema: acq; Owner: postgres
--

CREATE FUNCTION transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/* -------------------------------------------------------------------------------

Function to transfer money from one fund to another.

A transfer is represented as a pair of entries in acq.fund_allocation, with a
negative amount for the old (losing) fund and a positive amount for the new
(gaining) fund.  In some cases there may be more than one such pair of entries
in order to pull the money from different funding sources, or more specifically
from different funding source credits.  For each such pair there is also an
entry in acq.fund_transfer.

Since funding_source is a non-nullable column in acq.fund_allocation, we must
choose a funding source for the transferred money to come from.  This choice
must meet two constraints, so far as possible:

1. The amount transferred from a given funding source must not exceed the
amount allocated to the old fund by the funding source.  To that end we
compare the amount being transferred to the amount allocated.

2. We shouldn't transfer money that has already been spent or encumbered, as
defined by the funding attribution process.  We attribute expenses to the
oldest funding source credits first.  In order to avoid transferring that
attributed money, we reverse the priority, transferring from the newest funding
source credits first.  There can be no guarantee that this approach will
avoid overcommitting a fund, but no other approach can do any better.

In this context the age of a funding source credit is defined by the
deadline_date for credits with deadline_dates, and by the effective_date for
credits without deadline_dates, with the proviso that credits with deadline_dates
are all considered "older" than those without.

----------

In the signature for this function, there is one last parameter commented out,
named "funding_source_in".  Correspondingly, the WHERE clause for the query
driving the main loop has an OR clause commented out, which references the
funding_source_in parameter.

If these lines are uncommented, this function will allow the user optionally to
restrict a fund transfer to a specified funding source.  If the source
parameter is left NULL, then there will be no such restriction.

------------------------------------------------------------------------------- */ 
DECLARE
	same_currency      BOOLEAN;
	currency_ratio     NUMERIC;
	old_fund_currency  TEXT;
	old_remaining      NUMERIC;  -- in currency of old fund
	new_fund_currency  TEXT;
	new_fund_active    BOOLEAN;
	new_remaining      NUMERIC;  -- in currency of new fund
	curr_old_amt       NUMERIC;  -- in currency of old fund
	curr_new_amt       NUMERIC;  -- in currency of new fund
	source_addition    NUMERIC;  -- in currency of funding source
	source_deduction   NUMERIC;  -- in currency of funding source
	orig_allocated_amt NUMERIC;  -- in currency of funding source
	allocated_amt      NUMERIC;  -- in currency of fund
	source             RECORD;
BEGIN
	--
	-- Sanity checks
	--
	IF old_fund IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id is NULL';
	END IF;
	--
	IF old_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer is NULL';
	END IF;
	--
	-- The new fund and its amount must be both NULL or both not NULL.
	--
	IF new_fund IS NOT NULL AND new_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer to receiving fund is NULL';
	END IF;
	--
	IF new_fund IS NULL AND new_amount IS NOT NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: receiving fund is NULL, its amount is not NULL';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: user id is NULL';
	END IF;
	--
	-- Initialize the amounts to be transferred, each denominated
	-- in the currency of its respective fund.  They will be
	-- reduced on each iteration of the loop.
	--
	old_remaining := old_amount;
	new_remaining := new_amount;
	--
	-- RAISE NOTICE 'Transferring % in fund % to % in fund %',
	--	old_amount, old_fund, new_amount, new_fund;
	--
	-- Get the currency types of the old and new funds.
	--
	SELECT
		currency_type
	INTO
		old_fund_currency
	FROM
		acq.fund
	WHERE
		id = old_fund;
	--
	IF old_fund_currency IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id % is not defined', old_fund;
	END IF;
	--
	IF new_fund IS NOT NULL THEN
		SELECT
			currency_type,
			active
		INTO
			new_fund_currency,
			new_fund_active
		FROM
			acq.fund
		WHERE
			id = new_fund;
		--
		IF new_fund_currency IS NULL THEN
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is not defined', new_fund;
		ELSIF NOT new_fund_active THEN
			--
			-- No point in putting money into a fund from whence you can't spend it
			--
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is inactive', new_fund;
		END IF;
		--
		IF new_amount = old_amount THEN
			same_currency := true;
			currency_ratio := 1;
		ELSE
			--
			-- We'll have to translate currency between funds.  We presume that
			-- the calling code has already applied an appropriate exchange rate,
			-- so we'll apply the same conversion to each sub-transfer.
			--
			same_currency := false;
			currency_ratio := new_amount / old_amount;
		END IF;
	END IF;
	--
	-- Identify the funding source(s) from which we want to transfer the money.
	-- The principle is that we want to transfer the newest money first, because
	-- we spend the oldest money first.  The priority for spending is defined
	-- by a sort of the view acq.ordered_funding_source_credit.
	--
	FOR source in
		SELECT
			ofsc.id,
			ofsc.funding_source,
			ofsc.amount,
			ofsc.amount * acq.exchange_ratio( fs.currency_type, old_fund_currency )
				AS converted_amt,
			fs.currency_type
		FROM
			acq.ordered_funding_source_credit AS ofsc,
			acq.funding_source fs
		WHERE
			ofsc.funding_source = fs.id
			and ofsc.funding_source IN
			(
				SELECT funding_source
				FROM acq.fund_allocation
				WHERE fund = old_fund
			)
			-- and
			-- (
			-- 	ofsc.funding_source = funding_source_in
			-- 	OR funding_source_in IS NULL
			-- )
		ORDER BY
			ofsc.sort_priority desc,
			ofsc.sort_date desc,
			ofsc.id desc
	LOOP
		--
		-- Determine how much money the old fund got from this funding source,
		-- denominated in the currency types of the source and of the fund.
		-- This result may reflect transfers from previous iterations.
		--
		SELECT
			COALESCE( sum( amount ), 0 ),
			COALESCE( sum( amount )
				* acq.exchange_ratio( source.currency_type, old_fund_currency ), 0 )
		INTO
			orig_allocated_amt,     -- in currency of the source
			allocated_amt           -- in currency of the old fund
		FROM
			acq.fund_allocation
		WHERE
			fund = old_fund
			and funding_source = source.funding_source;
		--	
		-- Determine how much to transfer from this credit, in the currency
		-- of the fund.   Begin with the amount remaining to be attributed:
		--
		curr_old_amt := old_remaining;
		--
		-- Can't attribute more than was allocated from the fund:
		--
		IF curr_old_amt > allocated_amt THEN
			curr_old_amt := allocated_amt;
		END IF;
		--
		-- Can't attribute more than the amount of the current credit:
		--
		IF curr_old_amt > source.converted_amt THEN
			curr_old_amt := source.converted_amt;
		END IF;
		--
		curr_old_amt := trunc( curr_old_amt, 2 );
		--
		old_remaining := old_remaining - curr_old_amt;
		--
		-- Determine the amount to be deducted, if any,
		-- from the old allocation.
		--
		IF old_remaining > 0 THEN
			--
			-- In this case we're using the whole allocation, so use that
			-- amount directly instead of applying a currency translation
			-- and thereby inviting round-off errors.
			--
			source_deduction := - orig_allocated_amt;
		ELSE 
			source_deduction := trunc(
				( - curr_old_amt ) *
					acq.exchange_ratio( old_fund_currency, source.currency_type ),
				2 );
		END IF;
		--
		IF source_deduction <> 0 THEN
			--
			-- Insert negative allocation for old fund in fund_allocation,
			-- converted into the currency of the funding source
			--
			INSERT INTO acq.fund_allocation (
				funding_source,
				fund,
				amount,
				allocator,
				note
			) VALUES (
				source.funding_source,
				old_fund,
				source_deduction,
				user_id,
				'Transfer to fund ' || new_fund
			);
		END IF;
		--
		IF new_fund IS NOT NULL THEN
			--
			-- Determine how much to add to the new fund, in
			-- its currency, and how much remains to be added:
			--
			IF same_currency THEN
				curr_new_amt := curr_old_amt;
			ELSE
				IF old_remaining = 0 THEN
					--
					-- This is the last iteration, so nothing should be left
					--
					curr_new_amt := new_remaining;
					new_remaining := 0;
				ELSE
					curr_new_amt := trunc( curr_old_amt * currency_ratio, 2 );
					new_remaining := new_remaining - curr_new_amt;
				END IF;
			END IF;
			--
			-- Determine how much to add, if any,
			-- to the new fund's allocation.
			--
			IF old_remaining > 0 THEN
				--
				-- In this case we're using the whole allocation, so use that amount
				-- amount directly instead of applying a currency translation and
				-- thereby inviting round-off errors.
				--
				source_addition := orig_allocated_amt;
			ELSIF source.currency_type = old_fund_currency THEN
				--
				-- In this case we don't need a round trip currency translation,
				-- thereby inviting round-off errors:
				--
				source_addition := curr_old_amt;
			ELSE 
				source_addition := trunc(
					curr_new_amt *
						acq.exchange_ratio( new_fund_currency, source.currency_type ),
					2 );
			END IF;
			--
			IF source_addition <> 0 THEN
				--
				-- Insert positive allocation for new fund in fund_allocation,
				-- converted to the currency of the founding source
				--
				INSERT INTO acq.fund_allocation (
					funding_source,
					fund,
					amount,
					allocator,
					note
				) VALUES (
					source.funding_source,
					new_fund,
					source_addition,
					user_id,
					'Transfer from fund ' || old_fund
				);
			END IF;
		END IF;
		--
		IF trunc( curr_old_amt, 2 ) <> 0
		OR trunc( curr_new_amt, 2 ) <> 0 THEN
			--
			-- Insert row in fund_transfer, using amounts in the currency of the funds
			--
			INSERT INTO acq.fund_transfer (
				src_fund,
				src_amount,
				dest_fund,
				dest_amount,
				transfer_user,
				note,
				funding_source_credit
			) VALUES (
				old_fund,
				trunc( curr_old_amt, 2 ),
				new_fund,
				trunc( curr_new_amt, 2 ),
				user_id,
				xfer_note,
				source.id
			);
		END IF;
		--
		if old_remaining <= 0 THEN
			EXIT;                   -- Nothing more to be transferred
		END IF;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: age_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION age_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
found char := 'N';
BEGIN

    -- If there are any renewals for this circulation, don't archive or delete
    -- it yet.   We'll do so later, when we archive and delete the renewals.

    SELECT 'Y' INTO found
    FROM action.circulation
    WHERE parent_circ = OLD.id
    LIMIT 1;

    IF found = 'Y' THEN
        RETURN NULL;  -- don't delete
	END IF;

    -- Archive a copy of the old row to action.aged_circulation

    INSERT INTO action.aged_circulation
        (id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ)
      SELECT
        id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ
        FROM action.all_circulation WHERE id = OLD.id;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_circ_on_delete() OWNER TO postgres;

--
-- Name: age_parent_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION age_parent_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- Having deleted a renewal, we can delete the original circulation (or a previous
    -- renewal, if that's what parent_circ is pointing to).  That deletion will trigger
    -- deletion of any prior parents, etc. recursively.

    IF OLD.parent_circ IS NOT NULL THEN
        DELETE FROM action.circulation
        WHERE id = OLD.parent_circ;
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_parent_circ_on_delete() OWNER TO postgres;

--
-- Name: apply_fieldset(integer, text, text, text); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	statement TEXT;
	fs_status TEXT;
	fs_pkey_value TEXT;
	fs_query TEXT;
	sep CHAR;
	status_code TEXT;
	msg TEXT;
	update_count INT;
	cv RECORD;
BEGIN
	-- Sanity checks
	IF fieldset_id IS NULL THEN
		RETURN 'Fieldset ID parameter is NULL';
	END IF;
	IF table_name IS NULL THEN
		RETURN 'Table name parameter is NULL';
	END IF;
	IF pkey_name IS NULL THEN
		RETURN 'Primary key name parameter is NULL';
	END IF;
	--
	statement := 'UPDATE ' || table_name || ' SET';
	--
	SELECT
		status,
		quote_literal( pkey_value )
	INTO
		fs_status,
		fs_pkey_value
	FROM
		action.fieldset
	WHERE
		id = fieldset_id;
	--
	IF fs_status IS NULL THEN
		RETURN 'No fieldset found for id = ' || fieldset_id;
	ELSIF fs_status = 'APPLIED' THEN
		RETURN 'Fieldset ' || fieldset_id || ' has already been applied';
	END IF;
	--
	sep := '';
	FOR cv IN
		SELECT  col,
				val
		FROM    action.fieldset_col_val
		WHERE   fieldset = fieldset_id
	LOOP
		statement := statement || sep || ' ' || cv.col
					 || ' = ' || coalesce( quote_literal( cv.val ), 'NULL' );
		sep := ',';
	END LOOP;
	--
	IF sep = '' THEN
		RETURN 'Fieldset ' || fieldset_id || ' has no column values defined';
	END IF;
	--
	-- Add the WHERE clause.  This differs according to whether it's a
	-- single-row fieldset or a query-based fieldset.
	--
	IF query IS NULL        AND fs_pkey_value IS NULL THEN
		RETURN 'Incomplete fieldset: neither a primary key nor a query available';
	ELSIF query IS NOT NULL AND fs_pkey_value IS NULL THEN
	    fs_query := rtrim( query, ';' );
	    statement := statement || ' WHERE ' || pkey_name || ' IN ( '
	                 || fs_query || ' );';
	ELSIF query IS NULL     AND fs_pkey_value IS NOT NULL THEN
		statement := statement || ' WHERE ' || pkey_name || ' = '
				     || fs_pkey_value || ';';
	ELSE  -- both are not null
		RETURN 'Ambiguous fieldset: both a primary key and a query provided';
	END IF;
	--
	-- Execute the update
	--
	BEGIN
		EXECUTE statement;
		GET DIAGNOSTICS update_count = ROW_COUNT;
		--
		IF UPDATE_COUNT > 0 THEN
			status_code := 'APPLIED';
			msg := NULL;
		ELSE
			status_code := 'ERROR';
			msg := 'No eligible rows found for fieldset ' || fieldset_id;
    	END IF;
	EXCEPTION WHEN OTHERS THEN
		status_code := 'ERROR';
		msg := 'Unable to apply fieldset ' || fieldset_id
			   || ': ' || sqlerrm;
	END;
	--
	-- Update fieldset status
	--
	UPDATE action.fieldset
	SET status       = status_code,
	    applied_time = now()
	WHERE id = fieldset_id;
	--
	RETURN msg;
END;
$$;


ALTER FUNCTION action.apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) OWNER TO postgres;

--
-- Name: FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text); Type: COMMENT; Schema: action; Owner: postgres
--

COMMENT ON FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) IS '
Applies a specified fieldset, using a supplied table name and primary
key name.  The query parameter should be non-null only for
query-based fieldsets.

Returns NULL if successful, or an error message if not.
';


--
-- Name: archive_stat_cats(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION archive_stat_cats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO action.archive_actor_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, asceum.stat_cat, asceum.stat_cat_entry
        FROM actor.stat_cat_entry_usr_map asceum
             JOIN actor.stat_cat sc ON asceum.stat_cat = sc.id
        WHERE NEW.usr = asceum.target_usr AND sc.checkout_archive;
    INSERT INTO action.archive_asset_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, ascecm.stat_cat, asce.value
        FROM asset.stat_cat_entry_copy_map ascecm
             JOIN asset.stat_cat sc ON ascecm.stat_cat = sc.id
             JOIN asset.stat_cat_entry asce ON ascecm.stat_cat_entry = asce.id
        WHERE NEW.target_copy = ascecm.owning_copy AND sc.checkout_archive;
    RETURN NULL;
END;
$$;


ALTER FUNCTION action.archive_stat_cats() OWNER TO postgres;

SET search_path = money, pg_catalog;

--
-- Name: billable_xact; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE billable_xact (
    id bigint NOT NULL,
    usr integer NOT NULL,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean
);


ALTER TABLE money.billable_xact OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: circulation; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE circulation (
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    grace_period interval NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    copy_location integer DEFAULT 1 NOT NULL,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    CONSTRAINT circulation_stop_fines_check CHECK ((stop_fines = ANY (ARRAY['CHECKIN'::text, 'CLAIMSRETURNED'::text, 'LOST'::text, 'MAXFINES'::text, 'RENEW'::text, 'LONGOVERDUE'::text, 'CLAIMSNEVERCHECKEDOUT'::text])))
)
INHERITS (money.billable_xact);


ALTER TABLE action.circulation OWNER TO postgres;

--
-- Name: circ_chain(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION circ_chain(ctx_circ_id integer) RETURNS SETOF circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_circ action.circulation%ROWTYPE;
    circ_0 action.circulation%ROWTYPE;
BEGIN

    SELECT INTO tmp_circ * FROM action.circulation WHERE id = ctx_circ_id;

    IF tmp_circ IS NULL THEN
        RETURN NEXT tmp_circ;
    END IF;
    circ_0 := tmp_circ;

    -- find the front of the chain
    WHILE TRUE LOOP
        SELECT INTO tmp_circ * FROM action.circulation WHERE id = tmp_circ.parent_circ;
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        circ_0 := tmp_circ;
    END LOOP;

    -- now send the circs to the caller, oldest to newest
    tmp_circ := circ_0;
    WHILE TRUE LOOP
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        RETURN NEXT tmp_circ;
        SELECT INTO tmp_circ * FROM action.circulation WHERE parent_circ = tmp_circ.id;
    END LOOP;

END;
$$;


ALTER FUNCTION action.circ_chain(ctx_circ_id integer) OWNER TO postgres;

--
-- Name: circulation_claims_returned(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION circulation_claims_returned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF OLD.stop_fines IS NULL OR OLD.stop_fines <> NEW.stop_fines THEN
		IF NEW.stop_fines = 'CLAIMSRETURNED' THEN
			UPDATE actor.usr SET claims_returned_count = claims_returned_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'CLAIMSNEVERCHECKEDOUT' THEN
			UPDATE actor.usr SET claims_never_checked_out_count = claims_never_checked_out_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'LOST' THEN
			UPDATE asset.copy SET status = 3 WHERE id = NEW.target_copy;
		END IF;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.circulation_claims_returned() OWNER TO postgres;

--
-- Name: copy_related_hold_stats(bigint); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION copy_related_hold_stats(copy_id bigint) RETURNS hold_stats
    LANGUAGE plpgsql
    AS $$
DECLARE
    output          action.hold_stats%ROWTYPE;
    hold_count      INT := 0;
    copy_count      INT := 0;
    available_count INT := 0;
    hold_map_data   RECORD;
BEGIN

    output.hold_count := 0;
    output.copy_count := 0;
    output.available_count := 0;

    SELECT  COUNT( DISTINCT m.hold ) INTO hold_count
      FROM  action.hold_copy_map m
            JOIN action.hold_request h ON (m.hold = h.id)
      WHERE m.target_copy = copy_id
            AND NOT h.frozen;

    output.hold_count := hold_count;

    IF output.hold_count > 0 THEN
        FOR hold_map_data IN
            SELECT  DISTINCT m.target_copy,
                    acp.status
              FROM  action.hold_copy_map m
                    JOIN asset.copy acp ON (m.target_copy = acp.id)
                    JOIN action.hold_request h ON (m.hold = h.id)
              WHERE m.hold IN ( SELECT DISTINCT hold FROM action.hold_copy_map WHERE target_copy = copy_id ) AND NOT h.frozen
        LOOP
            output.copy_count := output.copy_count + 1;
            IF hold_map_data.status IN (0,7,12) THEN
                output.available_count := output.available_count + 1;
            END IF;
        END LOOP;
        output.total_copy_ratio = output.copy_count::FLOAT / output.hold_count::FLOAT;
        output.available_copy_ratio = output.available_count::FLOAT / output.hold_count::FLOAT;

    END IF;

    RETURN output;

END;
$$;


ALTER FUNCTION action.copy_related_hold_stats(copy_id bigint) OWNER TO postgres;

--
-- Name: fill_circ_copy_location(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION fill_circ_copy_location() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    SELECT INTO NEW.copy_location location FROM asset.copy WHERE id = NEW.target_copy;
    RETURN NEW;
END;
$$;


ALTER FUNCTION action.fill_circ_copy_location() OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: usr; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr (
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL,
    last_update_time timestamp with time zone
);


ALTER TABLE actor.usr OWNER TO postgres;

--
-- Name: TABLE usr; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE usr IS '
User objects

This table contains the core User objects that describe both
staff members and patrons.  The difference between the two
types of users is based on the user''s permissions.
';


SET search_path = asset, pg_catalog;

--
-- Name: copy; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy (
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    active_date timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2),
    CONSTRAINT copy_fine_level_check CHECK ((fine_level = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT copy_loan_duration_check CHECK ((loan_duration = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE asset.copy OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: find_circ_matrix_matchpoint(integer, asset.copy, actor.usr, boolean); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) RETURNS found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    cn_object       asset.call_number%ROWTYPE;
    rec_descriptor  metabib.rec_descriptor%ROWTYPE;
    cur_matchpoint  config.circ_matrix_matchpoint%ROWTYPE;
    matchpoint      config.circ_matrix_matchpoint%ROWTYPE;
    weights         config.circ_matrix_weights%ROWTYPE;
    user_age        INTERVAL;
    my_item_age     INTERVAL;
    denominator     NUMERIC(6,2);
    row_list        INT[];
    result          action.found_circ_matrix_matchpoint;
BEGIN
    -- Assume failure
    result.success = false;

    -- Fetch useful data
    SELECT INTO cn_object       * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor  * FROM metabib.rec_descriptor   WHERE record = cn_object.record;

    -- Pre-generate this so we only calc it once
    IF user_object.dob IS NOT NULL THEN
        SELECT INTO user_age age(user_object.dob);
    END IF;

    -- Ditto
    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- Grab the closest set circ weight setting.
    SELECT INTO weights cw.*
      FROM config.weight_assoc wa
           JOIN config.circ_matrix_weights cw ON (cw.id = wa.circ_weights)
           JOIN actor.org_unit_ancestors_distance( context_ou ) d ON (wa.org_unit = d.id)
      WHERE active
      ORDER BY d.distance
      LIMIT 1;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.grp                 := 11.0;
        weights.org_unit            := 10.0;
        weights.circ_modifier       := 5.0;
        weights.copy_location       := 5.0;
        weights.marc_type           := 4.0;
        weights.marc_form           := 3.0;
        weights.marc_bib_level      := 2.0;
        weights.marc_vr_format      := 2.0;
        weights.copy_circ_lib       := 8.0;
        weights.copy_owning_lib     := 8.0;
        weights.user_home_ou        := 8.0;
        weights.ref_flag            := 1.0;
        weights.juvenile_flag       := 6.0;
        weights.is_renewal          := 7.0;
        weights.usr_age_lower_bound := 0.0;
        weights.usr_age_upper_bound := 0.0;
        weights.item_age            := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_hold_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
       	    SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
	)
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- Loop over all the potential matchpoints
    FOR cur_matchpoint IN
        SELECT m.*
          FROM  config.circ_matrix_matchpoint m
                /*LEFT*/ JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.grp = upgad.id
                /*LEFT*/ JOIN actor.org_unit_ancestors_distance( context_ou ) ctoua ON m.org_unit = ctoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( cn_object.owning_lib ) cnoua ON m.copy_owning_lib = cnoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.copy_circ_lib = iooua.id
                LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
          WHERE m.active
                -- Permission Groups
             -- AND (m.grp                      IS NULL OR upgad.id IS NOT NULL) -- Optional Permission Group?
                -- Org Units
             -- AND (m.org_unit                 IS NULL OR ctoua.id IS NOT NULL) -- Optional Org Unit?
                AND (m.copy_owning_lib          IS NULL OR cnoua.id IS NOT NULL)
                AND (m.copy_circ_lib            IS NULL OR iooua.id IS NOT NULL)
                AND (m.user_home_ou             IS NULL OR uhoua.id IS NOT NULL)
                -- Circ Type
                AND (m.is_renewal               IS NULL OR m.is_renewal = renewal)
                -- Static User Checks
                AND (m.juvenile_flag            IS NULL OR m.juvenile_flag = user_object.juvenile)
                AND (m.usr_age_lower_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_lower_bound < user_age))
                AND (m.usr_age_upper_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_upper_bound > user_age))
                -- Static Item Checks
                AND (m.circ_modifier            IS NULL OR m.circ_modifier = item_object.circ_modifier)
                AND (m.copy_location            IS NULL OR m.copy_location = item_object.location)
                AND (m.marc_type                IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
                AND (m.marc_form                IS NULL OR m.marc_form = rec_descriptor.item_form)
                AND (m.marc_bib_level           IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
                AND (m.marc_vr_format           IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
                AND (m.ref_flag                 IS NULL OR m.ref_flag = item_object.ref)
                AND (m.item_age                 IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
          ORDER BY
                -- Permission Groups
                CASE WHEN upgad.distance        IS NOT NULL THEN 2^(2*weights.grp - (upgad.distance/denominator)) ELSE 0.0 END +
                -- Org Units
                CASE WHEN ctoua.distance        IS NOT NULL THEN 2^(2*weights.org_unit - (ctoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN cnoua.distance        IS NOT NULL THEN 2^(2*weights.copy_owning_lib - (cnoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN iooua.distance        IS NOT NULL THEN 2^(2*weights.copy_circ_lib - (iooua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN uhoua.distance        IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
                -- Circ Type                    -- Note: 4^x is equiv to 2^(2*x)
                CASE WHEN m.is_renewal          IS NOT NULL THEN 4^weights.is_renewal ELSE 0.0 END +
                -- Static User Checks
                CASE WHEN m.juvenile_flag       IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
                CASE WHEN m.usr_age_lower_bound IS NOT NULL THEN 4^weights.usr_age_lower_bound ELSE 0.0 END +
                CASE WHEN m.usr_age_upper_bound IS NOT NULL THEN 4^weights.usr_age_upper_bound ELSE 0.0 END +
                -- Static Item Checks
                CASE WHEN m.circ_modifier       IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
                CASE WHEN m.copy_location       IS NOT NULL THEN 4^weights.copy_location ELSE 0.0 END +
                CASE WHEN m.marc_type           IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
                CASE WHEN m.marc_form           IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
                CASE WHEN m.marc_vr_format      IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
                CASE WHEN m.ref_flag            IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
                -- Item age has a slight adjustment to weight based on value.
                -- This should ensure that a shorter age limit comes first when all else is equal.
                -- NOTE: This assumes that intervals will normally be in days.
                CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 1 + 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
                -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
                -- This prevents "we changed the table order by updating a rule, and we started getting different results"
                m.id LOOP

        -- Record the full matching row list
        row_list := row_list || cur_matchpoint.id;

        -- No matchpoint yet?
        IF matchpoint.id IS NULL THEN
            -- Take the entire matchpoint as a starting point
            matchpoint := cur_matchpoint;
            CONTINUE; -- No need to look at this row any more.
        END IF;

        -- Incomplete matchpoint?
        IF matchpoint.circulate IS NULL THEN
            matchpoint.circulate := cur_matchpoint.circulate;
        END IF;
        IF matchpoint.duration_rule IS NULL THEN
            matchpoint.duration_rule := cur_matchpoint.duration_rule;
        END IF;
        IF matchpoint.recurring_fine_rule IS NULL THEN
            matchpoint.recurring_fine_rule := cur_matchpoint.recurring_fine_rule;
        END IF;
        IF matchpoint.max_fine_rule IS NULL THEN
            matchpoint.max_fine_rule := cur_matchpoint.max_fine_rule;
        END IF;
        IF matchpoint.hard_due_date IS NULL THEN
            matchpoint.hard_due_date := cur_matchpoint.hard_due_date;
        END IF;
        IF matchpoint.total_copy_hold_ratio IS NULL THEN
            matchpoint.total_copy_hold_ratio := cur_matchpoint.total_copy_hold_ratio;
        END IF;
        IF matchpoint.available_copy_hold_ratio IS NULL THEN
            matchpoint.available_copy_hold_ratio := cur_matchpoint.available_copy_hold_ratio;
        END IF;
        IF matchpoint.renewals IS NULL THEN
            matchpoint.renewals := cur_matchpoint.renewals;
        END IF;
        IF matchpoint.grace_period IS NULL THEN
            matchpoint.grace_period := cur_matchpoint.grace_period;
        END IF;
    END LOOP;

    -- Check required fields
    IF matchpoint.circulate             IS NOT NULL AND
       matchpoint.duration_rule         IS NOT NULL AND
       matchpoint.recurring_fine_rule   IS NOT NULL AND
       matchpoint.max_fine_rule         IS NOT NULL THEN
        -- All there? We have a completed match.
        result.success := true;
    END IF;

    -- Include the assembled matchpoint, even if it isn't complete
    result.matchpoint := matchpoint;

    -- Include (for debugging) the full list of matching rows
    result.buildrows := row_list;

    -- Hand the result back to caller
    RETURN result;
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) OWNER TO postgres;

--
-- Name: find_circ_matrix_matchpoint(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    item_object asset.copy%ROWTYPE;
    user_object actor.usr%ROWTYPE;
BEGIN
    SELECT INTO item_object * FROM asset.copy 	WHERE id = match_item;
    SELECT INTO user_object * FROM actor.usr	WHERE id = match_user;

    RETURN QUERY SELECT * FROM action.find_circ_matrix_matchpoint( context_ou, item_object, user_object, renewal );
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO postgres;

--
-- Name: find_hold_matrix_matchpoint(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    requestor_object    actor.usr%ROWTYPE;
    user_object         actor.usr%ROWTYPE;
    item_object         asset.copy%ROWTYPE;
    item_cn_object      asset.call_number%ROWTYPE;
    my_item_age         INTERVAL;
    rec_descriptor      metabib.rec_descriptor%ROWTYPE;
    matchpoint          config.hold_matrix_matchpoint%ROWTYPE;
    weights             config.hold_matrix_weights%ROWTYPE;
    denominator         NUMERIC(6,2);
BEGIN
    SELECT INTO user_object         * FROM actor.usr                WHERE id = match_user;
    SELECT INTO requestor_object    * FROM actor.usr                WHERE id = match_requestor;
    SELECT INTO item_object         * FROM asset.copy               WHERE id = match_item;
    SELECT INTO item_cn_object      * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor      * FROM metabib.rec_descriptor   WHERE record = item_cn_object.record;

    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- The item's owner should probably be the one determining if the item is holdable
    -- How to decide that is debatable. Decided to default to the circ library (where the item lives)
    -- This flag will allow for setting it to the owning library (where the call number "lives")
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.weight_owner_not_circ' AND enabled;

    -- Grab the closest set circ weight setting.
    IF NOT FOUND THEN
        -- Default to circ library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    ELSE
        -- Flag is set, use owning library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    END IF;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.user_home_ou    := 5.0;
        weights.request_ou      := 5.0;
        weights.pickup_ou       := 5.0;
        weights.item_owning_ou  := 5.0;
        weights.item_circ_ou    := 5.0;
        weights.usr_grp         := 7.0;
        weights.requestor_grp   := 8.0;
        weights.circ_modifier   := 4.0;
        weights.marc_type       := 3.0;
        weights.marc_form       := 2.0;
        weights.marc_bib_level  := 1.0;
        weights.marc_vr_format  := 1.0;
        weights.juvenile_flag   := 4.0;
        weights.ref_flag        := 0.0;
        weights.item_age        := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_circ_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
            SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
	)
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- To ATTEMPT to make this work like it used to, make it reverse the user/requestor profile ids.
    -- This may be better implemented as part of the upgrade script?
    -- Set usr_grp = requestor_grp, requestor_grp = 1 or something when this flag is already set
    -- Then remove this flag, of course.
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.usr_not_requestor' AND enabled;

    IF FOUND THEN
        -- Note: This, to me, is REALLY hacky. I put it in anyway.
        -- If you can't tell, this is a single call swap on two variables.
        SELECT INTO user_object.profile, requestor_object.profile
                    requestor_object.profile, user_object.profile;
    END IF;

    -- Select the winning matchpoint into the matchpoint variable for returning
    SELECT INTO matchpoint m.*
      FROM  config.hold_matrix_matchpoint m
            /*LEFT*/ JOIN permission.grp_ancestors_distance( requestor_object.profile ) rpgad ON m.requestor_grp = rpgad.id
            LEFT JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.usr_grp = upgad.id
            LEFT JOIN actor.org_unit_ancestors_distance( pickup_ou ) puoua ON m.pickup_ou = puoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( request_ou ) rqoua ON m.request_ou = rqoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) cnoua ON m.item_owning_ou = cnoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.item_circ_ou = iooua.id
            LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
      WHERE m.active
            -- Permission Groups
         -- AND (m.requestor_grp        IS NULL OR upgad.id IS NOT NULL) -- Optional Requestor Group?
            AND (m.usr_grp              IS NULL OR upgad.id IS NOT NULL)
            -- Org Units
            AND (m.pickup_ou            IS NULL OR (puoua.id IS NOT NULL AND (puoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.request_ou           IS NULL OR (rqoua.id IS NOT NULL AND (rqoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_owning_ou       IS NULL OR (cnoua.id IS NOT NULL AND (cnoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_circ_ou         IS NULL OR (iooua.id IS NOT NULL AND (iooua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.user_home_ou         IS NULL OR (uhoua.id IS NOT NULL AND (uhoua.distance = 0 OR NOT m.strict_ou_match)))
            -- Static User Checks
            AND (m.juvenile_flag        IS NULL OR m.juvenile_flag = user_object.juvenile)
            -- Static Item Checks
            AND (m.circ_modifier        IS NULL OR m.circ_modifier = item_object.circ_modifier)
            AND (m.marc_type            IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
            AND (m.marc_form            IS NULL OR m.marc_form = rec_descriptor.item_form)
            AND (m.marc_bib_level       IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
            AND (m.marc_vr_format       IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
            AND (m.ref_flag             IS NULL OR m.ref_flag = item_object.ref)
            AND (m.item_age             IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
      ORDER BY
            -- Permission Groups
            CASE WHEN rpgad.distance    IS NOT NULL THEN 2^(2*weights.requestor_grp - (rpgad.distance/denominator)) ELSE 0.0 END +
            CASE WHEN upgad.distance    IS NOT NULL THEN 2^(2*weights.usr_grp - (upgad.distance/denominator)) ELSE 0.0 END +
            -- Org Units
            CASE WHEN puoua.distance    IS NOT NULL THEN 2^(2*weights.pickup_ou - (puoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN rqoua.distance    IS NOT NULL THEN 2^(2*weights.request_ou - (rqoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN cnoua.distance    IS NOT NULL THEN 2^(2*weights.item_owning_ou - (cnoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN iooua.distance    IS NOT NULL THEN 2^(2*weights.item_circ_ou - (iooua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN uhoua.distance    IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
            -- Static User Checks       -- Note: 4^x is equiv to 2^(2*x)
            CASE WHEN m.juvenile_flag   IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
            -- Static Item Checks
            CASE WHEN m.circ_modifier   IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
            CASE WHEN m.marc_type       IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
            CASE WHEN m.marc_form       IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
            CASE WHEN m.marc_vr_format  IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
            CASE WHEN m.ref_flag        IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
            -- Item age has a slight adjustment to weight based on value.
            -- This should ensure that a shorter age limit comes first when all else is equal.
            -- NOTE: This assumes that intervals will normally be in days.
            CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
            -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
            -- This prevents "we changed the table order by updating a rule, and we started getting different results"
            m.id;

    -- Return just the ID for now
    RETURN matchpoint.id;
END;
$$;


ALTER FUNCTION action.find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO postgres;

--
-- Name: hold_copy_calculated_proximity(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer DEFAULT NULL::integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    aoupa           actor.org_unit_proximity_adjustment%ROWTYPE;
    ahr             action.hold_request%ROWTYPE;
    acp             asset.copy%ROWTYPE;
    acn             asset.call_number%ROWTYPE;
    acl             asset.copy_location%ROWTYPE;
    baseline_prox   NUMERIC;

    icl_list        INT[];
    iol_list        INT[];
    isl_list        INT[];
    hpl_list        INT[];
    hrl_list        INT[];

BEGIN

    SELECT * INTO ahr FROM action.hold_request WHERE id = ahr_id;
    SELECT * INTO acp FROM asset.copy WHERE id = acp_id;
    SELECT * INTO acn FROM asset.call_number WHERE id = acp.call_number;
    SELECT * INTO acl FROM asset.copy_location WHERE id = acp.location;

    IF copy_context_ou IS NULL THEN
        copy_context_ou := acp.circ_lib;
    END IF;

    -- First, gather the baseline proximity of "here" to pickup lib
    SELECT prox INTO baseline_prox FROM actor.org_unit_proximity WHERE from_org = copy_context_ou AND to_org = ahr.pickup_lib;

    -- Find any absolute adjustments, and set the baseline prox to that
    SELECT  adj.* INTO aoupa
      FROM  actor.org_unit_proximity_adjustment adj
            LEFT JOIN actor.org_unit_ancestors_distance(copy_context_ou) acp_cl ON (acp_cl.id = adj.item_circ_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(acn.owning_lib) acn_ol ON (acn_ol.id = adj.item_owning_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(acl.owning_lib) acl_ol ON (acn_ol.id = adj.copy_location)
            LEFT JOIN actor.org_unit_ancestors_distance(ahr.pickup_lib) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(ahr.request_lib) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
      WHERE (adj.circ_mod IS NULL OR adj.circ_mod = acp.circ_modifier) AND
        absolute_adjustment AND
        COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
      ORDER BY
            COALESCE(acp_cl.distance,999)
                + COALESCE(acn_ol.distance,999)
                + COALESCE(acl_ol.distance,999)
                + COALESCE(ahr_pl.distance,999)
                + COALESCE(ahr_rl.distance,999),
            adj.pos
      LIMIT 1;

    IF FOUND THEN
        baseline_prox := aoupa.prox_adjustment;
    END IF;

    -- Now find any relative adjustments, and change the baseline prox based on them
    FOR aoupa IN
        SELECT  adj.* 
          FROM  actor.org_unit_proximity_adjustment adj
                LEFT JOIN actor.org_unit_ancestors_distance(copy_context_ou) acp_cl ON (acp_cl.id = adj.item_circ_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(acn.owning_lib) acn_ol ON (acn_ol.id = adj.item_owning_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(acl.owning_lib) acl_ol ON (acn_ol.id = adj.copy_location)
                LEFT JOIN actor.org_unit_ancestors_distance(ahr.pickup_lib) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(ahr.request_lib) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
          WHERE (adj.circ_mod IS NULL OR adj.circ_mod = acp.circ_modifier) AND
            NOT absolute_adjustment AND
            COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
    LOOP
        baseline_prox := baseline_prox + aoupa.prox_adjustment;
    END LOOP;

    RETURN baseline_prox;
END;
$$;


ALTER FUNCTION action.hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer) OWNER TO postgres;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, FALSE );
$_$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO postgres;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer, boolean); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) RETURNS SETOF matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    matchpoint_id        INT;
    user_object        actor.usr%ROWTYPE;
    age_protect_object    config.rule_age_hold_protect%ROWTYPE;
    standing_penalty    config.standing_penalty%ROWTYPE;
    transit_range_ou_type    actor.org_unit_type%ROWTYPE;
    transit_source        actor.org_unit%ROWTYPE;
    item_object        asset.copy%ROWTYPE;
    item_cn_object     asset.call_number%ROWTYPE;
    item_status_object  config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    ou_skip              actor.org_unit_setting%ROWTYPE;
    result            action.matrix_test_result;
    hold_test        config.hold_matrix_matchpoint%ROWTYPE;
    use_active_date   TEXT;
    age_protect_date  TIMESTAMP WITH TIME ZONE;
    hold_count        INT;
    hold_transit_prox    INT;
    frozen_hold_count    INT;
    context_org_list    INT[];
    done            BOOL := FALSE;
    hold_penalty TEXT;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;
    SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( pickup_ou );

    result.success := TRUE;

    -- The HOLD penalty block only applies to new holds.
    -- The CAPTURE penalty block applies to existing holds.
    hold_penalty := 'HOLD';
    IF retargetting THEN
        hold_penalty := 'CAPTURE';
    END IF;

    -- Fail if we couldn't find a user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_object * FROM asset.copy WHERE id = match_item;

    -- Fail if we couldn't find a copy
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO matchpoint_id action.find_hold_matrix_matchpoint(pickup_ou, request_ou, match_item, match_user, match_requestor);
    result.matchpoint := matchpoint_id;

    SELECT INTO ou_skip * FROM actor.org_unit_setting WHERE name = 'circ.holds.target_skip_me' AND org_unit = item_object.circ_lib;

    -- Fail if the circ_lib for the item has circ.holds.target_skip_me set to true
    IF ou_skip.id IS NOT NULL AND ou_skip.value = 'true' THEN
        result.fail_part := 'circ.holds.target_skip_me';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Fail if user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_cn_object * FROM asset.call_number WHERE id = item_object.call_number;
    SELECT INTO item_status_object * FROM config.copy_status WHERE id = item_object.status;
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;

    -- Fail if we couldn't find any matchpoint (requires a default)
    IF matchpoint_id IS NULL THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO hold_test * FROM config.hold_matrix_matchpoint WHERE id = matchpoint_id;

    IF hold_test.holdable IS FALSE THEN
        result.fail_part := 'config.hold_matrix_test.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_object.holdable IS FALSE THEN
        result.fail_part := 'item.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_status_object.holdable IS FALSE THEN
        result.fail_part := 'status.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_location_object.holdable IS FALSE THEN
        result.fail_part := 'location.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF hold_test.transit_range IS NOT NULL THEN
        SELECT INTO transit_range_ou_type * FROM actor.org_unit_type WHERE id = hold_test.transit_range;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO transit_source ou.* FROM actor.org_unit ou JOIN asset.call_number cn ON (cn.owning_lib = ou.id) WHERE cn.id = item_object.call_number;
        ELSE
            SELECT INTO transit_source * FROM actor.org_unit WHERE id = item_object.circ_lib;
        END IF;

        PERFORM * FROM actor.org_unit_descendants( transit_source.id, transit_range_ou_type.depth ) WHERE id = pickup_ou;

        IF NOT FOUND THEN
            result.fail_part := 'transit_range';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;
 
    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND csp.block_list LIKE '%' || hold_penalty || '%' LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    IF hold_test.stop_blocked_user IS TRUE THEN
        FOR standing_penalty IN
            SELECT  DISTINCT csp.*
              FROM  actor.usr_standing_penalty usp
                    JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
              WHERE usr = match_user
                    AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                    AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                    AND csp.block_list LIKE '%CIRC%' LOOP
    
            result.fail_part := standing_penalty.name;
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END LOOP;
    END IF;

    IF hold_test.max_holds IS NOT NULL AND NOT retargetting THEN
        SELECT    INTO hold_count COUNT(*)
          FROM    action.hold_request
          WHERE    usr = match_user
            AND fulfillment_time IS NULL
            AND cancel_time IS NULL
            AND CASE WHEN hold_test.include_frozen_holds THEN TRUE ELSE frozen IS FALSE END;

        IF hold_count >= hold_test.max_holds THEN
            result.fail_part := 'config.hold_matrix_test.max_holds';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    IF item_object.age_protect IS NOT NULL THEN
        SELECT INTO age_protect_object * FROM config.rule_age_hold_protect WHERE id = item_object.age_protect;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_cn_object.owning_lib);
        ELSE
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_object.circ_lib);
        END IF;
        IF use_active_date = 'true' THEN
            age_protect_date := COALESCE(item_object.active_date, NOW());
        ELSE
            age_protect_date := item_object.create_date;
        END IF;
        IF age_protect_date + age_protect_object.age > NOW() THEN
            IF hold_test.distance_is_from_owner THEN
                SELECT INTO item_cn_object * FROM asset.call_number WHERE id = item_object.call_number;
                SELECT INTO hold_transit_prox prox FROM actor.org_unit_proximity WHERE from_org = item_cn_object.owning_lib AND to_org = pickup_ou;
            ELSE
                SELECT INTO hold_transit_prox prox FROM actor.org_unit_proximity WHERE from_org = item_object.circ_lib AND to_org = pickup_ou;
            END IF;

            IF hold_transit_prox > age_protect_object.prox THEN
                result.fail_part := 'config.rule_age_hold_protect.prox';
                result.success := FALSE;
                done := TRUE;
                RETURN NEXT result;
            END IF;
        END IF;
    END IF;

    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) OWNER TO postgres;

--
-- Name: hold_retarget_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, TRUE );
$_$;


ALTER FUNCTION action.hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO postgres;

--
-- Name: item_user_circ_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION item_user_circ_test(integer, bigint, integer) RETURNS SETOF circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION action.item_user_circ_test(integer, bigint, integer) OWNER TO postgres;

--
-- Name: item_user_circ_test(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF circ_matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object             actor.usr%ROWTYPE;
    standing_penalty        config.standing_penalty%ROWTYPE;
    item_object             asset.copy%ROWTYPE;
    item_status_object      config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    result                  action.circ_matrix_test_result;
    circ_test               action.found_circ_matrix_matchpoint;
    circ_matchpoint         config.circ_matrix_matchpoint%ROWTYPE;
    circ_limit_set          config.circ_limit_set%ROWTYPE;
    hold_ratio              action.hold_stats%ROWTYPE;
    penalty_type            TEXT;
    items_out               INT;
    context_org_list        INT[];
    done                    BOOL := FALSE;
BEGIN
    -- Assume success unless we hit a failure condition
    result.success := TRUE;

    -- Need user info to look up matchpoints
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user AND NOT deleted;

    -- (Insta)Fail if we couldn't find the user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Need item info to look up matchpoints
    SELECT INTO item_object * FROM asset.copy WHERE id = match_item AND NOT deleted;

    -- (Insta)Fail if we couldn't find the item 
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO circ_test * FROM action.find_circ_matrix_matchpoint(circ_ou, item_object, user_object, renewal);

    circ_matchpoint             := circ_test.matchpoint;
    result.matchpoint           := circ_matchpoint.id;
    result.circulate            := circ_matchpoint.circulate;
    result.duration_rule        := circ_matchpoint.duration_rule;
    result.recurring_fine_rule  := circ_matchpoint.recurring_fine_rule;
    result.max_fine_rule        := circ_matchpoint.max_fine_rule;
    result.hard_due_date        := circ_matchpoint.hard_due_date;
    result.renewals             := circ_matchpoint.renewals;
    result.grace_period         := circ_matchpoint.grace_period;
    result.buildrows            := circ_test.buildrows;

    -- (Insta)Fail if we couldn't find a matchpoint
    IF circ_test.success = false THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- All failures before this point are non-recoverable
    -- Below this point are possibly overridable failures

    -- Fail if the user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate
    IF item_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item isn't in a circulateable status on a non-renewal
    IF NOT renewal AND item_object.status NOT IN ( 0, 7, 8 ) THEN 
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    -- Alternately, fail if the item isn't checked out on a renewal
    ELSIF renewal AND item_object.status <> 1 THEN
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate because of the shelving location
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;
    IF item_location_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy_location.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Use Circ OU for penalties and such
    SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( circ_ou );

    IF renewal THEN
        penalty_type = '%RENEW%';
    ELSE
        penalty_type = '%CIRC%';
    END IF;

    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND csp.block_list LIKE penalty_type LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    -- Fail if the test is set to hard non-circulating
    IF circ_matchpoint.circulate IS FALSE THEN
        result.fail_part := 'config.circ_matrix_test.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the total copy-hold ratio is too low
    IF circ_matchpoint.total_copy_hold_ratio IS NOT NULL THEN
        SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
        IF hold_ratio.total_copy_ratio IS NOT NULL AND hold_ratio.total_copy_ratio < circ_matchpoint.total_copy_hold_ratio THEN
            result.fail_part := 'config.circ_matrix_test.total_copy_hold_ratio';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    -- Fail if the available copy-hold ratio is too low
    IF circ_matchpoint.available_copy_hold_ratio IS NOT NULL THEN
        IF hold_ratio.hold_count IS NULL THEN
            SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
        END IF;
        IF hold_ratio.available_copy_ratio IS NOT NULL AND hold_ratio.available_copy_ratio < circ_matchpoint.available_copy_hold_ratio THEN
            result.fail_part := 'config.circ_matrix_test.available_copy_hold_ratio';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    -- Fail if the user has too many items out by defined limit sets
    FOR circ_limit_set IN SELECT ccls.* FROM config.circ_limit_set ccls
      JOIN config.circ_matrix_limit_set_map ccmlsm ON ccmlsm.limit_set = ccls.id
      WHERE ccmlsm.active AND ( ccmlsm.matchpoint = circ_matchpoint.id OR
        ( ccmlsm.matchpoint IN (SELECT * FROM unnest(result.buildrows)) AND ccmlsm.fallthrough )
        ) LOOP
            IF circ_limit_set.items_out > 0 AND NOT renewal THEN
                SELECT INTO context_org_list ARRAY_AGG(aou.id)
                  FROM actor.org_unit_full_path( circ_ou ) aou
                    JOIN actor.org_unit_type aout ON aou.ou_type = aout.id
                  WHERE aout.depth >= circ_limit_set.depth;
                IF circ_limit_set.global THEN
                    WITH RECURSIVE descendant_depth AS (
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                        WHERE ou.id IN (SELECT * FROM unnest(context_org_list))
                            UNION
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                            JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
                    ) SELECT INTO context_org_list ARRAY_AGG(ou.id) FROM actor.org_unit ou JOIN descendant_depth USING (id);
                END IF;
                SELECT INTO items_out COUNT(DISTINCT circ.id)
                  FROM action.circulation circ
                    JOIN asset.copy copy ON (copy.id = circ.target_copy)
                    LEFT JOIN action.circulation_limit_group_map aclgm ON (circ.id = aclgm.circ)
                  WHERE circ.usr = match_user
                    AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                    AND circ.checkin_time IS NULL
                    AND (circ.stop_fines IN ('MAXFINES','LONGOVERDUE') OR circ.stop_fines IS NULL)
                    AND (copy.circ_modifier IN (SELECT circ_mod FROM config.circ_limit_set_circ_mod_map WHERE limit_set = circ_limit_set.id)
                        OR copy.location IN (SELECT copy_loc FROM config.circ_limit_set_copy_loc_map WHERE limit_set = circ_limit_set.id)
                        OR aclgm.limit_group IN (SELECT limit_group FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id)
                    );
                IF items_out >= circ_limit_set.items_out THEN
                    result.fail_part := 'config.circ_matrix_circ_mod_test';
                    result.success := FALSE;
                    done := TRUE;
                    RETURN NEXT result;
                END IF;
            END IF;
            SELECT INTO result.limit_groups result.limit_groups || ARRAY_AGG(limit_group) FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id AND NOT check_only;
    END LOOP;

    -- If we passed everything, return the successful matchpoint
    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO postgres;

--
-- Name: item_user_renew_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION item_user_renew_test(integer, bigint, integer) RETURNS SETOF circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, TRUE );
$_$;


ALTER FUNCTION action.item_user_renew_test(integer, bigint, integer) OWNER TO postgres;

--
-- Name: link_circ_limit_groups(bigint, integer[]); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION link_circ_limit_groups(bigint, integer[]) RETURNS void
    LANGUAGE sql
    AS $_$
    INSERT INTO action.circulation_limit_group_map(circ, limit_group) SELECT $1, id FROM config.circ_limit_group WHERE id IN (SELECT * FROM UNNEST($2));
$_$;


ALTER FUNCTION action.link_circ_limit_groups(bigint, integer[]) OWNER TO postgres;

--
-- Name: purge_circulations(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION purge_circulations() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    usr_keep_age    actor.usr_setting%ROWTYPE;
    usr_keep_start  actor.usr_setting%ROWTYPE;
    org_keep_age    INTERVAL;
    org_keep_count  INT;

    keep_age        INTERVAL;

    target_acp      RECORD;
    circ_chain_head action.circulation%ROWTYPE;
    circ_chain_tail action.circulation%ROWTYPE;

    purge_position  INT;
    count_purged    INT;
BEGIN

    count_purged := 0;

    SELECT value::INTERVAL INTO org_keep_age FROM config.global_flag WHERE name = 'history.circ.retention_age' AND enabled;

    SELECT value::INT INTO org_keep_count FROM config.global_flag WHERE name = 'history.circ.retention_count' AND enabled;
    IF org_keep_count IS NULL THEN
        RETURN count_purged; -- Gimme a count to keep, or I keep them all, forever
    END IF;

    -- First, find copies with more than keep_count non-renewal circs
    FOR target_acp IN
        SELECT  target_copy,
                COUNT(*) AS total_real_circs
          FROM  action.circulation
          WHERE parent_circ IS NULL
                AND xact_finish IS NOT NULL
          GROUP BY target_copy
          HAVING COUNT(*) > org_keep_count
    LOOP
        purge_position := 0;
        -- And, for those, select circs that are finished and older than keep_age
        FOR circ_chain_head IN
            SELECT  *
              FROM  action.circulation
              WHERE target_copy = target_acp.target_copy
                    AND parent_circ IS NULL
              ORDER BY xact_start
        LOOP

            -- Stop once we've purged enough circs to hit org_keep_count
            EXIT WHEN target_acp.total_real_circs - purge_position <= org_keep_count;

            SELECT * INTO circ_chain_tail FROM action.circ_chain(circ_chain_head.id) ORDER BY xact_start DESC LIMIT 1;
            EXIT WHEN circ_chain_tail.xact_finish IS NULL;

            -- Now get the user settings, if any, to block purging if the user wants to keep more circs
            usr_keep_age.value := NULL;
            SELECT * INTO usr_keep_age FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_age';

            usr_keep_start.value := NULL;
            SELECT * INTO usr_keep_start FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_start';

            IF usr_keep_age.value IS NOT NULL AND usr_keep_start.value IS NOT NULL THEN
                IF oils_json_to_text(usr_keep_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ) THEN
                    keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
                ELSE
                    keep_age := oils_json_to_text(usr_keep_age.value)::INTERVAL;
                END IF;
            ELSIF usr_keep_start.value IS NOT NULL THEN
                keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
            ELSE
                keep_age := COALESCE( org_keep_age::INTERVAL, '2000 years'::INTERVAL );
            END IF;

            EXIT WHEN AGE(NOW(), circ_chain_tail.xact_finish) < keep_age;

            -- We've passed the purging tests, purge the circ chain starting at the end
            DELETE FROM action.circulation WHERE id = circ_chain_tail.id;
            WHILE circ_chain_tail.parent_circ IS NOT NULL LOOP
                SELECT * INTO circ_chain_tail FROM action.circulation WHERE id = circ_chain_tail.parent_circ;
                DELETE FROM action.circulation WHERE id = circ_chain_tail.id;
            END LOOP;

            count_purged := count_purged + 1;
            purge_position := purge_position + 1;

        END LOOP;
    END LOOP;
END;
$$;


ALTER FUNCTION action.purge_circulations() OWNER TO postgres;

--
-- Name: push_circ_due_time(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION push_circ_due_time() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (EXTRACT(EPOCH FROM NEW.duration)::INT % EXTRACT(EPOCH FROM '1 day'::INTERVAL)::INT) = 0 THEN
        NEW.due_date = (NEW.due_date::DATE + '1 day'::INTERVAL - '1 second'::INTERVAL)::TIMESTAMPTZ;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION action.push_circ_due_time() OWNER TO postgres;

--
-- Name: summarize_circ_chain(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION summarize_circ_chain(ctx_circ_id integer) RETURNS circ_chain_summary
    LANGUAGE plpgsql
    AS $$

DECLARE

    -- first circ in the chain
    circ_0 action.circulation%ROWTYPE;

    -- last circ in the chain
    circ_n action.circulation%ROWTYPE;

    -- circ chain under construction
    chain action.circ_chain_summary;
    tmp_circ action.circulation%ROWTYPE;

BEGIN
    
    chain.num_circs := 0;
    FOR tmp_circ IN SELECT * FROM action.circ_chain(ctx_circ_id) LOOP

        IF chain.num_circs = 0 THEN
            circ_0 := tmp_circ;
        END IF;

        chain.num_circs := chain.num_circs + 1;
        circ_n := tmp_circ;
    END LOOP;

    chain.start_time := circ_0.xact_start;
    chain.last_stop_fines := circ_n.stop_fines;
    chain.last_stop_fines_time := circ_n.stop_fines_time;
    chain.last_checkin_time := circ_n.checkin_time;
    chain.last_checkin_scan_time := circ_n.checkin_scan_time;
    SELECT INTO chain.checkout_workstation name FROM actor.workstation WHERE id = circ_0.workstation;
    SELECT INTO chain.last_checkin_workstation name FROM actor.workstation WHERE id = circ_n.checkin_workstation;

    IF chain.num_circs > 1 THEN
        chain.last_renewal_time := circ_n.xact_start;
        SELECT INTO chain.last_renewal_workstation name FROM actor.workstation WHERE id = circ_n.workstation;
    END IF;

    RETURN chain;

END;
$$;


ALTER FUNCTION action.summarize_circ_chain(ctx_circ_id integer) OWNER TO postgres;

--
-- Name: survey_response_answer_date_fixup(); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION survey_response_answer_date_fixup() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	NEW.answer_date := NOW();
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.survey_response_answer_date_fixup() OWNER TO postgres;

--
-- Name: usr_visible_circ_copies(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION usr_visible_circ_copies(integer) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT DISTINCT(target_copy) FROM action.usr_visible_circs($1)
$_$;


ALTER FUNCTION action.usr_visible_circ_copies(integer) OWNER TO postgres;

--
-- Name: usr_visible_circs(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION usr_visible_circs(usr_id integer) RETURNS SETOF circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    c               action.circulation%ROWTYPE;
    view_age        INTERVAL;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_start';

    IF usr_view_age.value IS NOT NULL AND usr_view_start.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSIF usr_view_start.value IS NOT NULL THEN
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    ELSE
        -- User did not opt in
        RETURN;
    END IF;

    FOR c IN
        SELECT  *
          FROM  action.circulation
          WHERE usr = usr_id
                AND parent_circ IS NULL
                AND xact_start > NOW() - view_age
          ORDER BY xact_start DESC
    LOOP
        RETURN NEXT c;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_circs(usr_id integer) OWNER TO postgres;

--
-- Name: hold_request; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_request (
    id integer NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    requestor integer NOT NULL,
    usr integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT false NOT NULL,
    sms_notify text,
    sms_carrier integer,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    CONSTRAINT sms_check CHECK (((sms_notify IS NULL) OR (sms_carrier IS NOT NULL)))
);


ALTER TABLE action.hold_request OWNER TO postgres;

--
-- Name: usr_visible_holds(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION usr_visible_holds(usr_id integer) RETURNS SETOF hold_request
    LANGUAGE plpgsql
    AS $$
DECLARE
    h               action.hold_request%ROWTYPE;
    view_age        INTERVAL;
    view_count      INT;
    usr_view_count  actor.usr_setting%ROWTYPE;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_count FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_count';
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_start';

    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND fulfillment_time IS NULL
                AND cancel_time IS NULL
          ORDER BY request_time DESC
    LOOP
        RETURN NEXT h;
    END LOOP;

    IF usr_view_start.value IS NULL THEN
        RETURN;
    END IF;

    IF usr_view_age.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSE
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    END IF;

    IF usr_view_count.value IS NOT NULL THEN
        view_count := oils_json_to_text(usr_view_count.value)::INT;
    ELSE
        view_count := 1000;
    END IF;

    -- show some fulfilled/canceled holds
    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND ( fulfillment_time IS NOT NULL OR cancel_time IS NOT NULL )
                AND request_time > NOW() - view_age
          ORDER BY request_time DESC
          LIMIT view_count
    LOOP
        RETURN NEXT h;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_holds(usr_id integer) OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: address_alert; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE address_alert (
    id integer NOT NULL,
    owner integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    match_all boolean DEFAULT true NOT NULL,
    alert_message text NOT NULL,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    mailing_address boolean DEFAULT false NOT NULL,
    billing_address boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.address_alert OWNER TO postgres;

--
-- Name: address_alert_matches(integer, text, text, text, text, text, text, text, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean DEFAULT false, billing_address boolean DEFAULT false) RETURNS SETOF address_alert
    LANGUAGE sql
    AS $_$

SELECT *
FROM actor.address_alert
WHERE
    active
    AND owner IN (SELECT id FROM actor.org_unit_ancestors($1)) 
    AND (
        (NOT mailing_address AND NOT billing_address)
        OR (mailing_address AND $9)
        OR (billing_address AND $10)
    )
    AND (
            (
                match_all
                AND COALESCE($2, '') ~* COALESCE(street1,   '.*')
                AND COALESCE($3, '') ~* COALESCE(street2,   '.*')
                AND COALESCE($4, '') ~* COALESCE(city,      '.*')
                AND COALESCE($5, '') ~* COALESCE(county,    '.*')
                AND COALESCE($6, '') ~* COALESCE(state,     '.*')
                AND COALESCE($7, '') ~* COALESCE(country,   '.*')
                AND COALESCE($8, '') ~* COALESCE(post_code, '.*')
            ) OR (
                NOT match_all 
                AND (  
                       $2 ~* street1
                    OR $3 ~* street2
                    OR $4 ~* city
                    OR $5 ~* county
                    OR $6 ~* state
                    OR $7 ~* country
                    OR $8 ~* post_code
                )
            )
        )
    ORDER BY actor.org_unit_proximity(owner, $1)
$_$;


ALTER FUNCTION actor.address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean, billing_address boolean) OWNER TO postgres;

--
-- Name: approve_pending_address(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION approve_pending_address(pending_id integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_id INT;
BEGIN
    SELECT INTO old_id replaces FROM actor.usr_address where id = pending_id;
    IF old_id IS NULL THEN
        UPDATE actor.usr_address SET pending = 'f' WHERE id = pending_id;
        RETURN pending_id;
    END IF;
    -- address replaces an existing address
    DELETE FROM actor.usr_address WHERE id = -old_id;
    UPDATE actor.usr_address SET id = -id WHERE id = old_id;
    UPDATE actor.usr_address SET replaces = NULL, id = old_id, pending = 'f' WHERE id = pending_id;
    RETURN old_id;
END
$$;


ALTER FUNCTION actor.approve_pending_address(pending_id integer) OWNER TO postgres;

--
-- Name: FUNCTION approve_pending_address(pending_id integer); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION approve_pending_address(pending_id integer) IS '
Replaces an address with a pending address.  This is done by giving the pending 
address the ID of the old address.  The replaced address is retained with -id.
';


--
-- Name: au_updated(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION au_updated() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.last_update_time := now();
	RETURN NEW;
END;
$$;


ALTER FUNCTION actor.au_updated() OWNER TO postgres;

--
-- Name: usr_standing_penalty; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_standing_penalty (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    standing_penalty integer NOT NULL,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE actor.usr_standing_penalty OWNER TO postgres;

--
-- Name: TABLE usr_standing_penalty; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE usr_standing_penalty IS '
User standing penalties
';


--
-- Name: calculate_system_penalties(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION calculate_system_penalties(match_user integer, context_org integer) RETURNS SETOF usr_standing_penalty
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object         actor.usr%ROWTYPE;
    new_sp_row          actor.usr_standing_penalty%ROWTYPE;
    existing_sp_row     actor.usr_standing_penalty%ROWTYPE;
    collections_fines   permission.grp_penalty_threshold%ROWTYPE;
    max_fines           permission.grp_penalty_threshold%ROWTYPE;
    max_overdue         permission.grp_penalty_threshold%ROWTYPE;
    max_items_out       permission.grp_penalty_threshold%ROWTYPE;
    tmp_grp             INT;
    items_overdue       INT;
    items_out           INT;
    context_org_list    INT[];
    current_fines        NUMERIC(8,2) := 0.0;
    tmp_fines            NUMERIC(8,2);
    tmp_groc            RECORD;
    tmp_circ            RECORD;
    tmp_org             actor.org_unit%ROWTYPE;
    tmp_penalty         config.standing_penalty%ROWTYPE;
    tmp_depth           INTEGER;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;

    -- Max fines
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a high fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 1 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 1;

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL ) l USING (id);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 1;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max overdue
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many overdue items
    LOOP
        tmp_grp := user_object.profile;
        LOOP

            SELECT * INTO max_overdue FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 2 AND org_unit = tmp_org.id;

            IF max_overdue.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_overdue.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_overdue.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_overdue.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 2;

        SELECT  INTO items_overdue COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_overdue.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
            AND circ.checkin_time IS NULL
            AND circ.due_date < NOW()
            AND (circ.stop_fines = 'MAXFINES' OR circ.stop_fines IS NULL);

        IF items_overdue >= max_overdue.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_overdue.org_unit;
            new_sp_row.standing_penalty := 2;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max out
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many checked out items
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_items_out FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 3 AND org_unit = tmp_org.id;

            IF max_items_out.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_items_out.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;


    -- Fail if the user has too many items checked out
    IF max_items_out.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_items_out.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 3;

        SELECT  INTO items_out COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_items_out.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
                AND circ.checkin_time IS NULL
                AND (circ.stop_fines IN ('MAXFINES','LONGOVERDUE') OR circ.stop_fines IS NULL);

           IF items_out >= max_items_out.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_items_out.org_unit;
            new_sp_row.standing_penalty := 3;
            RETURN NEXT new_sp_row;
           END IF;
    END IF;

    -- Start over for collections warning
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a collections-level fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 4 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 4;

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND r.xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND g.xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND circ.xact_finish IS NULL ) l USING (id);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 4;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for in collections
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Remove the in-collections penalty if the user has paid down enough
    -- This penalty is different, because this code is not responsible for creating 
    -- new in-collections penalties, only for removing them
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 30 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        -- first, see if the user had paid down to the threshold
        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND r.xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND g.xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND circ.xact_finish IS NULL ) l USING (id);

        IF current_fines IS NULL OR current_fines <= max_fines.threshold THEN
            -- patron has paid down enough

            SELECT INTO tmp_penalty * FROM config.standing_penalty WHERE id = 30;

            IF tmp_penalty.org_depth IS NOT NULL THEN

                -- since this code is not responsible for applying the penalty, it can't 
                -- guarantee the current context org will match the org at which the penalty 
                --- was applied.  search up the org tree until we hit the configured penalty depth
                SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;
                SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;

                WHILE tmp_depth >= tmp_penalty.org_depth LOOP

                    RETURN QUERY
                        SELECT  *
                          FROM  actor.usr_standing_penalty
                          WHERE usr = match_user
                                AND org_unit = tmp_org.id
                                AND (stop_date IS NULL or stop_date > NOW())
                                AND standing_penalty = 30;

                    IF tmp_org.parent_ou IS NULL THEN
                        EXIT;
                    END IF;

                    SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;
                    SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;
                END LOOP;

            ELSE

                -- no penalty depth is defined, look for exact matches

                RETURN QUERY
                    SELECT  *
                      FROM  actor.usr_standing_penalty
                      WHERE usr = match_user
                            AND org_unit = max_fines.org_unit
                            AND (stop_date IS NULL or stop_date > NOW())
                            AND standing_penalty = 30;
            END IF;
    
        END IF;

    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION actor.calculate_system_penalties(match_user integer, context_org integer) OWNER TO postgres;

--
-- Name: crypt_pw_insert(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION crypt_pw_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW.passwd = MD5( NEW.passwd );
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_insert() OWNER TO postgres;

--
-- Name: crypt_pw_update(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION crypt_pw_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.passwd <> OLD.passwd THEN
			NEW.passwd = MD5( NEW.passwd );
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_update() OWNER TO postgres;

--
-- Name: usr_activity; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_activity (
    id bigint NOT NULL,
    usr integer,
    etype integer NOT NULL,
    event_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.usr_activity OWNER TO postgres;

--
-- Name: insert_usr_activity(integer, text, text, text); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) RETURNS SETOF usr_activity
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_row actor.usr_activity%ROWTYPE;
BEGIN
    SELECT id INTO new_row.etype FROM actor.usr_activity_get_type(ewho, ewhat, ehow);
    IF FOUND THEN
        new_row.usr := usr;
        INSERT INTO actor.usr_activity (usr, etype) 
            VALUES (usr, new_row.etype)
            RETURNING * INTO new_row;
        RETURN NEXT new_row;
    END IF;
END;
$$;


ALTER FUNCTION actor.insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) OWNER TO postgres;

--
-- Name: org_unit; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit (
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean DEFAULT true NOT NULL,
    fiscal_calendar integer DEFAULT 1 NOT NULL
);


ALTER TABLE actor.org_unit OWNER TO postgres;

--
-- Name: org_unit_ancestor_at_depth(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_ancestor_at_depth(integer, integer) RETURNS org_unit
    LANGUAGE sql STABLE
    AS $_$
	SELECT	a.*
	  FROM	actor.org_unit a
	  WHERE	id = ( SELECT FIRST(x.id)
	  		 FROM	actor.org_unit_ancestors($1) x
			   	JOIN actor.org_unit_type y
					ON x.ou_type = y.id AND y.depth = $2);
$_$;


ALTER FUNCTION actor.org_unit_ancestor_at_depth(integer, integer) OWNER TO postgres;

SET search_path = evergreen, pg_catalog;

--
-- Name: is_json(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION is_json(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;
    my $json = shift();
    eval { JSON::XS->new->allow_nonref->decode( $json ) };
    return $@ ? 0 : 1;
$_$;


ALTER FUNCTION evergreen.is_json(text) OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: org_unit_setting; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_setting (
    id bigint NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL,
    CONSTRAINT aous_must_be_json CHECK (evergreen.is_json(value))
);


ALTER TABLE actor.org_unit_setting OWNER TO postgres;

--
-- Name: TABLE org_unit_setting; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE org_unit_setting IS '
Org Unit settings

This table contains any arbitrary settings that a client
program would like to save for an org unit.
';


--
-- Name: org_unit_ancestor_setting(text, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer) RETURNS SETOF org_unit_setting
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
DECLARE
    setting RECORD;
    cur_org INT;
BEGIN
    cur_org := org_id;
    LOOP
        SELECT INTO setting * FROM actor.org_unit_setting WHERE org_unit = cur_org AND name = setting_name;
        IF FOUND THEN
            RETURN NEXT setting;
            EXIT;
        END IF;
        SELECT INTO cur_org parent_ou FROM actor.org_unit WHERE id = cur_org;
        EXIT WHEN cur_org IS NULL;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION actor.org_unit_ancestor_setting(setting_name text, org_id integer) OWNER TO postgres;

--
-- Name: FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer) IS '
Search "up" the org_unit tree until we find the first occurrence of an 
org_unit_setting with the given name.
';


--
-- Name: org_unit_ancestors(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_ancestors(integer) RETURNS SETOF org_unit
    LANGUAGE sql ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT ou.* FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad USING (id) ORDER BY ouad.distance DESC;
$_$;


ALTER FUNCTION actor.org_unit_ancestors(integer) OWNER TO postgres;

--
-- Name: org_unit_ancestors_distance(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT * FROM org_unit_ancestors_distance;
$_$;


ALTER FUNCTION actor.org_unit_ancestors_distance(integer) OWNER TO postgres;

--
-- Name: org_unit_combined_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_combined_ancestors(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			UNION
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_combined_ancestors(integer, integer) OWNER TO postgres;

--
-- Name: org_unit_common_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_common_ancestors(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			INTERSECT
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_common_ancestors(integer, integer) OWNER TO postgres;

--
-- Name: org_unit_descendants(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_descendants(integer) RETURNS SETOF org_unit
    LANGUAGE sql ROWS 1
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer) OWNER TO postgres;

--
-- Name: org_unit_descendants(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_descendants(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql ROWS 1
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ad ON (ad.id = ou.id)
          WHERE ad.depth = $2
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ), anscestor_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer, integer) OWNER TO postgres;

--
-- Name: org_unit_descendants_distance(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.id, oudd.distance+1
            FROM actor.org_unit ou JOIN org_unit_descendants_distance oudd ON (ou.parent_ou = oudd.id)
    )
    SELECT * FROM org_unit_descendants_distance;
$_$;


ALTER FUNCTION actor.org_unit_descendants_distance(integer) OWNER TO postgres;

--
-- Name: org_unit_full_path(integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_full_path(integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			UNION
	SELECT	*
	  FROM	actor.org_unit_descendants($1);
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer) OWNER TO postgres;

--
-- Name: org_unit_full_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_full_path(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	* FROM actor.org_unit_full_path((actor.org_unit_ancestor_at_depth($1, $2)).id)
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer, integer) OWNER TO postgres;

--
-- Name: org_unit_parent_protect(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_parent_protect() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	DECLARE
		current_aou actor.org_unit%ROWTYPE;
		seen_ous    INT[];
		depth_count INT;
	BEGIN
		current_aou := NEW;
		depth_count := 0;
		seen_ous := ARRAY[NEW.id];

		IF (TG_OP = 'UPDATE') THEN
			IF (NEW.parent_ou IS NOT DISTINCT FROM OLD.parent_ou) THEN
				RETURN NEW; -- Doing an UPDATE with no change, just return it
			END IF;
		END IF;

		LOOP
			IF current_aou.parent_ou IS NULL THEN -- Top of the org tree?
				RETURN NEW; -- No loop. Carry on.
			END IF;
			IF current_aou.parent_ou = ANY(seen_ous) THEN -- Parent is one we have seen?
				RAISE 'OU LOOP: Saw % twice', current_aou.parent_ou; -- LOOP! ABORT!
			END IF;
			-- Get the next one!
			SELECT INTO current_aou * FROM actor.org_unit WHERE id = current_aou.parent_ou;
			seen_ous := seen_ous || current_aou.id;
			depth_count := depth_count + 1;
			IF depth_count = 100 THEN
				RAISE 'OU CHECK TOO DEEP';
			END IF;
		END LOOP;

		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.org_unit_parent_protect() OWNER TO postgres;

--
-- Name: org_unit_prox_update(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_prox_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN


IF TG_OP = 'DELETE' THEN

    DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);

END IF;

IF TG_OP = 'UPDATE' THEN

    IF NEW.parent_ou <> OLD.parent_ou THEN

        DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);
            INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
            SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
                FROM  actor.org_unit l, actor.org_unit r
                WHERE (l.id = NEW.id or r.id = NEW.id);

    END IF;

END IF;

IF TG_OP = 'INSERT' THEN

     INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
     SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
         FROM  actor.org_unit l, actor.org_unit r
         WHERE (l.id = NEW.id or r.id = NEW.id);

END IF;

RETURN null;

END;
$$;


ALTER FUNCTION actor.org_unit_prox_update() OWNER TO postgres;

--
-- Name: org_unit_proximity(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_proximity(integer, integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
	SELECT COUNT(id)::INT FROM (
		SELECT id FROM actor.org_unit_combined_ancestors($1, $2)
			EXCEPT
		SELECT id FROM actor.org_unit_common_ancestors($1, $2)
	) z;
$_$;


ALTER FUNCTION actor.org_unit_proximity(integer, integer) OWNER TO postgres;

--
-- Name: org_unit_simple_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION org_unit_simple_path(integer, integer) RETURNS integer[]
    LANGUAGE sql STABLE
    AS $_$
    WITH RECURSIVE descendant_depth(id, path) AS (
        SELECT  aou.id,
                ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
          WHERE aou.id = $2
            UNION ALL
        SELECT  aou.id,
                dd.path || ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
                JOIN descendant_depth dd ON (dd.id = aou.parent_ou)
    ) SELECT dd.path
        FROM actor.org_unit aou
        JOIN descendant_depth dd USING (id)
        WHERE aou.id = $1 ORDER BY dd.path;
$_$;


ALTER FUNCTION actor.org_unit_simple_path(integer, integer) OWNER TO postgres;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield actor.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM actor.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM actor.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.stat_cat_check() OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: usr_activity_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_activity_type (
    id integer NOT NULL,
    ewho text,
    ewhat text,
    ehow text,
    label text NOT NULL,
    egroup usr_activity_group NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    transient boolean DEFAULT false NOT NULL,
    CONSTRAINT one_of_wwh CHECK ((COALESCE(ewho, ewhat, ehow) IS NOT NULL))
);


ALTER TABLE config.usr_activity_type OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: usr_activity_get_type(text, text, text); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_activity_get_type(ewho text, ewhat text, ehow text) RETURNS SETOF config.usr_activity_type
    LANGUAGE sql
    AS $_$
SELECT * FROM config.usr_activity_type 
    WHERE 
        enabled AND 
        (ewho  IS NULL OR ewho  = $1) AND
        (ewhat IS NULL OR ewhat = $2) AND
        (ehow  IS NULL OR ehow  = $3) 
    ORDER BY 
        -- BOOL comparisons sort false to true
        COALESCE(ewho, '')  != COALESCE($1, ''),
        COALESCE(ewhat,'')  != COALESCE($2, ''),
        COALESCE(ehow, '')  != COALESCE($3, '') 
    LIMIT 1;
$_$;


ALTER FUNCTION actor.usr_activity_get_type(ewho text, ewhat text, ehow text) OWNER TO postgres;

--
-- Name: usr_activity_transient_trg(); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_activity_transient_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM actor.usr_activity act USING config.usr_activity_type atype
        WHERE atype.transient AND 
            NEW.etype = atype.id AND
            act.etype = atype.id AND
            act.usr = NEW.usr;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.usr_activity_transient_trg() OWNER TO postgres;

--
-- Name: usr_delete(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_delete(src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_profile actor.usr.profile%type;
	old_home_ou actor.usr.home_ou%type;
	new_profile actor.usr.profile%type;
	new_home_ou actor.usr.home_ou%type;
	new_name    text;
	new_dob     actor.usr.dob%type;
BEGIN
	SELECT
		id || '-PURGED-' || now(),
		profile,
		home_ou,
		dob
	INTO
		new_name,
		old_profile,
		old_home_ou,
		new_dob
	FROM
		actor.usr
	WHERE
		id = src_usr;
	--
	-- Quit if no such user
	--
	IF old_profile IS NULL THEN
		RETURN;
	END IF;
	--
	perform actor.usr_purge_data( src_usr, dest_usr );
	--
	-- Find the root grp_tree and the root org_unit.  This would be simpler if we 
	-- could assume that there is only one root.  Theoretically, someday, maybe,
	-- there could be multiple roots, so we take extra trouble to get the right ones.
	--
	SELECT
		id
	INTO
		new_profile
	FROM
		permission.grp_ancestors( old_profile )
	WHERE
		parent is null;
	--
	SELECT
		id
	INTO
		new_home_ou
	FROM
		actor.org_unit_ancestors( old_home_ou )
	WHERE
		parent_ou is null;
	--
	-- Truncate date of birth
	--
	IF new_dob IS NOT NULL THEN
		new_dob := date_trunc( 'year', new_dob );
	END IF;
	--
	UPDATE
		actor.usr
		SET
			card = NULL,
			profile = new_profile,
			usrname = new_name,
			email = NULL,
			passwd = random()::text,
			standing = DEFAULT,
			ident_type = 
			(
				SELECT MIN( id )
				FROM config.identification_type
			),
			ident_value = NULL,
			ident_type2 = NULL,
			ident_value2 = NULL,
			net_access_level = DEFAULT,
			photo_url = NULL,
			prefix = NULL,
			first_given_name = new_name,
			second_given_name = NULL,
			family_name = new_name,
			suffix = NULL,
			alias = NULL,
			day_phone = NULL,
			evening_phone = NULL,
			other_phone = NULL,
			mailing_address = NULL,
			billing_address = NULL,
			home_ou = new_home_ou,
			dob = new_dob,
			active = FALSE,
			master_account = DEFAULT, 
			super_user = DEFAULT,
			barred = FALSE,
			deleted = TRUE,
			juvenile = DEFAULT,
			usrgroup = 0,
			claims_returned_count = DEFAULT,
			credit_forward_balance = DEFAULT,
			last_xact_id = DEFAULT,
			alert_message = NULL,
			create_date = now(),
			expire_date = now()
	WHERE
		id = src_usr;
END;
$$;


ALTER FUNCTION actor.usr_delete(src_usr integer, dest_usr integer) OWNER TO postgres;

--
-- Name: FUNCTION usr_delete(src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION usr_delete(src_usr integer, dest_usr integer) IS '
Logically deletes a user.  Removes personally identifiable information,
and purges associated data in other tables.
';


--
-- Name: usr_merge(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	bucket_row RECORD;
	picklist_row RECORD;
	queue_row RECORD;
	folder_row RECORD;
BEGIN

    -- do some initial cleanup 
    UPDATE actor.usr SET card = NULL WHERE id = src_usr;
    UPDATE actor.usr SET mailing_address = NULL WHERE id = src_usr;
    UPDATE actor.usr SET billing_address = NULL WHERE id = src_usr;

    -- actor.*
    IF del_cards THEN
        DELETE FROM actor.card where usr = src_usr;
    ELSE
        IF deactivate_cards THEN
            UPDATE actor.card SET active = 'f' WHERE usr = src_usr;
        END IF;
        UPDATE actor.card SET usr = dest_usr WHERE usr = src_usr;
    END IF;


    IF del_addrs THEN
        DELETE FROM actor.usr_address WHERE usr = src_usr;
    ELSE
        UPDATE actor.usr_address SET usr = dest_usr WHERE usr = src_usr;
    END IF;

    UPDATE actor.usr_note SET usr = dest_usr WHERE usr = src_usr;
    -- dupes are technically OK in actor.usr_standing_penalty, should manually delete them...
    UPDATE actor.usr_standing_penalty SET usr = dest_usr WHERE usr = src_usr;
    PERFORM actor.usr_merge_rows('actor.usr_org_unit_opt_in', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('actor.usr_setting', 'usr', src_usr, dest_usr);

    -- permission.*
    PERFORM actor.usr_merge_rows('permission.usr_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_object_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_grp_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_work_ou_map', 'usr', src_usr, dest_usr);


    -- container.*
	
	-- For each *_bucket table: transfer every bucket belonging to src_usr
	-- into the custody of dest_usr.
	--
	-- In order to avoid colliding with an existing bucket owned by
	-- the destination user, append the source user's id (in parenthesese)
	-- to the name.  If you still get a collision, add successive
	-- spaces to the name and keep trying until you succeed.
	--
	FOR bucket_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE container.user_bucket_item SET target_user = dest_usr WHERE target_user = src_usr;

    -- vandelay.*
	-- transfer queues the same way we transfer buckets (see above)
	FOR queue_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = queue_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    -- money.*
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'collector', src_usr, dest_usr);
    UPDATE money.billable_xact SET usr = dest_usr WHERE usr = src_usr;
    UPDATE money.billing SET voider = dest_usr WHERE voider = src_usr;
    UPDATE money.bnm_payment SET accepting_usr = dest_usr WHERE accepting_usr = src_usr;

    -- action.*
    UPDATE action.circulation SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
    UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;

    UPDATE action.hold_request SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
    UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
    UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;

    UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET patron = dest_usr WHERE patron = src_usr;
    UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.survey_response SET usr = dest_usr WHERE usr = src_usr;

    -- acq.*
    UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
	UPDATE acq.fund_transfer SET transfer_user = dest_usr WHERE transfer_user = src_usr;

	-- transfer picklists the same way we transfer buckets (see above)
	FOR picklist_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = picklist_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
    UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.provider_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.provider_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_usr_attr_definition SET usr = dest_usr WHERE usr = src_usr;

    -- asset.*
    UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;

    -- serial.*
    UPDATE serial.record_entry SET creator = dest_usr WHERE creator = src_usr;
    UPDATE serial.record_entry SET editor = dest_usr WHERE editor = src_usr;

    -- reporter.*
    -- It's not uncommon to define the reporter schema in a replica 
    -- DB only, so don't assume these tables exist in the write DB.
    BEGIN
    	UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;

    -- Finally, delete the source user
    DELETE FROM actor.usr WHERE id = src_usr;

END;
$$;


ALTER FUNCTION actor.usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) OWNER TO postgres;

--
-- Name: FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) IS '
Merges all user date from src_usr to dest_usr.  When collisions occur, 
keep dest_usr''s data and delete src_usr''s data.
';


--
-- Name: usr_merge_rows(text, text, integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    sel TEXT;
    upd TEXT;
    del TEXT;
    cur_row RECORD;
BEGIN
    sel := 'SELECT id::BIGINT FROM ' || table_name || ' WHERE ' || quote_ident(col_name) || ' = ' || quote_literal(src_usr);
    upd := 'UPDATE ' || table_name || ' SET ' || quote_ident(col_name) || ' = ' || quote_literal(dest_usr) || ' WHERE id = ';
    del := 'DELETE FROM ' || table_name || ' WHERE id = ';
    FOR cur_row IN EXECUTE sel LOOP
        BEGIN
            --RAISE NOTICE 'Attempting to merge % %', table_name, cur_row.id;
            EXECUTE upd || cur_row.id;
        EXCEPTION WHEN unique_violation THEN
            --RAISE NOTICE 'Deleting conflicting % %', table_name, cur_row.id;
            EXECUTE del || cur_row.id;
        END;
    END LOOP;
END;
$$;


ALTER FUNCTION actor.usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) OWNER TO postgres;

--
-- Name: FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) IS '
Attempts to move each row of the specified table from src_user to dest_user.  
Where conflicts exist, the conflicting "source" row is deleted.
';


--
-- Name: usr_purge_data(integer, integer); Type: FUNCTION; Schema: actor; Owner: postgres
--

CREATE FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	renamable_row RECORD;
	dest_usr INTEGER;
BEGIN

	IF specified_dest_usr IS NULL THEN
		dest_usr := 1; -- Admin user on stock installs
	ELSE
		dest_usr := specified_dest_usr;
	END IF;

	UPDATE actor.usr SET
		active = FALSE,
		card = NULL,
		mailing_address = NULL,
		billing_address = NULL
	WHERE id = src_usr;

	-- acq.*
	UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
	UPDATE acq.lineitem SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.lineitem SET selector = dest_usr WHERE selector = src_usr;
	UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
	DELETE FROM acq.lineitem_usr_attr_definition WHERE usr = src_usr;

	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE acq.picklist SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.picklist SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
	UPDATE acq.purchase_order SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.purchase_order SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.claim_event SET creator = dest_usr WHERE creator = src_usr;

	-- action.*
	DELETE FROM action.circulation WHERE usr = src_usr;
	UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
	UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;
	UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;
	UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
	UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
	DELETE FROM action.hold_request WHERE usr = src_usr;
	UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
	UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.non_cataloged_circulation WHERE patron = src_usr;
	UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.survey_response WHERE usr = src_usr;
	UPDATE action.fieldset SET owner = dest_usr WHERE owner = src_usr;

	-- actor.*
	DELETE FROM actor.card WHERE usr = src_usr;
	DELETE FROM actor.stat_cat_entry_usr_map WHERE target_usr = src_usr;

	-- The following update is intended to avoid transient violations of a foreign
	-- key constraint, whereby actor.usr_address references itself.  It may not be
	-- necessary, but it does no harm.
	UPDATE actor.usr_address SET replaces = NULL
		WHERE usr = src_usr AND replaces IS NOT NULL;
	DELETE FROM actor.usr_address WHERE usr = src_usr;
	DELETE FROM actor.usr_note WHERE usr = src_usr;
	UPDATE actor.usr_note SET creator = dest_usr WHERE creator = src_usr;
	DELETE FROM actor.usr_org_unit_opt_in WHERE usr = src_usr;
	UPDATE actor.usr_org_unit_opt_in SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM actor.usr_setting WHERE usr = src_usr;
	DELETE FROM actor.usr_standing_penalty WHERE usr = src_usr;
	UPDATE actor.usr_standing_penalty SET staff = dest_usr WHERE staff = src_usr;

	-- asset.*
	UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;

	-- auditor.*
	DELETE FROM auditor.actor_usr_address_history WHERE id = src_usr;
	DELETE FROM auditor.actor_usr_history WHERE id = src_usr;
	UPDATE auditor.asset_call_number_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_call_number_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.asset_copy_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_copy_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.biblio_record_entry_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.biblio_record_entry_history SET editor  = dest_usr WHERE editor  = src_usr;

	-- biblio.*
	UPDATE biblio.record_entry SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_entry SET editor = dest_usr WHERE editor = src_usr;
	UPDATE biblio.record_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_note SET editor = dest_usr WHERE editor = src_usr;

	-- container.*
	-- Update buckets with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	DELETE FROM container.user_bucket_item WHERE target_user = src_usr;

	-- money.*
	DELETE FROM money.billable_xact WHERE usr = src_usr;
	DELETE FROM money.collections_tracker WHERE usr = src_usr;
	UPDATE money.collections_tracker SET collector = dest_usr WHERE collector = src_usr;

	-- permission.*
	DELETE FROM permission.usr_grp_map WHERE usr = src_usr;
	DELETE FROM permission.usr_object_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_work_ou_map WHERE usr = src_usr;

	-- reporter.*
	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
	-- do nothing
	END;

	-- vandelay.*
	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

END;
$$;


ALTER FUNCTION actor.usr_purge_data(src_usr integer, specified_dest_usr integer) OWNER TO postgres;

--
-- Name: FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer); Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer) IS '
Finds rows dependent on a given row in actor.usr and either deletes them
or reassigns them to a different user.
';


SET search_path = asset, pg_catalog;

--
-- Name: acp_created(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION acp_created() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
        NEW.active_date := now();
    END IF;
    IF NEW.status_changed_time IS NULL THEN
        NEW.status_changed_time := now();
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_created() OWNER TO postgres;

--
-- Name: acp_status_changed(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION acp_status_changed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.status <> OLD.status AND NOT (NEW.status = 0 AND OLD.status = 7) THEN
        NEW.status_changed_time := now();
        IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
            NEW.active_date := now();
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_status_changed() OWNER TO postgres;

--
-- Name: autogenerate_placeholder_barcode(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION autogenerate_placeholder_barcode() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.barcode LIKE '@@%' THEN
		NEW.barcode := '@@' || NEW.id;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION asset.autogenerate_placeholder_barcode() OWNER TO postgres;

--
-- Name: cache_copy_visibility(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION cache_copy_visibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    add_front       TEXT;
    add_back        TEXT;
    add_base_query  TEXT;
    add_peer_query  TEXT;
    remove_query    TEXT;
    do_add          BOOLEAN := false;
    do_remove       BOOLEAN := false;
BEGIN
    add_base_query := $$
        SELECT  cp.id, cp.circ_lib, cn.record, cn.id AS call_number, cp.location, cp.status
          FROM  asset.copy cp
                JOIN asset.call_number cn ON (cn.id = cp.call_number)
                JOIN actor.org_unit a ON (cp.circ_lib = a.id)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN config.copy_status cs ON (cp.status = cs.id)
                JOIN biblio.record_entry b ON (cn.record = b.id)
          WHERE NOT cp.deleted
                AND NOT cn.deleted
                AND NOT b.deleted
                AND cs.opac_visible
                AND cl.opac_visible
                AND cp.opac_visible
                AND a.opac_visible
    $$;
    add_peer_query := $$
        SELECT  cp.id, cp.circ_lib, pbcm.peer_record AS record, NULL AS call_number, cp.location, cp.status
          FROM  asset.copy cp
                JOIN biblio.peer_bib_copy_map pbcm ON (pbcm.target_copy = cp.id)
                JOIN actor.org_unit a ON (cp.circ_lib = a.id)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN config.copy_status cs ON (cp.status = cs.id)
          WHERE NOT cp.deleted
                AND cs.opac_visible
                AND cl.opac_visible
                AND cp.opac_visible
                AND a.opac_visible
    $$;
    add_front := $$
        INSERT INTO asset.opac_visible_copies (copy_id, circ_lib, record)
          SELECT DISTINCT ON (id, record) id, circ_lib, record FROM (
    $$;
    add_back := $$
        ) AS x
    $$;
 
    remove_query := $$ DELETE FROM asset.opac_visible_copies WHERE copy_id IN ( SELECT id FROM asset.copy WHERE $$;

    IF TG_TABLE_NAME = 'peer_bib_copy_map' THEN
        IF TG_OP = 'INSERT' THEN
            add_peer_query := add_peer_query || ' AND cp.id = ' || NEW.target_copy || ' AND pbcm.peer_record = ' || NEW.peer_record;
            EXECUTE add_front || add_peer_query || add_back;
            RETURN NEW;
        ELSE
            remove_query := 'DELETE FROM asset.opac_visible_copies WHERE copy_id = ' || OLD.target_copy || ' AND record = ' || OLD.peer_record || ';';
            EXECUTE remove_query;
            RETURN OLD;
        END IF;
    END IF;

    IF TG_OP = 'INSERT' THEN

        IF TG_TABLE_NAME IN ('copy', 'unit') THEN
            add_base_query := add_base_query || ' AND cp.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    -- handle items first, since with circulation activity
    -- their statuses change frequently
    IF TG_TABLE_NAME IN ('copy', 'unit') THEN

        IF OLD.location    <> NEW.location OR
           OLD.call_number <> NEW.call_number OR
           OLD.status      <> NEW.status OR
           OLD.circ_lib    <> NEW.circ_lib THEN
            -- any of these could change visibility, but
            -- we'll save some queries and not try to calculate
            -- the change directly
            do_remove := true;
            do_add := true;
        ELSE

            IF OLD.deleted <> NEW.deleted THEN
                IF NEW.deleted THEN
                    do_remove := true;
                ELSE
                    do_add := true;
                END IF;
            END IF;

            IF OLD.opac_visible <> NEW.opac_visible THEN
                IF OLD.opac_visible THEN
                    do_remove := true;
                ELSIF NOT do_remove THEN -- handle edge case where deleted item
                                        -- is also marked opac_visible
                    do_add := true;
                END IF;
            END IF;

        END IF;

        IF do_remove THEN
            DELETE FROM asset.opac_visible_copies WHERE copy_id = NEW.id;
        END IF;
        IF do_add THEN
            add_base_query := add_base_query || ' AND cp.id = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    IF TG_TABLE_NAME IN ('call_number', 'record_entry') THEN -- these have a 'deleted' column
 
        IF OLD.deleted AND NEW.deleted THEN -- do nothing

            RETURN NEW;
 
        ELSIF NEW.deleted THEN -- remove rows
 
            IF TG_TABLE_NAME = 'call_number' THEN
                DELETE FROM asset.opac_visible_copies WHERE copy_id IN (SELECT id FROM asset.copy WHERE call_number = NEW.id);
            ELSIF TG_TABLE_NAME = 'record_entry' THEN
                DELETE FROM asset.opac_visible_copies WHERE record = NEW.id;
            END IF;
 
            RETURN NEW;
 
        ELSIF OLD.deleted THEN -- add rows
 
            IF TG_TABLE_NAME = 'call_number' THEN
                add_base_query := add_base_query || ' AND cn.id = ' || NEW.id;
                EXECUTE add_front || add_base_query || add_back;
            ELSIF TG_TABLE_NAME = 'record_entry' THEN
                add_base_query := add_base_query || ' AND cn.record = ' || NEW.id;
                add_peer_query := add_peer_query || ' AND pbcm.peer_record = ' || NEW.id;
                EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
            END IF;
 
            RETURN NEW;
 
        END IF;
 
    END IF;

    IF TG_TABLE_NAME = 'call_number' THEN

        IF OLD.record <> NEW.record THEN
            -- call number is linked to different bib
            remove_query := remove_query || 'call_number = ' || NEW.id || ');';
            EXECUTE remove_query;
            add_base_query := add_base_query || ' AND cn.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    IF TG_TABLE_NAME IN ('record_entry') THEN
        RETURN NEW; -- don't have 'opac_visible'
    END IF;

    -- actor.org_unit, asset.copy_location, asset.copy_status
    IF NEW.opac_visible = OLD.opac_visible THEN -- do nothing

        RETURN NEW;

    ELSIF NEW.opac_visible THEN -- add rows

        IF TG_TABLE_NAME = 'org_unit' THEN
            add_base_query := add_base_query || ' AND cp.circ_lib = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.circ_lib = ' || NEW.id;
        ELSIF TG_TABLE_NAME = 'copy_location' THEN
            add_base_query := add_base_query || ' AND cp.location = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.location = ' || NEW.id;
        ELSIF TG_TABLE_NAME = 'copy_status' THEN
            add_base_query := add_base_query || ' AND cp.status = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.status = ' || NEW.id;
        END IF;
 
        EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
 
    ELSE -- delete rows

        IF TG_TABLE_NAME = 'org_unit' THEN
            remove_query := 'DELETE FROM asset.opac_visible_copies WHERE circ_lib = ' || NEW.id || ';';
        ELSIF TG_TABLE_NAME = 'copy_location' THEN
            remove_query := remove_query || 'location = ' || NEW.id || ');';
        ELSIF TG_TABLE_NAME = 'copy_status' THEN
            remove_query := remove_query || 'status = ' || NEW.id || ');';
        END IF;
 
        EXECUTE remove_query;
 
    END IF;
 
    RETURN NEW;
END;
$_$;


ALTER FUNCTION asset.cache_copy_visibility() OWNER TO postgres;

--
-- Name: FUNCTION cache_copy_visibility(); Type: COMMENT; Schema: asset; Owner: postgres
--

COMMENT ON FUNCTION cache_copy_visibility() IS '
Trigger function to update the copy OPAC visiblity cache.
';


--
-- Name: label_normalizer(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION label_normalizer() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sortkey        TEXT := '';
BEGIN
    sortkey := NEW.label_sortkey;

    IF NEW.label_class IS NULL THEN
            NEW.label_class := COALESCE(
            (
                SELECT substring(value from E'\\d+')::integer
                FROM actor.org_unit_ancestor_setting('cat.default_classification_scheme', NEW.owning_lib)
            ), 1
        );
    END IF;

    EXECUTE 'SELECT ' || acnc.normalizer || '(' || 
       quote_literal( NEW.label ) || ')'
       FROM asset.call_number_class acnc
       WHERE acnc.id = NEW.label_class
       INTO sortkey;
    NEW.label_sortkey = sortkey;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.label_normalizer() OWNER TO postgres;

--
-- Name: label_normalizer_dewey(text); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION label_normalizer_dewey(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    # Derived from the Koha C4::ClassSortRoutine::Dewey module
    # Copyright (C) 2007 LibLime
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    my $init = uc(shift);
    $init =~ s/^\s+//;
    $init =~ s/\s+$//;
    $init =~ s!/!!g;
    $init =~ s/^([\p{IsAlpha}]+)/$1 /;
    my @tokens = split /\.|\s+/, $init;
    my $digit_group_count = 0;
    my $first_digit_group_idx;
    for (my $i = 0; $i <= $#tokens; $i++) {
        if ($tokens[$i] =~ /^\d+$/) {
            $digit_group_count++;
            if ($digit_group_count == 1) {
                $first_digit_group_idx = $i;
            }
            if (2 == $digit_group_count) {
                $tokens[$i] = sprintf("%-15.15s", $tokens[$i]);
                $tokens[$i] =~ tr/ /0/;
            }
        }
    }
    # Pad the first digit_group if there was only one
    if (1 == $digit_group_count) {
        $tokens[$first_digit_group_idx] .= '_000000000000000'
    }
    my $key = join("_", @tokens);
    $key =~ s/[^\p{IsAlnum}_]//g;

    return $key;

$_$;


ALTER FUNCTION asset.label_normalizer_dewey(text) OWNER TO postgres;

--
-- Name: label_normalizer_generic(text); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION label_normalizer_generic(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    # Created after looking at the Koha C4::ClassSortRoutine::Generic module,
    # thus could probably be considered a derived work, although nothing was
    # directly copied - but to err on the safe side of providing attribution:
    # Copyright (C) 2007 LibLime
    # Copyright (C) 2011 Equinox Software, Inc (Steve Callendar)
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    # Converts the callnumber to uppercase
    # Strips spaces from start and end of the call number
    # Converts anything other than letters, digits, and periods into spaces
    # Collapses multiple spaces into a single underscore
    my $callnum = uc(shift);
    $callnum =~ s/^\s//g;
    $callnum =~ s/\s$//g;
    # NOTE: this previously used underscores, but this caused sorting issues
    # for the "before" half of page 0 on CN browse, sorting CNs containing a
    # decimal before "whole number" CNs
    $callnum =~ s/[^A-Z0-9_.]/ /g;
    $callnum =~ s/ {2,}/ /g;

    return $callnum;
$_$;


ALTER FUNCTION asset.label_normalizer_generic(text) OWNER TO postgres;

--
-- Name: label_normalizer_lc(text); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION label_normalizer_lc(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use strict;
    use warnings;

    # Library::CallNumber::LC is currently hosted at http://code.google.com/p/library-callnumber-lc/
    # The author hopes to upload it to CPAN some day, which would make our lives easier
    use Library::CallNumber::LC;

    my $callnum = Library::CallNumber::LC->new(shift);
    return $callnum->normalize();

$_$;


ALTER FUNCTION asset.label_normalizer_lc(text) OWNER TO postgres;

--
-- Name: merge_record_assets(bigint, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION merge_record_assets(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    moved_objects INT := 0;
    source_cn     asset.call_number%ROWTYPE;
    target_cn     asset.call_number%ROWTYPE;
    metarec       metabib.metarecord%ROWTYPE;
    hold          action.hold_request%ROWTYPE;
    ser_rec       serial.record_entry%ROWTYPE;
    ser_sub       serial.subscription%ROWTYPE;
    acq_lineitem  acq.lineitem%ROWTYPE;
    acq_request   acq.user_request%ROWTYPE;
    booking       booking.resource_type%ROWTYPE;
    source_part   biblio.monograph_part%ROWTYPE;
    target_part   biblio.monograph_part%ROWTYPE;
    multi_home    biblio.peer_bib_copy_map%ROWTYPE;
    uri_count     INT := 0;
    counter       INT := 0;
    uri_datafield TEXT;
    uri_text      TEXT := '';
BEGIN

    -- move any 856 entries on records that have at least one MARC-mapped URI entry
    SELECT  INTO uri_count COUNT(*)
      FROM  asset.uri_call_number_map m
            JOIN asset.call_number cn ON (m.call_number = cn.id)
      WHERE cn.record = source_record;

    IF uri_count > 0 THEN
        
        -- This returns more nodes than you might expect:
        -- 7 instead of 1 for an 856 with $u $y $9
        SELECT  COUNT(*) INTO counter
          FROM  oils_xpath_table(
                    'id',
                    'marc',
                    'biblio.record_entry',
                    '//*[@tag="856"]',
                    'id=' || source_record
                ) as t(i int,c text);
    
        FOR i IN 1 .. counter LOOP
            SELECT  '<datafield xmlns="http://www.loc.gov/MARC21/slim"' || 
			' tag="856"' ||
			' ind1="' || FIRST(ind1) || '"'  ||
			' ind2="' || FIRST(ind2) || '">' ||
                        array_to_string(
                            array_accum(
                                '<subfield code="' || subfield || '">' ||
                                regexp_replace(
                                    regexp_replace(
                                        regexp_replace(data,'&','&amp;','g'),
                                        '>', '&gt;', 'g'
                                    ),
                                    '<', '&lt;', 'g'
                                ) || '</subfield>'
                            ), ''
                        ) || '</datafield>' INTO uri_datafield
              FROM  oils_xpath_table(
                        'id',
                        'marc',
                        'biblio.record_entry',
                        '//*[@tag="856"][position()=' || i || ']/@ind1|' ||
                        '//*[@tag="856"][position()=' || i || ']/@ind2|' ||
                        '//*[@tag="856"][position()=' || i || ']/*/@code|' ||
                        '//*[@tag="856"][position()=' || i || ']/*[@code]',
                        'id=' || source_record
                    ) as t(id int,ind1 text, ind2 text,subfield text,data text);

            -- As most of the results will be NULL, protect against NULLifying
            -- the valid content that we do generate
            uri_text := uri_text || COALESCE(uri_datafield, '');
        END LOOP;

        IF uri_text <> '' THEN
            UPDATE  biblio.record_entry
              SET   marc = regexp_replace(marc,'(</[^>]*record>)', uri_text || E'\\1')
              WHERE id = target_record;
        END IF;

    END IF;

	-- Find and move metarecords to the target record
	SELECT	INTO metarec *
	  FROM	metabib.metarecord
	  WHERE	master_record = source_record;

	IF FOUND THEN
		UPDATE	metabib.metarecord
		  SET	master_record = target_record,
			mods = NULL
		  WHERE	id = metarec.id;

		moved_objects := moved_objects + 1;
	END IF;

	-- Find call numbers attached to the source ...
	FOR source_cn IN SELECT * FROM asset.call_number WHERE record = source_record LOOP

		SELECT	INTO target_cn *
		  FROM	asset.call_number
		  WHERE	label = source_cn.label
			AND owning_lib = source_cn.owning_lib
			AND record = target_record
			AND NOT deleted;

		-- ... and if there's a conflicting one on the target ...
		IF FOUND THEN

			-- ... move the copies to that, and ...
			UPDATE	asset.copy
			  SET	call_number = target_cn.id
			  WHERE	call_number = source_cn.id;

			-- ... move V holds to the move-target call number
			FOR hold IN SELECT * FROM action.hold_request WHERE target = source_cn.id AND hold_type = 'V' LOOP
		
				UPDATE	action.hold_request
				  SET	target = target_cn.id
				  WHERE	id = hold.id;
		
				moved_objects := moved_objects + 1;
			END LOOP;

		-- ... if not ...
		ELSE
			-- ... just move the call number to the target record
			UPDATE	asset.call_number
			  SET	record = target_record
			  WHERE	id = source_cn.id;
		END IF;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find T holds targeting the source record ...
	FOR hold IN SELECT * FROM action.hold_request WHERE target = source_record AND hold_type = 'T' LOOP

		-- ... and move them to the target record
		UPDATE	action.hold_request
		  SET	target = target_record
		  WHERE	id = hold.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find serial records targeting the source record ...
	FOR ser_rec IN SELECT * FROM serial.record_entry WHERE record = source_record LOOP
		-- ... and move them to the target record
		UPDATE	serial.record_entry
		  SET	record = target_record
		  WHERE	id = ser_rec.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find serial subscriptions targeting the source record ...
	FOR ser_sub IN SELECT * FROM serial.subscription WHERE record_entry = source_record LOOP
		-- ... and move them to the target record
		UPDATE	serial.subscription
		  SET	record_entry = target_record
		  WHERE	id = ser_sub.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find booking resource types targeting the source record ...
	FOR booking IN SELECT * FROM booking.resource_type WHERE record = source_record LOOP
		-- ... and move them to the target record
		UPDATE	booking.resource_type
		  SET	record = target_record
		  WHERE	id = booking.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find acq lineitems targeting the source record ...
	FOR acq_lineitem IN SELECT * FROM acq.lineitem WHERE eg_bib_id = source_record LOOP
		-- ... and move them to the target record
		UPDATE	acq.lineitem
		  SET	eg_bib_id = target_record
		  WHERE	id = acq_lineitem.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find acq user purchase requests targeting the source record ...
	FOR acq_request IN SELECT * FROM acq.user_request WHERE eg_bib = source_record LOOP
		-- ... and move them to the target record
		UPDATE	acq.user_request
		  SET	eg_bib = target_record
		  WHERE	id = acq_request.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find parts attached to the source ...
	FOR source_part IN SELECT * FROM biblio.monograph_part WHERE record = source_record LOOP

		SELECT	INTO target_part *
		  FROM	biblio.monograph_part
		  WHERE	label = source_part.label
			AND record = target_record;

		-- ... and if there's a conflicting one on the target ...
		IF FOUND THEN

			-- ... move the copy-part maps to that, and ...
			UPDATE	asset.copy_part_map
			  SET	part = target_part.id
			  WHERE	part = source_part.id;

			-- ... move P holds to the move-target part
			FOR hold IN SELECT * FROM action.hold_request WHERE target = source_part.id AND hold_type = 'P' LOOP
		
				UPDATE	action.hold_request
				  SET	target = target_part.id
				  WHERE	id = hold.id;
		
				moved_objects := moved_objects + 1;
			END LOOP;

		-- ... if not ...
		ELSE
			-- ... just move the part to the target record
			UPDATE	biblio.monograph_part
			  SET	record = target_record
			  WHERE	id = source_part.id;
		END IF;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- Find multi_home items attached to the source ...
	FOR multi_home IN SELECT * FROM biblio.peer_bib_copy_map WHERE peer_record = source_record LOOP
		-- ... and move them to the target record
		UPDATE	biblio.peer_bib_copy_map
		  SET	peer_record = target_record
		  WHERE	id = multi_home.id;

		moved_objects := moved_objects + 1;
	END LOOP;

	-- And delete mappings where the item's home bib was merged with the peer bib
	DELETE FROM biblio.peer_bib_copy_map WHERE peer_record = (
		SELECT (SELECT record FROM asset.call_number WHERE id = call_number)
		FROM asset.copy WHERE id = target_copy
	);

    -- Finally, "delete" the source record
    DELETE FROM biblio.record_entry WHERE id = source_record;

	-- That's all, folks!
	RETURN moved_objects;
END;
$_$;


ALTER FUNCTION asset.merge_record_assets(target_record bigint, source_record bigint) OWNER TO postgres;

--
-- Name: metarecord_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION metarecord_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_metarecord_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_metarecord_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.metarecord_copy_count(place integer, rid bigint, staff boolean) OWNER TO postgres;

--
-- Name: metarecord_has_holdable_copy(bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION metarecord_has_holdable_copy(rid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
            JOIN metabib.metarecord_source_map mmsm ON acn.record = mmsm.source
        WHERE
            mmsm.metarecord = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION asset.metarecord_has_holdable_copy(rid bigint) OWNER TO postgres;

--
-- Name: normalize_affix_sortkey(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION normalize_affix_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.normalize_affix_sortkey() OWNER TO postgres;

--
-- Name: opac_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
                JOIN metabib.metarecord_source_map m ON (m.source = av.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;   
                
    RETURN;     
END;            
$$;


ALTER FUNCTION asset.opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO postgres;

--
-- Name: opac_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION opac_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;   
                
    RETURN;     
END;            
$$;


ALTER FUNCTION asset.opac_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO postgres;

--
-- Name: opac_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION opac_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM  
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
                JOIN metabib.metarecord_source_map m ON (m.source = av.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO postgres;

--
-- Name: opac_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION opac_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM  
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_record_copy_count(org integer, rid bigint) OWNER TO postgres;

--
-- Name: record_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION record_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_record_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_record_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.record_copy_count(place integer, rid bigint, staff boolean) OWNER TO postgres;

--
-- Name: record_has_holdable_copy(bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION record_has_holdable_copy(rid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
        WHERE
            acn.record = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION asset.record_has_holdable_copy(rid bigint) OWNER TO postgres;

--
-- Name: refresh_opac_visible_copies_mat_view(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION refresh_opac_visible_copies_mat_view() RETURNS void
    LANGUAGE sql
    AS $$

    TRUNCATE TABLE asset.opac_visible_copies;

    INSERT INTO asset.opac_visible_copies (copy_id, circ_lib, record)
    SELECT  cp.id, cp.circ_lib, cn.record
    FROM  asset.copy cp
        JOIN asset.call_number cn ON (cn.id = cp.call_number)
        JOIN actor.org_unit a ON (cp.circ_lib = a.id)
        JOIN asset.copy_location cl ON (cp.location = cl.id)
        JOIN config.copy_status cs ON (cp.status = cs.id)
        JOIN biblio.record_entry b ON (cn.record = b.id)
    WHERE NOT cp.deleted
        AND NOT cn.deleted
        AND NOT b.deleted
        AND cs.opac_visible
        AND cl.opac_visible
        AND cp.opac_visible
        AND a.opac_visible
            UNION
    SELECT  cp.id, cp.circ_lib, pbcm.peer_record AS record
    FROM  asset.copy cp
        JOIN biblio.peer_bib_copy_map pbcm ON (pbcm.target_copy = cp.id)
        JOIN actor.org_unit a ON (cp.circ_lib = a.id)
        JOIN asset.copy_location cl ON (cp.location = cl.id)
        JOIN config.copy_status cs ON (cp.status = cs.id)
    WHERE NOT cp.deleted
        AND cs.opac_visible
        AND cl.opac_visible
        AND cp.opac_visible
        AND a.opac_visible;

$$;


ALTER FUNCTION asset.refresh_opac_visible_copies_mat_view() OWNER TO postgres;

--
-- Name: FUNCTION refresh_opac_visible_copies_mat_view(); Type: COMMENT; Schema: asset; Owner: postgres
--

COMMENT ON FUNCTION refresh_opac_visible_copies_mat_view() IS '
Rebuild the copy OPAC visibility cache.  Useful during migrations.
';


--
-- Name: staff_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO postgres;

--
-- Name: staff_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION staff_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                SUM( CASE WHEN cl.opac_visible AND cp.opac_visible THEN 1 ELSE 0 END),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO postgres;

--
-- Name: staff_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION staff_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE         
    ans RECORD; 
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO postgres;

--
-- Name: staff_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION staff_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE         
    ans RECORD; 
    trans INT;
BEGIN           
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                SUM( CASE WHEN cl.opac_visible AND cp.opac_visible THEN 1 ELSE 0 END),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_record_copy_count(org integer, rid bigint) OWNER TO postgres;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: asset; Owner: postgres
--

CREATE FUNCTION stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield asset.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM asset.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM asset.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.stat_cat_check() OWNER TO postgres;

SET search_path = auditor, pg_catalog;

--
-- Name: audit_acq_invoice_entry_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_acq_invoice_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, lineitem, inv_item_count, phys_item_count, note, billed_per_item, cost_billed, actual_cost, amount_paid )
                SELECT  nextval('auditor.acq_invoice_entry_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.lineitem, OLD.inv_item_count, OLD.phys_item_count, OLD.note, OLD.billed_per_item, OLD.cost_billed, OLD.actual_cost, OLD.amount_paid
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_entry_func() OWNER TO postgres;

--
-- Name: audit_acq_invoice_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_acq_invoice_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, receiver, provider, shipper, recv_date, recv_method, inv_type, inv_ident, payment_auth, payment_method, note, complete )
                SELECT  nextval('auditor.acq_invoice_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.receiver, OLD.provider, OLD.shipper, OLD.recv_date, OLD.recv_method, OLD.inv_type, OLD.inv_ident, OLD.payment_auth, OLD.payment_method, OLD.note, OLD.complete
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_func() OWNER TO postgres;

--
-- Name: audit_acq_invoice_item_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_acq_invoice_item_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_item_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, fund_debit, inv_item_type, title, author, note, cost_billed, actual_cost, fund, amount_paid, po_item, target )
                SELECT  nextval('auditor.acq_invoice_item_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.fund_debit, OLD.inv_item_type, OLD.title, OLD.author, OLD.note, OLD.cost_billed, OLD.actual_cost, OLD.fund, OLD.amount_paid, OLD.po_item, OLD.target
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_item_func() OWNER TO postgres;

--
-- Name: audit_actor_org_unit_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_actor_org_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_org_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, parent_ou, ou_type, ill_address, holds_address, mailing_address, billing_address, shortname, name, email, phone, opac_visible, fiscal_calendar )
                SELECT  nextval('auditor.actor_org_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.parent_ou, OLD.ou_type, OLD.ill_address, OLD.holds_address, OLD.mailing_address, OLD.billing_address, OLD.shortname, OLD.name, OLD.email, OLD.phone, OLD.opac_visible, OLD.fiscal_calendar
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_org_unit_func() OWNER TO postgres;

--
-- Name: audit_actor_usr_address_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_actor_usr_address_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_address_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, valid, within_city_limits, address_type, usr, street1, street2, city, county, state, country, post_code, pending, replaces )
                SELECT  nextval('auditor.actor_usr_address_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.valid, OLD.within_city_limits, OLD.address_type, OLD.usr, OLD.street1, OLD.street2, OLD.city, OLD.county, OLD.state, OLD.country, OLD.post_code, OLD.pending, OLD.replaces
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_address_func() OWNER TO postgres;

--
-- Name: audit_actor_usr_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_actor_usr_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, card, profile, usrname, email, passwd, standing, ident_type, ident_value, ident_type2, ident_value2, net_access_level, photo_url, prefix, first_given_name, second_given_name, family_name, suffix, alias, day_phone, evening_phone, other_phone, mailing_address, billing_address, home_ou, dob, active, master_account, super_user, barred, deleted, juvenile, usrgroup, claims_returned_count, credit_forward_balance, last_xact_id, alert_message, create_date, expire_date, claims_never_checked_out_count, last_update_time )
                SELECT  nextval('auditor.actor_usr_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.card, OLD.profile, OLD.usrname, OLD.email, OLD.passwd, OLD.standing, OLD.ident_type, OLD.ident_value, OLD.ident_type2, OLD.ident_value2, OLD.net_access_level, OLD.photo_url, OLD.prefix, OLD.first_given_name, OLD.second_given_name, OLD.family_name, OLD.suffix, OLD.alias, OLD.day_phone, OLD.evening_phone, OLD.other_phone, OLD.mailing_address, OLD.billing_address, OLD.home_ou, OLD.dob, OLD.active, OLD.master_account, OLD.super_user, OLD.barred, OLD.deleted, OLD.juvenile, OLD.usrgroup, OLD.claims_returned_count, OLD.credit_forward_balance, OLD.last_xact_id, OLD.alert_message, OLD.create_date, OLD.expire_date, OLD.claims_never_checked_out_count, OLD.last_update_time
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_func() OWNER TO postgres;

--
-- Name: audit_asset_call_number_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_asset_call_number_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_call_number_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, create_date, editor, edit_date, record, owning_lib, label, deleted, prefix, suffix, label_class, label_sortkey )
                SELECT  nextval('auditor.asset_call_number_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.creator, OLD.create_date, OLD.editor, OLD.edit_date, OLD.record, OLD.owning_lib, OLD.label, OLD.deleted, OLD.prefix, OLD.suffix, OLD.label_class, OLD.label_sortkey
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_call_number_func() OWNER TO postgres;

--
-- Name: audit_asset_copy_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_asset_copy_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_copy_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost )
                SELECT  nextval('auditor.asset_copy_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.active_date, OLD.mint_condition, OLD.cost
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_copy_func() OWNER TO postgres;

--
-- Name: audit_biblio_record_entry_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_biblio_record_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.biblio_record_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, editor, source, quality, create_date, edit_date, active, deleted, fingerprint, tcn_source, tcn_value, marc, last_xact_id, owner, share_depth )
                SELECT  nextval('auditor.biblio_record_entry_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.creator, OLD.editor, OLD.source, OLD.quality, OLD.create_date, OLD.edit_date, OLD.active, OLD.deleted, OLD.fingerprint, OLD.tcn_source, OLD.tcn_value, OLD.marc, OLD.last_xact_id, OLD.owner, OLD.share_depth
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_biblio_record_entry_func() OWNER TO postgres;

--
-- Name: audit_serial_unit_func(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION audit_serial_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.serial_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost, sort_key, detailed_contents, summary_contents )
                SELECT  nextval('auditor.serial_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.active_date, OLD.mint_condition, OLD.cost, OLD.sort_key, OLD.detailed_contents, OLD.summary_contents
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_serial_unit_func() OWNER TO postgres;

--
-- Name: clear_audit_info(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION clear_audit_info() RETURNS void
    LANGUAGE plperlu
    AS $_X$
    delete($_SHARED{"eg_audit_user"});
    delete($_SHARED{"eg_audit_ws"});
$_X$;


ALTER FUNCTION auditor.clear_audit_info() OWNER TO postgres;

--
-- Name: create_auditor(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM auditor.create_auditor_seq(sch, tbl);
    PERFORM auditor.create_auditor_history(sch, tbl);
    PERFORM auditor.create_auditor_func(sch, tbl);
    PERFORM auditor.create_auditor_update_trigger(sch, tbl);
    PERFORM auditor.create_auditor_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION auditor.create_auditor(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_auditor_func(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE OR REPLACE FUNCTION auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO auditor.$$ || sch || $$_$$ || tbl || $$_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, $$
            || array_to_string(column_list, ', ') || $$ )
                SELECT  nextval('auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.$$ || array_to_string(column_list, ', OLD.') || $$
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_func(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_auditor_history(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE auditor.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            audit_user  INT,
            audit_ws    INT,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_history(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_auditor_lifecycle(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE VIEW auditor.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT -1 AS audit_id,
                   now() AS audit_time,
                   '-' AS audit_action,
                   -1 AS audit_user,
                   -1 AS audit_ws,
                   $$ || array_to_string(column_list, ', ') || $$
              FROM $$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT audit_id, audit_time, audit_action, audit_user, audit_ws,
            $$ || array_to_string(column_list, ', ') || $$
              FROM auditor.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_lifecycle(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_auditor_seq(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_seq(sch text, tbl text) OWNER TO postgres;

--
-- Name: create_auditor_update_trigger(text, text); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION create_auditor_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_update_trigger(sch text, tbl text) OWNER TO postgres;

--
-- Name: fix_columns(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION fix_columns() RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    current_table TEXT = ''; -- Storage for post-loop main table name
    current_audit_table TEXT = ''; -- Storage for post-loop audit table name
    query TEXT = ''; -- Storage for built query
    cr RECORD; -- column record object
    alter_t BOOL = false; -- Has the alter table command been appended yet
    auditor_cores TEXT[] = ARRAY[]::TEXT[]; -- Core auditor function list (filled inside of loop)
    core_column TEXT; -- The current core column we are adding
BEGIN
    FOR cr IN
        WITH audit_tables AS ( -- Basic grab of auditor tables. Anything in the auditor namespace, basically. With oids.
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS ( -- Union of auditor tables with their "main" tables. With oids.
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        ),
        column_lists AS ( -- All columns associated with the auditor or main table, grouped by the main table's oid.
            SELECT DISTINCT ON (main_oid, attname) t.main_oid, a.attname
            FROM table_set t
            JOIN pg_catalog.pg_attribute a ON a.attrelid IN (t.main_oid, t.audit_oid)
            WHERE attnum > 0 AND NOT attisdropped
        ),
        column_defs AS ( -- The motherload, every audit table and main table plus column names and defs.
            SELECT audit_table,
                   main_namespace,
                   main_table,
                   a.attname AS main_column, -- These two will be null for columns that have since been deleted, or for auditor core columns
                   pg_catalog.format_type(a.atttypid, a.atttypmod) AS main_column_def,
                   b.attname AS audit_column, -- These two will be null for columns that have since been added
                   pg_catalog.format_type(b.atttypid, b.atttypmod) AS audit_column_def
            FROM table_set t
            JOIN column_lists c USING (main_oid)
            LEFT JOIN pg_catalog.pg_attribute a ON a.attname = c.attname AND a.attrelid = t.main_oid AND a.attnum > 0 AND NOT a.attisdropped
            LEFT JOIN pg_catalog.pg_attribute b ON b.attname = c.attname AND b.attrelid = t.audit_oid AND b.attnum > 0 AND NOT b.attisdropped
        )
        -- Nice sorted output from the above
        SELECT * FROM column_defs WHERE main_column_def IS DISTINCT FROM audit_column_def ORDER BY main_namespace, main_table, main_column, audit_column
    LOOP
        IF current_table <> (cr.main_namespace || '.' || cr.main_table) THEN -- New table?
            FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Update missing core auditor columns
                IF NOT alter_t THEN -- Add ALTER TABLE if we haven't already
                    query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                    alter_t:=TRUE;
                ELSE
                    query:=query || $$,$$;
                END IF;
                -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
                query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
            END LOOP;
            IF alter_t THEN -- Open alter table = needs a semicolon
                query:=query || $$; $$;
                alter_t:=FALSE;
                IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
                    -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
                    -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
                    EXECUTE query;
                    EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                        $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
                    EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                        $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
                    query:='';
                END IF;
            END IF;
            -- New table means we reset the list of needed auditor core columns
            auditor_cores = ARRAY['audit_id bigint', 'audit_time timestamp with time zone', 'audit_action text', 'audit_user integer', 'audit_ws integer'];
            -- And store some values for use later, because we can't rely on cr in all places.
            current_table:=cr.main_namespace || '.' || cr.main_table;
            current_audit_table:=cr.audit_table;
        END IF;
        IF cr.main_column IS NULL AND cr.audit_column LIKE 'audit_%' THEN -- Core auditor column?
            -- Remove core from list of cores
            SELECT INTO auditor_cores array_agg(core) FROM unnest(auditor_cores) AS core WHERE core != (cr.audit_column || ' ' || cr.audit_column_def);
        ELSIF cr.main_column IS NULL THEN -- Main column doesn't exist, and it isn't an auditor column. Needs dropping from the auditor.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ DROP COLUMN $$ || cr.audit_column;
        ELSIF cr.audit_column IS NULL AND cr.main_column IS NOT NULL THEN -- New column auditor doesn't have. Add it.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ADD COLUMN $$ || cr.main_column || $$ $$ || cr.main_column_def;
        ELSIF cr.main_column IS NOT NULL AND cr.audit_column IS NOT NULL THEN -- Both sides have this column, but types differ. Fix that.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ALTER COLUMN $$ || cr.audit_column || $$ TYPE $$ || cr.main_column_def;
        END IF;
    END LOOP;
    FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Repeat this outside of the loop to catch the last table
        IF NOT alter_t THEN
            query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
            alter_t:=TRUE;
        ELSE
            query:=query || $$,$$;
        END IF;
        -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
        query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
    END LOOP;
    IF alter_t THEN -- Open alter table = needs a semicolon
        query:=query || $$;$$;
        IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
            -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
            -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
            EXECUTE query;
            EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
            EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
            query:='';
        END IF;
    END IF;
    EXECUTE query;
END;
$_X$;


ALTER FUNCTION auditor.fix_columns() OWNER TO postgres;

--
-- Name: get_audit_info(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION get_audit_info() RETURNS TABLE(eg_user integer, eg_ws integer)
    LANGUAGE plperlu
    AS $_X$
    return [{eg_user => $_SHARED{"eg_audit_user"}, eg_ws => $_SHARED{"eg_audit_ws"}}];
$_X$;


ALTER FUNCTION auditor.get_audit_info() OWNER TO postgres;

--
-- Name: set_audit_info(integer, integer); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION set_audit_info(integer, integer) RETURNS void
    LANGUAGE plperlu
    AS $_X$
    $_SHARED{"eg_audit_user"} = $_[0];
    $_SHARED{"eg_audit_ws"} = $_[1];
$_X$;


ALTER FUNCTION auditor.set_audit_info(integer, integer) OWNER TO postgres;

--
-- Name: update_auditors(); Type: FUNCTION; Schema: auditor; Owner: postgres
--

CREATE FUNCTION update_auditors() RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
    auditor_name TEXT;
    table_schema TEXT;
    table_name TEXT;
BEGIN
    -- Drop Lifecycle view(s) before potential column changes
    FOR auditor_name IN
        SELECT c.relname
            FROM pg_catalog.pg_class c
                JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind = 'v' AND n.nspname = 'auditor' LOOP
        EXECUTE $$ DROP VIEW auditor.$$ || auditor_name || $$;$$;
    END LOOP;
    -- Fix all column discrepencies
    PERFORM auditor.fix_columns();
    -- Re-create trigger functions and lifecycle views
    FOR table_schema, table_name IN
        WITH audit_tables AS (
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS (
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        )
        SELECT main_namespace, main_table FROM table_set LOOP
        
        PERFORM auditor.create_auditor_func(table_schema, table_name);
        PERFORM auditor.create_auditor_lifecycle(table_schema, table_name);
    END LOOP;
    RETURN TRUE;
END;
$_$;


ALTER FUNCTION auditor.update_auditors() OWNER TO postgres;

SET search_path = authority, pg_catalog;

--
-- Name: atag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_authority_tags(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(id) FROM authority.control_set_authority_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.atag_authority_tags(atag text) OWNER TO postgres;

--
-- Name: atag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_authority_tags_refs(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
        SELECT  unnest(ARRAY_CAT(
                    ARRAY[a.id],
                    (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.id)
                )) y
      FROM  authority.control_set_authority_field a
      WHERE a.tag = $1) x
$_$;


ALTER FUNCTION authority.atag_authority_tags_refs(atag text) OWNER TO postgres;

--
-- Name: atag_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_center(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_top(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_heading(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_rank(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: atag_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION atag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_authority_tags(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(field) FROM authority.browse_axis_authority_field_map WHERE axis = $1;
$_$;


ALTER FUNCTION authority.axis_authority_tags(a text) OWNER TO postgres;

--
-- Name: axis_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_authority_tags_refs(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
       SELECT  unnest(ARRAY_CAT(
                 ARRAY[a.field],
                 (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.field)
             )) y
       FROM  authority.browse_axis_authority_field_map a
       WHERE axis = $1) x
$_$;


ALTER FUNCTION authority.axis_authority_tags_refs(a text) OWNER TO postgres;

--
-- Name: axis_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_center(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_top(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_heading(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_rank(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: axis_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION axis_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_authority_tags(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(authority_field) FROM authority.control_set_bib_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.btag_authority_tags(btag text) OWNER TO postgres;

--
-- Name: btag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_authority_tags_refs(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
        SELECT  unnest(ARRAY_CAT(
                    ARRAY[a.authority_field],
                    (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.authority_field)
                )) y
      FROM  authority.control_set_bib_field a
      WHERE a.tag = $1) x
$_$;


ALTER FUNCTION authority.btag_authority_tags_refs(btag text) OWNER TO postgres;

--
-- Name: btag_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_center(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_top(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_heading(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_rank(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: btag_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION btag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: full_rec; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE full_rec (
    id bigint NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE authority.full_rec OWNER TO postgres;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION flatten_marc(rid bigint) RETURNS SETOF full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
	auth	authority.record_entry%ROWTYPE;
	output	authority.full_rec%ROWTYPE;
	field	RECORD;
BEGIN
	SELECT INTO auth * FROM authority.record_entry WHERE id = rid;

	FOR field IN SELECT * FROM vandelay.flatten_marc( auth.marc ) LOOP
		output.record := rid;
		output.ind1 := field.ind1;
		output.ind2 := field.ind2;
		output.tag := field.tag;
		output.subfield := field.subfield;
		output.value := field.value;

		RETURN NEXT output;
	END LOOP;
END;
$$;


ALTER FUNCTION authority.flatten_marc(rid bigint) OWNER TO postgres;

--
-- Name: generate_overlay_template(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION generate_overlay_template(source_xml text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    cset                INT;
    main_entry          authority.control_set_authority_field%ROWTYPE;
    bib_field           authority.control_set_bib_field%ROWTYPE;
    auth_id             INT DEFAULT oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', source_xml)::INT;
    replace_data        XML[] DEFAULT '{}'::XML[];
    replace_rules       TEXT[] DEFAULT '{}'::TEXT[];
    auth_field          XML[];
BEGIN
    IF auth_id IS NULL THEN
        RETURN NULL;
    END IF;

    -- Default to the LoC controll set
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    -- if none, make a best guess
    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN (
                    SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marc::XML)::TEXT[])
                      FROM  authority.record_entry
                      WHERE id = auth_id
                )
          LIMIT 1;
    END IF;

    -- if STILL none, no-op change
    IF cset IS NULL THEN
        RETURN XMLELEMENT(
            name record,
            XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
            XMLELEMENT( name leader, '00881nam a2200193   4500'),
            XMLELEMENT(
                name datafield,
                XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
                XMLELEMENT(
                    name subfield,
                    XMLATTRIBUTES('d' AS code),
                    '901c'
                )
            )
        )::TEXT;
    END IF;

    FOR main_entry IN SELECT * FROM authority.control_set_authority_field acsaf WHERE acsaf.control_set = cset AND acsaf.main_entry IS NULL LOOP
        auth_field := XPATH('//*[@tag="'||main_entry.tag||'"][1]',source_xml::XML);
        IF ARRAY_LENGTH(auth_field,1) > 0 THEN
            FOR bib_field IN SELECT * FROM authority.control_set_bib_field WHERE authority_field = main_entry.id LOOP
                replace_data := replace_data || XMLELEMENT( name datafield, XMLATTRIBUTES(bib_field.tag AS tag), XPATH('//*[local-name()="subfield"]',auth_field[1])::XML[]);
                replace_rules := replace_rules || ( bib_field.tag || main_entry.sf_list || E'[0~\\)' || auth_id || '$]' );
            END LOOP;
            EXIT;
        END IF;
    END LOOP;

    RETURN XMLELEMENT(
        name record,
        XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
        XMLELEMENT( name leader, '00881nam a2200193   4500'),
        replace_data,
        XMLELEMENT(
            name datafield,
            XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
            XMLELEMENT(
                name subfield,
                XMLATTRIBUTES('r' AS code),
                ARRAY_TO_STRING(replace_rules,',')
            )
        )
    )::TEXT;
END;
$_$;


ALTER FUNCTION authority.generate_overlay_template(source_xml text) OWNER TO postgres;

--
-- Name: generate_overlay_template(bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION generate_overlay_template(bigint) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT authority.generate_overlay_template( marc ) FROM authority.record_entry WHERE id = $1;
$_$;


ALTER FUNCTION authority.generate_overlay_template(bigint) OWNER TO postgres;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
BEGIN

    IF NEW.deleted IS TRUE THEN -- If this authority is deleted
        DELETE FROM authority.bib_linking WHERE authority = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM authority.full_rec WHERE record = NEW.id; -- Avoid validating fields against deleted authority records
        DELETE FROM authority.simple_heading WHERE record = NEW.id;
          -- Should remove matching $0 from controlled fields at the same time?
        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;

        -- Propagate these updates to any linked bib records
        PERFORM authority.propagate_changes(NEW.id) FROM authority.record_entry WHERE id = NEW.id;

        DELETE FROM authority.simple_heading WHERE record = NEW.id;
    END IF;

    INSERT INTO authority.simple_heading (record,atag,value,sort_value)
        SELECT record, atag, value, sort_value FROM authority.simple_heading_set(NEW.marc);

    -- Flatten and insert the afr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM authority.reingest_authority_full_rec(NEW.id);
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            PERFORM authority.reingest_authority_rec_descriptor(NEW.id);
        END IF;
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION authority.indexing_ingest_or_delete() OWNER TO postgres;

--
-- Name: map_thesaurus_to_control_set(); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION map_thesaurus_to_control_set() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.control_set IS NULL THEN
        SELECT  control_set INTO NEW.control_set
          FROM  authority.thesaurus
          WHERE vandelay.marc21_extract_fixed_field(NEW.marc,'Subj') = code;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION authority.map_thesaurus_to_control_set() OWNER TO postgres;

--
-- Name: merge_records(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION merge_records(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    moved_objects INT := 0;
    bib_id        INT := 0;
    bib_rec       biblio.record_entry%ROWTYPE;
    auth_link     authority.bib_linking%ROWTYPE;
    ingest_same   boolean;
BEGIN

    -- Defining our terms:
    -- "target record" = the record that will survive the merge
    -- "source record" = the record that is sacrifing its existence and being
    --   replaced by the target record

    -- 1. Update all bib records with the ID from target_record in their $0
    FOR bib_rec IN
            SELECT  bre.*
              FROM  biblio.record_entry bre 
                    JOIN authority.bib_linking abl ON abl.bib = bre.id
              WHERE abl.authority = source_record
        LOOP

        UPDATE  biblio.record_entry
          SET   marc = REGEXP_REPLACE(
                    marc,
                    E'(<subfield\\s+code="0"\\s*>[^<]*?\\))' || source_record || '<',
                    E'\\1' || target_record || '<',
                    'g'
                )
          WHERE id = bib_rec.id;

          moved_objects := moved_objects + 1;
    END LOOP;

    -- 2. Grab the current value of reingest on same MARC flag
    SELECT  enabled INTO ingest_same
      FROM  config.internal_flag
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 3. Temporarily set reingest on same to TRUE
    UPDATE  config.internal_flag
      SET   enabled = TRUE
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 4. Make a harmless update to target_record to trigger auto-update
    --    in linked bibliographic records
    UPDATE  authority.record_entry
      SET   deleted = FALSE
      WHERE id = target_record;

    -- 5. "Delete" source_record
    DELETE FROM authority.record_entry WHERE id = source_record;

    -- 6. Set "reingest on same MARC" flag back to initial value
    UPDATE  config.internal_flag
      SET   enabled = ingest_same
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    RETURN moved_objects;
END;
$_$;


ALTER FUNCTION authority.merge_records(target_record bigint, source_record bigint) OWNER TO postgres;

--
-- Name: normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT authority.normalize_heading($1, FALSE);
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text) OWNER TO postgres;

--
-- Name: FUNCTION normalize_heading(marcxml text); Type: COMMENT; Schema: authority; Owner: postgres
--

COMMENT ON FUNCTION normalize_heading(marcxml text) IS '
Extract the authority heading, thesaurus, and NACO-normalized values
from an authority record. The primary purpose is to build a unique
index to defend against duplicated authority records from the same
thesaurus.
';


--
-- Name: normalize_heading(text, boolean); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION normalize_heading(marcxml text, no_thesaurus boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    thes_code       TEXT;
    cset            INT;
    heading_text    TEXT;
    tmp_text        TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT; 
BEGIN
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    thes_code := vandelay.marc21_extract_fixed_field(marcxml,'Subj');
    IF thes_code IS NULL THEN
        thes_code := '|';
    ELSIF thes_code = 'z' THEN
        thes_code := COALESCE( oils_xpath_string('//*[@tag="040"]/*[@code="f"][1]', marcxml), '' );
    END IF;

    heading_text := '';
    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset AND main_entry IS NULL LOOP
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        first_sf := TRUE;
        FOR sf IN SELECT * FROM regexp_split_to_table(acsaf.sf_list,'') LOOP
            tmp_text := oils_xpath_string('//*[@tag="'||tag_used||'"]/*[@code="'||sf||'"]', marcxml);

            IF first_sf AND tmp_text IS NOT NULL AND nfi_used IS NOT NULL THEN

                tmp_text := SUBSTRING(
                    tmp_text FROM
                    COALESCE(
                        NULLIF(
                            REGEXP_REPLACE(
                                oils_xpath_string('//*[@tag="'||tag_used||'"]/@ind'||nfi_used, marcxml),
                                $$\D+$$,
                                '',
                                'g'
                            ),
                            ''
                        )::INT,
                        0
                    ) + 1
                );

            END IF;

            first_sf := FALSE;

            IF tmp_text IS NOT NULL AND tmp_text <> '' THEN
                heading_text := heading_text || E'\u2021' || sf || ' ' || tmp_text;
            END IF;
        END LOOP;
        EXIT WHEN heading_text <> '';
    END LOOP;

    IF heading_text <> '' THEN
        IF no_thesaurus IS TRUE THEN
            heading_text := tag_used || ' ' || public.naco_normalize(heading_text);
        ELSE
            heading_text := tag_used || '_' || COALESCE(nfi_used,'-') || '_' || thes_code || ' ' || public.naco_normalize(heading_text);
        END IF;
    ELSE
        heading_text := 'NOHEADING_' || thes_code || ' ' || MD5(marcxml);
    END IF;

    RETURN heading_text;
END;
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text, no_thesaurus boolean) OWNER TO postgres;

--
-- Name: propagate_changes(bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION propagate_changes(aid bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT authority.propagate_changes( authority, bib ) FROM authority.bib_linking WHERE authority = $1;
$_$;


ALTER FUNCTION authority.propagate_changes(aid bigint) OWNER TO postgres;

--
-- Name: propagate_changes(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION propagate_changes(aid bigint, bid bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$
    UPDATE  biblio.record_entry
      SET   marc = vandelay.merge_record_xml( marc, authority.generate_overlay_template( $1 ) )
      WHERE id = $2;
    SELECT $1;
$_$;


ALTER FUNCTION authority.propagate_changes(aid bigint, bid bigint) OWNER TO postgres;

--
-- Name: reingest_authority_full_rec(bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION reingest_authority_full_rec(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.full_rec WHERE record = auth_id;
    INSERT INTO authority.full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM authority.flatten_marc( auth_id );

    RETURN;
END;
$$;


ALTER FUNCTION authority.reingest_authority_full_rec(auth_id bigint) OWNER TO postgres;

--
-- Name: reingest_authority_rec_descriptor(bigint); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION reingest_authority_rec_descriptor(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.rec_descriptor WHERE record = auth_id;
    INSERT INTO authority.rec_descriptor (record, record_status, encoding_level, thesaurus)
        SELECT  auth_id,
                vandelay.marc21_extract_fixed_field(marc,'RecStat'),
                vandelay.marc21_extract_fixed_field(marc,'ELvl'),
                vandelay.marc21_extract_fixed_field(marc,'Subj')
          FROM  authority.record_entry
          WHERE id = auth_id;
    RETURN;
END;
$$;


ALTER FUNCTION authority.reingest_authority_rec_descriptor(auth_id bigint) OWNER TO postgres;

--
-- Name: simple_heading_browse_center(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_browse_center(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
    boffset             INT DEFAULT 0;
    aoffset             INT DEFAULT 0;
    blimit              INT DEFAULT 0;
    alimit              INT DEFAULT 0;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q);

    IF page = 0 THEN
        blimit := pagesize / 2;
        alimit := blimit;

        IF pagesize % 2 <> 0 THEN
            alimit := alimit + 1;
        END IF;
    ELSE
        blimit := pagesize;
        alimit := blimit;

        boffset := pagesize / 2;
        aoffset := boffset;

        IF pagesize % 2 <> 0 THEN
            boffset := boffset + 1;
        END IF;
    END IF;

    IF page <= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                  FROM  authority.simple_heading ash
                  WHERE ash.atag = ANY (atag_list)
                        AND ash.sort_value < pivot_sort_value
                  ORDER BY ash.sort_value DESC
                  LIMIT blimit
                  OFFSET ABS(page) * pagesize - boffset
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT  ash.id
              FROM  authority.simple_heading ash
              WHERE ash.atag = ANY (atag_list)
                    AND ash.sort_value >= pivot_sort_value
              ORDER BY ash.sort_value
              LIMIT alimit
              OFFSET ABS(page) * pagesize - aoffset;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_center(atag_list integer[], q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: simple_heading_browse_top(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_browse_top(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q);

    IF page < 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                  FROM  authority.simple_heading ash
                  WHERE ash.atag = ANY (atag_list)
                        AND ash.sort_value < pivot_sort_value
                  ORDER BY ash.sort_value DESC
                  LIMIT pagesize
                  OFFSET (ABS(page) - 1) * pagesize
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT  ash.id
              FROM  authority.simple_heading ash
              WHERE ash.atag = ANY (atag_list)
                    AND ash.sort_value >= pivot_sort_value
              ORDER BY ash.sort_value
              LIMIT pagesize
              OFFSET ABS(page) * pagesize ;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_top(atag_list integer[], q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: simple_heading_find_pivot(integer[], text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_find_pivot(a integer[], q text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    sort_value_row  RECORD;
    value_row       RECORD;
    t_term          TEXT;
BEGIN

    t_term := public.naco_normalize(q);

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
      INTO  sort_value_row
      FROM  authority.simple_heading ash
      WHERE ash.atag = ANY (a)
            AND ash.sort_value >= t_term
      ORDER BY rank DESC, ash.sort_value
      LIMIT 1;

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
      INTO  value_row
      FROM  authority.simple_heading ash
      WHERE ash.atag = ANY (a)
            AND ash.value >= t_term
      ORDER BY rank DESC, ash.sort_value
      LIMIT 1;

    IF value_row.rank > sort_value_row.rank THEN
        RETURN value_row.sort_value;
    ELSE
        RETURN sort_value_row.sort_value;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_find_pivot(a integer[], q text) OWNER TO postgres;

--
-- Name: simple_heading_search_heading(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_search_heading(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
      ORDER BY ash.sort_value
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_heading(atag_list integer[], q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: simple_heading_search_rank(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_search_rank(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
      ORDER BY ts_rank_cd(ash.index_vector,ptsq.term,14)::numeric
                    + CASE WHEN ash.sort_value LIKE t.term || '%' THEN 2 ELSE 0 END
                    + CASE WHEN ash.value LIKE t.term || '%' THEN 1 ELSE 0 END DESC
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_rank(atag_list integer[], q text, page integer, pagesize integer) OWNER TO postgres;

--
-- Name: simple_heading; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE simple_heading (
    id bigint NOT NULL,
    record bigint NOT NULL,
    atag integer NOT NULL,
    value text NOT NULL,
    sort_value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE authority.simple_heading OWNER TO postgres;

--
-- Name: simple_heading_set(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_heading_set(marcxml text) RETURNS SETOF simple_heading
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    res             authority.simple_heading%ROWTYPE;
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    cset            INT;
    heading_text    TEXT;
    sort_text       TEXT;
    tmp_text        TEXT;
    tmp_xml         TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml)::INT;
BEGIN

    res.record := auth_id;

    SELECT  control_set INTO cset
      FROM  authority.control_set_authority_field
      WHERE tag IN ( SELECT UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]) )
      LIMIT 1;

    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset LOOP

        res.atag := acsaf.id;
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;

        FOR tmp_xml IN SELECT UNNEST(XPATH('//*[@tag="'||tag_used||'"]', marcxml::XML)) LOOP
            heading_text := '';

            FOR sf IN SELECT * FROM regexp_split_to_table(acsaf.sf_list,'') LOOP
                heading_text := heading_text || COALESCE( ' ' || oils_xpath_string('//*[@code="'||sf||'"]',tmp_xml::TEXT), '');
            END LOOP;

            heading_text := public.naco_normalize(heading_text);
            
            IF nfi_used IS NOT NULL THEN

                sort_text := SUBSTRING(
                    heading_text FROM
                    COALESCE(
                        NULLIF(
                            REGEXP_REPLACE(
                                oils_xpath_string('//*[@tag="'||tag_used||'"]/@ind'||nfi_used, marcxml),
                                $$\D+$$,
                                '',
                                'g'
                            ),
                            ''
                        )::INT,
                        0
                    ) + 1
                );

            ELSE
                sort_text := heading_text;
            END IF;

            IF heading_text IS NOT NULL AND heading_text <> '' THEN
                res.value := heading_text;
                res.sort_value := sort_text;
                RETURN NEXT res;
            END IF;

        END LOOP;

    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION authority.simple_heading_set(marcxml text) OWNER TO postgres;

--
-- Name: simple_normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: postgres
--

CREATE FUNCTION simple_normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT authority.normalize_heading($1, TRUE);
$_$;


ALTER FUNCTION authority.simple_normalize_heading(marcxml text) OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: check_marcxml_well_formed(); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION check_marcxml_well_formed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF xml_is_well_formed(NEW.marc) THEN
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'Attempted to % MARCXML that is not well formed', TG_OP;
    END IF;
    
END;
$$;


ALTER FUNCTION biblio.check_marcxml_well_formed() OWNER TO postgres;

--
-- Name: extract_fingerprint(text); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION extract_fingerprint(marc text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
	idx		config.biblio_fingerprint%ROWTYPE;
	xfrm		config.xml_transform%ROWTYPE;
	prev_xfrm	TEXT;
	transformed_xml	TEXT;
	xml_node	TEXT;
	xml_node_list	TEXT[];
	raw_text	TEXT;
    output_text TEXT := '';
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

	-- Loop over the indexing entries
	FOR idx IN SELECT * FROM config.biblio_fingerprint ORDER BY format, id LOOP

		SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

		-- See if we can skip the XSLT ... it's expensive
		IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
			-- Can't skip the transform
			IF xfrm.xslt <> '---' THEN
				transformed_xml := oils_xslt_process(marc,xfrm.xslt);
			ELSE
				transformed_xml := marc;
			END IF;

			prev_xfrm := xfrm.name;
		END IF;

		raw_text := COALESCE(
            naco_normalize(
                ARRAY_TO_STRING(
                    oils_xpath(
                        '//text()',
                        (oils_xpath(
                            idx.xpath,
                            transformed_xml,
                            ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] 
                        ))[1]
                    ),
                    ''
                )
            ),
            ''
        );

        raw_text := REGEXP_REPLACE(raw_text, E'\\[.+?\\]', E'');
        raw_text := REGEXP_REPLACE(raw_text, E'\\mthe\\M|\\man?d?d\\M', E'', 'g'); -- arg! the pain!

        IF idx.first_word IS TRUE THEN
            raw_text := REGEXP_REPLACE(raw_text, E'^(\\w+).*?$', E'\\1');
        END IF;

		output_text := output_text || REGEXP_REPLACE(raw_text, E'\\s+', '', 'g');

	END LOOP;

    RETURN output_text;

END;
$_$;


ALTER FUNCTION biblio.extract_fingerprint(marc text) OWNER TO postgres;

--
-- Name: extract_located_uris(bigint, text, integer); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner_list  TEXT[];
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;
BEGIN

    -- Clear any URI mappings and call numbers for this bib.
    -- This leads to acn / auricnm inflation, but also enables
    -- old acn/auricnm's to go away and for bibs to be deleted.
    FOR uri_cn_id IN SELECT id FROM asset.call_number WHERE record = bib_id AND label = '##URI##' AND NOT deleted LOOP
        DELETE FROM asset.uri_call_number_map WHERE call_number = uri_cn_id;
        DELETE FROM asset.call_number WHERE id = uri_cn_id;
    END LOOP;

    uris := oils_xpath('//*[@tag="856" and (@ind1="4" or @ind1="1") and (@ind2="0" or @ind2="1")]',marcxml);
    IF ARRAY_UPPER(uris,1) > 0 THEN
        FOR i IN 1 .. ARRAY_UPPER(uris, 1) LOOP
            -- First we pull info out of the 856
            uri_xml     := uris[i];

            uri_href    := (oils_xpath('//*[@code="u"]/text()',uri_xml))[1];
            uri_label   := (oils_xpath('//*[@code="y"]/text()|//*[@code="3"]/text()',uri_xml))[1];
            uri_use     := (oils_xpath('//*[@code="z"]/text()|//*[@code="2"]/text()|//*[@code="n"]/text()',uri_xml))[1];

            IF uri_label IS NULL THEN
                uri_label := uri_href;
            END IF;
            CONTINUE WHEN uri_href IS NULL;

            -- Get the distinct list of libraries wanting to use 
            SELECT  ARRAY_ACCUM(
                        DISTINCT REGEXP_REPLACE(
                            x,
                            $re$^.*?\((\w+)\).*$$re$,
                            E'\\1'
                        )
                    ) INTO uri_owner_list
              FROM  UNNEST(
                        oils_xpath(
                            '//*[@code="9"]/text()|//*[@code="w"]/text()|//*[@code="n"]/text()',
                            uri_xml
                        )
                    )x;

            IF ARRAY_UPPER(uri_owner_list,1) > 0 THEN

                -- look for a matching uri
                IF uri_use IS NULL THEN
                    SELECT id INTO uri_id
                        FROM asset.uri
                        WHERE label = uri_label AND href = uri_href AND use_restriction IS NULL AND active
                        ORDER BY id LIMIT 1;
                    IF NOT FOUND THEN -- create one
                        INSERT INTO asset.uri (label, href, use_restriction) VALUES (uri_label, uri_href, uri_use);
                        SELECT id INTO uri_id
                            FROM asset.uri
                            WHERE label = uri_label AND href = uri_href AND use_restriction IS NULL AND active;
                    END IF;
                ELSE
                    SELECT id INTO uri_id
                        FROM asset.uri
                        WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active
                        ORDER BY id LIMIT 1;
                    IF NOT FOUND THEN -- create one
                        INSERT INTO asset.uri (label, href, use_restriction) VALUES (uri_label, uri_href, uri_use);
                        SELECT id INTO uri_id
                            FROM asset.uri
                            WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active;
                    END IF;
                END IF;

                FOR j IN 1 .. ARRAY_UPPER(uri_owner_list, 1) LOOP
                    uri_owner := uri_owner_list[j];

                    SELECT id INTO uri_owner_id FROM actor.org_unit WHERE shortname = uri_owner;
                    CONTINUE WHEN NOT FOUND;

                    -- we need a call number to link through
                    SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    IF NOT FOUND THEN
                        INSERT INTO asset.call_number (owning_lib, record, create_date, edit_date, creator, editor, label)
                            VALUES (uri_owner_id, bib_id, 'now', 'now', editor_id, editor_id, '##URI##');
                        SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    END IF;

                    -- now, link them if they're not already
                    SELECT id INTO uri_map_id FROM asset.uri_call_number_map WHERE call_number = uri_cn_id AND uri = uri_id;
                    IF NOT FOUND THEN
                        INSERT INTO asset.uri_call_number_map (call_number, uri) VALUES (uri_cn_id, uri_id);
                    END IF;

                END LOOP;

            END IF;

        END LOOP;
    END IF;

    RETURN;
END;
$_$;


ALTER FUNCTION biblio.extract_located_uris(bib_id bigint, marcxml text, editor_id integer) OWNER TO postgres;

--
-- Name: extract_metabib_field_entry(bigint); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION extract_metabib_field_entry(bigint) RETURNS SETOF metabib.field_entry_template
    LANGUAGE sql
    AS $_$
	SELECT * FROM biblio.extract_metabib_field_entry($1, ' ');
$_$;


ALTER FUNCTION biblio.extract_metabib_field_entry(bigint) OWNER TO postgres;

--
-- Name: extract_metabib_field_entry(bigint, text); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) RETURNS SETOF metabib.field_entry_template
    LANGUAGE plpgsql
    AS $_$
DECLARE
    bib     biblio.record_entry%ROWTYPE;
    idx     config.metabib_field%ROWTYPE;
    xfrm        config.xml_transform%ROWTYPE;
    prev_xfrm   TEXT;
    transformed_xml TEXT;
    xml_node    TEXT;
    xml_node_list   TEXT[];
    facet_text  TEXT;
    browse_text TEXT;
    raw_text    TEXT;
    curr_text   TEXT;
    joiner      TEXT := default_joiner; -- XXX will index defs supply a joiner?
    output_row  metabib.field_entry_template%ROWTYPE;
BEGIN

    -- Start out with no field-use bools set
    output_row.browse_field = FALSE;
    output_row.facet_field = FALSE;
    output_row.search_field = FALSE;

    -- Get the record
    SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

    -- Loop over the indexing entries
    FOR idx IN SELECT * FROM config.metabib_field ORDER BY format LOOP

        SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

        -- See if we can skip the XSLT ... it's expensive
        IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
            -- Can't skip the transform
            IF xfrm.xslt <> '---' THEN
                transformed_xml := oils_xslt_process(bib.marc,xfrm.xslt);
            ELSE
                transformed_xml := bib.marc;
            END IF;

            prev_xfrm := xfrm.name;
        END IF;

        xml_node_list := oils_xpath( idx.xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );

        raw_text := NULL;
        FOR xml_node IN SELECT x FROM unnest(xml_node_list) AS x LOOP
            CONTINUE WHEN xml_node !~ E'^\\s*<';

            curr_text := ARRAY_TO_STRING(
                oils_xpath( '//text()',
                    REGEXP_REPLACE( -- This escapes all &s not followed by "amp;".  Data ise returned from oils_xpath (above) in UTF-8, not entity encoded
                        REGEXP_REPLACE( -- This escapes embeded <s
                            xml_node,
                            $re$(>[^<]+)(<)([^>]+<)$re$,
                            E'\\1&lt;\\3',
                            'g'
                        ),
                        '&(?!amp;)',
                        '&amp;',
                        'g'
                    )
                ),
                ' '
            );

            CONTINUE WHEN curr_text IS NULL OR curr_text = '';

            IF raw_text IS NOT NULL THEN
                raw_text := raw_text || joiner;
            END IF;

            raw_text := COALESCE(raw_text,'') || curr_text;

            -- autosuggest/metabib.browse_entry
            IF idx.browse_field THEN

                IF idx.browse_xpath IS NOT NULL AND idx.browse_xpath <> '' THEN
                    browse_text := oils_xpath_string( idx.browse_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    browse_text := curr_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(browse_text, E'\\s+', ' ', 'g'));

                output_row.browse_field = TRUE;
                RETURN NEXT output_row;
                output_row.browse_field = FALSE;
            END IF;

            -- insert raw node text for faceting
            IF idx.facet_field THEN

                IF idx.facet_xpath IS NOT NULL AND idx.facet_xpath <> '' THEN
                    facet_text := oils_xpath_string( idx.facet_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    facet_text := curr_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = -1 * idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(facet_text, E'\\s+', ' ', 'g'));

                output_row.facet_field = TRUE;
                RETURN NEXT output_row;
                output_row.facet_field = FALSE;
            END IF;

        END LOOP;

        CONTINUE WHEN raw_text IS NULL OR raw_text = '';

        -- insert combined node text for searching
        IF idx.search_field THEN
            output_row.field_class = idx.field_class;
            output_row.field = idx.id;
            output_row.source = rid;
            output_row.value = BTRIM(REGEXP_REPLACE(raw_text, E'\\s+', ' ', 'g'));

            output_row.search_field = TRUE;
            RETURN NEXT output_row;
            output_row.search_field = FALSE;
        END IF;

    END LOOP;

END;

$_$;


ALTER FUNCTION biblio.extract_metabib_field_entry(rid bigint, default_joiner text) OWNER TO postgres;

--
-- Name: extract_quality(text, text, text); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION extract_quality(marc text, best_lang text, best_type text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    qual        INT;
    ldr         TEXT;
    tval        TEXT;
    tval_rec    RECORD;
    bval        TEXT;
    bval_rec    RECORD;
    type_map    RECORD;
    ff_pos      RECORD;
    ff_tag_data TEXT;
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

    -- First, the count of tags
    qual := ARRAY_UPPER(oils_xpath('*[local-name()="datafield"]', marc), 1);

    -- now go through a bunch of pain to get the record type
    IF best_type IS NOT NULL THEN
        ldr := (oils_xpath('//*[local-name()="leader"]/text()', marc))[1];

        IF ldr IS NOT NULL THEN
            SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
            SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


            tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
            bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

            -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

            SELECT * INTO type_map FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';

            IF type_map.code IS NOT NULL THEN
                IF best_type = type_map.code THEN
                    qual := qual + qual / 2;
                END IF;

                FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = 'Lang' AND rec_type = type_map.code ORDER BY tag DESC LOOP
                    ff_tag_data := SUBSTRING((oils_xpath('//*[@tag="' || ff_pos.tag || '"]/text()',marc))[1], ff_pos.start_pos + 1, ff_pos.length);
                    IF ff_tag_data = best_lang THEN
                            qual := qual + 100;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    END IF;

    -- Now look for some quality metrics
    -- DCL record?
    IF ARRAY_UPPER(oils_xpath('//*[@tag="040"]/*[@code="a" and contains(.,"DLC")]', marc), 1) = 1 THEN
        qual := qual + 10;
    END IF;

    -- From OCLC?
    IF (oils_xpath('//*[@tag="003"]/text()', marc))[1] ~* E'oclo?c' THEN
        qual := qual + 10;
    END IF;

    RETURN qual;

END;
$$;


ALTER FUNCTION biblio.extract_quality(marc text, best_lang text, best_type text) OWNER TO postgres;

--
-- Name: fingerprint_trigger(); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION fingerprint_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- For TG_ARGV, first param is language (like 'eng'), second is record type (like 'BKS')

    IF NEW.deleted IS TRUE THEN -- we don't much care, then, do we?
        RETURN NEW;
    END IF;

    NEW.fingerprint := biblio.extract_fingerprint(NEW.marc);
    NEW.quality := biblio.extract_quality(NEW.marc, TG_ARGV[0], TG_ARGV[1]);

    RETURN NEW;

END;
$$;


ALTER FUNCTION biblio.fingerprint_trigger() OWNER TO postgres;

SET search_path = metabib, pg_catalog;

--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.full_rec_id_seq OWNER TO postgres;

--
-- Name: real_full_rec; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE real_full_rec (
    id bigint DEFAULT nextval('full_rec_id_seq'::regclass) NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.real_full_rec OWNER TO postgres;

--
-- Name: full_rec; Type: VIEW; Schema: metabib; Owner: postgres
--

CREATE VIEW full_rec AS
    SELECT real_full_rec.id, real_full_rec.record, real_full_rec.tag, real_full_rec.ind1, real_full_rec.ind2, real_full_rec.subfield, "substring"(real_full_rec.value, 1, 1024) AS value, real_full_rec.index_vector FROM real_full_rec;


ALTER TABLE metabib.full_rec OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION flatten_marc(rid bigint) RETURNS SETOF metabib.full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
	bib	biblio.record_entry%ROWTYPE;
	output	metabib.full_rec%ROWTYPE;
	field	RECORD;
BEGIN
	SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

	FOR field IN SELECT * FROM vandelay.flatten_marc( bib.marc ) LOOP
		output.record := rid;
		output.ind1 := field.ind1;
		output.ind2 := field.ind2;
		output.tag := field.tag;
		output.subfield := field.subfield;
		output.value := field.value;

		RETURN NEXT output;
	END LOOP;
END;
$$;


ALTER FUNCTION biblio.flatten_marc(rid bigint) OWNER TO postgres;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_value      TEXT;
    new_attrs       HSTORE := ''::HSTORE;
    attr_def        config.record_attr_definition%ROWTYPE;
BEGIN

    IF NEW.deleted IS TRUE THEN -- If this bib is deleted
        PERFORM * FROM config.internal_flag WHERE
            name = 'ingest.metarecord_mapping.preserve_on_delete' AND enabled;
        IF NOT FOUND THEN
            -- One needs to keep these around to support searches
            -- with the #deleted modifier, so one should turn on the named
            -- internal flag for that functionality.
            DELETE FROM metabib.metarecord_source_map WHERE source = NEW.id;
            DELETE FROM metabib.record_attr WHERE id = NEW.id;
        END IF;

        DELETE FROM authority.bib_linking WHERE bib = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM biblio.peer_bib_copy_map WHERE peer_record = NEW.id; -- Separate any multi-homed items
        DELETE FROM metabib.browse_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;
    END IF;

    -- Record authority linking
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_linking' AND enabled;
    IF NOT FOUND THEN
        PERFORM biblio.map_authority_linking( NEW.id, NEW.marc );
    END IF;

    -- Flatten and insert the mfr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM metabib.reingest_metabib_full_rec(NEW.id);

        -- Now we pull out attribute data, which is dependent on the mfr for all but XPath-based fields
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            FOR attr_def IN SELECT * FROM config.record_attr_definition ORDER BY format LOOP

                IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
                    SELECT  ARRAY_TO_STRING(ARRAY_ACCUM(value), COALESCE(attr_def.joiner,' ')) INTO attr_value
                      FROM  (SELECT * FROM metabib.full_rec ORDER BY tag, subfield) AS x
                      WHERE record = NEW.id
                            AND tag LIKE attr_def.tag
                            AND CASE
                                WHEN attr_def.sf_list IS NOT NULL 
                                    THEN POSITION(subfield IN attr_def.sf_list) > 0
                                ELSE TRUE
                                END
                      GROUP BY tag
                      ORDER BY tag
                      LIMIT 1;

                ELSIF attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
                    attr_value := biblio.marc21_extract_fixed_field(NEW.id, attr_def.fixed_field);

                ELSIF attr_def.xpath IS NOT NULL THEN -- and xpath expression

                    SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;
            
                    -- See if we can skip the XSLT ... it's expensive
                    IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                        -- Can't skip the transform
                        IF xfrm.xslt <> '---' THEN
                            transformed_xml := oils_xslt_process(NEW.marc,xfrm.xslt);
                        ELSE
                            transformed_xml := NEW.marc;
                        END IF;
            
                        prev_xfrm := xfrm.name;
                    END IF;

                    IF xfrm.name IS NULL THEN
                        -- just grab the marcxml (empty) transform
                        SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                        prev_xfrm := xfrm.name;
                    END IF;

                    attr_value := oils_xpath_string(attr_def.xpath, transformed_xml, COALESCE(attr_def.joiner,' '), ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]);

                ELSIF attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
                    SELECT  m.value INTO attr_value
                      FROM  biblio.marc21_physical_characteristics(NEW.id) v
                            JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
                      WHERE v.subfield = attr_def.phys_char_sf
                      LIMIT 1; -- Just in case ...

                END IF;

                -- apply index normalizers to attr_value
                FOR normalizer IN
                    SELECT  n.func AS func,
                            n.param_count AS param_count,
                            m.params AS params
                      FROM  config.index_normalizer n
                            JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
                      WHERE attr = attr_def.name
                      ORDER BY m.pos LOOP
                        EXECUTE 'SELECT ' || normalizer.func || '(' ||
                            COALESCE( quote_literal( attr_value ), 'NULL' ) ||
                            CASE
                                WHEN normalizer.param_count > 0
                                    THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                                    ELSE ''
                                END ||
                            ')' INTO attr_value;
        
                END LOOP;

                -- Add the new value to the hstore
                new_attrs := new_attrs || hstore( attr_def.name, attr_value );

            END LOOP;

            IF TG_OP = 'INSERT' OR OLD.deleted THEN -- initial insert OR revivication
                DELETE FROM metabib.record_attr WHERE id = NEW.id;
                INSERT INTO metabib.record_attr (id, attrs) VALUES (NEW.id, new_attrs);
            ELSE
                UPDATE metabib.record_attr SET attrs = new_attrs WHERE id = NEW.id;
            END IF;

        END IF;
    END IF;

    -- Gather and insert the field entry data
    PERFORM metabib.reingest_metabib_field_entries(NEW.id);

    -- Located URI magic
    IF TG_OP = 'INSERT' THEN
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_located_uri' AND enabled;
        IF NOT FOUND THEN
            PERFORM biblio.extract_located_uris( NEW.id, NEW.marc, NEW.editor );
        END IF;
    ELSE
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_located_uri' AND enabled;
        IF NOT FOUND THEN
            PERFORM biblio.extract_located_uris( NEW.id, NEW.marc, NEW.editor );
        END IF;
    END IF;

    -- (re)map metarecord-bib linking
    IF TG_OP = 'INSERT' THEN -- if not deleted and performing an insert, check for the flag
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_insert' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    ELSE -- we're doing an update, and we're not deleted, remap
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_update' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.indexing_ingest_or_delete() OWNER TO postgres;

--
-- Name: map_authority_linking(bigint, text); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION map_authority_linking(bibid bigint, marc text) RETURNS bigint
    LANGUAGE sql
    AS $_$
    DELETE FROM authority.bib_linking WHERE bib = $1;
    INSERT INTO authority.bib_linking (bib, authority)
        SELECT  y.bib,
                y.authority
          FROM (    SELECT  DISTINCT $1 AS bib,
                            BTRIM(remove_paren_substring(txt))::BIGINT AS authority
                      FROM  unnest(oils_xpath('//*[@code="0"]/text()',$2)) x(txt)
                      WHERE BTRIM(remove_paren_substring(txt)) ~ $re$^\d+$$re$
                ) y JOIN authority.record_entry r ON r.id = y.authority;
    SELECT $1;
$_$;


ALTER FUNCTION biblio.map_authority_linking(bibid bigint, marc text) OWNER TO postgres;

--
-- Name: marc21_extract_all_fixed_fields(bigint); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION marc21_extract_all_fixed_fields(rid bigint) RETURNS SETOF record_ff_map
    LANGUAGE sql
    AS $_$
    SELECT $1 AS record, ff_name, ff_value FROM vandelay.marc21_extract_all_fixed_fields( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_extract_all_fixed_fields(rid bigint) OWNER TO postgres;

--
-- Name: marc21_extract_fixed_field(bigint, text); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION marc21_extract_fixed_field(rid bigint, ff text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_extract_fixed_field( (SELECT marc FROM biblio.record_entry WHERE id = $1), $2 );
$_$;


ALTER FUNCTION biblio.marc21_extract_fixed_field(rid bigint, ff text) OWNER TO postgres;

--
-- Name: marc21_physical_characteristics(bigint); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION marc21_physical_characteristics(rid bigint) RETURNS SETOF marc21_physical_characteristics
    LANGUAGE sql
    AS $_$
    SELECT id, $1 AS record, ptype, subfield, value FROM vandelay.marc21_physical_characteristics( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_physical_characteristics(rid bigint) OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: marc21_rec_type_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE marc21_rec_type_map (
    code text NOT NULL,
    type_val text NOT NULL,
    blvl_val text NOT NULL
);


ALTER TABLE config.marc21_rec_type_map OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: marc21_record_type(bigint); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION marc21_record_type(rid bigint) RETURNS config.marc21_rec_type_map
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_record_type( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_record_type(rid bigint) OWNER TO postgres;

--
-- Name: next_autogen_tcn_value(); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION next_autogen_tcn_value() RETURNS text
    LANGUAGE plpgsql
    AS $$
	BEGIN RETURN 'AUTOGENERATED-' || nextval('biblio.autogen_tcn_value_seq'::TEXT); END;
$$;


ALTER FUNCTION biblio.next_autogen_tcn_value() OWNER TO postgres;

--
-- Name: normalize_biblio_monograph_part_sortkey(); Type: FUNCTION; Schema: biblio; Owner: postgres
--

CREATE FUNCTION normalize_biblio_monograph_part_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.normalize_biblio_monograph_part_sortkey() OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: interval_to_seconds(interval); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION interval_to_seconds(interval_val interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN EXTRACT( EPOCH FROM interval_val );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_val interval) OWNER TO postgres;

--
-- Name: interval_to_seconds(text); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION interval_to_seconds(interval_string text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN config.interval_to_seconds( interval_string::INTERVAL );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_string text) OWNER TO postgres;

--
-- Name: update_coded_value_map(text, text, text, text, boolean, text, boolean, boolean); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text DEFAULT NULL::text, in_opac_visible boolean DEFAULT NULL::boolean, in_search_label text DEFAULT NULL::text, in_is_simple boolean DEFAULT NULL::boolean, add_only boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_row config.coded_value_map%ROWTYPE;
BEGIN
    -- Look for a current value
    SELECT INTO current_row * FROM config.coded_value_map WHERE ctype = in_ctype AND code = in_code;
    -- If we have one..
    IF FOUND AND NOT add_only THEN
        -- Update anything we were handed
        current_row.value := COALESCE(current_row.value, in_value);
        current_row.description := COALESCE(current_row.description, in_description);
        current_row.opac_visible := COALESCE(current_row.opac_visible, in_opac_visible);
        current_row.search_label := COALESCE(current_row.search_label, in_search_label);
        current_row.is_simple := COALESCE(current_row.is_simple, in_is_simple);
        UPDATE config.coded_value_map
            SET
                value = current_row.value,
                description = current_row.description,
                opac_visible = current_row.opac_visible,
                search_label = current_row.search_label,
                is_simple = current_row.is_simple
            WHERE id = current_row.id;
    ELSE
        INSERT INTO config.coded_value_map(ctype, code, value, description, opac_visible, search_label, is_simple) VALUES
            (in_ctype, in_code, in_value, in_description, COALESCE(in_opac_visible, TRUE), in_search_label, COALESCE(in_is_simple, FALSE));
    END IF;
END;
$$;


ALTER FUNCTION config.update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) OWNER TO postgres;

--
-- Name: update_hard_due_dates(); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION update_hard_due_dates() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    temp_value  config.hard_due_date_values%ROWTYPE;
    updated     INT := 0;
BEGIN
    FOR temp_value IN
      SELECT  DISTINCT ON (hard_due_date) *
        FROM  config.hard_due_date_values
        WHERE active_date <= NOW() -- We've passed (or are at) the rollover time
        ORDER BY hard_due_date, active_date DESC -- Latest (nearest to us) active time
   LOOP
        UPDATE  config.hard_due_date
          SET   ceiling_date = temp_value.ceiling_date
          WHERE id = temp_value.hard_due_date
                AND ceiling_date <> temp_value.ceiling_date; -- Time is equal if we've already updated the chdd

        IF FOUND THEN
            updated := updated + 1;
        END IF;
    END LOOP;

    RETURN updated;
END;
$$;


ALTER FUNCTION config.update_hard_due_dates() OWNER TO postgres;

--
-- Name: z3950_source_credentials_apply(text, integer, text, text); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1 FROM config.z3950_source_credentials
        WHERE owner = org AND source = src;

    IF FOUND THEN
        IF COALESCE(uname, '') = '' AND COALESCE(passwd, '') = '' THEN
            DELETE FROM config.z3950_source_credentials 
                WHERE owner = org AND source = src;
        ELSE 
            UPDATE config.z3950_source_credentials 
                SET username = uname, password = passwd
                WHERE owner = org AND source = src;
        END IF;
    ELSE
        IF COALESCE(uname, '') <> '' OR COALESCE(passwd, '') <> '' THEN
            INSERT INTO config.z3950_source_credentials
                (source, owner, username, password) 
                VALUES (src, org, uname, passwd);
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION config.z3950_source_credentials_apply(src text, org integer, uname text, passwd text) OWNER TO postgres;

--
-- Name: z3950_source_credentials; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE z3950_source_credentials (
    id integer NOT NULL,
    owner integer NOT NULL,
    source text NOT NULL,
    username text,
    password text
);


ALTER TABLE config.z3950_source_credentials OWNER TO postgres;

--
-- Name: z3950_source_credentials_lookup(text, integer); Type: FUNCTION; Schema: config; Owner: postgres
--

CREATE FUNCTION z3950_source_credentials_lookup(source text, owner integer) RETURNS z3950_source_credentials
    LANGUAGE sql STABLE
    AS $_$

    SELECT creds.* 
    FROM config.z3950_source_credentials creds
        JOIN actor.org_unit aou ON (aou.id = creds.owner)
        JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
    WHERE creds.source = $1 AND creds.owner IN ( 
        SELECT id FROM actor.org_unit_ancestors($2) 
    )
    ORDER BY aout.depth DESC LIMIT 1;

$_$;


ALTER FUNCTION config.z3950_source_credentials_lookup(source text, owner integer) OWNER TO postgres;

SET search_path = container, pg_catalog;

--
-- Name: clear_all_expired_circ_history_items(); Type: FUNCTION; Schema: container; Owner: postgres
--

CREATE FUNCTION clear_all_expired_circ_history_items() RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete expired circulation bucket items for all users that have
-- a setting for patron.max_reading_list_interval.
--
DECLARE
    today        TIMESTAMP WITH TIME ZONE;
    threshold    TIMESTAMP WITH TIME ZONE;
	usr_setting  RECORD;
BEGIN
	SELECT date_trunc( 'day', now() ) INTO today;
	--
	FOR usr_setting in
		SELECT
			usr,
			value
		FROM
			actor.usr_setting
		WHERE
			name = 'patron.max_reading_list_interval'
	LOOP
		--
		-- Make sure the setting is a valid interval
		--
		BEGIN
			threshold := today - CAST( translate( usr_setting.value, '"', '' ) AS INTERVAL );
		EXCEPTION
			WHEN OTHERS THEN
				RAISE NOTICE 'Invalid setting patron.max_reading_list_interval for user %: ''%''',
					usr_setting.usr, usr_setting.value;
				CONTINUE;
		END;
		--
		--RAISE NOTICE 'User % threshold %', usr_setting.usr, threshold;
		--
    	DELETE FROM container.copy_bucket_item
    	WHERE
        	bucket IN
        	(
        	    SELECT
        	        id
        	    FROM
        	        container.copy_bucket
        	    WHERE
        	        owner = usr_setting.usr
        	        AND btype = 'circ_history'
        	)
        	AND create_time < threshold;
	END LOOP;
	--
END;
$$;


ALTER FUNCTION container.clear_all_expired_circ_history_items() OWNER TO postgres;

--
-- Name: FUNCTION clear_all_expired_circ_history_items(); Type: COMMENT; Schema: container; Owner: postgres
--

COMMENT ON FUNCTION clear_all_expired_circ_history_items() IS '
Delete expired circulation bucket items for all users that have
a setting for patron.max_reading_list_interval.
';


--
-- Name: clear_expired_circ_history_items(integer); Type: FUNCTION; Schema: container; Owner: postgres
--

CREATE FUNCTION clear_expired_circ_history_items(ac_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete old circulation bucket items for a specified user.
-- "Old" means older than the interval specified by a
-- user-level setting, if it is so specified.
--
DECLARE
    threshold TIMESTAMP WITH TIME ZONE;
BEGIN
	-- Sanity check
	IF ac_usr IS NULL THEN
		RETURN;
	END IF;
	-- Determine the threshold date that defines "old".  Subtract the
	-- interval from the system date, then truncate to midnight.
	SELECT
		date_trunc( 
			'day',
			now() - CAST( translate( value, '"', '' ) AS INTERVAL )
		)
	INTO
		threshold
	FROM
		actor.usr_setting
	WHERE
		usr = ac_usr
		AND name = 'patron.max_reading_list_interval';
	--
	IF threshold is null THEN
		-- No interval defined; don't delete anything
		-- RAISE NOTICE 'No interval defined for user %', ac_usr;
		return;
	END IF;
	--
	-- RAISE NOTICE 'Date threshold: %', threshold;
	--
	-- Threshold found; do the delete
	delete from container.copy_bucket_item
	where
		bucket in
		(
			select
				id
			from
				container.copy_bucket
			where
				owner = ac_usr
				and btype = 'circ_history'
		)
		and create_time < threshold;
	--
	RETURN;
END;
$$;


ALTER FUNCTION container.clear_expired_circ_history_items(ac_usr integer) OWNER TO postgres;

--
-- Name: FUNCTION clear_expired_circ_history_items(ac_usr integer); Type: COMMENT; Schema: container; Owner: postgres
--

COMMENT ON FUNCTION clear_expired_circ_history_items(ac_usr integer) IS '
Delete old circulation bucket items for a specified user.
"Old" means older than the interval specified by a
user-level setting, if it is so specified.
';


SET search_path = evergreen, pg_catalog;

--
-- Name: array_overlap_check(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION array_overlap_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    fld     TEXT;
    cnt     INT;
BEGIN
    fld := TG_ARGV[1];
    EXECUTE 'SELECT COUNT(*) FROM '|| TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME ||' WHERE '|| fld ||' && ($1).'|| fld INTO cnt USING NEW;
    IF cnt > 0 THEN
        RAISE EXCEPTION 'Cannot insert duplicate array into field % of table %', fld, TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME;
    END IF;
    RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.array_overlap_check() OWNER TO postgres;

--
-- Name: array_remove_item_by_value(anyarray, anyelement); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION array_remove_item_by_value(inp anyarray, el anyelement) RETURNS anyarray
    LANGUAGE sql STABLE
    AS $_$
    SELECT ARRAY_ACCUM(x.e) FROM UNNEST( $1 ) x(e) WHERE x.e <> $2;
$_$;


ALTER FUNCTION evergreen.array_remove_item_by_value(inp anyarray, el anyelement) OWNER TO postgres;

--
-- Name: change_db_setting(text, text[]); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION change_db_setting(setting_name text, settings text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET ' || quote_ident(setting_name) || ' = ' || array_to_string(settings, ',');
END;
$$;


ALTER FUNCTION evergreen.change_db_setting(setting_name text, settings text[]) OWNER TO postgres;

--
-- Name: coded_value_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION coded_value_map_normalizer(input text, ctype text) RETURNS text
    LANGUAGE sql
    AS $_$
        SELECT COALESCE(value,$1) 
            FROM config.coded_value_map 
            WHERE ctype = $2 AND code = $1;
$_$;


ALTER FUNCTION evergreen.coded_value_map_normalizer(input text, ctype text) OWNER TO postgres;

--
-- Name: could_be_serial_holding_code(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION could_be_serial_holding_code(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_X$
    use JSON::XS;
    use MARC::Field;

    eval {
        my $holding_code = (new JSON::XS)->decode(shift);
        new MARC::Field('999', @$holding_code);
    };
    return 0 if $@;
    # verify that subfield labels are exactly one character long
    foreach (keys %{ { @$holding_code } }) {
        return 0 if length($_) != 1;
    }
    return 1;
$_X$;


ALTER FUNCTION evergreen.could_be_serial_holding_code(text) OWNER TO postgres;

--
-- Name: FUNCTION could_be_serial_holding_code(text); Type: COMMENT; Schema: evergreen; Owner: postgres
--

COMMENT ON FUNCTION could_be_serial_holding_code(text) IS 'Return true if parameter is valid JSON representing an array that at minimum doesn''t make MARC::Field balk and only has subfield labels exactly one character long.  Otherwise false.';


--
-- Name: extract_marc_field(text, bigint, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION extract_marc_field(text, bigint, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT extract_marc_field($1,$2,$3,'');
$_$;


ALTER FUNCTION evergreen.extract_marc_field(text, bigint, text) OWNER TO postgres;

--
-- Name: extract_marc_field(text, bigint, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION extract_marc_field(text, bigint, text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    query := $q$
        SELECT  regexp_replace(
                    oils_xpath_string(
                        $q$ || quote_literal($3) || $q$,
                        marc,
                        ' '
                    ),
                    $q$ || quote_literal($4) || $q$,
                    '',
                    'g')
          FROM  $q$ || $1 || $q$
          WHERE id = $q$ || $2;

    EXECUTE query INTO output;

    -- RAISE NOTICE 'query: %, output; %', query, output;

    RETURN output;
END;
$_$;


ALTER FUNCTION evergreen.extract_marc_field(text, bigint, text, text) OWNER TO postgres;

--
-- Name: extract_marc_field_set(text, bigint, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION extract_marc_field_set(text, bigint, text, text) RETURNS SETOF text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    FOR output IN
        SELECT x.t FROM (
            SELECT id,t
                FROM  oils_xpath_table(
                    'id', 'marc', $1, $3, 'id = ' || $2)
                AS t(id int, t text))x
        LOOP
        IF $4 IS NOT NULL THEN
            SELECT INTO output (SELECT regexp_replace(output, $4, '', 'g'));
        END IF;
        RETURN NEXT output;
    END LOOP;
    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.extract_marc_field_set(text, bigint, text, text) OWNER TO postgres;

--
-- Name: facet_force_nfc(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION facet_force_nfc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.value := force_unicode_normal_form(NEW.value,'NFC');
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.facet_force_nfc() OWNER TO postgres;

--
-- Name: fake_fkey_tgr(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION fake_fkey_tgr() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    copy_id BIGINT;
BEGIN
    EXECUTE 'SELECT ($1).' || quote_ident(TG_ARGV[0]) INTO copy_id USING NEW;
    PERFORM * FROM asset.copy WHERE id = copy_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Key (%.%=%) does not exist in asset.copy', TG_TABLE_SCHEMA, TG_TABLE_NAME, copy_id;
    END IF;
    RETURN NULL;
END;
$_$;


ALTER FUNCTION evergreen.fake_fkey_tgr() OWNER TO postgres;

--
-- Name: force_unicode_normal_form(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION force_unicode_normal_form(string text, form text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
use Unicode::Normalize 'normalize';
return normalize($_[1],$_[0]); # reverse the params
$_X$;


ALTER FUNCTION evergreen.force_unicode_normal_form(string text, form text) OWNER TO postgres;

--
-- Name: generic_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION generic_map_normalizer(text, text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
my $string = shift;
my %map;

my $default = $string;

$_ = shift;
while (/^\s*?(.*?)\s*?=>\s*?(\S+)\s*/) {
    if ($1 eq '') {
        $default = $2;
    } else {
        $map{$2} = [split(/\s*,\s*/, $1)];
    }
    $_ = $';
}

for my $key ( keys %map ) {
    return $key if (grep { $_ eq $string } @{ $map{$key} });
}

return $default;

$_X$;


ALTER FUNCTION evergreen.generic_map_normalizer(text, text) OWNER TO postgres;

--
-- Name: get_barcodes(integer, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION get_barcodes(select_ou integer, type text, in_barcode text) RETURNS SETOF barcode_set
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_barcode TEXT;
    barcode_len INT;
    completion_len  INT;
    asset_barcodes  TEXT[];
    actor_barcodes  TEXT[];
    do_asset    BOOL = false;
    do_serial   BOOL = false;
    do_booking  BOOL = false;
    do_actor    BOOL = false;
    completion_set  config.barcode_completion%ROWTYPE;
BEGIN

    IF position('asset' in type) > 0 THEN
        do_asset = true;
    END IF;
    IF position('serial' in type) > 0 THEN
        do_serial = true;
    END IF;
    IF position('booking' in type) > 0 THEN
        do_booking = true;
    END IF;
    IF do_asset OR do_serial OR do_booking THEN
        asset_barcodes = asset_barcodes || in_barcode;
    END IF;
    IF position('actor' in type) > 0 THEN
        do_actor = true;
        actor_barcodes = actor_barcodes || in_barcode;
    END IF;

    barcode_len := length(in_barcode);

    FOR completion_set IN
      SELECT * FROM config.barcode_completion
        WHERE active
        AND org_unit IN (SELECT aou.id FROM actor.org_unit_ancestors(select_ou) aou)
        LOOP
        IF completion_set.prefix IS NULL THEN
            completion_set.prefix := '';
        END IF;
        IF completion_set.suffix IS NULL THEN
            completion_set.suffix := '';
        END IF;
        IF completion_set.length = 0 OR completion_set.padding IS NULL OR length(completion_set.padding) = 0 THEN
            cur_barcode = completion_set.prefix || in_barcode || completion_set.suffix;
        ELSE
            completion_len = completion_set.length - length(completion_set.prefix) - length(completion_set.suffix);
            IF completion_len >= barcode_len THEN
                IF completion_set.padding_end THEN
                    cur_barcode = rpad(in_barcode, completion_len, completion_set.padding);
                ELSE
                    cur_barcode = lpad(in_barcode, completion_len, completion_set.padding);
                END IF;
                cur_barcode = completion_set.prefix || cur_barcode || completion_set.suffix;
            END IF;
        END IF;
        IF completion_set.actor THEN
            actor_barcodes = actor_barcodes || cur_barcode;
        END IF;
        IF completion_set.asset THEN
            asset_barcodes = asset_barcodes || cur_barcode;
        END IF;
    END LOOP;

    IF do_asset AND do_serial THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM ONLY asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_asset THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_serial THEN
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    END IF;
    IF do_booking THEN
        RETURN QUERY SELECT 'booking'::TEXT, id::BIGINT, barcode FROM booking.resource WHERE barcode = ANY(asset_barcodes);
    END IF;
    IF do_actor THEN
        RETURN QUERY SELECT 'actor'::TEXT, c.usr::BIGINT, c.barcode FROM actor.card c JOIN actor.usr u ON c.usr = u.id WHERE
            ((c.barcode = ANY(actor_barcodes) AND c.active) OR c.barcode = in_barcode) AND NOT u.deleted ORDER BY usr;
    END IF;
    RETURN;
END;
$$;


ALTER FUNCTION evergreen.get_barcodes(select_ou integer, type text, in_barcode text) OWNER TO postgres;

--
-- Name: FUNCTION get_barcodes(select_ou integer, type text, in_barcode text); Type: COMMENT; Schema: evergreen; Owner: postgres
--

COMMENT ON FUNCTION get_barcodes(select_ou integer, type text, in_barcode text) IS '
Given user input, find an appropriate barcode in the proper class.

Will add prefix/suffix information to do so, and return all results.
';


--
-- Name: get_locale_name(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION get_locale_name(locale text, OUT name text, OUT description text) RETURNS record
    LANGUAGE plpgsql STABLE COST 1
    AS $$
DECLARE
    eg_locale TEXT;
BEGIN
    eg_locale := LOWER(SUBSTRING(locale FROM 1 FOR 2)) || '-' || UPPER(SUBSTRING(locale FROM 4 FOR 2));
        
    SELECT i18nc.string INTO name
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.name';

    IF name IS NULL THEN
       SELECT i18nl.name INTO name
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;

    SELECT i18nc.string INTO description
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.description';

    IF description IS NULL THEN
       SELECT i18nl.description INTO description
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;
END;
$$;


ALTER FUNCTION evergreen.get_locale_name(locale text, OUT name text, OUT description text) OWNER TO postgres;

--
-- Name: limit_oustl(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION limit_oustl() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    BEGIN
        -- Only keeps the most recent five settings changes.
        DELETE FROM config.org_unit_setting_type_log WHERE field_name = NEW.field_name AND date_applied NOT IN 
        (SELECT date_applied FROM config.org_unit_setting_type_log WHERE field_name = NEW.field_name ORDER BY date_applied DESC LIMIT 4);
        
        IF (TG_OP = 'UPDATE') THEN
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            RETURN NEW;
        END IF;
        RETURN NULL;
    END;
$$;


ALTER FUNCTION evergreen.limit_oustl() OWNER TO postgres;

--
-- Name: located_uris(bigint, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION located_uris(bibid bigint, ouid integer, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank integer)
    LANGUAGE sql STABLE
    AS $_$
    SELECT acn.id, aou.name, acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number 
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           INNER JOIN actor.org_unit_ancestors( COALESCE($3, $2) ) aou ON (acn.owning_lib = aou.id)
      WHERE acn.record = $1
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE
    UNION
    SELECT acn.id, aou.name, acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number 
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           INNER JOIN actor.org_unit_ancestors( $2 ) aou ON (acn.owning_lib = aou.id)
      WHERE acn.record = $1
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE;
$_$;


ALTER FUNCTION evergreen.located_uris(bibid bigint, ouid integer, pref_lib integer) OWNER TO postgres;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION evergreen.lowercase(text) OWNER TO postgres;

--
-- Name: lpad_number_substrings(text, text, integer); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION lpad_number_substrings(text, text, integer) RETURNS text
    LANGUAGE plperlu
    AS $_$
    my $string = shift;
    my $pad = shift;
    my $len = shift;
    my $find = $len - 1;

    while ($string =~ /(?:^|\D)(\d{1,$find})(?:$|\D)/) {
        my $padded = $1;
        $padded = $pad x ($len - length($padded)) . $padded;
        $string =~ s/$1/$padded/sg;
    }

    return $string;
$_$;


ALTER FUNCTION evergreen.lpad_number_substrings(text, text, integer) OWNER TO postgres;

--
-- Name: maintain_901(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION maintain_901() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $schema = $_TD->{table_schema};
my $marc = MARC::Record->new_from_xml($_TD->{new}{marc});

my @old901s = $marc->field('901');
$marc->delete_fields(@old901s);

if ($schema eq 'biblio') {
    my $tcn_value = $_TD->{new}{tcn_value};

    # Set TCN value to record ID?
    my $id_as_tcn = spi_exec_query("
        SELECT enabled
        FROM config.global_flag
        WHERE name = 'cat.bib.use_id_for_tcn'
    ");
    if (($id_as_tcn->{processed}) && $id_as_tcn->{rows}[0]->{enabled} eq 't') {
        $tcn_value = $_TD->{new}{id}; 
        $_TD->{new}{tcn_value} = $tcn_value;
    }

    my $new_901 = MARC::Field->new("901", " ", " ",
        "a" => $tcn_value,
        "b" => $_TD->{new}{tcn_source},
        "c" => $_TD->{new}{id},
        "t" => $schema
    );

    if ($_TD->{new}{owner}) {
        $new_901->add_subfields("o" => $_TD->{new}{owner});
    }

    if ($_TD->{new}{share_depth}) {
        $new_901->add_subfields("d" => $_TD->{new}{share_depth});
    }

    $marc->append_fields($new_901);
} elsif ($schema eq 'authority') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
} elsif ($schema eq 'serial') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
        "o" => $_TD->{new}{owning_lib},
    );

    if ($_TD->{new}{record}) {
        $new_901->add_subfields("r" => $_TD->{new}{record});
    }

    $marc->append_fields($new_901);
} else {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
}

my $xml = $marc->as_xml_record();
$xml =~ s/\n//sgo;
$xml =~ s/^<\?xml.+\?\s*>//go;
$xml =~ s/>\s+</></go;
$xml =~ s/\p{Cc}//go;

# Embed a version of OpenILS::Application::AppUtils->entityize()
# to avoid having to set PERL5LIB for PostgreSQL as well

# If we are going to convert non-ASCII characters to XML entities,
# we had better be dealing with a UTF8 string to begin with
$xml = decode_utf8($xml);

$xml = NFC($xml);

# Convert raw ampersands to entities
$xml =~ s/&(?!\S+;)/&amp;/gso;

# Convert Unicode characters to entities
$xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

$xml =~ s/[\x00-\x1f]//go;
$_TD->{new}{marc} = $xml;

return "MODIFY";
$_X$;


ALTER FUNCTION evergreen.maintain_901() OWNER TO postgres;

--
-- Name: maintain_control_numbers(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION maintain_control_numbers() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $record = MARC::Record->new_from_xml($_TD->{new}{marc});
my $schema = $_TD->{table_schema};
my $rec_id = $_TD->{new}{id};

# Short-circuit if maintaining control numbers per MARC21 spec is not enabled
my $enable = spi_exec_query("SELECT enabled FROM config.global_flag WHERE name = 'cat.maintain_control_numbers'");
if (!($enable->{processed}) or $enable->{rows}[0]->{enabled} eq 'f') {
    return;
}

# Get the control number identifier from an OU setting based on $_TD->{new}{owner}
my $ou_cni = 'EVRGRN';

my $owner;
if ($schema eq 'serial') {
    $owner = $_TD->{new}{owning_lib};
} else {
    # are.owner and bre.owner can be null, so fall back to the consortial setting
    $owner = $_TD->{new}{owner} || 1;
}

my $ous_rv = spi_exec_query("SELECT value FROM actor.org_unit_ancestor_setting('cat.marc_control_number_identifier', $owner)");
if ($ous_rv->{processed}) {
    $ou_cni = $ous_rv->{rows}[0]->{value};
    $ou_cni =~ s/"//g; # Stupid VIM syntax highlighting"
} else {
    # Fall back to the shortname of the OU if there was no OU setting
    $ous_rv = spi_exec_query("SELECT shortname FROM actor.org_unit WHERE id = $owner");
    if ($ous_rv->{processed}) {
        $ou_cni = $ous_rv->{rows}[0]->{shortname};
    }
}

my ($create, $munge) = (0, 0);

my @scns = $record->field('035');

foreach my $id_field ('001', '003') {
    my $spec_value;
    my @controls = $record->field($id_field);

    if ($id_field eq '001') {
        $spec_value = $rec_id;
    } else {
        $spec_value = $ou_cni;
    }

    # Create the 001/003 if none exist
    if (scalar(@controls) == 1) {
        # Only one field; check to see if we need to munge it
        unless (grep $_->data() eq $spec_value, @controls) {
            $munge = 1;
        }
    } else {
        # Delete the other fields, as with more than 1 001/003 we do not know which 003/001 to match
        foreach my $control (@controls) {
            $record->delete_field($control);
        }
        $record->insert_fields_ordered(MARC::Field->new($id_field, $spec_value));
        $create = 1;
    }
}

my $cn = $record->field('001')->data();
# Special handling of OCLC numbers, often found in records that lack 003
if ($cn =~ /^o(c[nm]|n)\d/) {
    $cn =~ s/^o(c[nm]|n)0*(\d+)/$2/;
    $record->field('003')->data('OCoLC');
    $create = 0;
}

# Now, if we need to munge the 001, we will first push the existing 001/003
# into the 035; but if the record did not have one (and one only) 001 and 003
# to begin with, skip this process
if ($munge and not $create) {

    my $scn = "(" . $record->field('003')->data() . ")" . $cn;

    # Do not create duplicate 035 fields
    unless (grep $_->subfield('a') eq $scn, @scns) {
        $record->insert_fields_ordered(MARC::Field->new('035', '', '', 'a' => $scn));
    }
}

# Set the 001/003 and update the MARC
if ($create or $munge) {
    $record->field('001')->data($rec_id);
    $record->field('003')->data($ou_cni);

    my $xml = $record->as_xml_record();
    $xml =~ s/\n//sgo;
    $xml =~ s/^<\?xml.+\?\s*>//go;
    $xml =~ s/>\s+</></go;
    $xml =~ s/\p{Cc}//go;

    # Embed a version of OpenILS::Application::AppUtils->entityize()
    # to avoid having to set PERL5LIB for PostgreSQL as well

    # If we are going to convert non-ASCII characters to XML entities,
    # we had better be dealing with a UTF8 string to begin with
    $xml = decode_utf8($xml);

    $xml = NFC($xml);

    # Convert raw ampersands to entities
    $xml =~ s/&(?!\S+;)/&amp;/gso;

    # Convert Unicode characters to entities
    $xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

    $xml =~ s/[\x00-\x1f]//go;
    $_TD->{new}{marc} = $xml;

    return "MODIFY";
}

return;
$_X$;


ALTER FUNCTION evergreen.maintain_control_numbers() OWNER TO postgres;

--
-- Name: oils_i18n_code_tracking(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_code_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.code::TEXT, NEW.code::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.oils_i18n_code_tracking() OWNER TO postgres;

--
-- Name: oils_i18n_gettext(integer, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_gettext(integer, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION evergreen.oils_i18n_gettext(integer, text, text, text) OWNER TO postgres;

--
-- Name: oils_i18n_gettext(text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_gettext(text, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION evergreen.oils_i18n_gettext(text, text, text, text) OWNER TO postgres;

--
-- Name: oils_i18n_id_tracking(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_id_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.id::TEXT, NEW.id::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.oils_i18n_id_tracking() OWNER TO postgres;

--
-- Name: oils_i18n_update_apply(text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_update_apply(old_ident text, new_ident text, hint text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN

    EXECUTE $$
        UPDATE  config.i18n_core
          SET   identity_value = $$ || quote_literal(new_ident) || $$ 
          WHERE fq_field LIKE '$$ || hint || $$.%' 
                AND identity_value = $$ || quote_literal(old_ident) || $$::TEXT;$$;

    RETURN;

END;
$_$;


ALTER FUNCTION evergreen.oils_i18n_update_apply(old_ident text, new_ident text, hint text) OWNER TO postgres;

--
-- Name: oils_i18n_xlate(text, text, text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    locale      TEXT := REGEXP_REPLACE( REGEXP_REPLACE( raw_locale, E'[;, ].+$', '' ), E'_', '-', 'g' );
    language    TEXT := REGEXP_REPLACE( locale, E'-.+$', '' );
    result      config.i18n_core%ROWTYPE;
    fallback    TEXT;
    keyfield    TEXT := keyclass || '.' || keycol;
BEGIN

    -- Try the full locale
    SELECT  * INTO result
      FROM  config.i18n_core
      WHERE fq_field = keyfield
            AND identity_value = keyvalue
            AND translation = locale;

    -- Try just the language
    IF NOT FOUND THEN
        SELECT  * INTO result
          FROM  config.i18n_core
          WHERE fq_field = keyfield
                AND identity_value = keyvalue
                AND translation = language;
    END IF;

    -- Fall back to the string we passed in in the first place
    IF NOT FOUND THEN
	EXECUTE
            'SELECT ' ||
                keycol ||
            ' FROM ' || keytable ||
            ' WHERE ' || identcol || ' = ' || quote_literal(keyvalue)
                INTO fallback;
        RETURN fallback;
    END IF;

    RETURN result.string;
END;
$_$;


ALTER FUNCTION evergreen.oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) OWNER TO postgres;

--
-- Name: oils_json_to_text(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_json_to_text(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;
    my $json = shift();
    my $txt;
    eval { $txt = JSON::XS->new->allow_nonref->decode( $json ) };
    return undef if ($@);
    return $txt
$_$;


ALTER FUNCTION evergreen.oils_json_to_text(text) OWNER TO postgres;

--
-- Name: oils_text_as_bytea(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_text_as_bytea(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT CAST(REGEXP_REPLACE(UPPER($1), $$\\$$, $$\\\\$$, 'g') AS BYTEA);
$_$;


ALTER FUNCTION evergreen.oils_text_as_bytea(text) OWNER TO postgres;

--
-- Name: oils_xpath(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath(text, text) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT XPATH( $1, $2::XML )::TEXT[];$_$;


ALTER FUNCTION evergreen.oils_xpath(text, text) OWNER TO postgres;

--
-- Name: oils_xpath(text, text, anyarray); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath(text, text, anyarray) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT XPATH( $1, $2::XML, $3 )::TEXT[];$_$;


ALTER FUNCTION evergreen.oils_xpath(text, text, anyarray) OWNER TO postgres;

--
-- Name: oils_xpath_string(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath_string(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '{}'::TEXT[] );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text) OWNER TO postgres;

--
-- Name: oils_xpath_string(text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath_string(text, text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, $3, '{}'::TEXT[] );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, text) OWNER TO postgres;

--
-- Name: oils_xpath_string(text, text, anyarray); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath_string(text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '', $3 );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, anyarray) OWNER TO postgres;

--
-- Name: oils_xpath_string(text, text, text, anyarray); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath_string(text, text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  ARRAY_TO_STRING(
                oils_xpath(
                    $1 ||
                        CASE WHEN $1 ~ $re$/[^/[]*@[^]]+$$re$ OR $1 ~ $re$text\(\)$$re$ THEN '' ELSE '//text()' END,
                    $2,
                    $4
                ),
                $3
            );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, text, anyarray) OWNER TO postgres;

--
-- Name: oils_xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) RETURNS SETOF record
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    xpath_list  TEXT[];
    select_list TEXT[];
    where_list  TEXT[];
    q           TEXT;
    out_record  RECORD;
    empty_test  RECORD;
BEGIN
    xpath_list := STRING_TO_ARRAY( xpaths, '|' );

    select_list := ARRAY_APPEND( select_list, key || '::INT AS key' );

    FOR i IN 1 .. ARRAY_UPPER(xpath_list,1) LOOP
        IF xpath_list[i] = 'null()' THEN
            select_list := ARRAY_APPEND( select_list, 'NULL::TEXT AS c_' || i );
        ELSE
            select_list := ARRAY_APPEND(
                select_list,
                $sel$
                unnest(
                    COALESCE(
                        NULLIF(
                            oils_xpath(
                                $sel$ ||
                                    quote_literal(
                                        CASE
                                            WHEN xpath_list[i] ~ $re$/[^/[]*@[^/]+$$re$ OR xpath_list[i] ~ $re$text\(\)$$re$ THEN xpath_list[i]
                                            ELSE xpath_list[i] || '//text()'
                                        END
                                    ) ||
                                $sel$,
                                $sel$ || document_field || $sel$
                            ),
                           '{}'::TEXT[]
                        ),
                        '{NULL}'::TEXT[]
                    )
                ) AS c_$sel$ || i
            );
            where_list := ARRAY_APPEND(
                where_list,
                'c_' || i || ' IS NOT NULL'
            );
        END IF;
    END LOOP;

    q := $q$
SELECT * FROM (
    SELECT $q$ || ARRAY_TO_STRING( select_list, ', ' ) || $q$ FROM $q$ || relation_name || $q$ WHERE ($q$ || criteria || $q$)
)x WHERE $q$ || ARRAY_TO_STRING( where_list, ' OR ' );
    -- RAISE NOTICE 'query: %', q;

    FOR out_record IN EXECUTE q LOOP
        RETURN NEXT out_record;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) OWNER TO postgres;

--
-- Name: oils_xslt_process(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION oils_xslt_process(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
  use strict;

  use XML::LibXSLT;
  use XML::LibXML;

  my $doc = shift;
  my $xslt = shift;

  # The following approach uses the older XML::LibXML 1.69 / XML::LibXSLT 1.68
  # methods of parsing XML documents and stylesheets, in the hopes of broader
  # compatibility with distributions
  my $parser = $_SHARED{'_xslt_process'}{parsers}{xml} || XML::LibXML->new();

  # Cache the XML parser, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xml} = $parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xml});

  my $xslt_parser = $_SHARED{'_xslt_process'}{parsers}{xslt} || XML::LibXSLT->new();

  # Cache the XSLT processor, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xslt} = $xslt_parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xslt});

  my $stylesheet = $_SHARED{'_xslt_process'}{stylesheets}{$xslt} ||
    $xslt_parser->parse_stylesheet( $parser->parse_string($xslt) );

  $_SHARED{'_xslt_process'}{stylesheets}{$xslt} = $stylesheet
    unless ($_SHARED{'_xslt_process'}{stylesheets}{$xslt});

  return $stylesheet->output_string(
    $stylesheet->transform(
      $parser->parse_string($doc)
    )
  );

$_X$;


ALTER FUNCTION evergreen.oils_xslt_process(text, text) OWNER TO postgres;

--
-- Name: org_top(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION org_top() RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $$
    SELECT * FROM actor.org_unit WHERE parent_ou IS NULL LIMIT 1;
$$;


ALTER FUNCTION evergreen.org_top() OWNER TO postgres;

--
-- Name: ous_change_log(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION ous_change_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = NEW.name AND org_unit = NEW.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (NEW.org_unit, original, NEW.value, NEW.name);
        
        RETURN NEW;
    END;
$$;


ALTER FUNCTION evergreen.ous_change_log() OWNER TO postgres;

--
-- Name: ous_delete_log(); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION ous_delete_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = OLD.name AND org_unit = OLD.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (OLD.org_unit, original, 'null', OLD.name);
        
        RETURN OLD;
    END;
$$;


ALTER FUNCTION evergreen.ous_delete_log() OWNER TO postgres;

--
-- Name: rank_cp_status(integer); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION rank_cp_status(status integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    WITH totally_available AS (
        SELECT id, 0 AS avail_rank
        FROM config.copy_status
        WHERE opac_visible IS TRUE
            AND copy_active IS TRUE
            AND id != 1 -- "Checked out"
    ), almost_available AS (
        SELECT id, 10 AS avail_rank
        FROM config.copy_status
        WHERE holdable IS TRUE
            AND opac_visible IS TRUE
            AND copy_active IS FALSE
            OR id = 1 -- "Checked out"
    )
    SELECT COALESCE(
        (SELECT avail_rank FROM totally_available WHERE $1 IN (id)),
        (SELECT avail_rank FROM almost_available WHERE $1 IN (id)),
        100
    );
$_$;


ALTER FUNCTION evergreen.rank_cp_status(status integer) OWNER TO postgres;

--
-- Name: rank_ou(integer, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION rank_ou(lib integer, search_lib integer, pref_lib integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    SELECT COALESCE(

        -- lib matches search_lib
        (SELECT CASE WHEN $1 = $2 THEN -20000 END),

        -- lib matches pref_lib
        (SELECT CASE WHEN $1 = $3 THEN -10000 END),


        -- pref_lib is a child of search_lib and lib is a child of pref lib.  
        -- For example, searching CONS, pref lib is SYS1, 
        -- copies at BR1 and BR2 sort to the front.
        (SELECT distance - 5000
            FROM actor.org_unit_descendants_distance($3) 
            WHERE id = $1 AND $3 IN (
                SELECT id FROM actor.org_unit_descendants($2))),

        -- lib is a child of search_lib
        (SELECT distance FROM actor.org_unit_descendants_distance($2) WHERE id = $1),

        -- all others pay cash
        1000
    );
$_$;


ALTER FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer) OWNER TO postgres;

--
-- Name: ranked_volumes(bigint, integer, integer, public.hstore, public.hstore, integer, text[]); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION ranked_volumes(bibid bigint, ouid integer, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, pref_lib integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[]) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE
    AS $_$
    SELECT ua.id, ua.name, ua.label_sortkey, MIN(ua.rank) AS rank FROM (
        SELECT acn.id, aou.name, acn.label_sortkey,
            evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status),
            RANK() OVER w
        FROM asset.call_number acn
            JOIN asset.copy acp ON (acn.id = acp.call_number)
            JOIN actor.org_unit_descendants( $2, COALESCE(
                $3, (
                    SELECT depth
                    FROM actor.org_unit_type aout
                        INNER JOIN actor.org_unit ou ON ou_type = aout.id
                    WHERE ou.id = $2
                ), $6)
            ) AS aou ON (acp.circ_lib = aou.id)
        WHERE acn.record = $1
            AND acn.deleted IS FALSE
            AND acp.deleted IS FALSE
            AND CASE WHEN ('exclude_invisible_acn' = ANY($7)) THEN 
                EXISTS (
                    SELECT 1 
                    FROM asset.opac_visible_copies 
                    WHERE copy_id = acp.id AND record = acn.record
                ) ELSE TRUE END
        GROUP BY acn.id, acp.status, aou.name, acn.label_sortkey, aou.id
        WINDOW w AS (
            ORDER BY evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status)
        )
    ) AS ua
    GROUP BY ua.id, ua.name, ua.label_sortkey
    ORDER BY rank, ua.name, ua.label_sortkey
    LIMIT ($4 -> 'acn')::INT
    OFFSET ($5 -> 'acn')::INT;
$_$;


ALTER FUNCTION evergreen.ranked_volumes(bibid bigint, ouid integer, depth integer, slimit public.hstore, soffset public.hstore, pref_lib integer, includes text[]) OWNER TO postgres;

--
-- Name: regexp_split_to_array(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION regexp_split_to_array(text, text) RETURNS text[]
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
    return encode_array_literal([split $_[1], $_[0]]);
$_X$;


ALTER FUNCTION evergreen.regexp_split_to_array(text, text) OWNER TO postgres;

--
-- Name: rel_bump(text[], text, text[], numeric[]); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION rel_bump(terms text[], value text, bumps text[], mults numeric[]) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
use strict;
my ($terms,$value,$bumps,$mults) = @_;

my $retval = 1;

for (my $id = 0; $id < @$bumps; $id++) {
        if ($bumps->[$id] eq 'first_word') {
                $retval *= $mults->[$id] if ($value =~ /^$terms->[0]/);
        } elsif ($bumps->[$id] eq 'full_match') {
                my $fullmatch = join(' ', @$terms);
                $retval *= $mults->[$id] if ($value =~ /^$fullmatch$/);
        } elsif ($bumps->[$id] eq 'word_order') {
                my $wordorder = join('.*', @$terms);
                $retval *= $mults->[$id] if ($value =~ /$wordorder/);
        }
}
return $retval;
$_$;


ALTER FUNCTION evergreen.rel_bump(terms text[], value text, bumps text[], mults numeric[]) OWNER TO postgres;

--
-- Name: tableoid2name(oid); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION tableoid2name(oid) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		RETURN $1::regclass;
	END;
$_$;


ALTER FUNCTION evergreen.tableoid2name(oid) OWNER TO postgres;

--
-- Name: upgrade_deps_block_check(text, text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_deps_block_check(my_db_patch text, my_applied_to text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
    deprecates TEXT;
    supersedes TEXT;
BEGIN
    IF NOT evergreen.upgrade_verify_no_dep_conflicts( my_db_patch ) THEN
        SELECT  STRING_AGG(patch, ', ') INTO deprecates FROM evergreen.upgrade_list_applied_deprecates(my_db_patch);
        SELECT  STRING_AGG(patch, ', ') INTO supersedes FROM evergreen.upgrade_list_applied_supersedes(my_db_patch);
        RAISE EXCEPTION '
Upgrade script % can not be applied:
  applied deprecated scripts %
  applied superseded scripts %
  deprecated by %
  superseded by %',
            my_db_patch,
            ARRAY_AGG(evergreen.upgrade_list_applied_deprecates(my_db_patch)),
            ARRAY_AGG(evergreen.upgrade_list_applied_supersedes(my_db_patch)),
            evergreen.upgrade_list_applied_deprecated(my_db_patch),
            evergreen.upgrade_list_applied_superseded(my_db_patch);
    END IF;

    INSERT INTO config.upgrade_log (version, applied_to) VALUES (my_db_patch, my_applied_to);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION evergreen.upgrade_deps_block_check(my_db_patch text, my_applied_to text) OWNER TO postgres;

--
-- Name: upgrade_list_applied_deprecated(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_list_applied_deprecated(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && deprecates
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecated(my_db_patch text) OWNER TO postgres;

--
-- Name: upgrade_list_applied_deprecates(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_list_applied_deprecates(my_db_patch text) RETURNS SETOF patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version::TEXT[] && d.deprecates)
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecates(my_db_patch text) OWNER TO postgres;

--
-- Name: upgrade_list_applied_superseded(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_list_applied_superseded(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && supersedes
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_superseded(my_db_patch text) OWNER TO postgres;

--
-- Name: upgrade_list_applied_supersedes(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_list_applied_supersedes(my_db_patch text) RETURNS SETOF patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version::TEXT[] && d.supersedes)
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_supersedes(my_db_patch text) OWNER TO postgres;

--
-- Name: upgrade_verify_no_dep_conflicts(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION upgrade_verify_no_dep_conflicts(my_db_patch text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT  COUNT(*) = 0
      FROM  (SELECT * FROM evergreen.upgrade_list_applied_deprecates( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_supersedes( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_deprecated( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_superseded( $1 ))x
$_$;


ALTER FUNCTION evergreen.upgrade_verify_no_dep_conflicts(my_db_patch text) OWNER TO postgres;

--
-- Name: xml_escape(text); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION xml_escape(str text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT REPLACE(REPLACE(REPLACE($1,
       '&', '&amp;'),
       '<', '&lt;'),
       '>', '&gt;');
$_$;


ALTER FUNCTION evergreen.xml_escape(str text) OWNER TO postgres;

--
-- Name: xml_pretty_print(xml); Type: FUNCTION; Schema: evergreen; Owner: postgres
--

CREATE FUNCTION xml_pretty_print(input xml) RETURNS xml
    LANGUAGE sql
    AS $_$
SELECT xslt_process($1::text,
$$<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    version="1.0">
   <xsl:output method="xml" omit-xml-declaration="yes" indent="yes"/>
   <xsl:strip-space elements="*"/>
   <xsl:template match="@*|node()">
     <xsl:copy>
       <xsl:apply-templates select="@*|node()"/>
     </xsl:copy>
   </xsl:template>
 </xsl:stylesheet>
$$::text)::XML
$_$;


ALTER FUNCTION evergreen.xml_pretty_print(input xml) OWNER TO postgres;

--
-- Name: FUNCTION xml_pretty_print(input xml); Type: COMMENT; Schema: evergreen; Owner: postgres
--

COMMENT ON FUNCTION xml_pretty_print(input xml) IS 'Simple pretty printer for XML, as written by Andrew Dunstan at http://goo.gl/zBHIk';


SET search_path = metabib, pg_catalog;

--
-- Name: autosuggest_prepare_tsquery(text); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION autosuggest_prepare_tsquery(orig text) RETURNS text[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    orig_ended_in_space     BOOLEAN;
    result                  RECORD;
    plain                   TEXT;
    normalized              TEXT;
BEGIN
    orig_ended_in_space := orig ~ E'\\s$';

    orig := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(orig, E'\\W+'), ' '
    );

    normalized := public.search_normalize(orig); -- also trim()s
    plain := trim(orig);

    IF NOT orig_ended_in_space THEN
        plain := plain || ':*';
        normalized := normalized || ':*';
    END IF;

    plain := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(plain, E'\\s+'), ' & '
    );
    normalized := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(normalized, E'\\s+'), ' & '
    );

    RETURN ARRAY[normalized, plain];
END;
$_$;


ALTER FUNCTION metabib.autosuggest_prepare_tsquery(orig text) OWNER TO postgres;

--
-- Name: browse_normalize(text, integer); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION browse_normalize(facet_text text, mapped_field integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
BEGIN

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = mapped_field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    RETURN facet_text;
END;

$$;


ALTER FUNCTION metabib.browse_normalize(facet_text text, mapped_field integer) OWNER TO postgres;

--
-- Name: facet_normalize_trigger(); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION facet_normalize_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
    facet_text  TEXT;
BEGIN
    facet_text := NEW.value;

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = NEW.field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    NEW.value = facet_text;

    RETURN NEW;
END;
$$;


ALTER FUNCTION metabib.facet_normalize_trigger() OWNER TO postgres;

--
-- Name: reingest_metabib_field_entries(bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean DEFAULT false, skip_browse boolean DEFAULT false, skip_search boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    fclass          RECORD;
    ind_data        metabib.field_entry_template%ROWTYPE;
    mbe_row         metabib.browse_entry%ROWTYPE;
    mbe_id          BIGINT;
    mbe_txt         TEXT;
    b_skip_facet    BOOL;
    b_skip_browse   BOOL;
    b_skip_search   BOOL;
BEGIN

    SELECT COALESCE(NULLIF(skip_facet, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_facet_indexing' AND enabled)) INTO b_skip_facet;
    SELECT COALESCE(NULLIF(skip_browse, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_browse_indexing' AND enabled)) INTO b_skip_browse;
    SELECT COALESCE(NULLIF(skip_search, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_search_indexing' AND enabled)) INTO b_skip_search;

    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        IF NOT b_skip_search THEN
            FOR fclass IN SELECT * FROM config.metabib_class LOOP
                -- RAISE NOTICE 'Emptying out %', fclass.name;
                EXECUTE $$DELETE FROM metabib.$$ || fclass.name || $$_field_entry WHERE source = $$ || bib_id;
            END LOOP;
        END IF;
        IF NOT b_skip_facet THEN
            DELETE FROM metabib.facet_entry WHERE source = bib_id;
        END IF;
        IF NOT b_skip_browse THEN
            DELETE FROM metabib.browse_entry_def_map WHERE source = bib_id;
        END IF;
    END IF;

    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( bib_id ) LOOP
        IF ind_data.field < 0 THEN
            ind_data.field = -1 * ind_data.field;
        END IF;

        IF ind_data.facet_field AND NOT b_skip_facet THEN
            INSERT INTO metabib.facet_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        END IF;

        IF ind_data.browse_field AND NOT b_skip_browse THEN
            -- A caveat about this SELECT: this should take care of replacing
            -- old mbe rows when data changes, but not if normalization (by
            -- which I mean specifically the output of
            -- evergreen.oils_tsearch2()) changes.  It may or may not be
            -- expensive to add a comparison of index_vector to index_vector
            -- to the WHERE clause below.
            mbe_txt := metabib.browse_normalize(ind_data.value, ind_data.field);
            SELECT INTO mbe_row * FROM metabib.browse_entry WHERE value = mbe_txt;
            IF FOUND THEN
                mbe_id := mbe_row.id;
            ELSE
                INSERT INTO metabib.browse_entry (value) VALUES (mbe_txt);
                mbe_id := CURRVAL('metabib.browse_entry_id_seq'::REGCLASS);
            END IF;

            INSERT INTO metabib.browse_entry_def_map (entry, def, source)
                VALUES (mbe_id, ind_data.field, ind_data.source);
        END IF;

        -- Avoid inserting duplicate rows, but retain granularity of being
        -- able to search browse fields with "starts with" type operators
        -- (for example, for titles of songs in music albums)
        IF (ind_data.search_field OR ind_data.browse_field) AND NOT b_skip_search THEN
            EXECUTE 'SELECT 1 FROM metabib.' || ind_data.field_class ||
                '_field_entry WHERE field = $1 AND source = $2 AND value = $3'
                INTO mbe_id USING ind_data.field, ind_data.source, ind_data.value;
                -- RAISE NOTICE 'Search for an already matching row returned %', mbe_id;
            IF mbe_id IS NULL THEN
                EXECUTE $$
                INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value)
                    VALUES ($$ ||
                        quote_literal(ind_data.field) || $$, $$ ||
                        quote_literal(ind_data.source) || $$, $$ ||
                        quote_literal(ind_data.value) ||
                    $$);$$;
            END IF;
        END IF;

    END LOOP;

    IF NOT b_skip_search THEN
        PERFORM metabib.update_combined_index_vectors(bib_id);
    END IF;

    RETURN;
END;
$_X$;


ALTER FUNCTION metabib.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) OWNER TO postgres;

--
-- Name: reingest_metabib_full_rec(bigint); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION reingest_metabib_full_rec(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        DELETE FROM metabib.real_full_rec WHERE record = bib_id;
    END IF;
    INSERT INTO metabib.real_full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM biblio.flatten_marc( bib_id );

    RETURN;
END;
$$;


ALTER FUNCTION metabib.reingest_metabib_full_rec(bib_id bigint) OWNER TO postgres;

--
-- Name: remap_metarecord_for_bib(bigint, text); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    source_count    INT;
    old_mr          BIGINT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    deleted_mrs     BIGINT[];
BEGIN

    DELETE FROM metabib.metarecord_source_map WHERE source = bib_id; -- Rid ourselves of the search-estimate-killing linkage

    FOR tmp_mr IN SELECT  m.* FROM  metabib.metarecord m JOIN metabib.metarecord_source_map s ON (s.metarecord = m.id) WHERE s.source = bib_id LOOP

        IF old_mr IS NULL AND fp = tmp_mr.fingerprint THEN -- Find the first fingerprint-matching
            old_mr := tmp_mr.id;
        ELSE
            SELECT COUNT(*) INTO source_count FROM metabib.metarecord_source_map WHERE metarecord = tmp_mr.id;
            IF source_count = 0 THEN -- No other records
                deleted_mrs := ARRAY_APPEND(deleted_mrs, tmp_mr.id);
                DELETE FROM metabib.metarecord WHERE id = tmp_mr.id;
            END IF;
        END IF;

    END LOOP;

    IF old_mr IS NULL THEN -- we found no suitable, preexisting MR based on old source maps
        SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp; -- is there one for our current fingerprint?
        IF old_mr IS NULL THEN -- nope, create one and grab its id
            INSERT INTO metabib.metarecord ( fingerprint, master_record ) VALUES ( fp, bib_id );
            SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp;
        ELSE -- indeed there is. update it with a null cache and recalcualated master record
            UPDATE  metabib.metarecord
              SET   mods = NULL,
                    master_record = ( SELECT id FROM biblio.record_entry WHERE fingerprint = fp ORDER BY quality DESC LIMIT 1)
              WHERE id = old_mr;
        END IF;
    ELSE -- there was one we already attached to, update its mods cache and master_record
        UPDATE  metabib.metarecord
          SET   mods = NULL,
                master_record = ( SELECT id FROM biblio.record_entry WHERE fingerprint = fp ORDER BY quality DESC LIMIT 1)
          WHERE id = old_mr;
    END IF;

    INSERT INTO metabib.metarecord_source_map (metarecord, source) VALUES (old_mr, bib_id); -- new source mapping

    IF ARRAY_UPPER(deleted_mrs,1) > 0 THEN
        UPDATE action.hold_request SET target = old_mr WHERE target IN ( SELECT unnest(deleted_mrs) ) AND hold_type = 'M'; -- if we had to delete any MRs above, make sure their holds are moved
    END IF;

    RETURN old_mr;

END;
$$;


ALTER FUNCTION metabib.remap_metarecord_for_bib(bib_id bigint, fp text) OWNER TO postgres;

--
-- Name: search_class_to_registered_components(text); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION search_class_to_registered_components(search_class text) RETURNS SETOF record
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
    search_parts        TEXT[];
    field_name          TEXT;
    search_part_count   INTEGER;
    rec                 RECORD;
    registered_class    config.metabib_class%ROWTYPE;
    registered_alias    config.metabib_search_alias%ROWTYPE;
    registered_field    config.metabib_field%ROWTYPE;
BEGIN
    search_parts := REGEXP_SPLIT_TO_ARRAY(search_class, E'\\|');

    search_part_count := ARRAY_LENGTH(search_parts, 1);
    IF search_part_count = 0 THEN
        RETURN;
    ELSE
        SELECT INTO registered_class
            * FROM config.metabib_class WHERE name = search_parts[1];
        IF FOUND THEN
            IF search_part_count < 2 THEN   -- all fields
                rec := (registered_class.name, NULL::INTEGER);
                RETURN NEXT rec;
                RETURN; -- done
            END IF;
            FOR field_name IN SELECT *
                FROM UNNEST(search_parts[2:search_part_count]) LOOP
                SELECT INTO registered_field
                    * FROM config.metabib_field
                    WHERE name = field_name AND
                        field_class = registered_class.name;
                IF FOUND THEN
                    rec := (registered_class.name, registered_field.id);
                    RETURN NEXT rec;
                END IF;
            END LOOP;
        ELSE
            -- maybe we have an alias?
            SELECT INTO registered_alias
                * FROM config.metabib_search_alias WHERE alias=search_parts[1];
            IF NOT FOUND THEN
                RETURN;
            ELSE
                IF search_part_count < 2 THEN   -- return w/e the alias says
                    rec := (
                        registered_alias.field_class, registered_alias.field
                    );
                    RETURN NEXT rec;
                    RETURN; -- done
                ELSE
                    FOR field_name IN SELECT *
                        FROM UNNEST(search_parts[2:search_part_count]) LOOP
                        SELECT INTO registered_field
                            * FROM config.metabib_field
                            WHERE name = field_name AND
                                field_class = registered_alias.field_class;
                        IF FOUND THEN
                            rec := (
                                registered_alias.field_class,
                                registered_field.id
                            );
                            RETURN NEXT rec;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION metabib.search_class_to_registered_components(search_class text) OWNER TO postgres;

--
-- Name: suggest_browse_entries(text, text, text, integer, integer, integer); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) RETURNS TABLE(value text, field integer, buoyant_and_class_match boolean, field_match boolean, field_weight integer, rank real, buoyant boolean, match text)
    LANGUAGE plpgsql
    AS $_$
DECLARE
    prepared_query_texts    TEXT[];
    query                   TSQUERY;
    plain_query             TSQUERY;
    opac_visibility_join    TEXT;
    search_class_join       TEXT;
    r_fields                RECORD;
BEGIN
    prepared_query_texts := metabib.autosuggest_prepare_tsquery(raw_query_text);

    query := TO_TSQUERY('keyword', prepared_query_texts[1]);
    plain_query := TO_TSQUERY('keyword', prepared_query_texts[2]);

    visibility_org := NULLIF(visibility_org,-1);
    IF visibility_org IS NOT NULL THEN
        opac_visibility_join := '
    JOIN asset.opac_visible_copies aovc ON (
        aovc.record = x.source AND
        aovc.circ_lib IN (SELECT id FROM actor.org_unit_descendants($4))
    )';
    ELSE
        opac_visibility_join := '';
    END IF;

    -- The following determines whether we only provide suggestsons matching
    -- the user's selected search_class, or whether we show other suggestions
    -- too. The reason for MIN() is that for search_classes like
    -- 'title|proper|uniform' you would otherwise get multiple rows.  The
    -- implication is that if title as a class doesn't have restrict,
    -- nor does the proper field, but the uniform field does, you're going
    -- to get 'false' for your overall evaluation of 'should we restrict?'
    -- To invert that, change from MIN() to MAX().

    SELECT
        INTO r_fields
            MIN(cmc.restrict::INT) AS restrict_class,
            MIN(cmf.restrict::INT) AS restrict_field
        FROM metabib.search_class_to_registered_components(search_class)
            AS _registered (field_class TEXT, field INT)
        JOIN
            config.metabib_class cmc ON (cmc.name = _registered.field_class)
        LEFT JOIN
            config.metabib_field cmf ON (cmf.id = _registered.field);

    -- evaluate 'should we restrict?'
    IF r_fields.restrict_field::BOOL OR r_fields.restrict_class::BOOL THEN
        search_class_join := '
    JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            (_registered.field IS NULL AND
                _registered.field_class = cmf.field_class) OR
            (_registered.field = cmf.id)
        )
    ';
    ELSE
        search_class_join := '
    LEFT JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            _registered.field_class = cmc.name
        )
    ';
    END IF;

    RETURN QUERY EXECUTE '
SELECT  DISTINCT
        x.value,
        x.id,
        x.push,
        x.restrict,
        x.weight,
        x.ts_rank_cd,
        x.buoyant,
        TS_HEADLINE(value, $7, $3)
  FROM  (SELECT DISTINCT
                mbe.value,
                cmf.id,
                cmc.buoyant AND _registered.field_class IS NOT NULL AS push,
                _registered.field = cmf.id AS restrict,
                cmf.weight,
                TS_RANK_CD(mbe.index_vector, $1, $6),
                cmc.buoyant,
                mbedm.source
          FROM  metabib.browse_entry_def_map mbedm
                JOIN (SELECT * FROM metabib.browse_entry WHERE index_vector @@ $1 LIMIT 10000) mbe ON (mbe.id = mbedm.entry)
                JOIN config.metabib_field cmf ON (cmf.id = mbedm.def)
                JOIN config.metabib_class cmc ON (cmf.field_class = cmc.name)
                '  || search_class_join || '
          ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
          LIMIT 1000) AS x
        ' || opac_visibility_join || '
  ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
  LIMIT $5
'   -- sic, repeat the order by clause in the outer select too
    USING
        query, search_class, headline_opts,
        visibility_org, query_limit, normalization, plain_query
        ;

    -- sort order:
    --  buoyant AND chosen class = match class
    --  chosen field = match field
    --  field weight
    --  rank
    --  buoyancy
    --  value itself

END;
$_$;


ALTER FUNCTION metabib.suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) OWNER TO postgres;

--
-- Name: update_combined_index_vectors(bigint); Type: FUNCTION; Schema: metabib; Owner: postgres
--

CREATE FUNCTION update_combined_index_vectors(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM metabib.combined_keyword_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_title_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_author_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_subject_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_series_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_identifier_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id;

END;
$$;


ALTER FUNCTION metabib.update_combined_index_vectors(bib_id bigint) OWNER TO postgres;

SET search_path = money, pg_catalog;

--
-- Name: mat_summary_create(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION mat_summary_create() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	INSERT INTO money.materialized_billable_xact_summary (id, usr, xact_start, xact_finish, total_paid, total_owed, balance_owed, xact_type)
		VALUES ( NEW.id, NEW.usr, NEW.xact_start, NEW.xact_finish, 0.0, 0.0, 0.0, TG_ARGV[0]);
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_create() OWNER TO postgres;

--
-- Name: mat_summary_delete(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION mat_summary_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	DELETE FROM money.materialized_billable_xact_summary WHERE id = OLD.id;
	RETURN OLD;
END;
$$;


ALTER FUNCTION money.mat_summary_delete() OWNER TO postgres;

--
-- Name: mat_summary_update(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION mat_summary_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE	money.materialized_billable_xact_summary
	  SET	usr = NEW.usr,
		xact_start = NEW.xact_start,
		xact_finish = NEW.xact_finish
	  WHERE	id = NEW.id;
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_update() OWNER TO postgres;

--
-- Name: materialized_summary_billing_add(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_billing_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = COALESCE(total_owed, 0.0::numeric) + NEW.amount,
			last_billing_ts = NEW.billing_ts,
			last_billing_note = NEW.note,
			last_billing_type = NEW.billing_type,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_add() OWNER TO postgres;

--
-- Name: materialized_summary_billing_del(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_billing_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	prev_billing	money.billing%ROWTYPE;
	old_billing	money.billing%ROWTYPE;
BEGIN
	SELECT * INTO prev_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1 OFFSET 1;
	SELECT * INTO old_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;

	IF OLD.id = old_billing.id THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	last_billing_ts = prev_billing.billing_ts,
			last_billing_note = prev_billing.note,
			last_billing_type = prev_billing.billing_type
		  WHERE	id = OLD.xact;
	END IF;

	IF NOT OLD.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - OLD.amount,
			balance_owed = balance_owed + OLD.amount
		  WHERE	id = OLD.xact;
	END IF;

	RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_del() OWNER TO postgres;

--
-- Name: materialized_summary_billing_update(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_billing_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_billing	money.billing%ROWTYPE;
	old_voided	money.billing%ROWTYPE;
BEGIN

	SELECT * INTO old_billing FROM money.billing WHERE xact = NEW.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.billing WHERE xact = NEW.xact ORDER BY billing_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_billing.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed + NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - (OLD.amount - NEW.amount),
			balance_owed = balance_owed - (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_update() OWNER TO postgres;

--
-- Name: materialized_summary_payment_add(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_payment_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = COALESCE(total_paid, 0.0::numeric) + NEW.amount,
			last_payment_ts = NEW.payment_ts,
			last_payment_note = NEW.note,
			last_payment_type = TG_ARGV[0],
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_add() OWNER TO postgres;

--
-- Name: materialized_summary_payment_del(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_payment_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	prev_payment	money.payment_view%ROWTYPE;
	old_payment	money.payment_view%ROWTYPE;
BEGIN
	SELECT * INTO prev_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1 OFFSET 1;
	SELECT * INTO old_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;

	IF OLD.id = old_payment.id THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	last_payment_ts = prev_payment.payment_ts,
			last_payment_note = prev_payment.note,
			last_payment_type = prev_payment.payment_type
		  WHERE	id = OLD.xact;
	END IF;

	IF NOT OLD.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - OLD.amount,
			balance_owed = balance_owed + OLD.amount
		  WHERE	id = OLD.xact;
	END IF;

	RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_del() OWNER TO postgres;

--
-- Name: materialized_summary_payment_update(); Type: FUNCTION; Schema: money; Owner: postgres
--

CREATE FUNCTION materialized_summary_payment_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_payment	money.payment_view%ROWTYPE;
	old_voided	money.payment_view%ROWTYPE;
BEGIN

	SELECT * INTO old_payment FROM money.payment_view WHERE xact = NEW.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.payment_view WHERE xact = NEW.xact ORDER BY payment_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_payment.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid + NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - (OLD.amount - NEW.amount),
			balance_owed = balance_owed + (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_update() OWNER TO postgres;

SET search_path = permission, pg_catalog;

--
-- Name: grp_tree; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE grp_tree (
    id integer NOT NULL,
    name text NOT NULL,
    parent integer,
    usergroup boolean DEFAULT true NOT NULL,
    perm_interval interval DEFAULT '3 years'::interval NOT NULL,
    description text,
    application_perm text,
    hold_priority integer DEFAULT 0 NOT NULL
);


ALTER TABLE permission.grp_tree OWNER TO postgres;

--
-- Name: grp_ancestors(integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION grp_ancestors(integer) RETURNS SETOF grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	a.*
	FROM	connectby('permission.grp_tree'::text,'parent'::text,'id'::text,'name'::text,$1::text,100,'.'::text)
			AS t(keyid text, parent_keyid text, level int, branch text,pos int)
		JOIN permission.grp_tree a ON a.id::text = t.keyid::text
	ORDER BY
		CASE WHEN a.parent IS NULL
			THEN 0
			ELSE 1
		END, a.name;
$_$;


ALTER FUNCTION permission.grp_ancestors(integer) OWNER TO postgres;

--
-- Name: grp_ancestors_distance(integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION grp_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.parent, gad.distance+1
            FROM permission.grp_tree pgt JOIN grp_ancestors_distance gad ON (pgt.id = gad.id)
            WHERE pgt.parent IS NOT NULL
    )
    SELECT * FROM grp_ancestors_distance;
$_$;


ALTER FUNCTION permission.grp_ancestors_distance(integer) OWNER TO postgres;

--
-- Name: grp_descendants_distance(integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION grp_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.id, gdd.distance+1
            FROM permission.grp_tree pgt JOIN grp_descendants_distance gdd ON (pgt.parent = gdd.id)
    )
    SELECT * FROM grp_descendants_distance;
$_$;


ALTER FUNCTION permission.grp_descendants_distance(integer) OWNER TO postgres;

--
-- Name: usr_can_grant_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_can_grant_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	(l.code = tperm AND p.grantable IS TRUE)
		LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_can_grant_perm(iuser integer, tperm text, target_ou integer) OWNER TO postgres;

--
-- Name: usr_has_home_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_home_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1 LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_home_perm(iuser integer, tperm text, target_ou integer) OWNER TO postgres;

--
-- Name: usr_has_object_perm(integer, text, text, text); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_object_perm(integer, text, text, text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT permission.usr_has_object_perm( $1, $2, $3, $4, -1 );
$_$;


ALTER FUNCTION permission.usr_has_object_perm(integer, text, text, text) OWNER TO postgres;

--
-- Name: usr_has_object_perm(integer, text, text, text, integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	res     BOOL;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	SELECT TRUE INTO res FROM permission.usr_object_perm_map WHERE usr = r_usr.id AND object_type = obj_type AND object_id = obj_id;

	IF FOUND THEN
		RETURN TRUE;
	END IF;

	IF target_ou > -1 THEN
		RETURN permission.usr_has_perm( iuser, tperm, target_ou);
	END IF;

	RETURN FALSE;

END;
$$;


ALTER FUNCTION permission.usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) OWNER TO postgres;

--
-- Name: usr_has_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_perm(integer, text, integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
	SELECT	CASE
			WHEN permission.usr_has_home_perm( $1, $2, $3 ) THEN TRUE
			WHEN permission.usr_has_work_perm( $1, $2, $3 ) THEN TRUE
			ELSE FALSE
		END;
$_$;


ALTER FUNCTION permission.usr_has_perm(integer, text, integer) OWNER TO postgres;

--
-- Name: usr_has_perm_at(integer, text); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_perm_at(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at(user_id integer, perm_code text) OWNER TO postgres;

--
-- Name: usr_has_perm_at_all(integer, text); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_perm_at_all(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_all_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at_all(user_id integer, perm_code text) OWNER TO postgres;

--
-- Name: usr_has_perm_at_all_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_perm_at_all_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted either directly or through inheritance from a parent
-- org unit.
--
-- The permissions apply to a minimum depth of the org unit hierarchy, and
-- to the subordinates of those org units, for the org unit(s) to which the
-- user is assigned.
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- assigns users to org units.  I.e. we ignore the home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	n_head_ou     INTEGER;
	n_child_ou    INTEGER;
BEGIN
	FOR n_head_ou IN
		SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( user_id, perm_code )
	LOOP
		--
		-- The permission applies only at a depth greater than the work org unit.
		-- Use connectby() to find all dependent org units at the specified depth.
		--
		FOR n_child_ou IN
			SELECT ou::INTEGER
			FROM connectby( 
					'actor.org_unit',   -- table name
					'id',               -- key column
					'parent_ou',        -- recursive foreign key
					n_head_ou::TEXT,    -- id of starting point
					0                   -- no limit on search depth
				)
				AS t(
					ou text,            -- dependent org unit
					parent_ou text,     -- (ignore)
					level int           -- (ignore)
				)
		LOOP
			RETURN NEXT n_child_ou;
		END LOOP;
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_all_nd(user_id integer, perm_code text) OWNER TO postgres;

--
-- Name: usr_has_perm_at_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_perm_at_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted directly (not through inheritance from a parent
-- org unit).
--
-- The permissions apply to a minimum depth of the org unit hierarchy,
-- for the org unit(s) to which the user is assigned.  (They also apply
-- to the subordinates of those org units, but we don't report the
-- subordinates here.)
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- defines which users belong to which org units.  I.e. we ignore the
-- home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	b_super       BOOLEAN;
	n_perm        INTEGER;
	n_min_depth   INTEGER; 
	n_work_ou     INTEGER;
	n_curr_ou     INTEGER;
	n_depth       INTEGER;
	n_curr_depth  INTEGER;
BEGIN
	--
	-- Check for superuser
	--
	SELECT INTO b_super
		super_user
	FROM
		actor.usr
	WHERE
		id = user_id;
	--
	IF NOT FOUND THEN
		return;				-- No user?  No permissions.
	ELSIF b_super THEN
		--
		-- Super user has all permissions everywhere
		--
		FOR n_work_ou IN
			SELECT
				id
			FROM
				actor.org_unit
			WHERE
				parent_ou IS NULL
		LOOP
			RETURN NEXT n_work_ou; 
		END LOOP;
		RETURN;
	END IF;
	--
	-- Translate the permission name
	-- to a numeric permission id
	--
	SELECT INTO n_perm
		id
	FROM
		permission.perm_list
	WHERE
		code = perm_code;
	--
	IF NOT FOUND THEN
		RETURN;               -- No such permission
	END IF;
	--
	-- Find the highest-level org unit (i.e. the minimum depth)
	-- to which the permission is applied for this user
	--
	-- This query is modified from the one in permission.usr_perms().
	--
	SELECT INTO n_min_depth
		min( depth )
	FROM	(
		SELECT depth 
		  FROM permission.usr_perm_map upm
		 WHERE upm.usr = user_id 
		   AND (upm.perm = n_perm OR upm.perm = -1)
       				UNION
		SELECT	gpm.depth
		  FROM	permission.grp_perm_map gpm
		  WHERE	(gpm.perm = n_perm OR gpm.perm = -1)
	        AND gpm.grp IN (
	 		   SELECT	(permission.grp_ancestors(
					(SELECT profile FROM actor.usr WHERE id = user_id)
				)).id
			)
       				UNION
		SELECT	p.depth
		  FROM	permission.grp_perm_map p 
		  WHERE (p.perm = n_perm OR p.perm = -1)
		    AND p.grp IN (
		  		SELECT (permission.grp_ancestors(m.grp)).id 
				FROM   permission.usr_grp_map m
				WHERE  m.usr = user_id
			)
	) AS x;
	--
	IF NOT FOUND THEN
		RETURN;                -- No such permission for this user
	END IF;
	--
	-- Identify the org units to which the user is assigned.  Note that
	-- we pay no attention to the home_ou column in actor.usr.
	--
	FOR n_work_ou IN
		SELECT
			work_ou
		FROM
			permission.usr_work_ou_map
		WHERE
			usr = user_id
	LOOP            -- For each org unit to which the user is assigned
		--
		-- Determine the level of the org unit by a lookup in actor.org_unit_type.
		-- We take it on faith that this depth agrees with the actual hierarchy
		-- defined in actor.org_unit.
		--
		SELECT INTO n_depth
		    type.depth
		FROM
		    actor.org_unit_type type
		        INNER JOIN actor.org_unit ou
		            ON ( ou.ou_type = type.id )
		WHERE
		    ou.id = n_work_ou;
		--
		IF NOT FOUND THEN
			CONTINUE;        -- Maybe raise exception?
		END IF;
		--
		-- Compare the depth of the work org unit to the
		-- minimum depth, and branch accordingly
		--
		IF n_depth = n_min_depth THEN
			--
			-- The org unit is at the right depth, so return it.
			--
			RETURN NEXT n_work_ou;
		ELSIF n_depth > n_min_depth THEN
			--
			-- Traverse the org unit tree toward the root,
			-- until you reach the minimum depth determined above
			--
			n_curr_depth := n_depth;
			n_curr_ou := n_work_ou;
			WHILE n_curr_depth > n_min_depth LOOP
				SELECT INTO n_curr_ou
					parent_ou
				FROM
					actor.org_unit
				WHERE
					id = n_curr_ou;
				--
				IF FOUND THEN
					n_curr_depth := n_curr_depth - 1;
				ELSE
					--
					-- This can happen only if the hierarchy defined in
					-- actor.org_unit is corrupted, or out of sync with
					-- the depths defined in actor.org_unit_type.
					-- Maybe we should raise an exception here, instead
					-- of silently ignoring the problem.
					--
					n_curr_ou = NULL;
					EXIT;
				END IF;
			END LOOP;
			--
			IF n_curr_ou IS NOT NULL THEN
				RETURN NEXT n_curr_ou;
			END IF;
		ELSE
			--
			-- The permission applies only at a depth greater than the work org unit.
			-- Use connectby() to find all dependent org units at the specified depth.
			--
			FOR n_curr_ou IN
				SELECT ou::INTEGER
				FROM connectby( 
						'actor.org_unit',         -- table name
						'id',                     -- key column
						'parent_ou',              -- recursive foreign key
						n_work_ou::TEXT,          -- id of starting point
						(n_min_depth - n_depth)   -- max depth to search, relative
					)                             --   to starting point
					AS t(
						ou text,            -- dependent org unit
						parent_ou text,     -- (ignore)
						level int           -- depth relative to starting point
					)
				WHERE
					level = n_min_depth - n_depth
			LOOP
				RETURN NEXT n_curr_ou;
			END LOOP;
		END IF;
		--
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_nd(user_id integer, perm_code text) OWNER TO postgres;

--
-- Name: usr_has_work_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_has_work_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_woum	permission.usr_work_ou_map%ROWTYPE;
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1
		LOOP

		FOR r_woum IN	SELECT	*
				  FROM	permission.usr_work_ou_map
				  WHERE	usr = iuser
			LOOP

			PERFORM	*
			  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
			  WHERE	id = r_woum.work_ou;

			IF FOUND THEN
				RETURN TRUE;
			END IF;

		END LOOP;

	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_work_perm(iuser integer, tperm text, target_ou integer) OWNER TO postgres;

--
-- Name: usr_perm_map; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_perm_map OWNER TO postgres;

--
-- Name: usr_perms(integer); Type: FUNCTION; Schema: permission; Owner: postgres
--

CREATE FUNCTION usr_perms(integer) RETURNS SETOF usr_perm_map
    LANGUAGE sql STABLE ROWS 10
    AS $_$
	SELECT	DISTINCT ON (usr,perm) *
	  FROM	(
			(SELECT * FROM permission.usr_perm_map WHERE usr = $1)
        				UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p
			  WHERE	p.grp IN (
			  	SELECT	(permission.grp_ancestors(
						(SELECT profile FROM actor.usr WHERE id = $1)
					)).id
				)
			)
        				UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p 
			  WHERE	p.grp IN (SELECT (permission.grp_ancestors(m.grp)).id FROM permission.usr_grp_map m WHERE usr = $1))
		) AS x
	  ORDER BY 2, 3, 1 DESC, 5 DESC ;
$_$;


ALTER FUNCTION permission.usr_perms(integer) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: approximate_date(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION approximate_date(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'\\D', $2, 'g' );
$_$;


ALTER FUNCTION public.approximate_date(text, text) OWNER TO postgres;

--
-- Name: approximate_high_date(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION approximate_high_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '9');
$_$;


ALTER FUNCTION public.approximate_high_date(text) OWNER TO postgres;

--
-- Name: approximate_low_date(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION approximate_low_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '0');
$_$;


ALTER FUNCTION public.approximate_low_date(text) OWNER TO postgres;

--
-- Name: call_number_dewey(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION call_number_dewey(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
	my $txt = shift;
	$txt =~ s/^\s+//o;
	$txt =~ s/[\[\]\{\}\(\)`'"#<>\*\?\-\+\$\\]+//og;
	$txt =~ s/\s+$//o;
	if ($txt =~ /(\d{3}(?:\.\d+)?)/o) {
		return $1;
	} else {
		return (split /\s+/, $txt)[0];
	}
$_$;


ALTER FUNCTION public.call_number_dewey(text) OWNER TO postgres;

--
-- Name: call_number_dewey(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION call_number_dewey(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT SUBSTRING(call_number_dewey($1) FROM 1 FOR $2);
$_$;


ALTER FUNCTION public.call_number_dewey(text, integer) OWNER TO postgres;

--
-- Name: cleanup_acq_marc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cleanup_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		DELETE FROM acq.lineitem_attr
	    		WHERE lineitem = OLD.id AND attr_type IN ('lineitem_provider_attr_definition', 'lineitem_marc_attr_definition','lineitem_generated_attr_definition');
		RETURN NEW;
	ELSE
		DELETE FROM acq.lineitem_attr WHERE lineitem = OLD.id;
		RETURN OLD;
	END IF;
END;
$$;


ALTER FUNCTION public.cleanup_acq_marc() OWNER TO postgres;

--
-- Name: content_or_null(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION content_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\s*$' THEN NULL ELSE $1 END
$_$;


ALTER FUNCTION public.content_or_null(text) OWNER TO postgres;

--
-- Name: entityize(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION entityize(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFC(shift);
    $x =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;
    return $x;

$_$;


ALTER FUNCTION public.entityize(text) OWNER TO postgres;

--
-- Name: extract_acq_marc_field(bigint, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION extract_acq_marc_field(bigint, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
	SELECT extract_marc_field('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field(bigint, text, text) OWNER TO postgres;

--
-- Name: extract_acq_marc_field_set(bigint, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION extract_acq_marc_field_set(bigint, text, text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
	SELECT extract_marc_field_set('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field_set(bigint, text, text) OWNER TO postgres;

--
-- Name: first5(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION first5(text) RETURNS text
    LANGUAGE sql
    AS $_$
	SELECT SUBSTRING( $1, 1, 5);
$_$;


ALTER FUNCTION public.first5(text) OWNER TO postgres;

--
-- Name: first_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION first_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT CASE WHEN $1 IS NULL THEN $2 ELSE $1 END;
$_$;


ALTER FUNCTION public.first_agg(anyelement, anyelement) OWNER TO postgres;

--
-- Name: first_word(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION first_word(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_X$
        SELECT COALESCE(SUBSTRING( $1 FROM $_$^\S+$_$), '');
$_X$;


ALTER FUNCTION public.first_word(text) OWNER TO postgres;

--
-- Name: force_to_isbn13(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_to_isbn13(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # Find the first ISBN, force it to ISBN13 and return it

    my $input = shift;

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, force it to ISBN13 and return it
        return $isbn->as_isbn13->isbn if ($isbn && $isbn->is_valid());
    }
    return undef;
$_$;


ALTER FUNCTION public.force_to_isbn13(text) OWNER TO postgres;

--
-- Name: FUNCTION force_to_isbn13(text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION force_to_isbn13(text) IS '
Inspired by translate_isbn1013

The force_to_isbn13 function takes an input ISBN and returns the ISBN13
version without hypens and with a repaired checksum if the checksum was bad
';


--
-- Name: ingest_acq_marc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ingest_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
	value		TEXT;
	atype		TEXT;
	prov		INT;
	pos 		INT;
	adef		RECORD;
	xpath_string	TEXT;
BEGIN
	FOR adef IN SELECT *,tableoid FROM acq.lineitem_attr_definition LOOP

		SELECT relname::TEXT INTO atype FROM pg_class WHERE oid = adef.tableoid;

		IF (atype NOT IN ('lineitem_usr_attr_definition','lineitem_local_attr_definition')) THEN
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT provider INTO prov FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
				CONTINUE WHEN NEW.provider IS NULL OR prov <> NEW.provider;
			END IF;
			
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_marc_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_marc_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_generated_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_generated_attr_definition WHERE id = adef.id;
			END IF;

            xpath_string := REGEXP_REPLACE(xpath_string,$re$//?text\(\)$$re$,'');

            IF (adef.code = 'title' OR adef.code = 'author') THEN
                -- title and author should not be split
                -- FIXME: once oils_xpath can grok XPATH 2.0 functions, we can use
                -- string-join in the xpath and remove this special case
    			SELECT extract_acq_marc_field(id, xpath_string, adef.remove) INTO value FROM acq.lineitem WHERE id = NEW.id;
    			IF (value IS NOT NULL AND value <> '') THEN
				    INSERT INTO acq.lineitem_attr (lineitem, definition, attr_type, attr_name, attr_value)
	     			    VALUES (NEW.id, adef.id, atype, adef.code, value);
                END IF;
            ELSE
                pos := 1;
                LOOP
                    -- each application of the regex may produce multiple values
                    FOR value IN
                        SELECT * FROM extract_acq_marc_field_set(
                            NEW.id, xpath_string || '[' || pos || ']', adef.remove)
                        LOOP

                        IF (value IS NOT NULL AND value <> '') THEN
                            INSERT INTO acq.lineitem_attr
                                (lineitem, definition, attr_type, attr_name, attr_value)
                                VALUES (NEW.id, adef.id, atype, adef.code, value);
                        ELSE
                            EXIT;
                        END IF;
                    END LOOP;
                    IF NOT FOUND THEN
                        EXIT;
                    END IF;
                    pos := pos + 1;
               END LOOP;
            END IF;

		END IF;

	END LOOP;

	RETURN NULL;
END;
$_$;


ALTER FUNCTION public.ingest_acq_marc() OWNER TO postgres;

--
-- Name: integer_or_null(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION integer_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\d+$' THEN $1 ELSE NULL END
$_$;


ALTER FUNCTION public.integer_or_null(text) OWNER TO postgres;

--
-- Name: last_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION last_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT $2;
$_$;


ALTER FUNCTION public.last_agg(anyelement, anyelement) OWNER TO postgres;

--
-- Name: left_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION left_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,$2);
$_$;


ALTER FUNCTION public.left_trunc(text, integer) OWNER TO postgres;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION public.lowercase(text) OWNER TO postgres;

--
-- Name: naco_normalize(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION naco_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.naco_normalize($1,'');
$_$;


ALTER FUNCTION public.naco_normalize(text) OWNER TO postgres;

--
-- Name: naco_normalize(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION naco_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # http://www.loc.gov/catdir/pcc/naco/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett (ß) and certain ligatures (ﬀ, ﬁ, ﬄ, etc.) will be handled correctly.
    # If there are any bugs in Perl's implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}]['/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

	if ($sf && $sf =~ /^a/o) {
		my $commapos = index($str, ',');
		if ($commapos > -1) {
			if ($commapos != length($str) - 1) {
                $str =~ s/,/\x07/; # preserve first comma
			}
		}
	}

    # since we've stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that's fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

    return lc $str;
$_$;


ALTER FUNCTION public.naco_normalize(text, text) OWNER TO postgres;

--
-- Name: naco_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION naco_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.naco_normalize($1,'a');
$_$;


ALTER FUNCTION public.naco_normalize_keep_comma(text) OWNER TO postgres;

--
-- Name: non_filing_normalize(text, "char"); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION non_filing_normalize(text, "char") RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT  SUBSTRING(
                        REGEXP_REPLACE(
                                REGEXP_REPLACE(
                                        $1,
                                        E'\W*$',
					''
				),
                                '  ',
                                ' '
                        ),
                        CASE
				WHEN $2::INT NOT BETWEEN 48 AND 57 THEN 1
				ELSE $2::TEXT::INT + 1
			END
		);
$_$;


ALTER FUNCTION public.non_filing_normalize(text, "char") OWNER TO postgres;

--
-- Name: normalize_space(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION normalize_space(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(regexp_replace(regexp_replace($1, E'\\n', ' ', 'g'), E'(?:^\\s+)|(\\s+$)', '', 'g'), E'\\s+', ' ', 'g');
$_$;


ALTER FUNCTION public.normalize_space(text) OWNER TO postgres;

--
-- Name: oils_tsearch2(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION oils_tsearch2() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    normalizer      RECORD;
    value           TEXT := '';
    temp_vector     TEXT := '';
    ts_rec          RECORD;
    cur_weight      "char";
BEGIN

    value := NEW.value;
    NEW.index_vector = ''::tsvector;

    IF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos < 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;

        NEW.value = value;

        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos >= 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;
   END IF;

    IF TG_TABLE_NAME::TEXT ~ 'browse_entry$' THEN
        value :=  ARRAY_TO_STRING(
            evergreen.regexp_split_to_array(value, E'\\W+'), ' '
        );
        value := public.search_normalize(value);
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);
    ELSIF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR ts_rec IN
            SELECT ts_config, index_weight
            FROM config.metabib_class_ts_map
            WHERE field_class = TG_ARGV[0]
                AND index_lang IS NULL OR EXISTS (SELECT 1 FROM metabib.record_attr WHERE id = NEW.source AND index_lang IN(attrs->'item_lang',attrs->'language'))
                AND always OR NOT EXISTS (SELECT 1 FROM config.metabib_field_ts_map WHERE metabib_field = NEW.field)
            UNION
            SELECT ts_config, index_weight
            FROM config.metabib_field_ts_map
            WHERE metabib_field = NEW.field
               AND index_lang IS NULL OR EXISTS (SELECT 1 FROM metabib.record_attr WHERE id = NEW.source AND index_lang IN(attrs->'item_lang',attrs->'language'))
            ORDER BY index_weight ASC
        LOOP
            IF cur_weight IS NOT NULL AND cur_weight != ts_rec.index_weight THEN
                NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
                temp_vector = '';
            END IF;
            cur_weight = ts_rec.index_weight;
            SELECT INTO temp_vector temp_vector || ' ' || to_tsvector(ts_rec.ts_config::regconfig, value)::TEXT;
        END LOOP;
        NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
    ELSE
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION public.oils_tsearch2() OWNER TO postgres;

--
-- Name: remove_commas(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION remove_commas(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, ',', '', 'g');
$_$;


ALTER FUNCTION public.remove_commas(text) OWNER TO postgres;

--
-- Name: remove_diacritics(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION remove_diacritics(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFD(shift);
    $x =~ s/\pM+//go;
    return $x;

$_$;


ALTER FUNCTION public.remove_diacritics(text) OWNER TO postgres;

--
-- Name: remove_paren_substring(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION remove_paren_substring(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, $$\([^)]+\)$$, '', 'g');
$_$;


ALTER FUNCTION public.remove_paren_substring(text) OWNER TO postgres;

--
-- Name: remove_whitespace(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION remove_whitespace(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(normalize_space($1), E'\\s+', '', 'g');
$_$;


ALTER FUNCTION public.remove_whitespace(text) OWNER TO postgres;

--
-- Name: right_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION right_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,1,$2);
$_$;


ALTER FUNCTION public.right_trunc(text, integer) OWNER TO postgres;

--
-- Name: search_normalize(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION search_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.search_normalize($1,'');
$_$;


ALTER FUNCTION public.search_normalize(text) OWNER TO postgres;

--
-- Name: search_normalize(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION search_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # http://www.loc.gov/catdir/pcc/naco/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett (ß) and certain ligatures (ﬀ, ﬁ, ﬄ, etc.) will be handled correctly.
    # If there are any bugs in Perl's implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}][/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

	if ($sf && $sf =~ /^a/o) {
		my $commapos = index($str, ',');
		if ($commapos > -1) {
			if ($commapos != length($str) - 1) {
                $str =~ s/,/\x07/; # preserve first comma
			}
		}
	}

    # since we've stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that's fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

    return lc $str;
$_$;


ALTER FUNCTION public.search_normalize(text, text) OWNER TO postgres;

--
-- Name: search_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION search_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.search_normalize($1,'a');
$_$;


ALTER FUNCTION public.search_normalize_keep_comma(text) OWNER TO postgres;

--
-- Name: split_date_range(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION split_date_range(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'(\\d{4})-(\\d{4})', E'\\1 \\2', 'g' );
$_$;


ALTER FUNCTION public.split_date_range(text) OWNER TO postgres;

--
-- Name: tableoid2name(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tableoid2name(oid) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		RETURN $1::regclass;
	END;
$_$;


ALTER FUNCTION public.tableoid2name(oid) OWNER TO postgres;

--
-- Name: text_concat(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text_concat(text, text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
SELECT
	CASE	WHEN $1 IS NULL
			THEN $2
		WHEN $2 IS NULL
			THEN $1
		ELSE $1 || ' ' || $2
	END;
$_$;


ALTER FUNCTION public.text_concat(text, text) OWNER TO postgres;

--
-- Name: translate_isbn1013(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION translate_isbn1013(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # For each ISBN found in a single string containing a set of ISBNs:
    #   * Normalize an incoming ISBN to have the correct checksum and no hyphens
    #   * Convert an incoming ISBN10 or ISBN13 to its counterpart and return

    my $input = shift;
    my $output = '';

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $output .= $isbn->isbn() . " ";
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, convert it to its counterpart ISBN10/ISBN13
        # and add the normalized original ISBN to the output
        if ($isbn && $isbn->is_valid()) {
            my $isbn_xlated = ($isbn->type eq "ISBN13") ? $isbn->as_isbn10 : $isbn->as_isbn13;
            $output .= $isbn->isbn . " ";

            # If we successfully converted the ISBN to its counterpart, add the
            # converted ISBN to the output as well
            $output .= ($isbn_xlated->isbn . " ") if ($isbn_xlated);
        }
    }
    return $output if $output;

    # If there were no valid ISBNs, just return the raw input
    return $input;
$_$;


ALTER FUNCTION public.translate_isbn1013(text) OWNER TO postgres;

--
-- Name: FUNCTION translate_isbn1013(text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION translate_isbn1013(text) IS '
The translate_isbn1013 function takes an input ISBN and returns the
following in a single space-delimited string if the input ISBN is valid:
  - The normalized input ISBN (hyphens stripped)
  - The normalized input ISBN with a fixed checksum if the checksum was bad
  - The ISBN converted to its ISBN10 or ISBN13 counterpart, if possible
';


--
-- Name: uppercase(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION uppercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return uc(shift);
$$;


ALTER FUNCTION public.uppercase(text) OWNER TO postgres;

SET search_path = reporter, pg_catalog;

--
-- Name: disable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION disable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$
    DROP TRIGGER IF EXISTS bbb_simple_rec_trigger ON biblio.record_entry;
$$;


ALTER FUNCTION reporter.disable_materialized_simple_record_trigger() OWNER TO postgres;

--
-- Name: enable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION enable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$

    DELETE FROM reporter.materialized_simple_record;

    INSERT INTO reporter.materialized_simple_record
        (id,fingerprint,quality,tcn_source,tcn_value,title,author,publisher,pubdate,isbn,issn)
        SELECT DISTINCT ON (id) * FROM reporter.old_super_simple_record;

    CREATE TRIGGER bbb_simple_rec_trigger
        AFTER INSERT OR UPDATE OR DELETE ON biblio.record_entry
        FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();

$$;


ALTER FUNCTION reporter.enable_materialized_simple_record_trigger() OWNER TO postgres;

--
-- Name: refresh_materialized_simple_record(); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION refresh_materialized_simple_record() RETURNS void
    LANGUAGE sql
    AS $$
    SELECT reporter.disable_materialized_simple_record_trigger();
    SELECT reporter.enable_materialized_simple_record_trigger();
$$;


ALTER FUNCTION reporter.refresh_materialized_simple_record() OWNER TO postgres;

--
-- Name: simple_rec_delete(bigint); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION simple_rec_delete(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, TRUE);
$_$;


ALTER FUNCTION reporter.simple_rec_delete(r_id bigint) OWNER TO postgres;

--
-- Name: simple_rec_trigger(); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION simple_rec_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM reporter.simple_rec_delete(NEW.id);
    ELSE
        PERFORM reporter.simple_rec_update(NEW.id);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION reporter.simple_rec_trigger() OWNER TO postgres;

--
-- Name: simple_rec_update(bigint); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION simple_rec_update(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, FALSE);
$_$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint) OWNER TO postgres;

--
-- Name: simple_rec_update(bigint, boolean); Type: FUNCTION; Schema: reporter; Owner: postgres
--

CREATE FUNCTION simple_rec_update(r_id bigint, deleted boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

    DELETE FROM reporter.materialized_simple_record WHERE id = r_id;

    IF NOT deleted THEN
        INSERT INTO reporter.materialized_simple_record SELECT DISTINCT ON (id) * FROM reporter.old_super_simple_record WHERE id = r_id;
    END IF;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint, deleted boolean) OWNER TO postgres;

SET search_path = search, pg_catalog;

--
-- Name: query_parser_fts(integer, integer, text, integer[], integer[], integer, integer, integer, boolean, boolean, boolean, integer); Type: FUNCTION; Schema: search; Owner: postgres
--

CREATE FUNCTION query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, deleted_search boolean, param_pref_ou integer DEFAULT NULL::integer) RETURNS SETOF search_result
    LANGUAGE plpgsql
    AS $$
DECLARE

    current_res         search.search_result%ROWTYPE;
    search_org_list     INT[];
    luri_org_list       INT[];
    tmp_int_list        INT[];

    check_limit         INT;
    core_limit          INT;
    core_offset         INT;
    tmp_int             INT;

    core_result         RECORD;
    core_cursor         REFCURSOR;
    core_rel_query      TEXT;

    total_count         INT := 0;
    check_count         INT := 0;
    deleted_count       INT := 0;
    visible_count       INT := 0;
    excluded_count      INT := 0;

BEGIN

    check_limit := COALESCE( param_check, 1000 );
    core_limit  := COALESCE( param_limit, 25000 );
    core_offset := COALESCE( param_offset, 0 );

    -- core_skip_chk := COALESCE( param_skip_chk, 1 );

    IF param_search_ou > 0 THEN
        IF param_depth IS NOT NULL THEN
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou, param_depth );
        ELSE
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou );
        END IF;

        SELECT array_accum(distinct id) INTO luri_org_list FROM actor.org_unit_ancestors( param_search_ou );

    ELSIF param_search_ou < 0 THEN
        SELECT array_accum(distinct org_unit) INTO search_org_list FROM actor.org_lasso_map WHERE lasso = -param_search_ou;

        FOR tmp_int IN SELECT * FROM UNNEST(search_org_list) LOOP
            SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors( tmp_int );
            luri_org_list := luri_org_list || tmp_int_list;
        END LOOP;

        SELECT array_accum(DISTINCT x.id) INTO luri_org_list FROM UNNEST(luri_org_list) x(id);

    ELSIF param_search_ou = 0 THEN
        -- reserved for user lassos (ou_buckets/type='lasso') with ID passed in depth ... hack? sure.
    END IF;

    IF param_pref_ou IS NOT NULL THEN
        SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors(param_pref_ou);
        luri_org_list := luri_org_list || tmp_int_list;
    END IF;

    OPEN core_cursor FOR EXECUTE param_query;

    LOOP

        FETCH core_cursor INTO core_result;
        EXIT WHEN NOT FOUND;
        EXIT WHEN total_count >= core_limit;

        total_count := total_count + 1;

        CONTINUE WHEN total_count NOT BETWEEN  core_offset + 1 AND check_limit + core_offset;

        check_count := check_count + 1;

        IF NOT deleted_search THEN

            PERFORM 1 FROM biblio.record_entry b WHERE NOT b.deleted AND b.id IN ( SELECT * FROM unnest( core_result.records ) );
            IF NOT FOUND THEN
                -- RAISE NOTICE ' % were all deleted ... ', core_result.records;
                deleted_count := deleted_count + 1;
                CONTINUE;
            END IF;

            PERFORM 1
              FROM  biblio.record_entry b
                    JOIN config.bib_source s ON (b.source = s.id)
              WHERE s.transcendant
                    AND b.id IN ( SELECT * FROM unnest( core_result.records ) );

            IF FOUND THEN
                -- RAISE NOTICE ' % were all transcendant ... ', core_result.records;
                visible_count := visible_count + 1;

                current_res.id = core_result.id;
                current_res.rel = core_result.rel;

                tmp_int := 1;
                IF metarecord THEN
                    SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
                END IF;

                IF tmp_int = 1 THEN
                    current_res.record = core_result.records[1];
                ELSE
                    current_res.record = NULL;
                END IF;

                RETURN NEXT current_res;

                CONTINUE;
            END IF;

            PERFORM 1
              FROM  asset.call_number cn
                    JOIN asset.uri_call_number_map map ON (map.call_number = cn.id)
                    JOIN asset.uri uri ON (map.uri = uri.id)
              WHERE NOT cn.deleted
                    AND cn.label = '##URI##'
                    AND uri.active
                    AND ( param_locations IS NULL OR array_upper(param_locations, 1) IS NULL )
                    AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                    AND cn.owning_lib IN ( SELECT * FROM unnest( luri_org_list ) )
              LIMIT 1;

            IF FOUND THEN
                -- RAISE NOTICE ' % have at least one URI ... ', core_result.records;
                visible_count := visible_count + 1;

                current_res.id = core_result.id;
                current_res.rel = core_result.rel;

                tmp_int := 1;
                IF metarecord THEN
                    SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
                END IF;

                IF tmp_int = 1 THEN
                    current_res.record = core_result.records[1];
                ELSE
                    current_res.record = NULL;
                END IF;

                RETURN NEXT current_res;

                CONTINUE;
            END IF;

            IF param_statuses IS NOT NULL AND array_upper(param_statuses, 1) > 0 THEN

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                      LIMIT 1;

                    IF NOT FOUND THEN
                    -- RAISE NOTICE ' % and multi-home linked records were all status-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            END IF;

            IF param_locations IS NOT NULL AND array_upper(param_locations, 1) > 0 THEN

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                      LIMIT 1;

                    IF NOT FOUND THEN
                        -- RAISE NOTICE ' % and multi-home linked records were all copy_location-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            END IF;

            IF staff IS NULL OR NOT staff THEN

                PERFORM 1
                  FROM  asset.opac_visible_copies
                  WHERE circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.opac_visible_copies cp ON (cp.copy_id = pr.target_copy)
                      WHERE cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                      LIMIT 1;

                    IF NOT FOUND THEN

                        -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            ELSE

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN

                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                      LIMIT 1;

                    IF NOT FOUND THEN

                        PERFORM 1
                          FROM  asset.call_number cn
                                JOIN asset.copy cp ON (cp.call_number = cn.id)
                          WHERE cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                                AND NOT cp.deleted
                          LIMIT 1;

                        IF FOUND THEN
                            -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                            excluded_count := excluded_count + 1;
                            CONTINUE;
                        END IF;
                    END IF;

                END IF;

            END IF;

        END IF;

        visible_count := visible_count + 1;

        current_res.id = core_result.id;
        current_res.rel = core_result.rel;

        tmp_int := 1;
        IF metarecord THEN
            SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
        END IF;

        IF tmp_int = 1 THEN
            current_res.record = core_result.records[1];
        ELSE
            current_res.record = NULL;
        END IF;

        RETURN NEXT current_res;

        IF visible_count % 1000 = 0 THEN
            -- RAISE NOTICE ' % visible so far ... ', visible_count;
        END IF;

    END LOOP;

    current_res.id = NULL;
    current_res.rel = NULL;
    current_res.record = NULL;
    current_res.total = total_count;
    current_res.checked = check_count;
    current_res.deleted = deleted_count;
    current_res.visible = visible_count;
    current_res.excluded = excluded_count;

    CLOSE core_cursor;

    RETURN NEXT current_res;

END;
$$;


ALTER FUNCTION search.query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, deleted_search boolean, param_pref_ou integer) OWNER TO postgres;

SET search_path = serial, pg_catalog;

--
-- Name: materialize_holding_code(); Type: FUNCTION; Schema: serial; Owner: postgres
--

CREATE FUNCTION materialize_holding_code() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$ 
use strict;

use MARC::Field;
use JSON::XS;

if (not defined $_TD->{new}{holding_code}) {
    elog(WARNING, 'NULL in "holding_code" column of serial.issuance allowed for now, but may not be useful');
    return;
}

# Do nothing if holding_code has not changed...

if ($_TD->{new}{holding_code} eq $_TD->{old}{holding_code}) {
    # ... unless the following internal flag is set.

    my $flag_rv = spi_exec_query(q{
        SELECT * FROM config.internal_flag
        WHERE name = 'serial.rematerialize_on_same_holding_code' AND enabled
    }, 1);
    return unless $flag_rv->{processed};
}


my $holding_code = (new JSON::XS)->decode($_TD->{new}{holding_code});

my $field = new MARC::Field('999', @$holding_code); # tag doesnt matter

my $dstmt = spi_prepare(
    'DELETE FROM serial.materialized_holding_code WHERE issuance = $1',
    'INT'
);
spi_exec_prepared($dstmt, $_TD->{new}{id});

my $istmt = spi_prepare(
    q{
        INSERT INTO serial.materialized_holding_code (
            issuance, subfield, value
        ) VALUES ($1, $2, $3)
    }, qw{INT CHAR TEXT}
);

foreach ($field->subfields) {
    spi_exec_prepared(
        $istmt,
        $_TD->{new}{id},
        $_->[0],
        $_->[1]
    );
}

return;

$_X$;


ALTER FUNCTION serial.materialize_holding_code() OWNER TO postgres;

SET search_path = unapi, pg_catalog;

--
-- Name: acl(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name location,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible,
                    label_prefix AS prefix,
                    label_suffix AS suffix
                ),
                name
            )
      FROM  asset.copy_location
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: acn(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name volume,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acn/' || acn.id AS id,
                        acn.id AS vol_id, o.shortname AS lib,
                        o.opac_visible AS opac_visible,
                        deleted, label, label_sortkey, label_class, record
                    ),
                    unapi.aou( owning_lib, $2, 'owning_lib', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            CASE WHEN $6 IS NOT NULL THEN
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp_status(cp.status) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5), $6) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            ELSE
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp_status(cp.status) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5) ) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            END
                        ELSE NULL
                    END,
                    XMLELEMENT(
                        name uris,
                        (SELECT XMLAGG(auri) FROM (SELECT unapi.auri(uri,'xml','uri', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE call_number = acn.id)x)
                    ),
                    unapi.acnp( acn.prefix, 'marcxml', 'prefix', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                    unapi.acns( acn.suffix, 'marcxml', 'suffix', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( acn.record, 'marcxml', 'record', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE) ELSE NULL END
                ) AS x
          FROM  asset.call_number acn
                JOIN actor.org_unit o ON (o.id = acn.owning_lib)
          WHERE acn.id = $1
              AND acn.deleted IS FALSE
          GROUP BY acn.id, o.shortname, o.opac_visible, deleted, label, label_sortkey, label_class, owning_lib, record, acn.prefix, acn.suffix;
$_$;


ALTER FUNCTION unapi.acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: acnp(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_prefix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_prefix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: acns(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_suffix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_suffix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: acp(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect
                    ),
                    unapi.ccs( status, $2, 'status', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('acpn' = ANY ($4)) THEN
                            XMLELEMENT( name copy_notes,
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('ascecm' = ANY ($4)) THEN
                            XMLELEMENT( name statcats,
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE
                        WHEN ('bre' = ANY ($4)) THEN
                            XMLELEMENT( name foreign_records,
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)

                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  asset.copy cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, deposit, ref, holdable,
              deleted, deposit_amount, price, barcode, circ_modifier,
              circ_as_type, opac_visible, age_protect;
$_$;


ALTER FUNCTION unapi.acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: acpn(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy_note,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        create_date AS date,
                        title
                    ),
                    value
                )
          FROM  asset.copy_note
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: aou(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    output XML;
BEGIN
    IF ename = 'circlib' THEN
        SELECT  XMLELEMENT(
                    name circlib,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        id AS ident
                    ),
                    name
                ) INTO output
          FROM  actor.org_unit aou
          WHERE id = obj_id;
    ELSE
        EXECUTE $$SELECT  XMLELEMENT(
                    name $$ || ename || $$,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        'tag:open-ils.org:U2@aou/' || id AS id,
                        shortname, name, opac_visible
                    )
                )
          FROM  actor.org_unit aou
         WHERE id = $1 $$ INTO output USING obj_id;
    END IF;

    RETURN output;

END;
$_$;


ALTER FUNCTION unapi.aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: ascecm(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name statcat,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        sc.name,
                        sc.opac_visible
                    ),
                    asce.value
                )
          FROM  asset.stat_cat_entry asce
                JOIN asset.stat_cat sc ON (sc.id = asce.stat_cat)
          WHERE asce.id = $1;
$_$;


ALTER FUNCTION unapi.ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: auri(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name uri,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@auri/' || uri.id AS id,
                        use_restriction,
                        href,
                        label
                    ),
                    CASE 
                        WHEN ('acn' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acn) FROM (SELECT unapi.acn( call_number, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'auri'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE uri = uri.id)x)
                            )
                        ELSE NULL
                    END
                ) AS x
          FROM  asset.uri uri
          WHERE uri.id = $1
          GROUP BY uri.id, use_restriction, href, label;
$_$;


ALTER FUNCTION unapi.auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: biblio_record_entry_feed(bigint[], text, text[], text, integer, public.hstore, public.hstore, boolean, text, text, text, text, text, xml); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true, title text DEFAULT NULL::text, description text DEFAULT NULL::text, creator text DEFAULT NULL::text, update_ts text DEFAULT NULL::text, unapi_url text DEFAULT NULL::text, header_xml xml DEFAULT NULL::xml) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    layout          unapi.bre_output_layout%ROWTYPE;
    transform       config.xml_transform%ROWTYPE;
    item_format     TEXT;
    tmp_xml         TEXT;
    xmlns_uri       TEXT := 'http://open-ils.org/spec/feed-xml/v1';
    ouid            INT;
    element_list    TEXT[];
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;
    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO transform FROM config.xml_transform WHERE name = layout.transform;
    xmlns_uri := COALESCE(transform.namespace_uri,xmlns_uri);

    -- Gather the bib xml
    SELECT XMLAGG( unapi.bre(i, format, '', includes, org, depth, slimit, soffset, include_xmlns)) INTO tmp_xml FROM UNNEST( id_list ) i;

    IF layout.title_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.title_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, title;
    END IF;

    IF layout.description_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.description_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, description;
    END IF;

    IF layout.creator_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.creator_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, creator;
    END IF;

    IF layout.update_ts_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.update_ts_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, update_ts;
    END IF;

    IF unapi_url IS NOT NULL THEN
        EXECUTE $$SELECT XMLCONCAT( XMLELEMENT( name link, XMLATTRIBUTES( 'http://www.w3.org/1999/xhtml' AS xmlns, 'unapi-server' AS rel, $1 AS href, 'unapi' AS title)), $2)$$ INTO tmp_xml USING unapi_url, tmp_xml::XML;
    END IF;

    IF header_xml IS NOT NULL THEN tmp_xml := XMLCONCAT(header_xml,tmp_xml::XML); END IF;

    element_list := regexp_split_to_array(layout.feed_top,E'\\.');
    FOR i IN REVERSE ARRAY_UPPER(element_list, 1) .. 1 LOOP
        EXECUTE 'SELECT XMLELEMENT( name '|| quote_ident(element_list[i]) ||', XMLATTRIBUTES( $1 AS xmlns), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML;
    END LOOP;

    RETURN tmp_xml::XML;
END;
$_$;


ALTER FUNCTION unapi.biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean, title text, description text, creator text, update_ts text, unapi_url text, header_xml xml) OWNER TO postgres;

--
-- Name: bmp(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name monograph_part,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@bmp/' || id AS id,
                        id AS ident,
                        label,
                        label_sortkey,
                        'tag:open-ils.org:U2@bre/' || record AS record
                    ),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acp) FROM (
                                    SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'bmp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy cp
                                            JOIN asset.copy_part_map cpm ON (cpm.target_copy = cp.id)
                                      WHERE cpm.part = $1
                                          AND cp.deleted IS FALSE
                                      ORDER BY COALESCE(cp.copy_number,0), cp.barcode
                                      LIMIT ($7 -> 'acp')::INT
                                      OFFSET ($8 -> 'acp')::INT

                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( record, 'marcxml', 'record', evergreen.array_remove_item_by_value($4,'bmp'), $5, $6, $7, $8, FALSE) ELSE NULL END
                )
          FROM  biblio.monograph_part
          WHERE id = $1
          GROUP BY id, label, label_sortkey, record;
$_$;


ALTER FUNCTION unapi.bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: bre(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    me      biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    tmp_xml TEXT;
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;

    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.holdings_xml( obj_id, ouid, org, depth, includes, slimit, soffset, include_xmlns);
        RETURN output;
    END IF;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

    SELECT * INTO me FROM biblio.record_entry WHERE id = obj_id;

    -- grab SVF if we need them
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mra(obj_id,NULL,NULL,NULL,NULL);
    ELSE
        axml := NULL::XML;
    END IF;

    -- grab holdings if we need them
    IF ('holdings_xml' = ANY (includes)) THEN 
        hxml := unapi.holdings_xml(obj_id, ouid, org, depth, evergreen.array_remove_item_by_value(includes,'holdings_xml'), slimit, soffset, include_xmlns, pref_lib);
    ELSE
        hxml := NULL::XML;
    END IF;


    -- generate our item node


    IF format = 'marcxml' THEN
        tmp_xml := me.marc;
        IF tmp_xml !~ E'<marc:' THEN -- If we're not using the prefixed namespace in this record, then remove all declarations of it
           tmp_xml := REGEXP_REPLACE(tmp_xml, ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        tmp_xml := oils_xslt_process(me.marc, xfrm.xslt)::XML;
    END IF;

    top_el := REGEXP_REPLACE(tmp_xml, E'^.*?<((?:\\S+:)?' || layout.holdings_element || ').*$', E'\\1');

    IF axml IS NOT NULL THEN 
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN -- XXX how do we configure the holdings position?
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

    IF ('bre.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@bre/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean, pref_lib integer) OWNER TO postgres;

--
-- Name: ccs(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name status,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible
                ),
                name
            )
      FROM  config.copy_status
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: circ(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION circ(obj_id bigint, format text, ename text, includes text[], org text DEFAULT '-'::text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT XMLELEMENT(
        name circ,
        XMLATTRIBUTES(
            CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
            'tag:open-ils.org:U2@circ/' || id AS id,
            xact_start,
            due_date
        ),
        CASE WHEN ('aou' = ANY ($4)) THEN unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END,
        CASE WHEN ('acp' = ANY ($4)) THEN unapi.acp( circ_lib, $2, 'target_copy', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END
    )
    FROM action.circulation
    WHERE id = $1;
$_$;


ALTER FUNCTION unapi.circ(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: holdings_xml(bigint, integer, text, integer, text[], public.hstore, public.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION holdings_xml(bid bigint, ouid integer, org text, depth integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[], slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
     SELECT  XMLELEMENT(
                 name holdings,
                 XMLATTRIBUTES(
                    CASE WHEN $8 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    CASE WHEN ('bre' = ANY ($5)) THEN 'tag:open-ils.org:U2@bre/' || $1 || '/' || $3 ELSE NULL END AS id,
                    (SELECT record_has_holdable_copy FROM asset.record_has_holdable_copy($1)) AS has_holdable
                 ),
                 XMLELEMENT(
                     name counts,
                     (SELECT  XMLAGG(XMLELEMENT::XML) FROM (
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('public' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($2,  $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('staff' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.staff_ou_record_copy_count($2, $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('pref_lib' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($9,  $1)
                                     ORDER BY 1
                     )x)
                 ),
                 CASE 
                     WHEN ('bmp' = ANY ($5)) THEN
                        XMLELEMENT(
                            name monograph_parts,
                            (SELECT XMLAGG(bmp) FROM (
                                SELECT  unapi.bmp( id, 'xml', 'monograph_part', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'bre'), 'holdings_xml'), $3, $4, $6, $7, FALSE)
                                  FROM  biblio.monograph_part
                                  WHERE record = $1
                            )x)
                        )
                     ELSE NULL
                 END,
                 XMLELEMENT(
                     name volumes,
                     (SELECT XMLAGG(acn ORDER BY rank, name, label_sortkey) FROM (
                        -- Physical copies
                        SELECT  unapi.acn(y.id,'xml','volume',evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), y.rank, name, label_sortkey
                        FROM evergreen.ranked_volumes($1, $2, $4, $6, $7, $9, $5) AS y
                        UNION ALL
                        -- Located URIs
                        SELECT unapi.acn(uris.id,'xml','volume',evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), 0, name, label_sortkey
                        FROM evergreen.located_uris($1, $2, $9) AS uris
                     )x)
                 ),
                 CASE WHEN ('ssub' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name subscriptions,
                         (SELECT XMLAGG(ssub) FROM (
                            SELECT  unapi.ssub(id,'xml','subscription','{}'::TEXT[], $3, $4, $6, $7, FALSE)
                              FROM  serial.subscription
                              WHERE record_entry = $1
                        )x)
                     )
                 ELSE NULL END,
                 CASE WHEN ('acp' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name foreign_copies,
                         (SELECT XMLAGG(acp) FROM (
                            SELECT  unapi.acp(p.target_copy,'xml','copy',evergreen.array_remove_item_by_value($5,'acp'), $3, $4, $6, $7, FALSE)
                              FROM  biblio.peer_bib_copy_map p
                                    JOIN asset.copy c ON (p.target_copy = c.id)
                              WHERE NOT c.deleted AND p.peer_record = $1
                            LIMIT ($6 -> 'acp')::INT
                            OFFSET ($7 -> 'acp')::INT
                        )x)
                     )
                 ELSE NULL END
             );
$_$;


ALTER FUNCTION unapi.holdings_xml(bid bigint, ouid integer, org text, depth integer, includes text[], slimit public.hstore, soffset public.hstore, include_xmlns boolean, pref_lib integer) OWNER TO postgres;

--
-- Name: memoize(text, bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    key     TEXT;
    output  XML;
BEGIN
    key :=
        'id'        || COALESCE(obj_id::TEXT,'') ||
        'format'    || COALESCE(format::TEXT,'') ||
        'ename'     || COALESCE(ename::TEXT,'') ||
        'includes'  || COALESCE(includes::TEXT,'{}'::TEXT[]::TEXT) ||
        'org'       || COALESCE(org::TEXT,'') ||
        'depth'     || COALESCE(depth::TEXT,'') ||
        'slimit'    || COALESCE(slimit::TEXT,'') ||
        'soffset'   || COALESCE(soffset::TEXT,'') ||
        'include_xmlns'   || COALESCE(include_xmlns::TEXT,'');
    -- RAISE NOTICE 'memoize key: %', key;

    key := MD5(key);
    -- RAISE NOTICE 'memoize hash: %', key;

    -- XXX cache logic ... memcached? table?

    EXECUTE $$SELECT unapi.$$ || classname || $$( $1, $2, $3, $4, $5, $6, $7, $8, $9);$$ INTO output USING obj_id, format, ename, includes, org, depth, slimit, soffset, include_xmlns;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: mra(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name attributes,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/indexing/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@mra/' || mra.id AS id,
                        'tag:open-ils.org:U2@bre/' || mra.id AS record
                    ),
                    (SELECT XMLAGG(foo.y)
                      FROM (SELECT XMLELEMENT(
                                name field,
                                XMLATTRIBUTES(
                                    key AS name,
                                    cvm.value AS "coded-value",
                                    rad.filter,
                                    rad.sorter
                                ),
                                x.value
                            )
                           FROM EACH(mra.attrs) AS x
                                JOIN config.record_attr_definition rad ON (x.key = rad.name)
                                LEFT JOIN config.coded_value_map cvm ON (cvm.ctype = x.key AND code = x.value)
                        )foo(y)
                    )
                )
          FROM  metabib.record_attr mra
          WHERE mra.id = $1;
$_$;


ALTER FUNCTION unapi.mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sbsum(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sbsum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.basic_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sdist(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name distribution,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sdist/' || id AS id,
            			'tag:open-ils.org:U2@acn/' || receive_call_number AS receive_call_number,
			            'tag:open-ils.org:U2@acn/' || bind_call_number AS bind_call_number,
                        unit_label_prefix, label, unit_label_suffix, summary_method
                    ),
                    unapi.aou( holding_lib, $2, 'holding_lib', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8),
                    CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('sstr' = ANY ($4)) THEN
                            XMLELEMENT( name streams,
                                (SELECT XMLAGG(sstr) FROM (
                                    SELECT  unapi.sstr( id, 'xml', 'stream', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.stream
                                      WHERE distribution = sdist.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    XMLELEMENT( name summaries,
                        CASE 
                            WHEN ('sbsum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sbsum) FROM (
                                    SELECT  unapi.sbsum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.basic_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sisum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sisum) FROM (
                                    SELECT  unapi.sisum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.index_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sssum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sssum) FROM (
                                    SELECT  unapi.sssum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.supplement_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END
                    )
                )
          FROM  serial.distribution sdist
          WHERE id = $1
          GROUP BY id, label, unit_label_prefix, unit_label_suffix, holding_lib, summary_method, subscription, receive_call_number, bind_call_number;
$_$;


ALTER FUNCTION unapi.sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: siss(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name issuance,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@siss/' || id AS id,
                    create_date, edit_date, label, date_published,
                    holding_code, holding_type, holding_link_id
                ),
                CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', evergreen.array_remove_item_by_value($4,'siss'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', evergreen.array_remove_item_by_value($4,'siss'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE issuance = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.issuance sstr
      WHERE id = $1
      GROUP BY id, create_date, edit_date, label, date_published, holding_code, holding_type, holding_link_id, subscription;
$_$;


ALTER FUNCTION unapi.siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sisum(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sisum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.index_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sitem(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_item,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sitem/' || id AS id,
                        'tag:open-ils.org:U2@siss/' || issuance AS issuance,
                        date_expected, date_received
                    ),
                    CASE WHEN issuance IS NOT NULL AND ('siss' = ANY ($4)) THEN unapi.siss( issuance, $2, 'issuance', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN stream IS NOT NULL AND ('sstr' = ANY ($4)) THEN unapi.sstr( stream, $2, 'stream', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN unit IS NOT NULL AND ('sunit' = ANY ($4)) THEN unapi.sunit( unit, $2, 'serial_unit', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN uri IS NOT NULL AND ('auri' = ANY ($4)) THEN unapi.auri( uri, $2, 'uri', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END
--                    XMLELEMENT( name notes,
--                        CASE 
--                            WHEN ('acpn' = ANY ($4)) THEN
--                                (SELECT XMLAGG(acpn) FROM (
--                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8)
--                                      FROM  asset.copy_note
--                                      WHERE owning_copy = cp.id AND pub
--                                )x)
--                            ELSE NULL
--                        END
--                    )
                )
          FROM  serial.item sitem
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sssum(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sssum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.supplement_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sstr(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name stream,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sstr/' || id AS id,
                    routing_label
                ),
                CASE WHEN distribution IS NOT NULL AND ('sdist' = ANY ($4)) THEN unapi.sssum( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'sstr'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', evergreen.array_remove_item_by_value($4,'sstr'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE stream = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.stream sstr
      WHERE id = $1
      GROUP BY id, routing_label, distribution;
$_$;


ALTER FUNCTION unapi.sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: ssub(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name subscription,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@ssub/' || id AS id,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        start_date AS start, end_date AS end, expected_date_offset
                    ),
                    CASE 
                        WHEN ('sdist' = ANY ($4)) THEN
                            XMLELEMENT( name distributions,
                                (SELECT XMLAGG(sdist) FROM (
                                    SELECT  unapi.sdist( id, 'xml', 'distribution', evergreen.array_remove_item_by_value($4,'ssub'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.distribution
                                      WHERE subscription = ssub.id
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.subscription ssub
          WHERE id = $1
          GROUP BY id, start_date, end_date, expected_date_offset, owning_lib;
$_$;


ALTER FUNCTION unapi.ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

--
-- Name: sunit(bigint, text, text, text[], text, integer, public.hstore, public.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit public.hstore DEFAULT NULL::public.hstore, soffset public.hstore DEFAULT NULL::public.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_unit,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect,
                        status_changed_time, floating, mint_condition,
                        detailed_contents, sort_key, summary_contents, cost 
                    ),
                    unapi.ccs( status, $2, 'status', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    XMLELEMENT( name copy_notes,
                        CASE 
                            WHEN ('acpn' = ANY ($4)) THEN
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name statcats,
                        CASE 
                            WHEN ('ascecm' = ANY ($4)) THEN
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name foreign_records,
                        CASE
                            WHEN ('bre' = ANY ($4)) THEN
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.unit cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, floating, mint_condition,
              deposit, ref, holdable, deleted, deposit_amount, price,
              barcode, circ_modifier, circ_as_type, opac_visible,
              status_changed_time, detailed_contents, sort_key,
              summary_contents, cost, age_protect;
$_$;


ALTER FUNCTION unapi.sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit public.hstore, soffset public.hstore, include_xmlns boolean) OWNER TO postgres;

SET search_path = url_verify, pg_catalog;

--
-- Name: extract_urls(integer, integer); Type: FUNCTION; Schema: url_verify; Owner: postgres
--

CREATE FUNCTION extract_urls(session_id integer, item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    last_seen_tag TEXT;
    current_tag TEXT;
    current_sf TEXT;
    current_url TEXT;
    current_ord INT;
    current_url_pos INT;
    current_selector url_verify.url_selector%ROWTYPE;
BEGIN
    current_ord := 1;

    FOR current_selector IN SELECT * FROM url_verify.url_selector s WHERE s.session = session_id LOOP
        current_url_pos := 1;
        LOOP
            SELECT  (XPATH(current_selector.xpath || '/text()', b.marc::XML))[current_url_pos]::TEXT INTO current_url
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            EXIT WHEN current_url IS NULL;

            SELECT  (XPATH(current_selector.xpath || '/../@tag', b.marc::XML))[current_url_pos]::TEXT INTO current_tag
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            IF current_tag IS NULL THEN
                current_tag := last_seen_tag;
            ELSE
                last_seen_tag := current_tag;
            END IF;

            SELECT  (XPATH(current_selector.xpath || '/@code', b.marc::XML))[current_url_pos]::TEXT INTO current_sf
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            INSERT INTO url_verify.url (session, item, url_selector, tag, subfield, ord, full_url)
              VALUES ( session_id, item_id, current_selector.id, current_tag, current_sf, current_ord, current_url);

            current_url_pos := current_url_pos + 1;
            current_ord := current_ord + 1;
        END LOOP;
    END LOOP;

    RETURN current_ord - 1;
END;
$$;


ALTER FUNCTION url_verify.extract_urls(session_id integer, item_id integer) OWNER TO postgres;

--
-- Name: ingest_url(); Type: FUNCTION; Schema: url_verify; Owner: postgres
--

CREATE FUNCTION ingest_url() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_row url_verify.url%ROWTYPE;
BEGIN
    SELECT * INTO tmp_row FROM url_verify.parse_url(NEW.full_url);

    NEW.scheme          := tmp_row.scheme;
    NEW.username        := tmp_row.username;
    NEW.password        := tmp_row.password;
    NEW.host            := tmp_row.host;
    NEW.domain          := tmp_row.domain;
    NEW.tld             := tmp_row.tld;
    NEW.port            := tmp_row.port;
    NEW.path            := tmp_row.path;
    NEW.page            := tmp_row.page;
    NEW.query           := tmp_row.query;
    NEW.fragment        := tmp_row.fragment;

    RETURN NEW;
END;
$$;


ALTER FUNCTION url_verify.ingest_url() OWNER TO postgres;

--
-- Name: url; Type: TABLE; Schema: url_verify; Owner: postgres; Tablespace: 
--

CREATE TABLE url (
    id integer NOT NULL,
    redirect_from integer,
    item integer,
    session integer,
    url_selector integer,
    tag text,
    subfield text,
    ord integer,
    full_url text NOT NULL,
    scheme text,
    username text,
    password text,
    host text,
    domain text,
    tld text,
    port text,
    path text,
    page text,
    query text,
    fragment text,
    CONSTRAINT redirect_or_from_item CHECK (((redirect_from IS NOT NULL) OR (((((item IS NOT NULL) AND (url_selector IS NOT NULL)) AND (tag IS NOT NULL)) AND (subfield IS NOT NULL)) AND (ord IS NOT NULL))))
);


ALTER TABLE url_verify.url OWNER TO postgres;

--
-- Name: parse_url(text); Type: FUNCTION; Schema: url_verify; Owner: postgres
--

CREATE FUNCTION parse_url(url_in text) RETURNS url
    LANGUAGE plperlu
    AS $_X$

use Rose::URI;

my $url_in = shift;
my $url = Rose::URI->new($url_in);

my %parts = map { $_ => $url->$_ } qw/scheme username password host port path query fragment/;

$parts{full_url} = $url_in;
($parts{domain} = $parts{host}) =~ s/^[^.]+\.//;
($parts{tld} = $parts{domain}) =~ s/(?:[^.]+\.)+//;
($parts{page} = $parts{path}) =~ s#(?:[^/]*/)+##;

return \%parts;

$_X$;


ALTER FUNCTION url_verify.parse_url(url_in text) OWNER TO postgres;

SET search_path = vandelay, pg_catalog;

--
-- Name: match_set_point; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE match_set_point (
    id integer NOT NULL,
    match_set integer,
    parent integer,
    bool_op text,
    svf text,
    tag text,
    subfield text,
    negate boolean DEFAULT false,
    quality integer DEFAULT 1 NOT NULL,
    CONSTRAINT match_set_point_bool_op_check CHECK (((bool_op IS NULL) OR (bool_op = ANY (ARRAY['AND'::text, 'OR'::text, 'NOT'::text])))),
    CONSTRAINT vmsp_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsp_need_a_tag_or_a_ff_or_a_bo CHECK ((((((tag IS NOT NULL) AND (svf IS NULL)) AND (bool_op IS NULL)) OR (((tag IS NULL) AND (svf IS NOT NULL)) AND (bool_op IS NULL))) OR (((tag IS NULL) AND (svf IS NULL)) AND (bool_op IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_point OWNER TO postgres;

--
-- Name: _get_expr_push_jrow(match_set_point, public.hstore); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION _get_expr_push_jrow(node match_set_point, tags_rstore public.hstore) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jrow        TEXT;
    my_alias    TEXT;
    op          TEXT;
    tagkey      TEXT;
    caseless    BOOL;
    jrow_count  INT;
    my_using    TEXT;
    my_join     TEXT;
BEGIN
    -- remember $1 is tags_rstore, and $2 is svf_rstore

    caseless := FALSE;
    SELECT COUNT(*) INTO jrow_count FROM _vandelay_tmp_jrows;
    IF jrow_count > 0 THEN
        my_using := ' USING (record)';
        my_join := 'FULL OUTER JOIN';
    ELSE
        my_using := '';
        my_join := 'FROM';
    END IF;

    IF node.tag IS NOT NULL THEN
        caseless := (node.tag IN ('020', '022', '024'));
        tagkey := node.tag;
        IF node.subfield IS NOT NULL THEN
            tagkey := tagkey || node.subfield;
        END IF;
    END IF;

    IF node.negate THEN
        IF caseless THEN
            op := 'NOT LIKE';
        ELSE
            op := '<>';
        END IF;
    ELSE
        IF caseless THEN
            op := 'LIKE';
        ELSE
            op := '=';
        END IF;
    END IF;

    my_alias := 'n' || node.id::TEXT;

    jrow := my_join || ' (SELECT *, ';
    IF node.tag IS NOT NULL THEN
        jrow := jrow  || node.quality ||
            ' AS quality FROM metabib.full_rec mfr WHERE mfr.tag = ''' ||
            node.tag || '''';
        IF node.subfield IS NOT NULL THEN
            jrow := jrow || ' AND mfr.subfield = ''' ||
                node.subfield || '''';
        END IF;
        jrow := jrow || ' AND (';
        jrow := jrow || vandelay._node_tag_comparisons(caseless, op, tags_rstore, tagkey);
        jrow := jrow || ')) ' || my_alias || my_using || E'\n';
    ELSE    -- svf
        jrow := jrow || 'id AS record, ' || node.quality ||
            ' AS quality FROM metabib.record_attr mra WHERE mra.attrs->''' ||
            node.svf || ''' ' || op || ' $2->''' || node.svf || ''') ' ||
            my_alias || my_using || E'\n';
    END IF;
    INSERT INTO _vandelay_tmp_jrows (j) VALUES (jrow);
END;
$_$;


ALTER FUNCTION vandelay._get_expr_push_jrow(node match_set_point, tags_rstore public.hstore) OWNER TO postgres;

--
-- Name: _get_expr_push_qrow(match_set_point); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION _get_expr_push_qrow(node match_set_point) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    INSERT INTO _vandelay_tmp_qrows (q) VALUES (node.id);
END;
$$;


ALTER FUNCTION vandelay._get_expr_push_qrow(node match_set_point) OWNER TO postgres;

--
-- Name: _get_expr_render_one(match_set_point); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION _get_expr_render_one(node match_set_point) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    s           TEXT;
BEGIN
    IF node.bool_op IS NOT NULL THEN
        RETURN node.bool_op;
    ELSE
        RETURN '(n' || node.id::TEXT || '.id IS NOT NULL)';
    END IF;
END;
$$;


ALTER FUNCTION vandelay._get_expr_render_one(node match_set_point) OWNER TO postgres;

--
-- Name: _node_tag_comparisons(boolean, text, public.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION _node_tag_comparisons(caseless boolean, op text, tags_rstore public.hstore, tagkey text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    result  TEXT;
    i       INT;
    vals    TEXT[];
BEGIN
    i := 1;
    vals := tags_rstore->tagkey;
    result := '';

    WHILE TRUE LOOP
        IF i > 1 THEN
            IF vals[i] IS NULL THEN
                EXIT;
            ELSE
                result := result || ' OR ';
            END IF;
        END IF;

        IF caseless THEN
            result := result || 'LOWER(mfr.value) ' || op;
        ELSE
            result := result || 'mfr.value ' || op;
        END IF;

        result := result || ' ' || COALESCE('''' || vals[i] || '''', 'NULL');

        IF vals[i] IS NULL THEN
            EXIT;
        END IF;
        i := i + 1;
    END LOOP;

    RETURN result;

END;
$$;


ALTER FUNCTION vandelay._node_tag_comparisons(caseless boolean, op text, tags_rstore public.hstore, tagkey text) OWNER TO postgres;

--
-- Name: add_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION add_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.add_field( $1, $2, $3, 0 );
$_$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text) OWNER TO postgres;

--
-- Name: add_field(text, text, text, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION add_field(target_xml text, source_xml text, field text, force_add integer) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $target_xml = shift;
    my $source_xml = shift;
    my $field_spec = shift;
    my $force_add = shift || 0;

    my $target_r = MARC::Record->new_from_xml( $target_xml );
    my $source_r = MARC::Record->new_from_xml( $source_xml );

    return $target_xml unless ($target_r && $source_r);

    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    for my $f ( keys %fields) {
        if ( @{$fields{$f}{sf}} ) {
            for my $from_field ($source_r->field( $f )) {
                my @tos = $target_r->field( $f );
                if (!@tos) {
                    next if (exists($fields{$f}{match}) and !$force_add);
                    my @new_fields = map { $_->clone } $source_r->field( $f );
                    $target_r->insert_fields_ordered( @new_fields );
                } else {
                    for my $to_field (@tos) {
                        if (exists($fields{$f}{match})) {
                            next unless (grep { $_ =~ $fields{$f}{match}{re} } $to_field->subfield($fields{$f}{match}{sf}));
                        }
                        my @new_sf = map { ($_ => $from_field->subfield($_)) } grep { defined($from_field->subfield($_)) } @{$fields{$f}{sf}};
                        $to_field->add_subfields( @new_sf );
                    }
                }
            }
        } else {
            my @new_fields = map { $_->clone } $source_r->field( $f );
            $target_r->insert_fields_ordered( @new_fields );
        }
    }

    $target_xml = $target_r->as_xml_record;
    $target_xml =~ s/^<\?.+?\?>$//mo;
    $target_xml =~ s/\n//sgo;
    $target_xml =~ s/>\s+</></sgo;

    return $target_xml;

$_X$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text, force_add integer) OWNER TO postgres;

--
-- Name: auto_overlay_authority_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_authority_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_authority_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint) OWNER TO postgres;

--
-- Name: auto_overlay_authority_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_authority_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_authority_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_authority_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;
    
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_authority_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_authority_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN
    SELECT COUNT(*) INTO match_count FROM vandelay.authority_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.authority_match m
      WHERE m.queued_record = import_id
      LIMIT 1;

    IF eg_id IS NULL THEN
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_authority_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_record(import_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_bib_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_bib_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint) OWNER TO postgres;

--
-- Name: auto_overlay_bib_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;
    
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT vandelay.auto_overlay_bib_queue_with_best( $1, $2, p.lwm_ratio ) FROM vandelay.merge_profile p WHERE id = $2;
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record_with_best( queued_record.id, merge_profile_id, lwm_ratio_value ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;
    
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) OWNER TO postgres;

--
-- Name: auto_overlay_bib_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT COUNT(*) INTO match_count FROM vandelay.bib_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    -- Check that the one match is on the first 901c
    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.queued_bib_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id)
      WHERE q.id = import_id
            AND m.eg_record = oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]',marc)::BIGINT;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'not a 901c match';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record(import_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_bib_record_with_best(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT vandelay.auto_overlay_bib_record_with_best( $1, $2, p.lwm_ratio ) FROM vandelay.merge_profile p WHERE id = $2;
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: auto_overlay_bib_record_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    lwm_ratio_value NUMERIC;
BEGIN

    lwm_ratio_value := COALESCE(lwm_ratio_value_p, 0.0);

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.bib_match m
            JOIN vandelay.queued_bib_record qr ON (m.queued_record = qr.id)
            JOIN vandelay.bib_queue q ON (qr.queue = q.id)
            JOIN biblio.record_entry r ON (r.id = m.eg_record)
      WHERE m.queued_record = import_id
            AND qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC >= lwm_ratio_value
      ORDER BY  m.match_score DESC, -- required match score
                qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC DESC, -- quality tie breaker
                m.id -- when in doubt, use the first match
      LIMIT 1;

    IF eg_id IS NULL THEN
        -- RAISE NOTICE 'incoming record is not of high enough quality';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO postgres;

--
-- Name: cleanup_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION cleanup_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_authority_record_attr WHERE record = OLD.id;
    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_authority_marc() OWNER TO postgres;

--
-- Name: cleanup_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION cleanup_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_bib_record_attr WHERE record = OLD.id;
    DELETE FROM vandelay.import_item WHERE record = OLD.id;

    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_bib_marc() OWNER TO postgres;

--
-- Name: compile_profile(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION compile_profile(incoming_xml text) RETURNS compile_profile
    LANGUAGE plpgsql
    AS $$
DECLARE
    output              vandelay.compile_profile%ROWTYPE;
    profile             vandelay.merge_profile%ROWTYPE;
    profile_tmpl        TEXT;
    profile_tmpl_owner  TEXT;
    add_rule            TEXT := '';
    strip_rule          TEXT := '';
    replace_rule        TEXT := '';
    preserve_rule       TEXT := '';

BEGIN

    profile_tmpl := (oils_xpath('//*[@tag="905"]/*[@code="t"]/text()',incoming_xml))[1];
    profile_tmpl_owner := (oils_xpath('//*[@tag="905"]/*[@code="o"]/text()',incoming_xml))[1];

    IF profile_tmpl IS NOT NULL AND profile_tmpl <> '' AND profile_tmpl_owner IS NOT NULL AND profile_tmpl_owner <> '' THEN
        SELECT  p.* INTO profile
          FROM  vandelay.merge_profile p
                JOIN actor.org_unit u ON (u.id = p.owner)
          WHERE p.name = profile_tmpl
                AND u.shortname = profile_tmpl_owner;

        IF profile.id IS NOT NULL THEN
            add_rule := COALESCE(profile.add_spec,'');
            strip_rule := COALESCE(profile.strip_spec,'');
            replace_rule := COALESCE(profile.replace_spec,'');
            preserve_rule := COALESCE(profile.preserve_spec,'');
        END IF;
    END IF;

    add_rule := add_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="a"]/text()',incoming_xml),','),'');
    strip_rule := strip_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="d"]/text()',incoming_xml),','),'');
    replace_rule := replace_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="r"]/text()',incoming_xml),','),'');
    preserve_rule := preserve_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="p"]/text()',incoming_xml),','),'');

    output.add_rule := BTRIM(add_rule,',');
    output.replace_rule := BTRIM(replace_rule,',');
    output.strip_rule := BTRIM(strip_rule,',');
    output.preserve_rule := BTRIM(preserve_rule,',');

    RETURN output;
END;
$$;


ALTER FUNCTION vandelay.compile_profile(incoming_xml text) OWNER TO postgres;

--
-- Name: extract_rec_attrs(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION extract_rec_attrs(xml text) RETURNS public.hstore
    LANGUAGE sql
    AS $_$
    SELECT vandelay.extract_rec_attrs( $1, (SELECT ARRAY_ACCUM(name) FROM config.record_attr_definition));
$_$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text) OWNER TO postgres;

--
-- Name: extract_rec_attrs(text, text[]); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION extract_rec_attrs(xml text, attr_defs text[]) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_value      TEXT;
    new_attrs       HSTORE := ''::HSTORE;
    attr_def        config.record_attr_definition%ROWTYPE;
BEGIN

    FOR attr_def IN SELECT * FROM config.record_attr_definition WHERE name IN (SELECT * FROM UNNEST(attr_defs)) ORDER BY format LOOP

        IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
            SELECT  ARRAY_TO_STRING(ARRAY_ACCUM(x.value), COALESCE(attr_def.joiner,' ')) INTO attr_value
              FROM  vandelay.flatten_marc(xml) AS x
              WHERE x.tag LIKE attr_def.tag
                    AND CASE
                        WHEN attr_def.sf_list IS NOT NULL
                            THEN POSITION(x.subfield IN attr_def.sf_list) > 0
                        ELSE TRUE
                        END
              GROUP BY x.tag
              ORDER BY x.tag
              LIMIT 1;

        ELSIF attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
            attr_value := vandelay.marc21_extract_fixed_field(xml, attr_def.fixed_field);

        ELSIF attr_def.xpath IS NOT NULL THEN -- and xpath expression

            SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;

            -- See if we can skip the XSLT ... it's expensive
            IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                -- Can't skip the transform
                IF xfrm.xslt <> '---' THEN
                    transformed_xml := oils_xslt_process(xml,xfrm.xslt);
                ELSE
                    transformed_xml := xml;
                END IF;

                prev_xfrm := xfrm.name;
            END IF;

            IF xfrm.name IS NULL THEN
                -- just grab the marcxml (empty) transform
                SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                prev_xfrm := xfrm.name;
            END IF;

            attr_value := oils_xpath_string(attr_def.xpath, transformed_xml, COALESCE(attr_def.joiner,' '), ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]);

        ELSIF attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
            SELECT  m.value::TEXT INTO attr_value
              FROM  vandelay.marc21_physical_characteristics(xml) v
                    JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
              WHERE v.subfield = attr_def.phys_char_sf
              LIMIT 1; -- Just in case ...

        END IF;

        -- apply index normalizers to attr_value
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
              WHERE attr = attr_def.name
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_nullable( attr_value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO attr_value;

        END LOOP;

        -- Add the new value to the hstore
        new_attrs := new_attrs || hstore( attr_def.name, attr_value );

    END LOOP;

    RETURN new_attrs;
END;
$$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text, attr_defs text[]) OWNER TO postgres;

--
-- Name: find_bib_tcn_data(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION find_bib_tcn_data(xml text) RETURNS SETOF tcn_data
    LANGUAGE plpgsql
    AS $_$
DECLARE
    eg_tcn          TEXT;
    eg_tcn_source   TEXT;
    output          vandelay.tcn_data%ROWTYPE;
BEGIN

    -- 001/003
    eg_tcn := BTRIM((oils_xpath('//*[@tag="001"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="003"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 901 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 039 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 020 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="020"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISBN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 022 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="022"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISSN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 010 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="010"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'LCCN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 035 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="035"]/*[@code="a"]/text()',xml))[1], $re$^.*?(\w+)$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'System Legacy';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    RETURN;
END;
$_$;


ALTER FUNCTION vandelay.find_bib_tcn_data(xml text) OWNER TO postgres;

--
-- Name: flatten_marc(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION flatten_marc(marc text) RETURNS SETOF flat_marc
    LANGUAGE plpgsql
    AS $$
DECLARE
    output  vandelay.flat_marc%ROWTYPE;
    field   RECORD;
BEGIN
    FOR field IN SELECT * FROM vandelay.flay_marc( marc ) LOOP
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        IF field.subfield IS NOT NULL AND field.tag NOT IN ('020','022','024') THEN -- exclude standard numbers and control fields
            output.value := naco_normalize(field.value, field.subfield);
        ELSE
            output.value := field.value;
        END IF;

        CONTINUE WHEN output.value IS NULL;

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION vandelay.flatten_marc(marc text) OWNER TO postgres;

--
-- Name: flatten_marc_hstore(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION flatten_marc_hstore(record_xml text) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN (SELECT
        HSTORE(
            ARRAY_ACCUM(tag || (COALESCE(subfield, ''))),
            ARRAY_ACCUM(value)
        )
        FROM (
            SELECT  tag, subfield, ARRAY_ACCUM(value)::TEXT AS value
              FROM  (SELECT tag,
                            subfield,
                            CASE WHEN tag = '020' THEN -- caseless -- isbn
                                LOWER((REGEXP_MATCHES(value,$$^(\S{10,17})$$))[1] || '%')
                            WHEN tag = '022' THEN -- caseless -- issn
                                LOWER((REGEXP_MATCHES(value,$$^(\S{4}[- ]?\S{4})$$))[1] || '%')
                            WHEN tag = '024' THEN -- caseless -- upc (other)
                                LOWER(value || '%')
                            ELSE
                                value
                            END AS value
                      FROM  vandelay.flatten_marc(record_xml)) x
                GROUP BY tag, subfield ORDER BY tag, subfield
        ) subquery
    );
END;
$_$;


ALTER FUNCTION vandelay.flatten_marc_hstore(record_xml text) OWNER TO postgres;

--
-- Name: flay_marc(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION flay_marc(text) RETURNS SETOF flat_marc
    LANGUAGE plperlu
    AS $_$

use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use strict;

MARC::Charset->assume_unicode(1);

my $xml = shift;
my $r = MARC::Record->new_from_xml( $xml );

return_next( { tag => 'LDR', value => $r->leader } );

for my $f ( $r->fields ) {
    if ($f->is_control_field) {
        return_next({ tag => $f->tag, value => $f->data });
    } else {
        for my $s ($f->subfields) {
            return_next({
                tag      => $f->tag,
                ind1     => $f->indicator(1),
                ind2     => $f->indicator(2),
                subfield => $s->[0],
                value    => $s->[1]
            });

            if ( $f->tag eq '245' and $s->[0] eq 'a' ) {
                my $trim = $f->indicator(2) || 0;
                return_next({
                    tag      => 'tnf',
                    ind1     => $f->indicator(1),
                    ind2     => $f->indicator(2),
                    subfield => 'a',
                    value    => substr( $s->[1], $trim )
                });
            }
        }
    }
}

return undef;

$_$;


ALTER FUNCTION vandelay.flay_marc(text) OWNER TO postgres;

--
-- Name: get_expr_from_match_set(integer, public.hstore); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION get_expr_from_match_set(match_set_id integer, tags_rstore public.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    root    vandelay.match_set_point;
BEGIN
    SELECT * INTO root FROM vandelay.match_set_point
        WHERE parent IS NULL AND match_set = match_set_id;

    RETURN vandelay.get_expr_from_match_set_point(root, tags_rstore);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore public.hstore) OWNER TO postgres;

--
-- Name: get_expr_from_match_set_point(match_set_point, public.hstore); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION get_expr_from_match_set_point(node match_set_point, tags_rstore public.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    q           TEXT;
    i           INTEGER;
    this_op     TEXT;
    children    INTEGER[];
    child       vandelay.match_set_point;
BEGIN
    SELECT ARRAY_ACCUM(id) INTO children FROM vandelay.match_set_point
        WHERE parent = node.id;

    IF ARRAY_LENGTH(children, 1) > 0 THEN
        this_op := vandelay._get_expr_render_one(node);
        q := '(';
        i := 1;
        WHILE children[i] IS NOT NULL LOOP
            SELECT * INTO child FROM vandelay.match_set_point
                WHERE id = children[i];
            IF i > 1 THEN
                q := q || ' ' || this_op || ' ';
            END IF;
            i := i + 1;
            q := q || vandelay.get_expr_from_match_set_point(child, tags_rstore);
        END LOOP;
        q := q || ')';
        RETURN q;
    ELSIF node.bool_op IS NULL THEN
        PERFORM vandelay._get_expr_push_qrow(node);
        PERFORM vandelay._get_expr_push_jrow(node, tags_rstore);
        RETURN vandelay._get_expr_render_one(node);
    ELSE
        RETURN '';
    END IF;
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_point(node match_set_point, tags_rstore public.hstore) OWNER TO postgres;

--
-- Name: ingest_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION ingest_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.authority_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_authority_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_authority_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_authority_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_authority_marc() OWNER TO postgres;

--
-- Name: ingest_bib_items(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION ingest_bib_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    attr_def    BIGINT;
    item_data   vandelay.import_item%ROWTYPE;
BEGIN

    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    SELECT item_attr_def INTO attr_def FROM vandelay.bib_queue WHERE id = NEW.queue;

    FOR item_data IN SELECT * FROM vandelay.ingest_items( NEW.id::BIGINT, attr_def ) LOOP
        INSERT INTO vandelay.import_item (
            record,
            definition,
            owning_lib,
            circ_lib,
            call_number,
            copy_number,
            status,
            location,
            circulate,
            deposit,
            deposit_amount,
            ref,
            holdable,
            price,
            barcode,
            circ_modifier,
            circ_as_type,
            alert_message,
            pub_note,
            priv_note,
            internal_id,
            opac_visible,
            import_error,
            error_detail
        ) VALUES (
            NEW.id,
            item_data.definition,
            item_data.owning_lib,
            item_data.circ_lib,
            item_data.call_number,
            item_data.copy_number,
            item_data.status,
            item_data.location,
            item_data.circulate,
            item_data.deposit,
            item_data.deposit_amount,
            item_data.ref,
            item_data.holdable,
            item_data.price,
            item_data.barcode,
            item_data.circ_modifier,
            item_data.circ_as_type,
            item_data.alert_message,
            item_data.pub_note,
            item_data.priv_note,
            item_data.internal_id,
            item_data.opac_visible,
            item_data.import_error,
            item_data.error_detail
        );
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_items() OWNER TO postgres;

--
-- Name: ingest_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION ingest_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.bib_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_bib_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_bib_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_bib_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_marc() OWNER TO postgres;

--
-- Name: import_item; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE import_item (
    id bigint NOT NULL,
    record bigint NOT NULL,
    definition bigint NOT NULL,
    import_error text,
    error_detail text,
    imported_as bigint,
    import_time timestamp with time zone,
    owning_lib integer,
    circ_lib integer,
    call_number text,
    copy_number integer,
    status integer,
    location integer,
    circulate boolean,
    deposit boolean,
    deposit_amount numeric(8,2),
    ref boolean,
    holdable boolean,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    pub_note text,
    priv_note text,
    opac_visible boolean,
    internal_id bigint
);


ALTER TABLE vandelay.import_item OWNER TO postgres;

--
-- Name: ingest_items(bigint, bigint); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION ingest_items(import_id bigint, attr_def_id bigint) RETURNS SETOF import_item
    LANGUAGE plpgsql
    AS $$
DECLARE

    owning_lib      TEXT;
    circ_lib        TEXT;
    call_number     TEXT;
    copy_number     TEXT;
    status          TEXT;
    location        TEXT;
    circulate       TEXT;
    deposit         TEXT;
    deposit_amount  TEXT;
    ref             TEXT;
    holdable        TEXT;
    price           TEXT;
    barcode         TEXT;
    circ_modifier   TEXT;
    circ_as_type    TEXT;
    alert_message   TEXT;
    opac_visible    TEXT;
    pub_note        TEXT;
    priv_note       TEXT;
    internal_id     TEXT;

    attr_def        RECORD;
    tmp_attr_set    RECORD;
    attr_set        vandelay.import_item%ROWTYPE;

    xpath           TEXT;
    tmp_str         TEXT;

BEGIN

    SELECT * INTO attr_def FROM vandelay.import_item_attr_definition WHERE id = attr_def_id;

    IF FOUND THEN

        attr_set.definition := attr_def.id;

        -- Build the combined XPath

        owning_lib :=
            CASE
                WHEN attr_def.owning_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.owning_lib ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.owning_lib || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.owning_lib
            END;

        circ_lib :=
            CASE
                WHEN attr_def.circ_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_lib ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_lib || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_lib
            END;

        call_number :=
            CASE
                WHEN attr_def.call_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.call_number ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.call_number || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.call_number
            END;

        copy_number :=
            CASE
                WHEN attr_def.copy_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.copy_number ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.copy_number || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.copy_number
            END;

        status :=
            CASE
                WHEN attr_def.status IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.status ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.status || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.status
            END;

        location :=
            CASE
                WHEN attr_def.location IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.location ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.location || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.location
            END;

        circulate :=
            CASE
                WHEN attr_def.circulate IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circulate ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circulate || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circulate
            END;

        deposit :=
            CASE
                WHEN attr_def.deposit IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.deposit || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.deposit
            END;

        deposit_amount :=
            CASE
                WHEN attr_def.deposit_amount IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit_amount ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.deposit_amount || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.deposit_amount
            END;

        ref :=
            CASE
                WHEN attr_def.ref IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.ref ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.ref || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.ref
            END;

        holdable :=
            CASE
                WHEN attr_def.holdable IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.holdable ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.holdable || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.holdable
            END;

        price :=
            CASE
                WHEN attr_def.price IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.price ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.price || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.price
            END;

        barcode :=
            CASE
                WHEN attr_def.barcode IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.barcode ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.barcode || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.barcode
            END;

        circ_modifier :=
            CASE
                WHEN attr_def.circ_modifier IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_modifier ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_modifier || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_modifier
            END;

        circ_as_type :=
            CASE
                WHEN attr_def.circ_as_type IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_as_type ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_as_type || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_as_type
            END;

        alert_message :=
            CASE
                WHEN attr_def.alert_message IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.alert_message ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.alert_message || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.alert_message
            END;

        opac_visible :=
            CASE
                WHEN attr_def.opac_visible IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.opac_visible ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.opac_visible || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.opac_visible
            END;

        pub_note :=
            CASE
                WHEN attr_def.pub_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.pub_note ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.pub_note || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.pub_note
            END;
        priv_note :=
            CASE
                WHEN attr_def.priv_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.priv_note ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.priv_note || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.priv_note
            END;

        internal_id :=
            CASE
                WHEN attr_def.internal_id IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.internal_id ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.internal_id || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.internal_id
            END;



        xpath :=
            owning_lib      || '|' ||
            circ_lib        || '|' ||
            call_number     || '|' ||
            copy_number     || '|' ||
            status          || '|' ||
            location        || '|' ||
            circulate       || '|' ||
            deposit         || '|' ||
            deposit_amount  || '|' ||
            ref             || '|' ||
            holdable        || '|' ||
            price           || '|' ||
            barcode         || '|' ||
            circ_modifier   || '|' ||
            circ_as_type    || '|' ||
            alert_message   || '|' ||
            pub_note        || '|' ||
            priv_note       || '|' ||
            internal_id     || '|' ||
            opac_visible;

        FOR tmp_attr_set IN
                SELECT  *
                  FROM  oils_xpath_table( 'id', 'marc', 'vandelay.queued_bib_record', xpath, 'id = ' || import_id )
                            AS t( id INT, ol TEXT, clib TEXT, cn TEXT, cnum TEXT, cs TEXT, cl TEXT, circ TEXT,
                                  dep TEXT, dep_amount TEXT, r TEXT, hold TEXT, pr TEXT, bc TEXT, circ_mod TEXT,
                                  circ_as TEXT, amessage TEXT, note TEXT, pnote TEXT, internal_id TEXT, opac_vis TEXT )
        LOOP

            attr_set.import_error := NULL;
            attr_set.error_detail := NULL;
            attr_set.deposit_amount := NULL;
            attr_set.copy_number := NULL;
            attr_set.price := NULL;

            IF tmp_attr_set.pr != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.pr, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.price';
                    attr_set.error_detail := tmp_attr_set.pr; -- original value
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.price := tmp_str::NUMERIC(8,2); 
            END IF;

            IF tmp_attr_set.dep_amount != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.dep_amount, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.deposit_amount';
                    attr_set.error_detail := tmp_attr_set.dep_amount; 
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.deposit_amount := tmp_str::NUMERIC(8,2); 
            END IF;

            IF tmp_attr_set.cnum != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.cnum, E'[^0-9]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.copy_number';
                    attr_set.error_detail := tmp_attr_set.cnum; 
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.copy_number := tmp_str::INT; 
            END IF;

            IF tmp_attr_set.ol != '' THEN
                SELECT id INTO attr_set.owning_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.ol); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.owning_lib';
                    attr_set.error_detail := tmp_attr_set.ol;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.clib != '' THEN
                SELECT id INTO attr_set.circ_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.clib); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_lib';
                    attr_set.error_detail := tmp_attr_set.clib;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.cs != '' THEN
                SELECT id INTO attr_set.status FROM config.copy_status WHERE LOWER(name) = LOWER(tmp_attr_set.cs); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.status';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.circ_mod != '' THEN
                SELECT code INTO attr_set.circ_modifier FROM config.circ_modifier WHERE code = tmp_attr_set.circ_mod;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_modifier';
                    attr_set.error_detail := tmp_attr_set.circ_mod;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.circ_as != '' THEN
                SELECT code INTO attr_set.circ_as_type FROM config.coded_value_map WHERE ctype = 'item_type' AND code = tmp_attr_set.circ_as;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_as_type';
                    attr_set.error_detail := tmp_attr_set.circ_as;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.cl != '' THEN

                -- search up the org unit tree for a matching copy location
                WITH RECURSIVE anscestor_depth AS (
                    SELECT  ou.id,
                        out.depth AS depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                    WHERE ou.id = COALESCE(attr_set.owning_lib, attr_set.circ_lib)
                        UNION ALL
                    SELECT  ou.id,
                        out.depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                        JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
                ) SELECT  cpl.id INTO attr_set.location
                    FROM  anscestor_depth a
                        JOIN asset.copy_location cpl ON (cpl.owning_lib = a.id)
                    WHERE LOWER(cpl.name) = LOWER(tmp_attr_set.cl)
                    ORDER BY a.depth DESC
                    LIMIT 1; 

                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.location';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            attr_set.circulate      :=
                LOWER( SUBSTRING( tmp_attr_set.circ, 1, 1)) IN ('t','y','1')
                OR LOWER(tmp_attr_set.circ) = 'circulating'; -- BOOL

            attr_set.deposit        :=
                LOWER( SUBSTRING( tmp_attr_set.dep, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.dep) = 'deposit'; -- BOOL

            attr_set.holdable       :=
                LOWER( SUBSTRING( tmp_attr_set.hold, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.hold) = 'holdable'; -- BOOL

            attr_set.opac_visible   :=
                LOWER( SUBSTRING( tmp_attr_set.opac_vis, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.opac_vis) = 'visible'; -- BOOL

            attr_set.ref            :=
                LOWER( SUBSTRING( tmp_attr_set.r, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.r) = 'reference'; -- BOOL

            attr_set.call_number    := tmp_attr_set.cn; -- TEXT
            attr_set.barcode        := tmp_attr_set.bc; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.pub_note       := tmp_attr_set.note; -- TEXT,
            attr_set.priv_note      := tmp_attr_set.pnote; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.internal_id    := tmp_attr_set.internal_id::BIGINT;

            RETURN NEXT attr_set;

        END LOOP;

    END IF;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.ingest_items(import_id bigint, attr_def_id bigint) OWNER TO postgres;

--
-- Name: marc21_extract_all_fixed_fields(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION marc21_extract_all_fixed_fields(marc text) RETURNS SETOF biblio.record_ff_map
    LANGUAGE plpgsql
    AS $$
DECLARE
    tag_data    TEXT;
    rtype       TEXT;
    ff_pos      RECORD;
    output      biblio.record_ff_map%ROWTYPE;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;

    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE rec_type = rtype ORDER BY tag DESC LOOP
        output.ff_name  := ff_pos.fixed_field;
        output.ff_value := NULL;

        IF ff_pos.tag = 'ldr' THEN
            output.ff_value := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF output.ff_value IS NOT NULL THEN
                output.ff_value := SUBSTRING( output.ff_value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN NEXT output;
                output.ff_value := NULL;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                output.ff_value := SUBSTRING( tag_data, ff_pos.start_pos + 1, ff_pos.length );
                IF output.ff_value IS NULL THEN output.ff_value := REPEAT( ff_pos.default_val, ff_pos.length ); END IF;
                RETURN NEXT output;
                output.ff_value := NULL;
            END LOOP;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_all_fixed_fields(marc text) OWNER TO postgres;

--
-- Name: marc21_extract_fixed_field(text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION marc21_extract_fixed_field(marc text, ff text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    rtype       TEXT;
    ff_pos      RECORD;
    tag_data    RECORD;
    val         TEXT;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;
    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = ff AND rec_type = rtype ORDER BY tag DESC LOOP
        IF ff_pos.tag = 'ldr' THEN
            val := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF val IS NOT NULL THEN
                val := SUBSTRING( val, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                val := SUBSTRING( tag_data.value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END LOOP;
        END IF;
        val := REPEAT( ff_pos.default_val, ff_pos.length );
        RETURN val;
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_fixed_field(marc text, ff text) OWNER TO postgres;

--
-- Name: marc21_physical_characteristics(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION marc21_physical_characteristics(marc text) RETURNS SETOF biblio.marc21_physical_characteristics
    LANGUAGE plpgsql
    AS $$
DECLARE
    rowid   INT := 0;
    _007    TEXT;
    ptype   config.marc21_physical_characteristic_type_map%ROWTYPE;
    psf     config.marc21_physical_characteristic_subfield_map%ROWTYPE;
    pval    config.marc21_physical_characteristic_value_map%ROWTYPE;
    retval  biblio.marc21_physical_characteristics%ROWTYPE;
BEGIN

    _007 := oils_xpath_string( '//*[@tag="007"]', marc );

    IF _007 IS NOT NULL AND _007 <> '' THEN
        SELECT * INTO ptype FROM config.marc21_physical_characteristic_type_map WHERE ptype_key = SUBSTRING( _007, 1, 1 );

        IF ptype.ptype_key IS NOT NULL THEN
            FOR psf IN SELECT * FROM config.marc21_physical_characteristic_subfield_map WHERE ptype_key = ptype.ptype_key LOOP
                SELECT * INTO pval FROM config.marc21_physical_characteristic_value_map WHERE ptype_subfield = psf.id AND value = SUBSTRING( _007, psf.start_pos + 1, psf.length );

                IF pval.id IS NOT NULL THEN
                    rowid := rowid + 1;
                    retval.id := rowid;
                    retval.ptype := ptype.ptype_key;
                    retval.subfield := psf.id;
                    retval.value := pval.id;
                    RETURN NEXT retval;
                END IF;

            END LOOP;
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_physical_characteristics(marc text) OWNER TO postgres;

--
-- Name: marc21_record_type(text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION marc21_record_type(marc text) RETURNS config.marc21_rec_type_map
    LANGUAGE plpgsql
    AS $$
DECLARE
	ldr         TEXT;
	tval        TEXT;
	tval_rec    RECORD;
	bval        TEXT;
	bval_rec    RECORD;
    retval      config.marc21_rec_type_map%ROWTYPE;
BEGIN
    ldr := oils_xpath_string( '//*[local-name()="leader"]', marc );

    IF ldr IS NULL OR ldr = '' THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
        RETURN retval;
    END IF;

    SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
    SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


    tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
    bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

    -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

    SELECT * INTO retval FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';


    IF retval.code IS NULL THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
    END IF;

    RETURN retval;
END;
$$;


ALTER FUNCTION vandelay.marc21_record_type(marc text) OWNER TO postgres;

--
-- Name: match_bib_record(); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION match_bib_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.bib_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.bib_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM biblio.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.bib_match (queued_record, eg_record, match_score, quality) 
                SELECT
                    NEW.id, 
                    b.id,
                    9999,
                    -- note: no match_set means quality==0
                    vandelay.measure_record_quality( b.marc, match_set )
                FROM biblio.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_marcxml(match_set, NEW.marc) LOOP

        INSERT INTO vandelay.bib_match ( queued_record, eg_record, match_score, quality )
            SELECT  
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_record_quality( b.marc, match_set )
	        FROM  biblio.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_bib_record() OWNER TO postgres;

--
-- Name: match_set_test_marcxml(integer, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION match_set_test_marcxml(match_set_id integer, record_xml text) RETURNS SETOF match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    svf_rstore  HSTORE;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);
    svf_rstore := vandelay.extract_rec_attrs(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set(match_set_id, tags_rstore);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT ARRAY_TO_STRING(
        ARRAY_ACCUM('COALESCE(n' || q::TEXT || '.quality, 0)'), ' + '
    ) INTO coal FROM _vandelay_tmp_qrows;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT ARRAY_TO_STRING(ARRAY_ACCUM(j), E'\n') INTO joins
        FROM _vandelay_tmp_jrows;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n' || 'JOIN biblio.record_entry bre ON (bre.id = record) ' || 'WHERE ' || wq || ' AND not bre.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore, svf_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows;
    DROP TABLE _vandelay_tmp_jrows;
    RETURN;
END;

$$;


ALTER FUNCTION vandelay.match_set_test_marcxml(match_set_id integer, record_xml text) OWNER TO postgres;

--
-- Name: measure_record_quality(text, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION measure_record_quality(xml text, match_set_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    out_q   INT := 0;
    rvalue  TEXT;
    test    vandelay.match_set_quality%ROWTYPE;
BEGIN

    FOR test IN SELECT * FROM vandelay.match_set_quality WHERE match_set = match_set_id LOOP
        IF test.tag IS NOT NULL THEN
            FOR rvalue IN SELECT value FROM vandelay.flatten_marc( xml ) WHERE tag = test.tag AND subfield = test.subfield LOOP
                IF test.value = rvalue THEN
                    out_q := out_q + test.quality;
                END IF;
            END LOOP;
        ELSE
            IF test.value = vandelay.extract_rec_attrs(xml, ARRAY[test.svf]) -> test.svf THEN
                out_q := out_q + test.quality;
            END IF;
        END IF;
    END LOOP;

    RETURN out_q;
END;
$$;


ALTER FUNCTION vandelay.measure_record_quality(xml text, match_set_id integer) OWNER TO postgres;

--
-- Name: merge_record_xml(text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION merge_record_xml(target_marc text, template_marc text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    replace_rule    TEXT;
    tmp_marc        TEXT;
    trgt_marc        TEXT;
    tmpl_marc        TEXT;
    match_count     INT;
BEGIN

    IF target_marc IS NULL OR template_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for target or template record';
        RETURN NULL;
    END IF;

    dyn_profile := vandelay.compile_profile( template_marc );

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN NULL;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return what we were given.
        RETURN target_marc;
    ELSIF dyn_profile.replace_rule <> '' THEN
        trgt_marc = target_marc;
        tmpl_marc = template_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        tmp_marc = target_marc;
        trgt_marc = template_marc;
        tmpl_marc = tmp_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    RETURN vandelay.merge_record_xml( trgt_marc, tmpl_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule );

END;
$$;


ALTER FUNCTION vandelay.merge_record_xml(target_marc text, template_marc text) OWNER TO postgres;

--
-- Name: merge_record_xml(text, text, text, text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.replace_field( vandelay.add_field( vandelay.strip_field( $1, $5) , $2, $3 ), $2, $4);
$_$;


ALTER FUNCTION vandelay.merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) OWNER TO postgres;

--
-- Name: overlay_authority_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    v_marc          TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    SELECT  b.marc INTO eg_marc
      FROM  authority.record_entry b
            JOIN vandelay.authority_match m ON (m.eg_record = b.id AND m.queued_record = import_id)
      LIMIT 1;

    SELECT  q.marc INTO v_marc
      FROM  vandelay.queued_record q
            JOIN vandelay.authority_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or authority record';
        RETURN FALSE;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  authority.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule )
      WHERE id = eg_id;

    IF FOUND THEN
        UPDATE  vandelay.queued_authority_record
          SET   imported_as = eg_id,
                import_time = NOW()
          WHERE id = import_id;
        RETURN TRUE;
    END IF;

    -- RAISE NOTICE 'update of authority.record_entry failed';

    RETURN FALSE;

END;
$$;


ALTER FUNCTION vandelay.overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: overlay_bib_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    editor_id       INT;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    v_marc          TEXT;
    replace_rule    TEXT;
BEGIN

    SELECT  q.marc INTO v_marc
      FROM  vandelay.queued_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    IF v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or bib record';
        RETURN FALSE;
    END IF;

    IF vandelay.template_overlay_bib_record( v_marc, eg_id, merge_profile_id) THEN
        UPDATE  vandelay.queued_bib_record
          SET   imported_as = eg_id,
                import_time = NOW()
          WHERE id = import_id;

        editor_string := (oils_xpath('//*[@tag="905"]/*[@code="u"]/text()',v_marc))[1];

        IF editor_string IS NOT NULL AND editor_string <> '' THEN
            SELECT usr INTO editor_id FROM actor.card WHERE barcode = editor_string;

            IF editor_id IS NULL THEN
                SELECT id INTO editor_id FROM actor.usr WHERE usrname = editor_string;
            END IF;

            IF editor_id IS NOT NULL THEN
                UPDATE biblio.record_entry SET editor = editor_id WHERE id = eg_id;
            END IF;
        END IF;

        RETURN TRUE;
    END IF;

    -- RAISE NOTICE 'update of biblio.record_entry failed';

    RETURN FALSE;

END;
$$;


ALTER FUNCTION vandelay.overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO postgres;

--
-- Name: replace_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION replace_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    xml_output TEXT;
    parsed_target TEXT;
    curr_field TEXT;
BEGIN

    parsed_target := vandelay.strip_field( target_xml, ''); -- this dance normalizes the format of the xml for the IF below
    xml_output := parsed_target; -- if there are no replace rules, just return the input

    FOR curr_field IN SELECT UNNEST( STRING_TO_ARRAY(field, ',') ) LOOP -- naive split, but it's the same we use in the perl

        xml_output := vandelay.strip_field( parsed_target, curr_field);

        IF xml_output <> parsed_target  AND curr_field ~ E'~' THEN
            -- we removed something, and there was a regexp restriction in the curr_field definition, so proceed
            xml_output := vandelay.add_field( xml_output, source_xml, curr_field, 1 );
        ELSIF curr_field !~ E'~' THEN
            -- No regexp restriction, add the curr_field
            xml_output := vandelay.add_field( xml_output, source_xml, curr_field, 0 );
        END IF;

        parsed_target := xml_output; -- in prep for any following loop iterations

    END LOOP;

    RETURN xml_output;
END;
$$;


ALTER FUNCTION vandelay.replace_field(target_xml text, source_xml text, field text) OWNER TO postgres;

--
-- Name: strip_field(text, text); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION strip_field(xml text, field text) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $xml = shift;
    my $r = MARC::Record->new_from_xml( $xml );

    return $xml unless ($r);

    my $field_spec = shift;
    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    for my $f ( keys %fields) {
        for my $to_field ($r->field( $f )) {
            if (exists($fields{$f}{match})) {
                next unless (grep { $_ =~ $fields{$f}{match}{re} } $to_field->subfield($fields{$f}{match}{sf}));
            }

            if ( @{$fields{$f}{sf}} ) {
                $to_field->delete_subfield(code => $fields{$f}{sf});
            } else {
                $r->delete_field( $to_field );
            }
        }
    }

    $xml = $r->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;

    return $xml;

$_X$;


ALTER FUNCTION vandelay.strip_field(xml text, field text) OWNER TO postgres;

--
-- Name: template_overlay_bib_record(text, bigint); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION template_overlay_bib_record(v_marc text, eg_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT vandelay.template_overlay_bib_record( $1, $2, NULL);
$_$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint) OWNER TO postgres;

--
-- Name: template_overlay_bib_record(text, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: postgres
--

CREATE FUNCTION template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    editor_id       INT;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    SELECT  b.marc INTO eg_marc
      FROM  biblio.record_entry b
      WHERE b.id = eg_id
      LIMIT 1;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for template or bib record';
        RETURN FALSE;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  biblio.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule )
      WHERE id = eg_id;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'update of biblio.record_entry failed';
        RETURN FALSE;
    END IF;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) OWNER TO postgres;

SET search_path = evergreen, pg_catalog;

--
-- Name: array_accum(anyelement); Type: AGGREGATE; Schema: evergreen; Owner: postgres
--

CREATE AGGREGATE array_accum(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE evergreen.array_accum(anyelement) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: agg_text(text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE agg_text(text) (
    SFUNC = text_concat,
    STYPE = text
);


ALTER AGGREGATE public.agg_text(text) OWNER TO postgres;

--
-- Name: first(anyelement); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE first(anyelement) (
    SFUNC = first_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.first(anyelement) OWNER TO postgres;

--
-- Name: last(anyelement); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE last(anyelement) (
    SFUNC = last_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.last(anyelement) OWNER TO postgres;

--
-- Name: danish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY danish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'danish' );


ALTER TEXT SEARCH DICTIONARY public.danish_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY danish_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY danish_nostop IS 'danish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: dutch_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY dutch_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'dutch' );


ALTER TEXT SEARCH DICTIONARY public.dutch_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY dutch_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY dutch_nostop IS 'dutch snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: english_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY english_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'english' );


ALTER TEXT SEARCH DICTIONARY public.english_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY english_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY english_nostop IS 'english snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: finnish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY finnish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'finnish' );


ALTER TEXT SEARCH DICTIONARY public.finnish_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY finnish_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY finnish_nostop IS 'finnish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: french_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY french_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'french' );


ALTER TEXT SEARCH DICTIONARY public.french_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY french_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY french_nostop IS 'french snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: german_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY german_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'german' );


ALTER TEXT SEARCH DICTIONARY public.german_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY german_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY german_nostop IS 'german snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: hungarian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY hungarian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'hungarian' );


ALTER TEXT SEARCH DICTIONARY public.hungarian_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY hungarian_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY hungarian_nostop IS 'hungarian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: italian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY italian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'italian' );


ALTER TEXT SEARCH DICTIONARY public.italian_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY italian_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY italian_nostop IS 'italian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: norwegian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY norwegian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'norwegian' );


ALTER TEXT SEARCH DICTIONARY public.norwegian_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY norwegian_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY norwegian_nostop IS 'norwegian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: portuguese_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY portuguese_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'portuguese' );


ALTER TEXT SEARCH DICTIONARY public.portuguese_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY portuguese_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY portuguese_nostop IS 'portuguese snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: romanian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY romanian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'romanian' );


ALTER TEXT SEARCH DICTIONARY public.romanian_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY romanian_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY romanian_nostop IS 'romanian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: russian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY russian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'russian' );


ALTER TEXT SEARCH DICTIONARY public.russian_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY russian_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY russian_nostop IS 'russian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: spanish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY spanish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'spanish' );


ALTER TEXT SEARCH DICTIONARY public.spanish_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY spanish_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY spanish_nostop IS 'spanish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: swedish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY swedish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'swedish' );


ALTER TEXT SEARCH DICTIONARY public.swedish_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY swedish_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY swedish_nostop IS 'swedish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: turkish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH DICTIONARY turkish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'turkish' );


ALTER TEXT SEARCH DICTIONARY public.turkish_nostop OWNER TO postgres;

--
-- Name: TEXT SEARCH DICTIONARY turkish_nostop; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON TEXT SEARCH DICTIONARY turkish_nostop IS 'turkish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: author; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION author (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.author OWNER TO postgres;

--
-- Name: danish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION danish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR asciiword WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_asciipart WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR asciihword WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.danish_nostop OWNER TO postgres;

--
-- Name: default; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION "default" (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public."default" OWNER TO postgres;

--
-- Name: dutch_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION dutch_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR asciiword WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_asciipart WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR asciihword WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop OWNER TO postgres;

--
-- Name: english_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION english_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.english_nostop OWNER TO postgres;

--
-- Name: finnish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION finnish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR asciiword WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_asciipart WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR asciihword WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop OWNER TO postgres;

--
-- Name: french_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION french_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR asciiword WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_asciipart WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR asciihword WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.french_nostop OWNER TO postgres;

--
-- Name: german_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION german_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR asciiword WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_asciipart WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR asciihword WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.german_nostop OWNER TO postgres;

--
-- Name: hungarian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION hungarian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR asciiword WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_asciipart WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR asciihword WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop OWNER TO postgres;

--
-- Name: identifier; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION identifier (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.identifier OWNER TO postgres;

--
-- Name: italian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION italian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR asciiword WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_asciipart WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR asciihword WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.italian_nostop OWNER TO postgres;

--
-- Name: keyword; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION keyword (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.keyword OWNER TO postgres;

--
-- Name: norwegian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION norwegian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR asciiword WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_asciipart WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR asciihword WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop OWNER TO postgres;

--
-- Name: portuguese_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION portuguese_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR asciiword WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_asciipart WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR asciihword WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop OWNER TO postgres;

--
-- Name: romanian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION romanian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR asciiword WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_asciipart WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR asciihword WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop OWNER TO postgres;

--
-- Name: russian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION russian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR asciiword WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_asciipart WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR asciihword WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.russian_nostop OWNER TO postgres;

--
-- Name: series; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION series (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.series OWNER TO postgres;

--
-- Name: spanish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION spanish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR asciiword WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_asciipart WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR asciihword WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop OWNER TO postgres;

--
-- Name: subject; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION subject (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.subject OWNER TO postgres;

--
-- Name: swedish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION swedish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR asciiword WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_asciipart WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR asciihword WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop OWNER TO postgres;

--
-- Name: title; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION title (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.title OWNER TO postgres;

--
-- Name: turkish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: postgres
--

CREATE TEXT SEARCH CONFIGURATION turkish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR asciiword WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_asciipart WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR asciihword WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop OWNER TO postgres;

SET search_path = acq, pg_catalog;

--
-- Name: acq_lineitem_history; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE acq_lineitem_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint
);


ALTER TABLE acq.acq_lineitem_history OWNER TO postgres;

--
-- Name: lineitem; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem (
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text DEFAULT 'new'::text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint,
    CONSTRAINT picklist_or_po CHECK (((picklist IS NOT NULL) OR (purchase_order IS NOT NULL)))
);


ALTER TABLE acq.lineitem OWNER TO postgres;

--
-- Name: acq_lineitem_lifecycle; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW acq_lineitem_lifecycle AS
    SELECT (-1), now() AS audit_time, '-'::text AS audit_action, lineitem.id, lineitem.creator, lineitem.editor, lineitem.selector, lineitem.provider, lineitem.purchase_order, lineitem.picklist, lineitem.expected_recv_time, lineitem.create_time, lineitem.edit_time, lineitem.marc, lineitem.eg_bib_id, lineitem.source_label, lineitem.state, lineitem.cancel_reason, lineitem.estimated_unit_price, lineitem.claim_policy, lineitem.queued_record FROM lineitem UNION ALL SELECT acq_lineitem_history.audit_id AS "?column?", acq_lineitem_history.audit_time, acq_lineitem_history.audit_action, acq_lineitem_history.id, acq_lineitem_history.creator, acq_lineitem_history.editor, acq_lineitem_history.selector, acq_lineitem_history.provider, acq_lineitem_history.purchase_order, acq_lineitem_history.picklist, acq_lineitem_history.expected_recv_time, acq_lineitem_history.create_time, acq_lineitem_history.edit_time, acq_lineitem_history.marc, acq_lineitem_history.eg_bib_id, acq_lineitem_history.source_label, acq_lineitem_history.state, acq_lineitem_history.cancel_reason, acq_lineitem_history.estimated_unit_price, acq_lineitem_history.claim_policy, acq_lineitem_history.queued_record FROM acq_lineitem_history;


ALTER TABLE acq.acq_lineitem_lifecycle OWNER TO postgres;

--
-- Name: acq_lineitem_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE acq_lineitem_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_lineitem_pkey_seq OWNER TO postgres;

--
-- Name: acq_purchase_order_history; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE acq_purchase_order_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    provider integer NOT NULL,
    state text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean NOT NULL
);


ALTER TABLE acq.acq_purchase_order_history OWNER TO postgres;

--
-- Name: purchase_order; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE purchase_order (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    provider integer NOT NULL,
    state text DEFAULT 'new'::text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean DEFAULT false NOT NULL,
    CONSTRAINT valid_po_state CHECK ((state = ANY (ARRAY['new'::text, 'pending'::text, 'on-order'::text, 'received'::text, 'cancelled'::text])))
);


ALTER TABLE acq.purchase_order OWNER TO postgres;

--
-- Name: acq_purchase_order_lifecycle; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW acq_purchase_order_lifecycle AS
    SELECT (-1), now() AS audit_time, '-'::text AS audit_action, purchase_order.id, purchase_order.owner, purchase_order.creator, purchase_order.editor, purchase_order.ordering_agency, purchase_order.create_time, purchase_order.edit_time, purchase_order.provider, purchase_order.state, purchase_order.order_date, purchase_order.name, purchase_order.cancel_reason, purchase_order.prepayment_required FROM purchase_order UNION ALL SELECT acq_purchase_order_history.audit_id AS "?column?", acq_purchase_order_history.audit_time, acq_purchase_order_history.audit_action, acq_purchase_order_history.id, acq_purchase_order_history.owner, acq_purchase_order_history.creator, acq_purchase_order_history.editor, acq_purchase_order_history.ordering_agency, acq_purchase_order_history.create_time, acq_purchase_order_history.edit_time, acq_purchase_order_history.provider, acq_purchase_order_history.state, acq_purchase_order_history.order_date, acq_purchase_order_history.name, acq_purchase_order_history.cancel_reason, acq_purchase_order_history.prepayment_required FROM acq_purchase_order_history;


ALTER TABLE acq.acq_purchase_order_lifecycle OWNER TO postgres;

--
-- Name: acq_purchase_order_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE acq_purchase_order_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_purchase_order_pkey_seq OWNER TO postgres;

--
-- Name: fund; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund (
    id integer NOT NULL,
    org integer NOT NULL,
    name text NOT NULL,
    year integer DEFAULT date_part('year'::text, now()) NOT NULL,
    currency_type text NOT NULL,
    code text,
    rollover boolean DEFAULT false NOT NULL,
    propagate boolean DEFAULT true NOT NULL,
    active boolean DEFAULT true NOT NULL,
    balance_warning_percent integer,
    balance_stop_percent integer,
    CONSTRAINT acq_fund_rollover_implies_propagate CHECK ((propagate OR (NOT rollover)))
);


ALTER TABLE acq.fund OWNER TO postgres;

--
-- Name: fund_allocation; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_allocation (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    fund integer NOT NULL,
    amount numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.fund_allocation OWNER TO postgres;

--
-- Name: funding_source; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE funding_source (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text
);


ALTER TABLE acq.funding_source OWNER TO postgres;

--
-- Name: all_fund_allocation_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW all_fund_allocation_total AS
    SELECT f.id AS fund, COALESCE((sum((a.amount * exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2), (0)::numeric) AS amount FROM ((fund f LEFT JOIN fund_allocation a ON ((a.fund = f.id))) LEFT JOIN funding_source s ON ((a.funding_source = s.id))) GROUP BY f.id;


ALTER TABLE acq.all_fund_allocation_total OWNER TO postgres;

--
-- Name: fund_debit; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_debit (
    id integer NOT NULL,
    fund integer NOT NULL,
    origin_amount numeric NOT NULL,
    origin_currency_type text NOT NULL,
    amount numeric NOT NULL,
    encumbrance boolean DEFAULT true NOT NULL,
    debit_type text NOT NULL,
    xfer_destination integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.fund_debit OWNER TO postgres;

--
-- Name: all_fund_combined_balance; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW all_fund_combined_balance AS
    SELECT a.fund, (a.amount - COALESCE(c.amount, (0)::numeric)) AS amount FROM (all_fund_allocation_total a LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit GROUP BY fund_debit.fund) c USING (fund));


ALTER TABLE acq.all_fund_combined_balance OWNER TO postgres;

--
-- Name: all_fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW all_fund_encumbrance_total AS
    SELECT f.id AS fund, COALESCE(encumb.amount, (0)::numeric) AS amount FROM (fund f LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit WHERE fund_debit.encumbrance GROUP BY fund_debit.fund) encumb ON ((f.id = encumb.fund)));


ALTER TABLE acq.all_fund_encumbrance_total OWNER TO postgres;

--
-- Name: all_fund_spent_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW all_fund_spent_total AS
    SELECT f.id AS fund, COALESCE(spent.amount, (0)::numeric) AS amount FROM (fund f LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit WHERE (NOT fund_debit.encumbrance) GROUP BY fund_debit.fund) spent ON ((f.id = spent.fund)));


ALTER TABLE acq.all_fund_spent_total OWNER TO postgres;

--
-- Name: all_fund_spent_balance; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW all_fund_spent_balance AS
    SELECT c.fund, (c.amount - d.amount) AS amount FROM (all_fund_allocation_total c LEFT JOIN all_fund_spent_total d USING (fund));


ALTER TABLE acq.all_fund_spent_balance OWNER TO postgres;

--
-- Name: cancel_reason; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE cancel_reason (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    label text NOT NULL,
    description text NOT NULL,
    keep_debits boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.cancel_reason OWNER TO postgres;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE cancel_reason_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.cancel_reason_id_seq OWNER TO postgres;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE cancel_reason_id_seq OWNED BY cancel_reason.id;


--
-- Name: claim; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim (
    id integer NOT NULL,
    type integer NOT NULL,
    lineitem_detail bigint NOT NULL
);


ALTER TABLE acq.claim OWNER TO postgres;

--
-- Name: claim_event; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.claim_event OWNER TO postgres;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_claim_seq OWNER TO postgres;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_event_claim_seq OWNED BY claim_event.claim;


--
-- Name: claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_id_seq OWNER TO postgres;

--
-- Name: claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_event_id_seq OWNED BY claim_event.id;


--
-- Name: claim_event_type; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim_event_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    library_initiated boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.claim_event_type OWNER TO postgres;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_event_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_type_id_seq OWNER TO postgres;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_event_type_id_seq OWNED BY claim_event_type.id;


--
-- Name: claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_id_seq OWNER TO postgres;

--
-- Name: claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_id_seq OWNED BY claim.id;


--
-- Name: claim_policy; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim_policy (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_policy OWNER TO postgres;

--
-- Name: claim_policy_action; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim_policy_action (
    id integer NOT NULL,
    claim_policy integer NOT NULL,
    action_interval interval NOT NULL,
    action integer NOT NULL
);


ALTER TABLE acq.claim_policy_action OWNER TO postgres;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_policy_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_action_id_seq OWNER TO postgres;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_policy_action_id_seq OWNED BY claim_policy_action.id;


--
-- Name: claim_policy_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_policy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_id_seq OWNER TO postgres;

--
-- Name: claim_policy_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_policy_id_seq OWNED BY claim_policy.id;


--
-- Name: claim_type; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE claim_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_type OWNER TO postgres;

--
-- Name: claim_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE claim_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_type_id_seq OWNER TO postgres;

--
-- Name: claim_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE claim_type_id_seq OWNED BY claim_type.id;


--
-- Name: currency_type; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE currency_type (
    code text NOT NULL,
    label text
);


ALTER TABLE acq.currency_type OWNER TO postgres;

--
-- Name: debit_attribution; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE debit_attribution (
    id integer NOT NULL,
    fund_debit integer NOT NULL,
    debit_amount numeric NOT NULL,
    funding_source_credit integer,
    credit_amount numeric
);


ALTER TABLE acq.debit_attribution OWNER TO postgres;

--
-- Name: distribution_formula; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE distribution_formula (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    skip_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE acq.distribution_formula OWNER TO postgres;

--
-- Name: distribution_formula_application; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE distribution_formula_application (
    id bigint NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    formula integer NOT NULL,
    lineitem integer NOT NULL
);


ALTER TABLE acq.distribution_formula_application OWNER TO postgres;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE distribution_formula_application_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_application_id_seq OWNER TO postgres;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE distribution_formula_application_id_seq OWNED BY distribution_formula_application.id;


--
-- Name: distribution_formula_entry; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE distribution_formula_entry (
    id integer NOT NULL,
    formula integer NOT NULL,
    "position" integer NOT NULL,
    item_count integer NOT NULL,
    owning_lib integer,
    location integer,
    fund integer,
    circ_modifier text,
    collection_code text,
    CONSTRAINT acqdfe_must_be_somewhere CHECK (((owning_lib IS NOT NULL) OR (location IS NOT NULL)))
);


ALTER TABLE acq.distribution_formula_entry OWNER TO postgres;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE distribution_formula_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_entry_id_seq OWNER TO postgres;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE distribution_formula_entry_id_seq OWNED BY distribution_formula_entry.id;


--
-- Name: distribution_formula_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE distribution_formula_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_id_seq OWNER TO postgres;

--
-- Name: distribution_formula_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE distribution_formula_id_seq OWNED BY distribution_formula.id;


SET search_path = config, pg_catalog;

--
-- Name: remote_account; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE remote_account (
    id integer NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    username text,
    password text,
    account text,
    path text,
    owner integer NOT NULL,
    last_activity timestamp with time zone
);


ALTER TABLE config.remote_account OWNER TO postgres;

SET search_path = acq, pg_catalog;

--
-- Name: edi_account; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE edi_account (
    provider integer NOT NULL,
    in_dir text,
    vendcode text,
    vendacct text
)
INHERITS (config.remote_account);


ALTER TABLE acq.edi_account OWNER TO postgres;

--
-- Name: edi_message; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE edi_message (
    id integer NOT NULL,
    account integer,
    remote_file text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text DEFAULT 'new'::text NOT NULL,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text NOT NULL,
    CONSTRAINT status_value CHECK ((status = ANY (ARRAY['new'::text, 'translated'::text, 'trans_error'::text, 'processed'::text, 'proc_error'::text, 'delete_error'::text, 'retry'::text, 'complete'::text]))),
    CONSTRAINT valid_message_type CHECK ((message_type = ANY (ARRAY['ORDERS'::text, 'ORDRSP'::text, 'INVOIC'::text, 'OSTENQ'::text, 'OSTRPT'::text])))
);


ALTER TABLE acq.edi_message OWNER TO postgres;

--
-- Name: edi_message_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE edi_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.edi_message_id_seq OWNER TO postgres;

--
-- Name: edi_message_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE edi_message_id_seq OWNED BY edi_message.id;


--
-- Name: exchange_rate; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE exchange_rate (
    id integer NOT NULL,
    from_currency text NOT NULL,
    to_currency text NOT NULL,
    ratio numeric NOT NULL
);


ALTER TABLE acq.exchange_rate OWNER TO postgres;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE exchange_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.exchange_rate_id_seq OWNER TO postgres;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE exchange_rate_id_seq OWNED BY exchange_rate.id;


--
-- Name: fiscal_calendar; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fiscal_calendar (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fiscal_calendar OWNER TO postgres;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fiscal_calendar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_calendar_id_seq OWNER TO postgres;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fiscal_calendar_id_seq OWNED BY fiscal_calendar.id;


--
-- Name: fiscal_year; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fiscal_year (
    id integer NOT NULL,
    calendar integer NOT NULL,
    year integer NOT NULL,
    year_begin timestamp with time zone NOT NULL,
    year_end timestamp with time zone NOT NULL
);


ALTER TABLE acq.fiscal_year OWNER TO postgres;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fiscal_year_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_year_id_seq OWNER TO postgres;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fiscal_year_id_seq OWNED BY fiscal_year.id;


--
-- Name: fund_allocation_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_allocation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_id_seq OWNER TO postgres;

--
-- Name: fund_allocation_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_allocation_id_seq OWNED BY fund_allocation.id;


--
-- Name: fund_allocation_percent; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_allocation_percent (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    org integer NOT NULL,
    fund_code text,
    percent numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT percentage_range CHECK (((percent >= (0)::numeric) AND (percent <= (100)::numeric)))
);


ALTER TABLE acq.fund_allocation_percent OWNER TO postgres;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_allocation_percent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_percent_id_seq OWNER TO postgres;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_allocation_percent_id_seq OWNED BY fund_allocation_percent.id;


--
-- Name: fund_allocation_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_allocation_total AS
    SELECT a.fund, (sum((a.amount * exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2) AS amount FROM ((fund_allocation a JOIN fund f ON ((a.fund = f.id))) JOIN funding_source s ON ((a.funding_source = s.id))) GROUP BY a.fund;


ALTER TABLE acq.fund_allocation_total OWNER TO postgres;

--
-- Name: fund_debit_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_debit_total AS
    SELECT fund.id AS fund, sum(COALESCE(fund_debit.amount, (0)::numeric)) AS amount FROM (fund fund LEFT JOIN fund_debit fund_debit ON ((fund.id = fund_debit.fund))) GROUP BY fund.id;


ALTER TABLE acq.fund_debit_total OWNER TO postgres;

--
-- Name: fund_combined_balance; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_combined_balance AS
    SELECT c.fund, (c.amount - COALESCE(d.amount, 0.0)) AS amount FROM (fund_allocation_total c LEFT JOIN fund_debit_total d USING (fund));


ALTER TABLE acq.fund_combined_balance OWNER TO postgres;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_debit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_debit_id_seq OWNER TO postgres;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_debit_id_seq OWNED BY fund_debit.id;


--
-- Name: fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_encumbrance_total AS
    SELECT fund.id AS fund, sum(COALESCE(fund_debit.amount, (0)::numeric)) AS amount FROM (fund fund LEFT JOIN fund_debit fund_debit ON ((fund.id = fund_debit.fund))) WHERE fund_debit.encumbrance GROUP BY fund.id;


ALTER TABLE acq.fund_encumbrance_total OWNER TO postgres;

--
-- Name: fund_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_id_seq OWNER TO postgres;

--
-- Name: fund_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_id_seq OWNED BY fund.id;


--
-- Name: fund_spent_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_spent_total AS
    SELECT fund.id AS fund, sum(COALESCE(fund_debit.amount, (0)::numeric)) AS amount FROM (fund fund LEFT JOIN fund_debit fund_debit ON ((fund.id = fund_debit.fund))) WHERE (NOT fund_debit.encumbrance) GROUP BY fund.id;


ALTER TABLE acq.fund_spent_total OWNER TO postgres;

--
-- Name: fund_spent_balance; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW fund_spent_balance AS
    SELECT c.fund, (c.amount - COALESCE(d.amount, 0.0)) AS amount FROM (fund_allocation_total c LEFT JOIN fund_spent_total d USING (fund));


ALTER TABLE acq.fund_spent_balance OWNER TO postgres;

--
-- Name: fund_tag; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_tag (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fund_tag OWNER TO postgres;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_id_seq OWNER TO postgres;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_tag_id_seq OWNED BY fund_tag.id;


--
-- Name: fund_tag_map; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_tag_map (
    id integer NOT NULL,
    fund integer NOT NULL,
    tag integer
);


ALTER TABLE acq.fund_tag_map OWNER TO postgres;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_tag_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_map_id_seq OWNER TO postgres;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_tag_map_id_seq OWNED BY fund_tag_map.id;


--
-- Name: fund_transfer; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE fund_transfer (
    id integer NOT NULL,
    src_fund integer NOT NULL,
    src_amount numeric NOT NULL,
    dest_fund integer,
    dest_amount numeric,
    transfer_time timestamp with time zone DEFAULT now() NOT NULL,
    transfer_user integer NOT NULL,
    note text,
    funding_source_credit integer NOT NULL
);


ALTER TABLE acq.fund_transfer OWNER TO postgres;

--
-- Name: TABLE fund_transfer; Type: COMMENT; Schema: acq; Owner: postgres
--

COMMENT ON TABLE fund_transfer IS '
Fund Transfer
Each row represents the transfer of money from a source fund
to a destination fund.  There should be corresponding entries
in acq.fund_allocation.  The purpose of acq.fund_transfer is
to record how much money moved from which fund to which other
fund.

The presence of two amount fields, rather than one, reflects
the possibility that the two funds are denominated in different
currencies.  If they use the same currency type, the two
amounts should be the same.
';


--
-- Name: fund_transfer_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE fund_transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_transfer_id_seq OWNER TO postgres;

--
-- Name: fund_transfer_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE fund_transfer_id_seq OWNED BY fund_transfer.id;


--
-- Name: funding_source_allocation_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW funding_source_allocation_total AS
    SELECT a.funding_source, (sum(a.amount))::numeric(100,2) AS amount FROM fund_allocation a GROUP BY a.funding_source;


ALTER TABLE acq.funding_source_allocation_total OWNER TO postgres;

--
-- Name: funding_source_credit; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE funding_source_credit (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    amount numeric NOT NULL,
    note text,
    deadline_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.funding_source_credit OWNER TO postgres;

--
-- Name: funding_source_credit_total; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW funding_source_credit_total AS
    SELECT funding_source_credit.funding_source, sum(funding_source_credit.amount) AS amount FROM funding_source_credit GROUP BY funding_source_credit.funding_source;


ALTER TABLE acq.funding_source_credit_total OWNER TO postgres;

--
-- Name: funding_source_balance; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW funding_source_balance AS
    SELECT COALESCE(c.funding_source, a.funding_source) AS funding_source, (sum((COALESCE(c.amount, 0.0) - COALESCE(a.amount, 0.0))))::numeric(100,2) AS amount FROM (funding_source_credit_total c FULL JOIN funding_source_allocation_total a USING (funding_source)) GROUP BY COALESCE(c.funding_source, a.funding_source);


ALTER TABLE acq.funding_source_balance OWNER TO postgres;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE funding_source_credit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_credit_id_seq OWNER TO postgres;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE funding_source_credit_id_seq OWNED BY funding_source_credit.id;


--
-- Name: funding_source_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE funding_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_id_seq OWNER TO postgres;

--
-- Name: funding_source_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE funding_source_id_seq OWNED BY funding_source.id;


--
-- Name: invoice; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice (
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone DEFAULT now() NOT NULL,
    recv_method text DEFAULT 'EDI'::text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    complete boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.invoice OWNER TO postgres;

--
-- Name: invoice_entry; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice_entry (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2)
);


ALTER TABLE acq.invoice_entry OWNER TO postgres;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE invoice_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_entry_id_seq OWNER TO postgres;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE invoice_entry_id_seq OWNED BY invoice_entry.id;


--
-- Name: invoice_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_id_seq OWNER TO postgres;

--
-- Name: invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE invoice_id_seq OWNED BY invoice.id;


--
-- Name: invoice_item; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice_item (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint
);


ALTER TABLE acq.invoice_item OWNER TO postgres;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE invoice_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_item_id_seq OWNER TO postgres;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE invoice_item_id_seq OWNED BY invoice_item.id;


--
-- Name: invoice_item_type; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice_item_type (
    code text NOT NULL,
    name text NOT NULL,
    prorate boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.invoice_item_type OWNER TO postgres;

--
-- Name: invoice_method; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_method OWNER TO postgres;

--
-- Name: invoice_payment_method; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE invoice_payment_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_payment_method OWNER TO postgres;

--
-- Name: lineitem_alert_text; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_alert_text (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    owning_lib integer NOT NULL
);


ALTER TABLE acq.lineitem_alert_text OWNER TO postgres;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_alert_text_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_alert_text_id_seq OWNER TO postgres;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_alert_text_id_seq OWNED BY lineitem_alert_text.id;


--
-- Name: lineitem_attr; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_attr (
    id bigint NOT NULL,
    definition bigint NOT NULL,
    lineitem bigint NOT NULL,
    attr_type text NOT NULL,
    attr_name text NOT NULL,
    attr_value text NOT NULL,
    order_ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr OWNER TO postgres;

--
-- Name: lineitem_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_attr_definition (
    id bigint NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    remove text DEFAULT ''::text NOT NULL,
    ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr_definition OWNER TO postgres;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_definition_id_seq OWNER TO postgres;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_attr_definition_id_seq OWNED BY lineitem_attr_definition.id;


--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_id_seq OWNER TO postgres;

--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_attr_id_seq OWNED BY lineitem_attr.id;


--
-- Name: lineitem_detail; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_detail (
    id bigint NOT NULL,
    lineitem integer NOT NULL,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    receiver integer,
    cancel_reason integer
);


ALTER TABLE acq.lineitem_detail OWNER TO postgres;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_detail_id_seq OWNER TO postgres;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_detail_id_seq OWNED BY lineitem_detail.id;


--
-- Name: lineitem_generated_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_generated_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_generated_attr_definition OWNER TO postgres;

--
-- Name: lineitem_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_id_seq OWNER TO postgres;

--
-- Name: lineitem_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_id_seq OWNED BY lineitem.id;


--
-- Name: lineitem_local_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_local_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass)
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_local_attr_definition OWNER TO postgres;

--
-- Name: lineitem_marc_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_marc_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_marc_attr_definition OWNER TO postgres;

--
-- Name: lineitem_note; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_note (
    id integer NOT NULL,
    lineitem integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    alert_text integer,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_note OWNER TO postgres;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE lineitem_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_note_id_seq OWNER TO postgres;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE lineitem_note_id_seq OWNED BY lineitem_note.id;


--
-- Name: lineitem_provider_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_provider_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL,
    provider integer NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_provider_attr_definition OWNER TO postgres;

--
-- Name: lineitem_summary; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW lineitem_summary AS
    SELECT li.id AS lineitem, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE (lid.lineitem = li.id)) AS item_count, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE ((lid.recv_time IS NOT NULL) AND (lid.lineitem = li.id))) AS recv_count, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE ((lid.cancel_reason IS NOT NULL) AND (lid.lineitem = li.id))) AS cancel_count, (SELECT count(lid.id) AS count FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS invoice_count, (SELECT count(DISTINCT lid.id) AS count FROM (lineitem_detail lid JOIN claim claim ON ((claim.lineitem_detail = lid.id))) WHERE (lid.lineitem = li.id)) AS claim_count, (SELECT (((count(lid.id))::numeric * li.estimated_unit_price))::numeric(8,2) AS "numeric" FROM lineitem_detail lid WHERE ((lid.cancel_reason IS NULL) AND (lid.lineitem = li.id))) AS estimated_amount, (SELECT (sum(debit.amount))::numeric(8,2) AS sum FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE (debit.encumbrance AND (lid.lineitem = li.id))) AS encumbrance_amount, (SELECT (sum(debit.amount))::numeric(8,2) AS sum FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS paid_amount FROM lineitem li;


ALTER TABLE acq.lineitem_summary OWNER TO postgres;

--
-- Name: lineitem_usr_attr_definition; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE lineitem_usr_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    usr integer NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_usr_attr_definition OWNER TO postgres;

--
-- Name: ordered_funding_source_credit; Type: VIEW; Schema: acq; Owner: postgres
--

CREATE VIEW ordered_funding_source_credit AS
    SELECT CASE WHEN (funding_source_credit.deadline_date IS NULL) THEN 2 ELSE 1 END AS sort_priority, CASE WHEN (funding_source_credit.deadline_date IS NULL) THEN funding_source_credit.effective_date ELSE funding_source_credit.deadline_date END AS sort_date, funding_source_credit.id, funding_source_credit.funding_source, funding_source_credit.amount, funding_source_credit.note FROM funding_source_credit;


ALTER TABLE acq.ordered_funding_source_credit OWNER TO postgres;

--
-- Name: VIEW ordered_funding_source_credit; Type: COMMENT; Schema: acq; Owner: postgres
--

COMMENT ON VIEW ordered_funding_source_credit IS '
The acq.ordered_funding_source_credit view is a prioritized
ordering of funding source credits.  When ordered by the first
three columns, this view defines the order in which the various
credits are to be tapped for spending, subject to the allocations
in the acq.fund_allocation table.

The first column reflects the principle that we should spend
money with deadlines before spending money without deadlines.

The second column reflects the principle that we should spend the
oldest money first.  For money with deadlines, that means that we
spend first from the credit with the earliest deadline.  For
money without deadlines, we spend first from the credit with the
earliest effective date.

The third column is a tie breaker to ensure a consistent
ordering.
';


--
-- Name: picklist; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE picklist (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.picklist OWNER TO postgres;

--
-- Name: picklist_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE picklist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.picklist_id_seq OWNER TO postgres;

--
-- Name: picklist_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE picklist_id_seq OWNED BY picklist.id;


--
-- Name: po_item; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE po_item (
    id integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    estimated_cost numeric(8,2),
    fund integer,
    target bigint
);


ALTER TABLE acq.po_item OWNER TO postgres;

--
-- Name: po_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE po_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_item_id_seq OWNER TO postgres;

--
-- Name: po_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE po_item_id_seq OWNED BY po_item.id;


--
-- Name: po_note; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE po_note (
    id integer NOT NULL,
    purchase_order integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.po_note OWNER TO postgres;

--
-- Name: po_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE po_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_note_id_seq OWNER TO postgres;

--
-- Name: po_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE po_note_id_seq OWNED BY po_note.id;


--
-- Name: provider; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text NOT NULL,
    holding_tag text,
    san text,
    edi_default integer,
    active boolean DEFAULT true NOT NULL,
    prepayment_required boolean DEFAULT false NOT NULL,
    url text,
    email text,
    phone text,
    fax_phone text,
    default_copy_count integer DEFAULT 0 NOT NULL,
    default_claim_policy integer
);


ALTER TABLE acq.provider OWNER TO postgres;

--
-- Name: provider_address; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    provider integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text
);


ALTER TABLE acq.provider_address OWNER TO postgres;

--
-- Name: provider_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_address_id_seq OWNER TO postgres;

--
-- Name: provider_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_address_id_seq OWNED BY provider_address.id;


--
-- Name: provider_contact; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider_contact (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    role text,
    email text,
    phone text
);


ALTER TABLE acq.provider_contact OWNER TO postgres;

--
-- Name: provider_contact_address; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider_contact_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    contact integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text
);


ALTER TABLE acq.provider_contact_address OWNER TO postgres;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_contact_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_address_id_seq OWNER TO postgres;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_contact_address_id_seq OWNED BY provider_contact_address.id;


--
-- Name: provider_contact_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_id_seq OWNER TO postgres;

--
-- Name: provider_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_contact_id_seq OWNED BY provider_contact.id;


--
-- Name: provider_holding_subfield_map; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider_holding_subfield_map (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    subfield text NOT NULL
);


ALTER TABLE acq.provider_holding_subfield_map OWNER TO postgres;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_holding_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_holding_subfield_map_id_seq OWNER TO postgres;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_holding_subfield_map_id_seq OWNED BY provider_holding_subfield_map.id;


--
-- Name: provider_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_id_seq OWNER TO postgres;

--
-- Name: provider_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_id_seq OWNED BY provider.id;


--
-- Name: provider_note; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE provider_note (
    id integer NOT NULL,
    provider integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL
);


ALTER TABLE acq.provider_note OWNER TO postgres;

--
-- Name: provider_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE provider_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_note_id_seq OWNER TO postgres;

--
-- Name: provider_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE provider_note_id_seq OWNED BY provider_note.id;


--
-- Name: purchase_order_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE purchase_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.purchase_order_id_seq OWNER TO postgres;

--
-- Name: purchase_order_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE purchase_order_id_seq OWNED BY purchase_order.id;


--
-- Name: serial_claim; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE serial_claim (
    id integer NOT NULL,
    type integer NOT NULL,
    item bigint NOT NULL
);


ALTER TABLE acq.serial_claim OWNER TO postgres;

--
-- Name: serial_claim_event; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE serial_claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.serial_claim_event OWNER TO postgres;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE serial_claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_claim_seq OWNER TO postgres;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE serial_claim_event_claim_seq OWNED BY serial_claim_event.claim;


--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE serial_claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_id_seq OWNER TO postgres;

--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE serial_claim_event_id_seq OWNED BY serial_claim_event.id;


--
-- Name: serial_claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE serial_claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_id_seq OWNER TO postgres;

--
-- Name: serial_claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE serial_claim_id_seq OWNED BY serial_claim.id;


--
-- Name: user_request; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE user_request (
    id integer NOT NULL,
    usr integer NOT NULL,
    hold boolean DEFAULT true NOT NULL,
    pickup_lib integer NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    lineitem integer,
    eg_bib bigint,
    request_date timestamp with time zone DEFAULT now() NOT NULL,
    need_before timestamp with time zone,
    max_fee text,
    request_type integer NOT NULL,
    isxn text,
    title text,
    volume text,
    author text,
    article_title text,
    article_pages text,
    publisher text,
    location text,
    pubdate text,
    mentioned text,
    other_info text,
    cancel_reason integer
);


ALTER TABLE acq.user_request OWNER TO postgres;

--
-- Name: user_request_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE user_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_id_seq OWNER TO postgres;

--
-- Name: user_request_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE user_request_id_seq OWNED BY user_request.id;


--
-- Name: user_request_type; Type: TABLE; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE TABLE user_request_type (
    id integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE acq.user_request_type OWNER TO postgres;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: postgres
--

CREATE SEQUENCE user_request_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_type_id_seq OWNER TO postgres;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: postgres
--

ALTER SEQUENCE user_request_type_id_seq OWNED BY user_request_type.id;


SET search_path = action, pg_catalog;

--
-- Name: aged_circulation; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE aged_circulation (
    usr_post_code text,
    usr_home_ou integer NOT NULL,
    usr_profile integer NOT NULL,
    usr_birth_year integer,
    copy_call_number integer NOT NULL,
    copy_owning_lib integer NOT NULL,
    copy_circ_lib integer NOT NULL,
    copy_bib_record bigint NOT NULL,
    id bigint NOT NULL,
    xact_start timestamp with time zone NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    grace_period interval NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    duration interval,
    fine_interval interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean NOT NULL,
    desk_renewal boolean NOT NULL,
    opac_renewal boolean NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    copy_location integer NOT NULL,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE action.aged_circulation OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: usr_address; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE actor.usr_address OWNER TO postgres;

SET search_path = asset, pg_catalog;

--
-- Name: call_number; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number (
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint NOT NULL,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    prefix integer DEFAULT (-1) NOT NULL,
    suffix integer DEFAULT (-1) NOT NULL,
    label_class bigint NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number OWNER TO postgres;

SET search_path = action, pg_catalog;

--
-- Name: all_circulation; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW all_circulation AS
    SELECT aged_circulation.id, aged_circulation.usr_post_code, aged_circulation.usr_home_ou, aged_circulation.usr_profile, aged_circulation.usr_birth_year, aged_circulation.copy_call_number, aged_circulation.copy_location, aged_circulation.copy_owning_lib, aged_circulation.copy_circ_lib, aged_circulation.copy_bib_record, aged_circulation.xact_start, aged_circulation.xact_finish, aged_circulation.target_copy, aged_circulation.circ_lib, aged_circulation.circ_staff, aged_circulation.checkin_staff, aged_circulation.checkin_lib, aged_circulation.renewal_remaining, aged_circulation.grace_period, aged_circulation.due_date, aged_circulation.stop_fines_time, aged_circulation.checkin_time, aged_circulation.create_time, aged_circulation.duration, aged_circulation.fine_interval, aged_circulation.recurring_fine, aged_circulation.max_fine, aged_circulation.phone_renewal, aged_circulation.desk_renewal, aged_circulation.opac_renewal, aged_circulation.duration_rule, aged_circulation.recurring_fine_rule, aged_circulation.max_fine_rule, aged_circulation.stop_fines, aged_circulation.workstation, aged_circulation.checkin_workstation, aged_circulation.checkin_scan_time, aged_circulation.parent_circ FROM aged_circulation UNION ALL SELECT DISTINCT circ.id, COALESCE(a.post_code, b.post_code) AS usr_post_code, p.home_ou AS usr_home_ou, p.profile AS usr_profile, (date_part('year'::text, p.dob))::integer AS usr_birth_year, cp.call_number AS copy_call_number, circ.copy_location, cn.owning_lib AS copy_owning_lib, cp.circ_lib AS copy_circ_lib, cn.record AS copy_bib_record, circ.xact_start, circ.xact_finish, circ.target_copy, circ.circ_lib, circ.circ_staff, circ.checkin_staff, circ.checkin_lib, circ.renewal_remaining, circ.grace_period, circ.due_date, circ.stop_fines_time, circ.checkin_time, circ.create_time, circ.duration, circ.fine_interval, circ.recurring_fine, circ.max_fine, circ.phone_renewal, circ.desk_renewal, circ.opac_renewal, circ.duration_rule, circ.recurring_fine_rule, circ.max_fine_rule, circ.stop_fines, circ.workstation, circ.checkin_workstation, circ.checkin_scan_time, circ.parent_circ FROM (((((circulation circ JOIN asset.copy cp ON ((circ.target_copy = cp.id))) JOIN asset.call_number cn ON ((cp.call_number = cn.id))) JOIN actor.usr p ON ((circ.usr = p.id))) LEFT JOIN actor.usr_address a ON ((p.mailing_address = a.id))) LEFT JOIN actor.usr_address b ON ((p.billing_address = b.id)));


ALTER TABLE action.all_circulation OWNER TO postgres;

--
-- Name: archive_actor_stat_cat; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE archive_actor_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_actor_stat_cat OWNER TO postgres;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE archive_actor_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_actor_stat_cat_id_seq OWNER TO postgres;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE archive_actor_stat_cat_id_seq OWNED BY archive_actor_stat_cat.id;


--
-- Name: archive_asset_stat_cat; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE archive_asset_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_asset_stat_cat OWNER TO postgres;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE archive_asset_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_asset_stat_cat_id_seq OWNER TO postgres;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE archive_asset_stat_cat_id_seq OWNED BY archive_asset_stat_cat.id;


--
-- Name: billable_circulations; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW billable_circulations AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.grace_period, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.copy_location, circulation.checkin_scan_time, circulation.parent_circ FROM circulation WHERE (circulation.xact_finish IS NULL);


ALTER TABLE action.billable_circulations OWNER TO postgres;

--
-- Name: circulation_limit_group_map; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE circulation_limit_group_map (
    circ bigint NOT NULL,
    limit_group integer NOT NULL
);


ALTER TABLE action.circulation_limit_group_map OWNER TO postgres;

--
-- Name: fieldset; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE fieldset (
    id integer NOT NULL,
    owner integer NOT NULL,
    owning_lib integer NOT NULL,
    status text NOT NULL,
    creation_time timestamp with time zone DEFAULT now() NOT NULL,
    scheduled_time timestamp with time zone,
    applied_time timestamp with time zone,
    classname text NOT NULL,
    name text NOT NULL,
    stored_query integer,
    pkey_value text,
    CONSTRAINT fieldset_one_or_the_other CHECK ((((stored_query IS NOT NULL) AND (pkey_value IS NULL)) OR ((pkey_value IS NOT NULL) AND (stored_query IS NULL)))),
    CONSTRAINT valid_status CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPLIED'::text, 'ERROR'::text])))
);


ALTER TABLE action.fieldset OWNER TO postgres;

--
-- Name: fieldset_col_val; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE fieldset_col_val (
    id integer NOT NULL,
    fieldset integer NOT NULL,
    col text NOT NULL,
    val text
);


ALTER TABLE action.fieldset_col_val OWNER TO postgres;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE fieldset_col_val_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_col_val_id_seq OWNER TO postgres;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE fieldset_col_val_id_seq OWNED BY fieldset_col_val.id;


--
-- Name: fieldset_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE fieldset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_id_seq OWNER TO postgres;

--
-- Name: fieldset_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE fieldset_id_seq OWNED BY fieldset.id;


--
-- Name: hold_copy_map; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_copy_map (
    id bigint NOT NULL,
    hold integer NOT NULL,
    target_copy bigint NOT NULL,
    proximity numeric
);


ALTER TABLE action.hold_copy_map OWNER TO postgres;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE hold_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_copy_map_id_seq OWNER TO postgres;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE hold_copy_map_id_seq OWNED BY hold_copy_map.id;


--
-- Name: hold_notification; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_notification (
    id integer NOT NULL,
    hold integer NOT NULL,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text NOT NULL,
    note text
);


ALTER TABLE action.hold_notification OWNER TO postgres;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE hold_notification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_notification_id_seq OWNER TO postgres;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE hold_notification_id_seq OWNED BY hold_notification.id;


--
-- Name: hold_request_cancel_cause; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_request_cancel_cause (
    id integer NOT NULL,
    label text
);


ALTER TABLE action.hold_request_cancel_cause OWNER TO postgres;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE hold_request_cancel_cause_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_cancel_cause_id_seq OWNER TO postgres;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE hold_request_cancel_cause_id_seq OWNED BY hold_request_cancel_cause.id;


--
-- Name: hold_request_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE hold_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_id_seq OWNER TO postgres;

--
-- Name: hold_request_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE hold_request_id_seq OWNED BY hold_request.id;


--
-- Name: hold_request_note; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_request_note (
    id bigint NOT NULL,
    hold bigint NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    slip boolean DEFAULT false NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    staff boolean DEFAULT false NOT NULL
);


ALTER TABLE action.hold_request_note OWNER TO postgres;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE hold_request_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_note_id_seq OWNER TO postgres;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE hold_request_note_id_seq OWNED BY hold_request_note.id;


--
-- Name: transit_copy; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE transit_copy (
    id integer NOT NULL,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint NOT NULL,
    source integer NOT NULL,
    dest integer NOT NULL,
    prev_hop integer,
    copy_status integer NOT NULL,
    persistant_transfer boolean DEFAULT false NOT NULL,
    prev_dest integer
);


ALTER TABLE action.transit_copy OWNER TO postgres;

--
-- Name: hold_transit_copy; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_transit_copy (
    hold integer
)
INHERITS (transit_copy);


ALTER TABLE action.hold_transit_copy OWNER TO postgres;

--
-- Name: in_house_use; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE in_house_use (
    id integer NOT NULL,
    item bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.in_house_use OWNER TO postgres;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.in_house_use_id_seq OWNER TO postgres;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE in_house_use_id_seq OWNED BY in_house_use.id;


--
-- Name: non_cat_in_house_use; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE non_cat_in_house_use (
    id integer NOT NULL,
    item_type bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.non_cat_in_house_use OWNER TO postgres;

--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE non_cat_in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cat_in_house_use_id_seq OWNER TO postgres;

--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE non_cat_in_house_use_id_seq OWNED BY non_cat_in_house_use.id;


--
-- Name: non_cataloged_circulation; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE non_cataloged_circulation (
    id integer NOT NULL,
    patron integer NOT NULL,
    staff integer NOT NULL,
    circ_lib integer NOT NULL,
    item_type integer NOT NULL,
    circ_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.non_cataloged_circulation OWNER TO postgres;

--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE non_cataloged_circulation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cataloged_circulation_id_seq OWNER TO postgres;

--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE non_cataloged_circulation_id_seq OWNED BY non_cataloged_circulation.id;


--
-- Name: open_circulation; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW open_circulation AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.grace_period, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.copy_location, circulation.checkin_scan_time, circulation.parent_circ FROM circulation WHERE (circulation.checkin_time IS NULL) ORDER BY circulation.due_date;


ALTER TABLE action.open_circulation OWNER TO postgres;

--
-- Name: reservation_transit_copy; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE reservation_transit_copy (
    reservation integer
)
INHERITS (transit_copy);


ALTER TABLE action.reservation_transit_copy OWNER TO postgres;

--
-- Name: survey; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE survey (
    id integer NOT NULL,
    owner integer NOT NULL,
    start_date timestamp with time zone DEFAULT now() NOT NULL,
    end_date timestamp with time zone DEFAULT (now() + '10 years'::interval) NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    opac boolean DEFAULT false NOT NULL,
    poll boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE action.survey OWNER TO postgres;

--
-- Name: survey_answer; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE survey_answer (
    id integer NOT NULL,
    question integer NOT NULL,
    answer text NOT NULL
);


ALTER TABLE action.survey_answer OWNER TO postgres;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE survey_answer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_answer_id_seq OWNER TO postgres;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE survey_answer_id_seq OWNED BY survey_answer.id;


--
-- Name: survey_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE survey_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_id_seq OWNER TO postgres;

--
-- Name: survey_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE survey_id_seq OWNED BY survey.id;


--
-- Name: survey_question; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE survey_question (
    id integer NOT NULL,
    survey integer NOT NULL,
    question text NOT NULL
);


ALTER TABLE action.survey_question OWNER TO postgres;

--
-- Name: survey_question_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE survey_question_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_question_id_seq OWNER TO postgres;

--
-- Name: survey_question_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE survey_question_id_seq OWNED BY survey_question.id;


--
-- Name: survey_response; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE survey_response (
    id bigint NOT NULL,
    response_group_id integer,
    usr integer,
    survey integer NOT NULL,
    question integer NOT NULL,
    answer integer NOT NULL,
    answer_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.survey_response OWNER TO postgres;

--
-- Name: survey_response_group_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE survey_response_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_group_id_seq OWNER TO postgres;

--
-- Name: survey_response_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE survey_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_id_seq OWNER TO postgres;

--
-- Name: survey_response_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE survey_response_id_seq OWNED BY survey_response.id;


--
-- Name: transit_copy_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE transit_copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.transit_copy_id_seq OWNER TO postgres;

--
-- Name: transit_copy_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE transit_copy_id_seq OWNED BY transit_copy.id;


--
-- Name: unfulfilled_hold_list; Type: TABLE; Schema: action; Owner: postgres; Tablespace: 
--

CREATE TABLE unfulfilled_hold_list (
    id bigint NOT NULL,
    current_copy bigint NOT NULL,
    hold integer NOT NULL,
    circ_lib integer NOT NULL,
    fail_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.unfulfilled_hold_list OWNER TO postgres;

--
-- Name: unfulfilled_hold_loops; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW unfulfilled_hold_loops AS
    SELECT u.hold, c.circ_lib, count(*) AS count FROM (unfulfilled_hold_list u JOIN asset.copy c ON ((c.id = u.current_copy))) GROUP BY u.hold, c.circ_lib;


ALTER TABLE action.unfulfilled_hold_loops OWNER TO postgres;

--
-- Name: unfulfilled_hold_min_loop; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW unfulfilled_hold_min_loop AS
    SELECT unfulfilled_hold_loops.hold, min(unfulfilled_hold_loops.count) AS min FROM unfulfilled_hold_loops GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_min_loop OWNER TO postgres;

--
-- Name: unfulfilled_hold_innermost_loop; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW unfulfilled_hold_innermost_loop AS
    SELECT DISTINCT l.hold, l.circ_lib, l.count FROM (unfulfilled_hold_loops l JOIN unfulfilled_hold_min_loop m USING (hold)) WHERE (l.count = m.min);


ALTER TABLE action.unfulfilled_hold_innermost_loop OWNER TO postgres;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE; Schema: action; Owner: postgres
--

CREATE SEQUENCE unfulfilled_hold_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.unfulfilled_hold_list_id_seq OWNER TO postgres;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: postgres
--

ALTER SEQUENCE unfulfilled_hold_list_id_seq OWNED BY unfulfilled_hold_list.id;


--
-- Name: unfulfilled_hold_max_loop; Type: VIEW; Schema: action; Owner: postgres
--

CREATE VIEW unfulfilled_hold_max_loop AS
    SELECT unfulfilled_hold_loops.hold, max(unfulfilled_hold_loops.count) AS max FROM unfulfilled_hold_loops GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_max_loop OWNER TO postgres;

SET search_path = action_trigger, pg_catalog;

--
-- Name: cleanup; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE cleanup (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.cleanup OWNER TO postgres;

--
-- Name: collector; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE collector (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.collector OWNER TO postgres;

--
-- Name: environment; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE environment (
    id integer NOT NULL,
    event_def integer NOT NULL,
    path text,
    collector text,
    label text,
    CONSTRAINT environment_label_check CHECK ((label <> ALL (ARRAY['result'::text, 'target'::text, 'event'::text])))
);


ALTER TABLE action_trigger.environment OWNER TO postgres;

--
-- Name: environment_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: postgres
--

CREATE SEQUENCE environment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.environment_id_seq OWNER TO postgres;

--
-- Name: environment_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: postgres
--

ALTER SEQUENCE environment_id_seq OWNED BY environment.id;


--
-- Name: event; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE event (
    id bigint NOT NULL,
    target bigint NOT NULL,
    event_def integer,
    add_time timestamp with time zone DEFAULT now() NOT NULL,
    run_time timestamp with time zone NOT NULL,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text DEFAULT 'pending'::text NOT NULL,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint,
    CONSTRAINT event_state_check CHECK ((state = ANY (ARRAY['pending'::text, 'invalid'::text, 'found'::text, 'collecting'::text, 'collected'::text, 'validating'::text, 'valid'::text, 'reacting'::text, 'reacted'::text, 'cleaning'::text, 'complete'::text, 'error'::text]))),
    CONSTRAINT event_user_data_check CHECK (((user_data IS NULL) OR evergreen.is_json(user_data)))
);


ALTER TABLE action_trigger.event OWNER TO postgres;

--
-- Name: event_definition; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE event_definition (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    hook text NOT NULL,
    validator text NOT NULL,
    reactor text NOT NULL,
    cleanup_success text,
    cleanup_failure text,
    delay interval DEFAULT '00:05:00'::interval NOT NULL,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE action_trigger.event_definition OWNER TO postgres;

--
-- Name: event_definition_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: postgres
--

CREATE SEQUENCE event_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_definition_id_seq OWNER TO postgres;

--
-- Name: event_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: postgres
--

ALTER SEQUENCE event_definition_id_seq OWNED BY event_definition.id;


--
-- Name: event_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: postgres
--

CREATE SEQUENCE event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_id_seq OWNER TO postgres;

--
-- Name: event_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: postgres
--

ALTER SEQUENCE event_id_seq OWNED BY event.id;


--
-- Name: event_output; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE event_output (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    is_error boolean DEFAULT false NOT NULL,
    data text NOT NULL
);


ALTER TABLE action_trigger.event_output OWNER TO postgres;

--
-- Name: event_output_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: postgres
--

CREATE SEQUENCE event_output_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_output_id_seq OWNER TO postgres;

--
-- Name: event_output_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: postgres
--

ALTER SEQUENCE event_output_id_seq OWNED BY event_output.id;


--
-- Name: event_params; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE event_params (
    id bigint NOT NULL,
    event_def integer NOT NULL,
    param text NOT NULL,
    value text NOT NULL
);


ALTER TABLE action_trigger.event_params OWNER TO postgres;

--
-- Name: event_params_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: postgres
--

CREATE SEQUENCE event_params_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_params_id_seq OWNER TO postgres;

--
-- Name: event_params_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: postgres
--

ALTER SEQUENCE event_params_id_seq OWNED BY event_params.id;


--
-- Name: hook; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE hook (
    key text NOT NULL,
    core_type text NOT NULL,
    description text,
    passive boolean DEFAULT false NOT NULL
);


ALTER TABLE action_trigger.hook OWNER TO postgres;

--
-- Name: reactor; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE reactor (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.reactor OWNER TO postgres;

--
-- Name: validator; Type: TABLE; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE TABLE validator (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.validator OWNER TO postgres;

SET search_path = actor, pg_catalog;

--
-- Name: address_alert_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE address_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.address_alert_id_seq OWNER TO postgres;

--
-- Name: address_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE address_alert_id_seq OWNED BY address_alert.id;


--
-- Name: card; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE card (
    id integer NOT NULL,
    usr integer NOT NULL,
    barcode text NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.card OWNER TO postgres;

--
-- Name: TABLE card; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE card IS '
Library Cards

Each User has one or more library cards.  The current "main"
card is linked to here from the actor.usr table, and it is up
to the consortium policy whether more than one card can be
active for any one user at a given time.
';


--
-- Name: card_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.card_id_seq OWNER TO postgres;

--
-- Name: card_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE card_id_seq OWNED BY card.id;


--
-- Name: hours_of_operation; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE hours_of_operation (
    id integer NOT NULL,
    dow_0_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_0_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_1_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_1_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_2_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_2_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_3_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_3_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_4_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_4_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_5_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_5_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_6_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_6_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL
);


ALTER TABLE actor.hours_of_operation OWNER TO postgres;

--
-- Name: TABLE hours_of_operation; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE hours_of_operation IS '
When does this org_unit usually open and close?  (Variations
are expressed in the actor.org_unit_closed table.)
';


--
-- Name: COLUMN hours_of_operation.dow_0_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_0_open IS '
When does this org_unit open on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_0_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_0_close IS '
When does this org_unit close on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_1_open IS '
When does this org_unit open on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_1_close IS '
When does this org_unit close on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_2_open IS '
When does this org_unit open on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_2_close IS '
When does this org_unit close on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_3_open IS '
When does this org_unit open on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_3_close IS '
When does this org_unit close on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_4_open IS '
When does this org_unit open on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_4_close IS '
When does this org_unit close on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_5_open IS '
When does this org_unit open on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_5_close IS '
When does this org_unit close on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_open; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_6_open IS '
When does this org_unit open on Sunday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_close; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON COLUMN hours_of_operation.dow_6_close IS '
When does this org_unit close on Sunday?
';


--
-- Name: org_address; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    org_unit integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    san text
);


ALTER TABLE actor.org_address OWNER TO postgres;

--
-- Name: org_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_address_id_seq OWNER TO postgres;

--
-- Name: org_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_address_id_seq OWNED BY org_address.id;


--
-- Name: org_lasso; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_lasso (
    id integer NOT NULL,
    name text
);


ALTER TABLE actor.org_lasso OWNER TO postgres;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_lasso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_id_seq OWNER TO postgres;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_lasso_id_seq OWNED BY org_lasso.id;


--
-- Name: org_lasso_map; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_lasso_map (
    id integer NOT NULL,
    lasso integer NOT NULL,
    org_unit integer NOT NULL
);


ALTER TABLE actor.org_lasso_map OWNER TO postgres;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_lasso_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_map_id_seq OWNER TO postgres;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_lasso_map_id_seq OWNED BY org_lasso_map.id;


--
-- Name: org_unit_closed; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_closed (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    close_start timestamp with time zone NOT NULL,
    close_end timestamp with time zone NOT NULL,
    reason text
);


ALTER TABLE actor.org_unit_closed OWNER TO postgres;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_closed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_closed_id_seq OWNER TO postgres;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_closed_id_seq OWNED BY org_unit_closed.id;


--
-- Name: org_unit_custom_tree; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_custom_tree (
    id integer NOT NULL,
    active boolean DEFAULT false,
    purpose org_unit_custom_tree_purpose DEFAULT 'opac'::org_unit_custom_tree_purpose NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree OWNER TO postgres;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_custom_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_id_seq OWNER TO postgres;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_custom_tree_id_seq OWNED BY org_unit_custom_tree.id;


--
-- Name: org_unit_custom_tree_node; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_custom_tree_node (
    id integer NOT NULL,
    tree integer,
    org_unit integer NOT NULL,
    parent_node integer,
    sibling_order integer DEFAULT 0 NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree_node OWNER TO postgres;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_custom_tree_node_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_node_id_seq OWNER TO postgres;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_custom_tree_node_id_seq OWNED BY org_unit_custom_tree_node.id;


--
-- Name: org_unit_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_id_seq OWNER TO postgres;

--
-- Name: org_unit_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_id_seq OWNED BY org_unit.id;


--
-- Name: org_unit_proximity; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_proximity (
    id bigint NOT NULL,
    from_org integer,
    to_org integer,
    prox integer
);


ALTER TABLE actor.org_unit_proximity OWNER TO postgres;

--
-- Name: org_unit_proximity_adjustment; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_proximity_adjustment (
    id integer NOT NULL,
    item_circ_lib integer,
    item_owning_lib integer,
    copy_location integer,
    hold_pickup_lib integer,
    hold_request_lib integer,
    pos integer DEFAULT 0 NOT NULL,
    absolute_adjustment boolean DEFAULT false NOT NULL,
    prox_adjustment numeric,
    circ_mod text,
    CONSTRAINT prox_adj_criterium CHECK ((COALESCE((item_circ_lib)::text, (item_owning_lib)::text, (copy_location)::text, (hold_pickup_lib)::text, (hold_request_lib)::text, circ_mod) IS NOT NULL))
);


ALTER TABLE actor.org_unit_proximity_adjustment OWNER TO postgres;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_proximity_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_adjustment_id_seq OWNER TO postgres;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_proximity_adjustment_id_seq OWNED BY org_unit_proximity_adjustment.id;


--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_proximity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_id_seq OWNER TO postgres;

--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_proximity_id_seq OWNED BY org_unit_proximity.id;


--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_setting_id_seq OWNER TO postgres;

--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_setting_id_seq OWNED BY org_unit_setting.id;


--
-- Name: org_unit_type; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_type (
    id integer NOT NULL,
    name text NOT NULL,
    opac_label text NOT NULL,
    depth integer NOT NULL,
    parent integer,
    can_have_vols boolean DEFAULT true NOT NULL,
    can_have_users boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.org_unit_type OWNER TO postgres;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE org_unit_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_type_id_seq OWNER TO postgres;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE org_unit_type_id_seq OWNED BY org_unit_type.id;


--
-- Name: search_filter_group; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE search_filter_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    code text NOT NULL,
    label text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.search_filter_group OWNER TO postgres;

--
-- Name: search_filter_group_entry; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE search_filter_group_entry (
    id integer NOT NULL,
    grp integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    query integer NOT NULL
);


ALTER TABLE actor.search_filter_group_entry OWNER TO postgres;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE search_filter_group_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_entry_id_seq OWNER TO postgres;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE search_filter_group_entry_id_seq OWNED BY search_filter_group_entry.id;


--
-- Name: search_filter_group_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE search_filter_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_id_seq OWNER TO postgres;

--
-- Name: search_filter_group_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE search_filter_group_id_seq OWNED BY search_filter_group.id;


--
-- Name: search_query; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE search_query (
    id integer NOT NULL,
    label text NOT NULL,
    query_text text NOT NULL
);


ALTER TABLE actor.search_query OWNER TO postgres;

--
-- Name: search_query_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE search_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_query_id_seq OWNER TO postgres;

--
-- Name: search_query_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE search_query_id_seq OWNED BY search_query.id;


--
-- Name: stat_cat; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    allow_freetext boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.stat_cat OWNER TO postgres;

--
-- Name: TABLE stat_cat; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE stat_cat IS '
User Statistical Catagories

Local data collected about Users is placed into a Statistical
Catagory.  Here''s where those catagories are defined.
';


--
-- Name: stat_cat_entry; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.stat_cat_entry OWNER TO postgres;

--
-- Name: TABLE stat_cat_entry; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE stat_cat_entry IS '
User Statistical Catagory Entries

Local data collected about Users is placed into a Statistical
Catagory.  Each library can create entries into any of its own
stat_cats, its ancestors'' stat_cats, or its descendants'' stat_cats.
';


--
-- Name: stat_cat_entry_default; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry_default (
    id integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_default OWNER TO postgres;

--
-- Name: TABLE stat_cat_entry_default; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE stat_cat_entry_default IS '
User Statistical Category Default Entry

A library may choose one of the stat_cat entries to be the
default entry.
';


--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_default_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_default_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_default_id_seq OWNED BY stat_cat_entry_default.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_id_seq OWNED BY stat_cat_entry.id;


--
-- Name: stat_cat_entry_usr_map; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry_usr_map (
    id bigint NOT NULL,
    stat_cat_entry text NOT NULL,
    stat_cat integer NOT NULL,
    target_usr integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_usr_map OWNER TO postgres;

--
-- Name: TABLE stat_cat_entry_usr_map; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE stat_cat_entry_usr_map IS '
Statistical Catagory Entry to User map

Records the stat_cat entries for each user.
';


--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_usr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_usr_map_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_usr_map_id_seq OWNED BY stat_cat_entry_usr_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_id_seq OWNER TO postgres;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE stat_cat_id_seq OWNED BY stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.stat_cat_sip_fields OWNER TO postgres;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE stat_cat_sip_fields IS '
Actor Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: toolbar; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE toolbar (
    id bigint NOT NULL,
    ws integer,
    org integer,
    usr integer,
    label text NOT NULL,
    layout text NOT NULL,
    CONSTRAINT layout_must_be_json CHECK (evergreen.is_json(layout)),
    CONSTRAINT only_one_type CHECK (((((ws IS NOT NULL) AND (COALESCE(org, usr) IS NULL)) OR ((org IS NOT NULL) AND (COALESCE(ws, usr) IS NULL))) OR ((usr IS NOT NULL) AND (COALESCE(org, ws) IS NULL))))
);


ALTER TABLE actor.toolbar OWNER TO postgres;

--
-- Name: toolbar_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE toolbar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.toolbar_id_seq OWNER TO postgres;

--
-- Name: toolbar_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE toolbar_id_seq OWNED BY toolbar.id;


--
-- Name: usr_activity_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_activity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_activity_id_seq OWNER TO postgres;

--
-- Name: usr_activity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_activity_id_seq OWNED BY usr_activity.id;


--
-- Name: usr_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_address_id_seq OWNER TO postgres;

--
-- Name: usr_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_address_id_seq OWNED BY usr_address.id;


--
-- Name: usr_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_id_seq OWNER TO postgres;

--
-- Name: usr_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_id_seq OWNED BY usr.id;


--
-- Name: usr_note; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_note (
    id bigint NOT NULL,
    usr bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.usr_note OWNER TO postgres;

--
-- Name: usr_note_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_note_id_seq OWNER TO postgres;

--
-- Name: usr_note_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_note_id_seq OWNED BY usr_note.id;


--
-- Name: usr_org_unit_opt_in; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_org_unit_opt_in (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    staff integer NOT NULL,
    opt_in_ts timestamp with time zone DEFAULT now() NOT NULL,
    opt_in_ws integer NOT NULL
);


ALTER TABLE actor.usr_org_unit_opt_in OWNER TO postgres;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_org_unit_opt_in_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_org_unit_opt_in_id_seq OWNER TO postgres;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_org_unit_opt_in_id_seq OWNED BY usr_org_unit_opt_in.id;


--
-- Name: usr_password_reset; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_password_reset (
    id integer NOT NULL,
    uuid text NOT NULL,
    usr bigint NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    has_been_reset boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.usr_password_reset OWNER TO postgres;

--
-- Name: TABLE usr_password_reset; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE usr_password_reset IS '
Self-serve password reset requests
';


--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_password_reset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_password_reset_id_seq OWNER TO postgres;

--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_password_reset_id_seq OWNED BY usr_password_reset.id;


--
-- Name: usr_saved_search; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_saved_search (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    query_text text NOT NULL,
    query_type text DEFAULT 'URL'::text NOT NULL,
    target text NOT NULL,
    CONSTRAINT valid_query_text CHECK ((query_type = 'URL'::text)),
    CONSTRAINT valid_target CHECK ((target = ANY (ARRAY['record'::text, 'metarecord'::text, 'callnumber'::text])))
);


ALTER TABLE actor.usr_saved_search OWNER TO postgres;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_saved_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_saved_search_id_seq OWNER TO postgres;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_saved_search_id_seq OWNED BY usr_saved_search.id;


--
-- Name: usr_setting; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_setting (
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.usr_setting OWNER TO postgres;

--
-- Name: TABLE usr_setting; Type: COMMENT; Schema: actor; Owner: postgres
--

COMMENT ON TABLE usr_setting IS '
User settings

This table contains any arbitrary settings that a client
program would like to save for a user.
';


--
-- Name: usr_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_setting_id_seq OWNER TO postgres;

--
-- Name: usr_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_setting_id_seq OWNED BY usr_setting.id;


--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_standing_penalty_id_seq OWNER TO postgres;

--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_standing_penalty_id_seq OWNED BY usr_standing_penalty.id;


--
-- Name: usr_usrgroup_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE usr_usrgroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_usrgroup_seq OWNER TO postgres;

--
-- Name: usr_usrgroup_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE usr_usrgroup_seq OWNED BY usr.usrgroup;


--
-- Name: workstation; Type: TABLE; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE TABLE workstation (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL
);


ALTER TABLE actor.workstation OWNER TO postgres;

--
-- Name: workstation_id_seq; Type: SEQUENCE; Schema: actor; Owner: postgres
--

CREATE SEQUENCE workstation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.workstation_id_seq OWNER TO postgres;

--
-- Name: workstation_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: postgres
--

ALTER SEQUENCE workstation_id_seq OWNED BY workstation.id;


SET search_path = asset, pg_catalog;

--
-- Name: call_number_class; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_class (
    id bigint NOT NULL,
    name text NOT NULL,
    normalizer text DEFAULT 'asset.normalize_generic'::text NOT NULL,
    field text DEFAULT '050ab,055ab,060ab,070ab,080ab,082ab,086ab,088ab,090,092,096,098,099'::text NOT NULL
);


ALTER TABLE asset.call_number_class OWNER TO postgres;

--
-- Name: TABLE call_number_class; Type: COMMENT; Schema: asset; Owner: postgres
--

COMMENT ON TABLE call_number_class IS '
Defines the call number normalization database functions in the "normalizer"
column and the tag/subfield combinations to use to lookup the call number in
the "field" column for a given classification scheme. Tag/subfield combinations
are delimited by commas.
';


--
-- Name: call_number_class_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE call_number_class_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_class_id_seq OWNER TO postgres;

--
-- Name: call_number_class_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE call_number_class_id_seq OWNED BY call_number_class.id;


--
-- Name: call_number_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE call_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_id_seq OWNER TO postgres;

--
-- Name: call_number_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE call_number_id_seq OWNED BY call_number.id;


--
-- Name: call_number_note; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_note (
    id bigint NOT NULL,
    call_number bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.call_number_note OWNER TO postgres;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE call_number_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_note_id_seq OWNER TO postgres;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE call_number_note_id_seq OWNED BY call_number_note.id;


--
-- Name: call_number_prefix; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_prefix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_prefix OWNER TO postgres;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE call_number_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_prefix_id_seq OWNER TO postgres;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE call_number_prefix_id_seq OWNED BY call_number_prefix.id;


--
-- Name: call_number_suffix; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_suffix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_suffix OWNER TO postgres;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE call_number_suffix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_suffix_id_seq OWNER TO postgres;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE call_number_suffix_id_seq OWNED BY call_number_suffix.id;


--
-- Name: copy_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_id_seq OWNER TO postgres;

--
-- Name: copy_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_id_seq OWNED BY copy.id;


--
-- Name: copy_location; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_location (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text,
    checkin_alert boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.copy_location OWNER TO postgres;

--
-- Name: copy_location_group; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_location_group (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    top boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.copy_location_group OWNER TO postgres;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_location_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_id_seq OWNER TO postgres;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_location_group_id_seq OWNED BY copy_location_group.id;


--
-- Name: copy_location_group_map; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_location_group_map (
    id integer NOT NULL,
    location integer NOT NULL,
    lgroup integer NOT NULL
);


ALTER TABLE asset.copy_location_group_map OWNER TO postgres;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_location_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_map_id_seq OWNER TO postgres;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_location_group_map_id_seq OWNED BY copy_location_group_map.id;


--
-- Name: copy_location_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_location_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_id_seq OWNER TO postgres;

--
-- Name: copy_location_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_location_id_seq OWNED BY copy_location.id;


--
-- Name: copy_location_order; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_location_order (
    id integer NOT NULL,
    location integer NOT NULL,
    org integer NOT NULL,
    "position" integer DEFAULT 0 NOT NULL
);


ALTER TABLE asset.copy_location_order OWNER TO postgres;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_location_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_order_id_seq OWNER TO postgres;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_location_order_id_seq OWNED BY copy_location_order.id;


--
-- Name: copy_note; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_note (
    id bigint NOT NULL,
    owning_copy bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.copy_note OWNER TO postgres;

--
-- Name: copy_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_note_id_seq OWNER TO postgres;

--
-- Name: copy_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_note_id_seq OWNED BY copy_note.id;


--
-- Name: copy_part_map; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_part_map (
    id integer NOT NULL,
    target_copy bigint NOT NULL,
    part integer NOT NULL
);


ALTER TABLE asset.copy_part_map OWNER TO postgres;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_part_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_part_map_id_seq OWNER TO postgres;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_part_map_id_seq OWNED BY copy_part_map.id;


--
-- Name: copy_template; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_template (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    creator bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    name text NOT NULL,
    circ_lib integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible boolean,
    floating boolean,
    mint_condition boolean,
    CONSTRAINT valid_fine_level CHECK (((fine_level IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3])))),
    CONSTRAINT valid_loan_duration CHECK (((loan_duration IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3]))))
);


ALTER TABLE asset.copy_template OWNER TO postgres;

--
-- Name: copy_template_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE copy_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_template_id_seq OWNER TO postgres;

--
-- Name: copy_template_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE copy_template_id_seq OWNED BY copy_template.id;


--
-- Name: opac_visible_copies; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE opac_visible_copies (
    id bigint NOT NULL,
    copy_id bigint,
    record bigint,
    circ_lib integer
);


ALTER TABLE asset.opac_visible_copies OWNER TO postgres;

--
-- Name: TABLE opac_visible_copies; Type: COMMENT; Schema: asset; Owner: postgres
--

COMMENT ON TABLE opac_visible_copies IS '
Materialized view of copies that are visible in the OPAC, used by
search.query_parser_fts() to speed up OPAC visibility checks on large
databases.  Contents are maintained by a set of triggers.
';


--
-- Name: opac_visible_copies_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE opac_visible_copies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.opac_visible_copies_id_seq OWNER TO postgres;

--
-- Name: opac_visible_copies_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE opac_visible_copies_id_seq OWNED BY opac_visible_copies.id;


--
-- Name: stat_cat; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    required boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat OWNER TO postgres;

--
-- Name: stat_cat_entry; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.stat_cat_entry OWNER TO postgres;

--
-- Name: stat_cat_entry_copy_map; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry_copy_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_copy bigint NOT NULL
);


ALTER TABLE asset.stat_cat_entry_copy_map OWNER TO postgres;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_copy_map_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_copy_map_id_seq OWNED BY stat_cat_entry_copy_map.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_id_seq OWNED BY stat_cat_entry.id;


--
-- Name: stat_cat_entry_transparency_map; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_entry_transparency_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_transparency integer NOT NULL
);


ALTER TABLE asset.stat_cat_entry_transparency_map OWNER TO postgres;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE stat_cat_entry_transparency_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_transparency_map_id_seq OWNER TO postgres;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE stat_cat_entry_transparency_map_id_seq OWNED BY stat_cat_entry_transparency_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_id_seq OWNER TO postgres;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE stat_cat_id_seq OWNED BY stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat_sip_fields OWNER TO postgres;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: asset; Owner: postgres
--

COMMENT ON TABLE stat_cat_sip_fields IS '
Asset Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: uri; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE uri (
    id integer NOT NULL,
    href text NOT NULL,
    label text,
    use_restriction text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.uri OWNER TO postgres;

--
-- Name: uri_call_number_map; Type: TABLE; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE TABLE uri_call_number_map (
    id bigint NOT NULL,
    uri integer NOT NULL,
    call_number integer NOT NULL
);


ALTER TABLE asset.uri_call_number_map OWNER TO postgres;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE uri_call_number_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_call_number_map_id_seq OWNER TO postgres;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE uri_call_number_map_id_seq OWNED BY uri_call_number_map.id;


--
-- Name: uri_id_seq; Type: SEQUENCE; Schema: asset; Owner: postgres
--

CREATE SEQUENCE uri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_id_seq OWNER TO postgres;

--
-- Name: uri_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: postgres
--

ALTER SEQUENCE uri_id_seq OWNED BY uri.id;


SET search_path = auditor, pg_catalog;

--
-- Name: acq_invoice_entry_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE acq_invoice_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2)
);


ALTER TABLE auditor.acq_invoice_entry_history OWNER TO postgres;

--
-- Name: acq_invoice_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW acq_invoice_entry_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice_entry.id, invoice_entry.invoice, invoice_entry.purchase_order, invoice_entry.lineitem, invoice_entry.inv_item_count, invoice_entry.phys_item_count, invoice_entry.note, invoice_entry.billed_per_item, invoice_entry.cost_billed, invoice_entry.actual_cost, invoice_entry.amount_paid FROM acq.invoice_entry UNION ALL SELECT acq_invoice_entry_history.audit_id, acq_invoice_entry_history.audit_time, acq_invoice_entry_history.audit_action, acq_invoice_entry_history.audit_user, acq_invoice_entry_history.audit_ws, acq_invoice_entry_history.id, acq_invoice_entry_history.invoice, acq_invoice_entry_history.purchase_order, acq_invoice_entry_history.lineitem, acq_invoice_entry_history.inv_item_count, acq_invoice_entry_history.phys_item_count, acq_invoice_entry_history.note, acq_invoice_entry_history.billed_per_item, acq_invoice_entry_history.cost_billed, acq_invoice_entry_history.actual_cost, acq_invoice_entry_history.amount_paid FROM acq_invoice_entry_history;


ALTER TABLE auditor.acq_invoice_entry_lifecycle OWNER TO postgres;

--
-- Name: acq_invoice_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE acq_invoice_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_entry_pkey_seq OWNER TO postgres;

--
-- Name: acq_invoice_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE acq_invoice_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone NOT NULL,
    recv_method text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    complete boolean NOT NULL
);


ALTER TABLE auditor.acq_invoice_history OWNER TO postgres;

--
-- Name: acq_invoice_item_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE acq_invoice_item_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint
);


ALTER TABLE auditor.acq_invoice_item_history OWNER TO postgres;

--
-- Name: acq_invoice_item_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW acq_invoice_item_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice_item.id, invoice_item.invoice, invoice_item.purchase_order, invoice_item.fund_debit, invoice_item.inv_item_type, invoice_item.title, invoice_item.author, invoice_item.note, invoice_item.cost_billed, invoice_item.actual_cost, invoice_item.fund, invoice_item.amount_paid, invoice_item.po_item, invoice_item.target FROM acq.invoice_item UNION ALL SELECT acq_invoice_item_history.audit_id, acq_invoice_item_history.audit_time, acq_invoice_item_history.audit_action, acq_invoice_item_history.audit_user, acq_invoice_item_history.audit_ws, acq_invoice_item_history.id, acq_invoice_item_history.invoice, acq_invoice_item_history.purchase_order, acq_invoice_item_history.fund_debit, acq_invoice_item_history.inv_item_type, acq_invoice_item_history.title, acq_invoice_item_history.author, acq_invoice_item_history.note, acq_invoice_item_history.cost_billed, acq_invoice_item_history.actual_cost, acq_invoice_item_history.fund, acq_invoice_item_history.amount_paid, acq_invoice_item_history.po_item, acq_invoice_item_history.target FROM acq_invoice_item_history;


ALTER TABLE auditor.acq_invoice_item_lifecycle OWNER TO postgres;

--
-- Name: acq_invoice_item_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE acq_invoice_item_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_item_pkey_seq OWNER TO postgres;

--
-- Name: acq_invoice_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW acq_invoice_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice.id, invoice.receiver, invoice.provider, invoice.shipper, invoice.recv_date, invoice.recv_method, invoice.inv_type, invoice.inv_ident, invoice.payment_auth, invoice.payment_method, invoice.note, invoice.complete FROM acq.invoice UNION ALL SELECT acq_invoice_history.audit_id, acq_invoice_history.audit_time, acq_invoice_history.audit_action, acq_invoice_history.audit_user, acq_invoice_history.audit_ws, acq_invoice_history.id, acq_invoice_history.receiver, acq_invoice_history.provider, acq_invoice_history.shipper, acq_invoice_history.recv_date, acq_invoice_history.recv_method, acq_invoice_history.inv_type, acq_invoice_history.inv_ident, acq_invoice_history.payment_auth, acq_invoice_history.payment_method, acq_invoice_history.note, acq_invoice_history.complete FROM acq_invoice_history;


ALTER TABLE auditor.acq_invoice_lifecycle OWNER TO postgres;

--
-- Name: acq_invoice_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE acq_invoice_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_pkey_seq OWNER TO postgres;

--
-- Name: actor_org_unit_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE actor_org_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean NOT NULL,
    fiscal_calendar integer NOT NULL
);


ALTER TABLE auditor.actor_org_unit_history OWNER TO postgres;

--
-- Name: actor_org_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW actor_org_unit_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, org_unit.id, org_unit.parent_ou, org_unit.ou_type, org_unit.ill_address, org_unit.holds_address, org_unit.mailing_address, org_unit.billing_address, org_unit.shortname, org_unit.name, org_unit.email, org_unit.phone, org_unit.opac_visible, org_unit.fiscal_calendar FROM actor.org_unit UNION ALL SELECT actor_org_unit_history.audit_id, actor_org_unit_history.audit_time, actor_org_unit_history.audit_action, actor_org_unit_history.audit_user, actor_org_unit_history.audit_ws, actor_org_unit_history.id, actor_org_unit_history.parent_ou, actor_org_unit_history.ou_type, actor_org_unit_history.ill_address, actor_org_unit_history.holds_address, actor_org_unit_history.mailing_address, actor_org_unit_history.billing_address, actor_org_unit_history.shortname, actor_org_unit_history.name, actor_org_unit_history.email, actor_org_unit_history.phone, actor_org_unit_history.opac_visible, actor_org_unit_history.fiscal_calendar FROM actor_org_unit_history;


ALTER TABLE auditor.actor_org_unit_lifecycle OWNER TO postgres;

--
-- Name: actor_org_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE actor_org_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_org_unit_pkey_seq OWNER TO postgres;

--
-- Name: actor_usr_address_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE actor_usr_address_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    valid boolean NOT NULL,
    within_city_limits boolean NOT NULL,
    address_type text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean NOT NULL,
    replaces integer
);


ALTER TABLE auditor.actor_usr_address_history OWNER TO postgres;

--
-- Name: actor_usr_address_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW actor_usr_address_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, usr_address.id, usr_address.valid, usr_address.within_city_limits, usr_address.address_type, usr_address.usr, usr_address.street1, usr_address.street2, usr_address.city, usr_address.county, usr_address.state, usr_address.country, usr_address.post_code, usr_address.pending, usr_address.replaces FROM actor.usr_address UNION ALL SELECT actor_usr_address_history.audit_id, actor_usr_address_history.audit_time, actor_usr_address_history.audit_action, actor_usr_address_history.audit_user, actor_usr_address_history.audit_ws, actor_usr_address_history.id, actor_usr_address_history.valid, actor_usr_address_history.within_city_limits, actor_usr_address_history.address_type, actor_usr_address_history.usr, actor_usr_address_history.street1, actor_usr_address_history.street2, actor_usr_address_history.city, actor_usr_address_history.county, actor_usr_address_history.state, actor_usr_address_history.country, actor_usr_address_history.post_code, actor_usr_address_history.pending, actor_usr_address_history.replaces FROM actor_usr_address_history;


ALTER TABLE auditor.actor_usr_address_lifecycle OWNER TO postgres;

--
-- Name: actor_usr_address_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE actor_usr_address_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_address_pkey_seq OWNER TO postgres;

--
-- Name: actor_usr_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE actor_usr_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean NOT NULL,
    master_account boolean NOT NULL,
    super_user boolean NOT NULL,
    barred boolean NOT NULL,
    deleted boolean NOT NULL,
    juvenile boolean NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer NOT NULL,
    credit_forward_balance numeric(6,2) NOT NULL,
    last_xact_id text NOT NULL,
    alert_message text,
    create_date timestamp with time zone NOT NULL,
    expire_date timestamp with time zone NOT NULL,
    claims_never_checked_out_count integer NOT NULL,
    last_update_time timestamp with time zone
);


ALTER TABLE auditor.actor_usr_history OWNER TO postgres;

--
-- Name: actor_usr_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW actor_usr_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, usr.id, usr.card, usr.profile, usr.usrname, usr.email, usr.passwd, usr.standing, usr.ident_type, usr.ident_value, usr.ident_type2, usr.ident_value2, usr.net_access_level, usr.photo_url, usr.prefix, usr.first_given_name, usr.second_given_name, usr.family_name, usr.suffix, usr.alias, usr.day_phone, usr.evening_phone, usr.other_phone, usr.mailing_address, usr.billing_address, usr.home_ou, usr.dob, usr.active, usr.master_account, usr.super_user, usr.barred, usr.deleted, usr.juvenile, usr.usrgroup, usr.claims_returned_count, usr.credit_forward_balance, usr.last_xact_id, usr.alert_message, usr.create_date, usr.expire_date, usr.claims_never_checked_out_count, usr.last_update_time FROM actor.usr UNION ALL SELECT actor_usr_history.audit_id, actor_usr_history.audit_time, actor_usr_history.audit_action, actor_usr_history.audit_user, actor_usr_history.audit_ws, actor_usr_history.id, actor_usr_history.card, actor_usr_history.profile, actor_usr_history.usrname, actor_usr_history.email, actor_usr_history.passwd, actor_usr_history.standing, actor_usr_history.ident_type, actor_usr_history.ident_value, actor_usr_history.ident_type2, actor_usr_history.ident_value2, actor_usr_history.net_access_level, actor_usr_history.photo_url, actor_usr_history.prefix, actor_usr_history.first_given_name, actor_usr_history.second_given_name, actor_usr_history.family_name, actor_usr_history.suffix, actor_usr_history.alias, actor_usr_history.day_phone, actor_usr_history.evening_phone, actor_usr_history.other_phone, actor_usr_history.mailing_address, actor_usr_history.billing_address, actor_usr_history.home_ou, actor_usr_history.dob, actor_usr_history.active, actor_usr_history.master_account, actor_usr_history.super_user, actor_usr_history.barred, actor_usr_history.deleted, actor_usr_history.juvenile, actor_usr_history.usrgroup, actor_usr_history.claims_returned_count, actor_usr_history.credit_forward_balance, actor_usr_history.last_xact_id, actor_usr_history.alert_message, actor_usr_history.create_date, actor_usr_history.expire_date, actor_usr_history.claims_never_checked_out_count, actor_usr_history.last_update_time FROM actor_usr_history;


ALTER TABLE auditor.actor_usr_lifecycle OWNER TO postgres;

--
-- Name: actor_usr_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE actor_usr_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_pkey_seq OWNER TO postgres;

--
-- Name: asset_call_number_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE asset_call_number_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone,
    editor bigint NOT NULL,
    edit_date timestamp with time zone,
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean NOT NULL,
    prefix integer NOT NULL,
    suffix integer NOT NULL,
    label_class bigint NOT NULL,
    label_sortkey text
);


ALTER TABLE auditor.asset_call_number_history OWNER TO postgres;

--
-- Name: asset_call_number_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW asset_call_number_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, call_number.id, call_number.creator, call_number.create_date, call_number.editor, call_number.edit_date, call_number.record, call_number.owning_lib, call_number.label, call_number.deleted, call_number.prefix, call_number.suffix, call_number.label_class, call_number.label_sortkey FROM asset.call_number UNION ALL SELECT asset_call_number_history.audit_id, asset_call_number_history.audit_time, asset_call_number_history.audit_action, asset_call_number_history.audit_user, asset_call_number_history.audit_ws, asset_call_number_history.id, asset_call_number_history.creator, asset_call_number_history.create_date, asset_call_number_history.editor, asset_call_number_history.edit_date, asset_call_number_history.record, asset_call_number_history.owning_lib, asset_call_number_history.label, asset_call_number_history.deleted, asset_call_number_history.prefix, asset_call_number_history.suffix, asset_call_number_history.label_class, asset_call_number_history.label_sortkey FROM asset_call_number_history;


ALTER TABLE auditor.asset_call_number_lifecycle OWNER TO postgres;

--
-- Name: asset_call_number_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE asset_call_number_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_call_number_pkey_seq OWNER TO postgres;

--
-- Name: asset_copy_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE asset_copy_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating boolean NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    active_date timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE auditor.asset_copy_history OWNER TO postgres;

--
-- Name: asset_copy_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW asset_copy_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, copy.id, copy.circ_lib, copy.creator, copy.call_number, copy.editor, copy.create_date, copy.edit_date, copy.copy_number, copy.status, copy.location, copy.loan_duration, copy.fine_level, copy.age_protect, copy.circulate, copy.deposit, copy.ref, copy.holdable, copy.deposit_amount, copy.price, copy.barcode, copy.circ_modifier, copy.circ_as_type, copy.dummy_title, copy.dummy_author, copy.alert_message, copy.opac_visible, copy.deleted, copy.floating, copy.dummy_isbn, copy.status_changed_time, copy.active_date, copy.mint_condition, copy.cost FROM asset.copy UNION ALL SELECT asset_copy_history.audit_id, asset_copy_history.audit_time, asset_copy_history.audit_action, asset_copy_history.audit_user, asset_copy_history.audit_ws, asset_copy_history.id, asset_copy_history.circ_lib, asset_copy_history.creator, asset_copy_history.call_number, asset_copy_history.editor, asset_copy_history.create_date, asset_copy_history.edit_date, asset_copy_history.copy_number, asset_copy_history.status, asset_copy_history.location, asset_copy_history.loan_duration, asset_copy_history.fine_level, asset_copy_history.age_protect, asset_copy_history.circulate, asset_copy_history.deposit, asset_copy_history.ref, asset_copy_history.holdable, asset_copy_history.deposit_amount, asset_copy_history.price, asset_copy_history.barcode, asset_copy_history.circ_modifier, asset_copy_history.circ_as_type, asset_copy_history.dummy_title, asset_copy_history.dummy_author, asset_copy_history.alert_message, asset_copy_history.opac_visible, asset_copy_history.deleted, asset_copy_history.floating, asset_copy_history.dummy_isbn, asset_copy_history.status_changed_time, asset_copy_history.active_date, asset_copy_history.mint_condition, asset_copy_history.cost FROM asset_copy_history;


ALTER TABLE auditor.asset_copy_lifecycle OWNER TO postgres;

--
-- Name: asset_copy_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE asset_copy_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_copy_pkey_seq OWNER TO postgres;

--
-- Name: biblio_record_entry_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone NOT NULL,
    edit_date timestamp with time zone NOT NULL,
    active boolean NOT NULL,
    deleted boolean NOT NULL,
    fingerprint text,
    tcn_source text NOT NULL,
    tcn_value text NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer
);


ALTER TABLE auditor.biblio_record_entry_history OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: record_entry; Type: TABLE; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    fingerprint text,
    tcn_source text DEFAULT 'AUTOGEN'::text NOT NULL,
    tcn_value text DEFAULT next_autogen_tcn_value() NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer
);


ALTER TABLE biblio.record_entry OWNER TO postgres;

SET search_path = auditor, pg_catalog;

--
-- Name: biblio_record_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW biblio_record_entry_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, record_entry.id, record_entry.creator, record_entry.editor, record_entry.source, record_entry.quality, record_entry.create_date, record_entry.edit_date, record_entry.active, record_entry.deleted, record_entry.fingerprint, record_entry.tcn_source, record_entry.tcn_value, record_entry.marc, record_entry.last_xact_id, record_entry.owner, record_entry.share_depth FROM biblio.record_entry UNION ALL SELECT biblio_record_entry_history.audit_id, biblio_record_entry_history.audit_time, biblio_record_entry_history.audit_action, biblio_record_entry_history.audit_user, biblio_record_entry_history.audit_ws, biblio_record_entry_history.id, biblio_record_entry_history.creator, biblio_record_entry_history.editor, biblio_record_entry_history.source, biblio_record_entry_history.quality, biblio_record_entry_history.create_date, biblio_record_entry_history.edit_date, biblio_record_entry_history.active, biblio_record_entry_history.deleted, biblio_record_entry_history.fingerprint, biblio_record_entry_history.tcn_source, biblio_record_entry_history.tcn_value, biblio_record_entry_history.marc, biblio_record_entry_history.last_xact_id, biblio_record_entry_history.owner, biblio_record_entry_history.share_depth FROM biblio_record_entry_history;


ALTER TABLE auditor.biblio_record_entry_lifecycle OWNER TO postgres;

--
-- Name: biblio_record_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE biblio_record_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.biblio_record_entry_pkey_seq OWNER TO postgres;

--
-- Name: serial_unit_history; Type: TABLE; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE TABLE serial_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    audit_user integer,
    audit_ws integer,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating boolean NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    active_date timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2),
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL
);


ALTER TABLE auditor.serial_unit_history OWNER TO postgres;

SET search_path = serial, pg_catalog;

--
-- Name: unit; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE unit (
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL
)
INHERITS (asset.copy);


ALTER TABLE serial.unit OWNER TO postgres;

SET search_path = auditor, pg_catalog;

--
-- Name: serial_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: postgres
--

CREATE VIEW serial_unit_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, unit.id, unit.circ_lib, unit.creator, unit.call_number, unit.editor, unit.create_date, unit.edit_date, unit.copy_number, unit.status, unit.location, unit.loan_duration, unit.fine_level, unit.age_protect, unit.circulate, unit.deposit, unit.ref, unit.holdable, unit.deposit_amount, unit.price, unit.barcode, unit.circ_modifier, unit.circ_as_type, unit.dummy_title, unit.dummy_author, unit.alert_message, unit.opac_visible, unit.deleted, unit.floating, unit.dummy_isbn, unit.status_changed_time, unit.active_date, unit.mint_condition, unit.cost, unit.sort_key, unit.detailed_contents, unit.summary_contents FROM serial.unit UNION ALL SELECT serial_unit_history.audit_id, serial_unit_history.audit_time, serial_unit_history.audit_action, serial_unit_history.audit_user, serial_unit_history.audit_ws, serial_unit_history.id, serial_unit_history.circ_lib, serial_unit_history.creator, serial_unit_history.call_number, serial_unit_history.editor, serial_unit_history.create_date, serial_unit_history.edit_date, serial_unit_history.copy_number, serial_unit_history.status, serial_unit_history.location, serial_unit_history.loan_duration, serial_unit_history.fine_level, serial_unit_history.age_protect, serial_unit_history.circulate, serial_unit_history.deposit, serial_unit_history.ref, serial_unit_history.holdable, serial_unit_history.deposit_amount, serial_unit_history.price, serial_unit_history.barcode, serial_unit_history.circ_modifier, serial_unit_history.circ_as_type, serial_unit_history.dummy_title, serial_unit_history.dummy_author, serial_unit_history.alert_message, serial_unit_history.opac_visible, serial_unit_history.deleted, serial_unit_history.floating, serial_unit_history.dummy_isbn, serial_unit_history.status_changed_time, serial_unit_history.active_date, serial_unit_history.mint_condition, serial_unit_history.cost, serial_unit_history.sort_key, serial_unit_history.detailed_contents, serial_unit_history.summary_contents FROM serial_unit_history;


ALTER TABLE auditor.serial_unit_lifecycle OWNER TO postgres;

--
-- Name: serial_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: postgres
--

CREATE SEQUENCE serial_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.serial_unit_pkey_seq OWNER TO postgres;

SET search_path = authority, pg_catalog;

--
-- Name: bib_linking; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE bib_linking (
    id bigint NOT NULL,
    bib bigint NOT NULL,
    authority bigint NOT NULL
);


ALTER TABLE authority.bib_linking OWNER TO postgres;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE bib_linking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.bib_linking_id_seq OWNER TO postgres;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE bib_linking_id_seq OWNED BY bib_linking.id;


--
-- Name: browse_axis; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE browse_axis (
    code text NOT NULL,
    name text NOT NULL,
    sorter text,
    description text
);


ALTER TABLE authority.browse_axis OWNER TO postgres;

--
-- Name: browse_axis_authority_field_map; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE browse_axis_authority_field_map (
    id integer NOT NULL,
    axis text NOT NULL,
    field integer NOT NULL
);


ALTER TABLE authority.browse_axis_authority_field_map OWNER TO postgres;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE browse_axis_authority_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.browse_axis_authority_field_map_id_seq OWNER TO postgres;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE browse_axis_authority_field_map_id_seq OWNED BY browse_axis_authority_field_map.id;


--
-- Name: control_set; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE control_set (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.control_set OWNER TO postgres;

--
-- Name: control_set_authority_field; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE control_set_authority_field (
    id integer NOT NULL,
    main_entry integer,
    control_set integer NOT NULL,
    tag character(3) NOT NULL,
    nfi character(1),
    sf_list text NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.control_set_authority_field OWNER TO postgres;

--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE control_set_authority_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_authority_field_id_seq OWNER TO postgres;

--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE control_set_authority_field_id_seq OWNED BY control_set_authority_field.id;


--
-- Name: control_set_bib_field; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE control_set_bib_field (
    id integer NOT NULL,
    authority_field integer NOT NULL,
    tag character(3) NOT NULL
);


ALTER TABLE authority.control_set_bib_field OWNER TO postgres;

--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE control_set_bib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_bib_field_id_seq OWNER TO postgres;

--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE control_set_bib_field_id_seq OWNED BY control_set_bib_field.id;


--
-- Name: control_set_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE control_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_id_seq OWNER TO postgres;

--
-- Name: control_set_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE control_set_id_seq OWNED BY control_set.id;


--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.full_rec_id_seq OWNER TO postgres;

--
-- Name: full_rec_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE full_rec_id_seq OWNED BY full_rec.id;


--
-- Name: rec_descriptor; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE rec_descriptor (
    id bigint NOT NULL,
    record bigint,
    record_status text,
    encoding_level text,
    thesaurus text
);


ALTER TABLE authority.rec_descriptor OWNER TO postgres;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE rec_descriptor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.rec_descriptor_id_seq OWNER TO postgres;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE rec_descriptor_id_seq OWNED BY rec_descriptor.id;


--
-- Name: record_entry; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    source integer,
    control_set integer,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer
);


ALTER TABLE authority.record_entry OWNER TO postgres;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_entry_id_seq OWNER TO postgres;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE authority.record_note OWNER TO postgres;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_note_id_seq OWNER TO postgres;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE record_note_id_seq OWNED BY record_note.id;


--
-- Name: simple_heading_id_seq; Type: SEQUENCE; Schema: authority; Owner: postgres
--

CREATE SEQUENCE simple_heading_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.simple_heading_id_seq OWNER TO postgres;

--
-- Name: simple_heading_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: postgres
--

ALTER SEQUENCE simple_heading_id_seq OWNED BY simple_heading.id;


--
-- Name: thesaurus; Type: TABLE; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE TABLE thesaurus (
    code text NOT NULL,
    control_set integer,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.thesaurus OWNER TO postgres;

--
-- Name: tracing_links; Type: VIEW; Schema: authority; Owner: postgres
--

CREATE VIEW tracing_links AS
    SELECT main.record, main.id AS main_id, main.tag AS main_tag, evergreen.oils_xpath_string((('//*[@tag="'::text || (main.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS main_value, substr(link.value, 1, 1) AS relationship, substr(link.value, 2, 1) AS use_restriction, substr(link.value, 3, 1) AS deprecation, substr(link.value, 4, 1) AS display_restriction, link.id AS link_id, link.tag AS link_tag, evergreen.oils_xpath_string((('//*[@tag="'::text || (link.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS link_value, normalize_heading(are.marc) AS normalized_main_value FROM ((((full_rec main JOIN record_entry are ON ((main.record = are.id))) JOIN control_set_authority_field main_entry ON ((((main_entry.tag = main.tag) AND (main_entry.main_entry IS NULL)) AND (main.subfield = 'a'::text)))) JOIN control_set_authority_field sub_entry ON ((main_entry.id = sub_entry.main_entry))) JOIN full_rec link ON ((((link.record = main.record) AND (link.tag = sub_entry.tag)) AND (link.subfield = 'w'::text))));


ALTER TABLE authority.tracing_links OWNER TO postgres;

SET search_path = biblio, pg_catalog;

--
-- Name: autogen_tcn_value_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE autogen_tcn_value_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.autogen_tcn_value_seq OWNER TO postgres;

--
-- Name: monograph_part; Type: TABLE; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE TABLE monograph_part (
    id integer NOT NULL,
    record bigint NOT NULL,
    label text NOT NULL,
    label_sortkey text NOT NULL
);


ALTER TABLE biblio.monograph_part OWNER TO postgres;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE monograph_part_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.monograph_part_id_seq OWNER TO postgres;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: postgres
--

ALTER SEQUENCE monograph_part_id_seq OWNED BY monograph_part.id;


--
-- Name: peer_bib_copy_map; Type: TABLE; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE TABLE peer_bib_copy_map (
    id integer NOT NULL,
    peer_type integer NOT NULL,
    peer_record bigint NOT NULL,
    target_copy bigint NOT NULL
);


ALTER TABLE biblio.peer_bib_copy_map OWNER TO postgres;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE peer_bib_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_bib_copy_map_id_seq OWNER TO postgres;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: postgres
--

ALTER SEQUENCE peer_bib_copy_map_id_seq OWNED BY peer_bib_copy_map.id;


--
-- Name: peer_type; Type: TABLE; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE TABLE peer_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE biblio.peer_type OWNER TO postgres;

--
-- Name: peer_type_id_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE peer_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_type_id_seq OWNER TO postgres;

--
-- Name: peer_type_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: postgres
--

ALTER SEQUENCE peer_type_id_seq OWNED BY peer_type.id;


--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_entry_id_seq OWNER TO postgres;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: postgres
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE TABLE record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE biblio.record_note OWNER TO postgres;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: biblio; Owner: postgres
--

CREATE SEQUENCE record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_note_id_seq OWNER TO postgres;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: postgres
--

ALTER SEQUENCE record_note_id_seq OWNED BY record_note.id;


SET search_path = booking, pg_catalog;

--
-- Name: reservation; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE reservation (
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    capture_time timestamp with time zone,
    cancel_time timestamp with time zone,
    pickup_time timestamp with time zone,
    return_time timestamp with time zone,
    booking_interval interval,
    fine_interval interval,
    fine_amount numeric(8,2),
    max_fine numeric(8,2),
    target_resource_type integer NOT NULL,
    target_resource integer,
    current_resource integer,
    request_lib integer NOT NULL,
    pickup_lib integer,
    capture_staff integer,
    email_notify boolean DEFAULT false NOT NULL
)
INHERITS (money.billable_xact);


ALTER TABLE booking.reservation OWNER TO postgres;

--
-- Name: reservation_attr_value_map; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE reservation_attr_value_map (
    id integer NOT NULL,
    reservation integer NOT NULL,
    attr_value integer NOT NULL
);


ALTER TABLE booking.reservation_attr_value_map OWNER TO postgres;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE reservation_attr_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.reservation_attr_value_map_id_seq OWNER TO postgres;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE reservation_attr_value_map_id_seq OWNED BY reservation_attr_value_map.id;


--
-- Name: resource; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE resource (
    id integer NOT NULL,
    owner integer NOT NULL,
    type integer NOT NULL,
    overbook boolean DEFAULT false NOT NULL,
    barcode text NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    deposit_amount numeric(8,2) DEFAULT 0.00 NOT NULL,
    user_fee numeric(8,2) DEFAULT 0.00 NOT NULL
);


ALTER TABLE booking.resource OWNER TO postgres;

--
-- Name: resource_attr; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE resource_attr (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    resource_type integer NOT NULL,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE booking.resource_attr OWNER TO postgres;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE resource_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_id_seq OWNER TO postgres;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE resource_attr_id_seq OWNED BY resource_attr.id;


--
-- Name: resource_attr_map; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE resource_attr_map (
    id integer NOT NULL,
    resource integer NOT NULL,
    resource_attr integer NOT NULL,
    value integer NOT NULL
);


ALTER TABLE booking.resource_attr_map OWNER TO postgres;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE resource_attr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_map_id_seq OWNER TO postgres;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE resource_attr_map_id_seq OWNED BY resource_attr_map.id;


--
-- Name: resource_attr_value; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE resource_attr_value (
    id integer NOT NULL,
    owner integer NOT NULL,
    attr integer NOT NULL,
    valid_value text NOT NULL
);


ALTER TABLE booking.resource_attr_value OWNER TO postgres;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE resource_attr_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_value_id_seq OWNER TO postgres;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE resource_attr_value_id_seq OWNED BY resource_attr_value.id;


--
-- Name: resource_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_id_seq OWNER TO postgres;

--
-- Name: resource_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE resource_id_seq OWNED BY resource.id;


--
-- Name: resource_type; Type: TABLE; Schema: booking; Owner: postgres; Tablespace: 
--

CREATE TABLE resource_type (
    id integer NOT NULL,
    name text NOT NULL,
    elbow_room interval,
    fine_interval interval,
    fine_amount numeric(8,2) DEFAULT 0 NOT NULL,
    max_fine numeric(8,2),
    owner integer NOT NULL,
    catalog_item boolean DEFAULT false NOT NULL,
    transferable boolean DEFAULT false NOT NULL,
    record bigint
);


ALTER TABLE booking.resource_type OWNER TO postgres;

--
-- Name: resource_type_id_seq; Type: SEQUENCE; Schema: booking; Owner: postgres
--

CREATE SEQUENCE resource_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_type_id_seq OWNER TO postgres;

--
-- Name: resource_type_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: postgres
--

ALTER SEQUENCE resource_type_id_seq OWNED BY resource_type.id;


SET search_path = config, pg_catalog;

--
-- Name: coded_value_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE coded_value_map (
    id integer NOT NULL,
    ctype text NOT NULL,
    code text NOT NULL,
    value text NOT NULL,
    description text,
    opac_visible boolean DEFAULT true NOT NULL,
    search_label text,
    is_simple boolean DEFAULT false NOT NULL
);


ALTER TABLE config.coded_value_map OWNER TO postgres;

--
-- Name: audience_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW audience_map AS
    SELECT coded_value_map.code, coded_value_map.value, coded_value_map.description FROM coded_value_map WHERE (coded_value_map.ctype = 'audience'::text);


ALTER TABLE config.audience_map OWNER TO postgres;

--
-- Name: barcode_completion; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE barcode_completion (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    prefix text,
    suffix text,
    length integer DEFAULT 0 NOT NULL,
    padding text,
    padding_end boolean DEFAULT false NOT NULL,
    asset boolean DEFAULT true NOT NULL,
    actor boolean DEFAULT true NOT NULL
);


ALTER TABLE config.barcode_completion OWNER TO postgres;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE barcode_completion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.barcode_completion_id_seq OWNER TO postgres;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE barcode_completion_id_seq OWNED BY barcode_completion.id;


--
-- Name: best_hold_order; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE best_hold_order (
    id integer NOT NULL,
    name text,
    pprox integer,
    hprox integer,
    aprox integer,
    approx integer,
    priority integer,
    cut integer,
    depth integer,
    htime integer,
    rtime integer,
    shtime integer,
    CONSTRAINT best_hold_order_check CHECK (((((((((pprox IS NOT NULL) OR (hprox IS NOT NULL)) OR (aprox IS NOT NULL)) OR (priority IS NOT NULL)) OR (cut IS NOT NULL)) OR (depth IS NOT NULL)) OR (htime IS NOT NULL)) OR (rtime IS NOT NULL)))
);


ALTER TABLE config.best_hold_order OWNER TO postgres;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE best_hold_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.best_hold_order_id_seq OWNER TO postgres;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE best_hold_order_id_seq OWNED BY best_hold_order.id;


--
-- Name: bib_level_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW bib_level_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'bib_level'::text);


ALTER TABLE config.bib_level_map OWNER TO postgres;

--
-- Name: bib_source; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE bib_source (
    id integer NOT NULL,
    quality integer,
    source text NOT NULL,
    transcendant boolean DEFAULT false NOT NULL,
    can_have_copies boolean DEFAULT true NOT NULL,
    CONSTRAINT bib_source_quality_check CHECK (((quality >= 0) AND (quality <= 100)))
);


ALTER TABLE config.bib_source OWNER TO postgres;

--
-- Name: TABLE bib_source; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE bib_source IS '
This is table is used to set up the relative "quality" of each
MARC source, such as OCLC.  Also identifies "transcendant" sources,
i.e., sources of bib records that should display in the OPAC
even if no copies or located URIs are attached. Also indicates if
the source is allowed to have actual copies on its bibs. Volumes
for targeted URIs are unaffected by this setting.
';


--
-- Name: bib_source_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE bib_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.bib_source_id_seq OWNER TO postgres;

--
-- Name: bib_source_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE bib_source_id_seq OWNED BY bib_source.id;


--
-- Name: biblio_fingerprint; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_fingerprint (
    id integer NOT NULL,
    name text NOT NULL,
    xpath text NOT NULL,
    first_word boolean DEFAULT false NOT NULL,
    format text DEFAULT 'marcxml'::text NOT NULL
);


ALTER TABLE config.biblio_fingerprint OWNER TO postgres;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE biblio_fingerprint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.biblio_fingerprint_id_seq OWNER TO postgres;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE biblio_fingerprint_id_seq OWNED BY biblio_fingerprint.id;


--
-- Name: billing_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE billing_type (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    default_price numeric(6,2)
);


ALTER TABLE config.billing_type OWNER TO postgres;

--
-- Name: billing_type_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE billing_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.billing_type_id_seq OWNER TO postgres;

--
-- Name: billing_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE billing_type_id_seq OWNED BY billing_type.id;


--
-- Name: circ_limit_group; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_limit_group (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_group OWNER TO postgres;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_limit_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_group_id_seq OWNER TO postgres;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_limit_group_id_seq OWNED BY circ_limit_group.id;


--
-- Name: circ_limit_set; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_limit_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    items_out integer NOT NULL,
    depth integer DEFAULT 0 NOT NULL,
    global boolean DEFAULT false NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_set OWNER TO postgres;

--
-- Name: circ_limit_set_circ_mod_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_limit_set_circ_mod_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    circ_mod text NOT NULL
);


ALTER TABLE config.circ_limit_set_circ_mod_map OWNER TO postgres;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_limit_set_circ_mod_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_circ_mod_map_id_seq OWNER TO postgres;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_limit_set_circ_mod_map_id_seq OWNED BY circ_limit_set_circ_mod_map.id;


--
-- Name: circ_limit_set_copy_loc_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_limit_set_copy_loc_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    copy_loc integer NOT NULL
);


ALTER TABLE config.circ_limit_set_copy_loc_map OWNER TO postgres;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_limit_set_copy_loc_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_copy_loc_map_id_seq OWNER TO postgres;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_limit_set_copy_loc_map_id_seq OWNED BY circ_limit_set_copy_loc_map.id;


--
-- Name: circ_limit_set_group_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_limit_set_group_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    limit_group integer NOT NULL,
    check_only boolean DEFAULT false NOT NULL
);


ALTER TABLE config.circ_limit_set_group_map OWNER TO postgres;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_limit_set_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_group_map_id_seq OWNER TO postgres;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_limit_set_group_map_id_seq OWNED BY circ_limit_set_group_map.id;


--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_limit_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_id_seq OWNER TO postgres;

--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_limit_set_id_seq OWNED BY circ_limit_set.id;


--
-- Name: circ_matrix_limit_set_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_matrix_limit_set_map (
    id integer NOT NULL,
    matchpoint integer NOT NULL,
    limit_set integer NOT NULL,
    fallthrough boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE config.circ_matrix_limit_set_map OWNER TO postgres;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_matrix_limit_set_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_limit_set_map_id_seq OWNER TO postgres;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_matrix_limit_set_map_id_seq OWNED BY circ_matrix_limit_set_map.id;


--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_matchpoint_id_seq OWNER TO postgres;

--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_matrix_matchpoint_id_seq OWNED BY circ_matrix_matchpoint.id;


--
-- Name: circ_matrix_weights; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    org_unit numeric(6,2) NOT NULL,
    grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    copy_location numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    copy_circ_lib numeric(6,2) NOT NULL,
    copy_owning_lib numeric(6,2) NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    is_renewal numeric(6,2) NOT NULL,
    usr_age_lower_bound numeric(6,2) NOT NULL,
    usr_age_upper_bound numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL
);


ALTER TABLE config.circ_matrix_weights OWNER TO postgres;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE circ_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_weights_id_seq OWNER TO postgres;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE circ_matrix_weights_id_seq OWNED BY circ_matrix_weights.id;


--
-- Name: circ_modifier; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE circ_modifier (
    code text NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    sip2_media_type text NOT NULL,
    magnetic_media boolean DEFAULT true NOT NULL,
    avg_wait_time interval
);


ALTER TABLE config.circ_modifier OWNER TO postgres;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE coded_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.coded_value_map_id_seq OWNER TO postgres;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE coded_value_map_id_seq OWNED BY coded_value_map.id;


--
-- Name: copy_status; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_status (
    id integer NOT NULL,
    name text NOT NULL,
    holdable boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    copy_active boolean DEFAULT false NOT NULL,
    restrict_copy_delete boolean DEFAULT false NOT NULL
);


ALTER TABLE config.copy_status OWNER TO postgres;

--
-- Name: TABLE copy_status; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE copy_status IS '
Copy Statuses

The available copy statuses, and whether a copy in that
status is available for hold request capture.  0 (zero) is
the only special number in this set, meaning that the item
is available for immediate checkout, and is counted as available
in the OPAC.

Statuses with an ID below 100 are not removable, and have special
meaning in the code.  Do not change them except to translate the
textual name.

You may add and remove statuses above 100, and these can be used
to remove items from normal circulation without affecting the rest
of the copy''s values or its location.
';


--
-- Name: copy_status_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE copy_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.copy_status_id_seq OWNER TO postgres;

--
-- Name: copy_status_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE copy_status_id_seq OWNED BY copy_status.id;


--
-- Name: db_patch_dependencies; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE db_patch_dependencies (
    db_patch text NOT NULL,
    supersedes text[],
    deprecates text[]
);


ALTER TABLE config.db_patch_dependencies OWNER TO postgres;

--
-- Name: filter_dialog_filter_set; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE filter_dialog_filter_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    interface text NOT NULL,
    filters text NOT NULL,
    CONSTRAINT config_filter_dialog_filter_set_filters_check CHECK (evergreen.is_json(filters))
);


ALTER TABLE config.filter_dialog_filter_set OWNER TO postgres;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE filter_dialog_filter_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.filter_dialog_filter_set_id_seq OWNER TO postgres;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE filter_dialog_filter_set_id_seq OWNED BY filter_dialog_filter_set.id;


--
-- Name: filter_dialog_interface; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE filter_dialog_interface (
    key text NOT NULL,
    description text
);


ALTER TABLE config.filter_dialog_interface OWNER TO postgres;

--
-- Name: internal_flag; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE internal_flag (
    name text NOT NULL,
    value text,
    enabled boolean DEFAULT false NOT NULL
);


ALTER TABLE config.internal_flag OWNER TO postgres;

--
-- Name: global_flag; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE global_flag (
    label text NOT NULL
)
INHERITS (internal_flag);


ALTER TABLE config.global_flag OWNER TO postgres;

--
-- Name: hard_due_date; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE hard_due_date (
    id integer NOT NULL,
    name text NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    forceto boolean NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE config.hard_due_date OWNER TO postgres;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE hard_due_date_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_id_seq OWNER TO postgres;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE hard_due_date_id_seq OWNED BY hard_due_date.id;


--
-- Name: hard_due_date_values; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE hard_due_date_values (
    id integer NOT NULL,
    hard_due_date integer NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    active_date timestamp with time zone NOT NULL
);


ALTER TABLE config.hard_due_date_values OWNER TO postgres;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE hard_due_date_values_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_values_id_seq OWNER TO postgres;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE hard_due_date_values_id_seq OWNED BY hard_due_date_values.id;


--
-- Name: hold_matrix_matchpoint; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    strict_ou_match boolean DEFAULT false NOT NULL,
    user_home_ou integer,
    request_ou integer,
    pickup_ou integer,
    item_owning_ou integer,
    item_circ_ou integer,
    usr_grp integer,
    requestor_grp integer NOT NULL,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_bib_level text,
    marc_vr_format text,
    juvenile_flag boolean,
    ref_flag boolean,
    item_age interval,
    holdable boolean DEFAULT true NOT NULL,
    distance_is_from_owner boolean DEFAULT false NOT NULL,
    transit_range integer,
    max_holds integer,
    include_frozen_holds boolean DEFAULT true NOT NULL,
    stop_blocked_user boolean DEFAULT false NOT NULL,
    age_hold_protect_rule integer
);


ALTER TABLE config.hold_matrix_matchpoint OWNER TO postgres;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE hold_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_matchpoint_id_seq OWNER TO postgres;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE hold_matrix_matchpoint_id_seq OWNED BY hold_matrix_matchpoint.id;


--
-- Name: hold_matrix_weights; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE hold_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    request_ou numeric(6,2) NOT NULL,
    pickup_ou numeric(6,2) NOT NULL,
    item_owning_ou numeric(6,2) NOT NULL,
    item_circ_ou numeric(6,2) NOT NULL,
    usr_grp numeric(6,2) NOT NULL,
    requestor_grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL
);


ALTER TABLE config.hold_matrix_weights OWNER TO postgres;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE hold_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_weights_id_seq OWNER TO postgres;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE hold_matrix_weights_id_seq OWNED BY hold_matrix_weights.id;


--
-- Name: i18n_core; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE i18n_core (
    id bigint NOT NULL,
    fq_field text NOT NULL,
    identity_value text NOT NULL,
    translation text NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.i18n_core OWNER TO postgres;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE i18n_core_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.i18n_core_id_seq OWNER TO postgres;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE i18n_core_id_seq OWNED BY i18n_core.id;


--
-- Name: i18n_locale; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE i18n_locale (
    code text NOT NULL,
    marc_code text NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE config.i18n_locale OWNER TO postgres;

--
-- Name: identification_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE identification_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.identification_type OWNER TO postgres;

--
-- Name: TABLE identification_type; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE identification_type IS '
Types of valid patron identification.

Each patron must display at least one valid form of identification
in order to get a library card.  This table lists those forms.
';


--
-- Name: identification_type_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE identification_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.identification_type_id_seq OWNER TO postgres;

--
-- Name: identification_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE identification_type_id_seq OWNED BY identification_type.id;


--
-- Name: idl_field_doc; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE idl_field_doc (
    id bigint NOT NULL,
    fm_class text NOT NULL,
    field text NOT NULL,
    owner integer NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.idl_field_doc OWNER TO postgres;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE idl_field_doc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.idl_field_doc_id_seq OWNER TO postgres;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE idl_field_doc_id_seq OWNED BY idl_field_doc.id;


--
-- Name: index_normalizer; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE index_normalizer (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    func text NOT NULL,
    param_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.index_normalizer OWNER TO postgres;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE index_normalizer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.index_normalizer_id_seq OWNER TO postgres;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE index_normalizer_id_seq OWNED BY index_normalizer.id;


--
-- Name: item_form_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW item_form_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_form'::text);


ALTER TABLE config.item_form_map OWNER TO postgres;

--
-- Name: item_type_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW item_type_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_type'::text);


ALTER TABLE config.item_type_map OWNER TO postgres;

--
-- Name: language_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW language_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_lang'::text);


ALTER TABLE config.language_map OWNER TO postgres;

--
-- Name: lit_form_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW lit_form_map AS
    SELECT coded_value_map.code, coded_value_map.value, coded_value_map.description FROM coded_value_map WHERE (coded_value_map.ctype = 'lit_form'::text);


ALTER TABLE config.lit_form_map OWNER TO postgres;

--
-- Name: marc21_ff_pos_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE marc21_ff_pos_map (
    id integer NOT NULL,
    fixed_field text NOT NULL,
    tag text NOT NULL,
    rec_type text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    default_val text DEFAULT ' '::text NOT NULL
);


ALTER TABLE config.marc21_ff_pos_map OWNER TO postgres;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE marc21_ff_pos_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_ff_pos_map_id_seq OWNER TO postgres;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE marc21_ff_pos_map_id_seq OWNED BY marc21_ff_pos_map.id;


--
-- Name: marc21_physical_characteristic_subfield_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_subfield_map (
    id integer NOT NULL,
    ptype_key text NOT NULL,
    subfield text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_subfield_map OWNER TO postgres;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE marc21_physical_characteristic_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_subfield_map_id_seq OWNER TO postgres;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE marc21_physical_characteristic_subfield_map_id_seq OWNED BY marc21_physical_characteristic_subfield_map.id;


--
-- Name: marc21_physical_characteristic_type_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_type_map (
    ptype_key text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_type_map OWNER TO postgres;

--
-- Name: marc21_physical_characteristic_value_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_value_map (
    id integer NOT NULL,
    value text NOT NULL,
    ptype_subfield integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_value_map OWNER TO postgres;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE marc21_physical_characteristic_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_value_map_id_seq OWNER TO postgres;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE marc21_physical_characteristic_value_map_id_seq OWNED BY marc21_physical_characteristic_value_map.id;


--
-- Name: metabib_class; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_class (
    name text NOT NULL,
    label text NOT NULL,
    buoyant boolean DEFAULT false NOT NULL,
    restrict boolean DEFAULT false NOT NULL,
    combined boolean DEFAULT false NOT NULL,
    a_weight numeric DEFAULT 1.0 NOT NULL,
    b_weight numeric DEFAULT 0.4 NOT NULL,
    c_weight numeric DEFAULT 0.2 NOT NULL,
    d_weight numeric DEFAULT 0.1 NOT NULL
);


ALTER TABLE config.metabib_class OWNER TO postgres;

--
-- Name: metabib_class_ts_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_class_ts_map (
    id integer NOT NULL,
    field_class text NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    always boolean DEFAULT true NOT NULL,
    CONSTRAINT metabib_class_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_class_ts_map OWNER TO postgres;

--
-- Name: TABLE metabib_class_ts_map; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE metabib_class_ts_map IS '
Text Search Configs for metabib class indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE metabib_class_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_class_ts_map_id_seq OWNER TO postgres;

--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE metabib_class_ts_map_id_seq OWNED BY metabib_class_ts_map.id;


--
-- Name: metabib_field; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_field (
    id integer NOT NULL,
    field_class text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    xpath text NOT NULL,
    weight integer DEFAULT 1 NOT NULL,
    format text DEFAULT 'mods33'::text NOT NULL,
    search_field boolean DEFAULT true NOT NULL,
    facet_field boolean DEFAULT false NOT NULL,
    browse_field boolean DEFAULT true NOT NULL,
    browse_xpath text,
    facet_xpath text,
    restrict boolean DEFAULT false NOT NULL
);


ALTER TABLE config.metabib_field OWNER TO postgres;

--
-- Name: TABLE metabib_field; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE metabib_field IS '
XPath used for record indexing ingest

This table contains the XPath used to chop up MODS into its
indexable parts.  Each XPath entry is named and assigned to
a "class" of either title, subject, author, keyword, series
or identifier.
';


--
-- Name: metabib_field_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE metabib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_id_seq OWNER TO postgres;

--
-- Name: metabib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE metabib_field_id_seq OWNED BY metabib_field.id;


--
-- Name: metabib_field_index_norm_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_field_index_norm_map (
    id integer NOT NULL,
    field integer NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.metabib_field_index_norm_map OWNER TO postgres;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE metabib_field_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_index_norm_map_id_seq OWNER TO postgres;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE metabib_field_index_norm_map_id_seq OWNED BY metabib_field_index_norm_map.id;


--
-- Name: metabib_field_ts_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_field_ts_map (
    id integer NOT NULL,
    metabib_field integer NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    CONSTRAINT metabib_field_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_field_ts_map OWNER TO postgres;

--
-- Name: TABLE metabib_field_ts_map; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE metabib_field_ts_map IS '
Text Search Configs for metabib field indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE metabib_field_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_ts_map_id_seq OWNER TO postgres;

--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE metabib_field_ts_map_id_seq OWNED BY metabib_field_ts_map.id;


--
-- Name: metabib_search_alias; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE metabib_search_alias (
    alias text NOT NULL,
    field_class text NOT NULL,
    field integer
);


ALTER TABLE config.metabib_search_alias OWNER TO postgres;

--
-- Name: net_access_level; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE net_access_level (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.net_access_level OWNER TO postgres;

--
-- Name: TABLE net_access_level; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE net_access_level IS '
Patron Network Access level

This will be used to inform the in-library firewall of how much
internet access the using patron should be allowed.
';


--
-- Name: net_access_level_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE net_access_level_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.net_access_level_id_seq OWNER TO postgres;

--
-- Name: net_access_level_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE net_access_level_id_seq OWNED BY net_access_level.id;


--
-- Name: non_cataloged_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE non_cataloged_type (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    name text NOT NULL,
    circ_duration interval DEFAULT '14 days'::interval NOT NULL,
    in_house boolean DEFAULT false NOT NULL
);


ALTER TABLE config.non_cataloged_type OWNER TO postgres;

--
-- Name: TABLE non_cataloged_type; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE non_cataloged_type IS '
Types of valid non-cataloged items.
';


--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE non_cataloged_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.non_cataloged_type_id_seq OWNER TO postgres;

--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE non_cataloged_type_id_seq OWNED BY non_cataloged_type.id;


--
-- Name: org_unit_setting_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_setting_type (
    name text NOT NULL,
    label text NOT NULL,
    grp text,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    view_perm integer,
    update_perm integer,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.org_unit_setting_type OWNER TO postgres;

--
-- Name: org_unit_setting_type_log; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE org_unit_setting_type_log (
    id bigint NOT NULL,
    date_applied timestamp with time zone DEFAULT now() NOT NULL,
    org integer,
    original_value text,
    new_value text,
    field_name text
);


ALTER TABLE config.org_unit_setting_type_log OWNER TO postgres;

--
-- Name: TABLE org_unit_setting_type_log; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE org_unit_setting_type_log IS '
Org Unit setting Logs

This table contains the most recent changes to each setting 
in actor.org_unit_setting, allowing for mistakes to be undone.
This is NOT meant to be an auditor, but rather an undo/redo.
';


--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE org_unit_setting_type_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.org_unit_setting_type_log_id_seq OWNER TO postgres;

--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE org_unit_setting_type_log_id_seq OWNED BY org_unit_setting_type_log.id;


--
-- Name: record_attr_definition; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE record_attr_definition (
    name text NOT NULL,
    label text NOT NULL,
    description text,
    filter boolean DEFAULT true NOT NULL,
    sorter boolean DEFAULT false NOT NULL,
    tag text,
    sf_list text,
    joiner text,
    xpath text,
    format text,
    start_pos integer,
    string_len integer,
    fixed_field text,
    phys_char_sf integer
);


ALTER TABLE config.record_attr_definition OWNER TO postgres;

--
-- Name: record_attr_index_norm_map; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE record_attr_index_norm_map (
    id integer NOT NULL,
    attr text NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.record_attr_index_norm_map OWNER TO postgres;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE record_attr_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.record_attr_index_norm_map_id_seq OWNER TO postgres;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE record_attr_index_norm_map_id_seq OWNED BY record_attr_index_norm_map.id;


--
-- Name: remote_account_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE remote_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.remote_account_id_seq OWNER TO postgres;

--
-- Name: remote_account_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE remote_account_id_seq OWNED BY remote_account.id;


--
-- Name: rule_age_hold_protect; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE rule_age_hold_protect (
    id integer NOT NULL,
    name text NOT NULL,
    age interval NOT NULL,
    prox integer NOT NULL,
    CONSTRAINT rule_age_hold_protect_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_age_hold_protect OWNER TO postgres;

--
-- Name: TABLE rule_age_hold_protect; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE rule_age_hold_protect IS '
Hold Item Age Protection rules

A hold request can only capture new(ish) items when they are
within a particular proximity of the pickup_lib of the request.
The proximity (''prox'' column) is calculated by counting
the number of tree edges between the pickup_lib and either the
owning_lib or circ_lib of the copy that could fulfill the hold,
as determined by the distance_is_from_owner value of the hold matrix
rule controlling the hold request.
';


--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE rule_age_hold_protect_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_age_hold_protect_id_seq OWNER TO postgres;

--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE rule_age_hold_protect_id_seq OWNED BY rule_age_hold_protect.id;


--
-- Name: rule_circ_duration; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE rule_circ_duration (
    id integer NOT NULL,
    name text NOT NULL,
    extended interval NOT NULL,
    normal interval NOT NULL,
    shrt interval NOT NULL,
    max_renewals integer NOT NULL,
    CONSTRAINT rule_circ_duration_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_circ_duration OWNER TO postgres;

--
-- Name: TABLE rule_circ_duration; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE rule_circ_duration IS '
Circulation Duration rules

Each circulation is given a duration based on one of these rules.
';


--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE rule_circ_duration_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_circ_duration_id_seq OWNER TO postgres;

--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE rule_circ_duration_id_seq OWNED BY rule_circ_duration.id;


--
-- Name: rule_max_fine; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE rule_max_fine (
    id integer NOT NULL,
    name text NOT NULL,
    amount numeric(6,2) NOT NULL,
    is_percent boolean DEFAULT false NOT NULL,
    CONSTRAINT rule_max_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_max_fine OWNER TO postgres;

--
-- Name: TABLE rule_max_fine; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE rule_max_fine IS '
Circulation Max Fine rules

Each circulation is given a maximum fine based on one of
these rules.
';


--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE rule_max_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_max_fine_id_seq OWNER TO postgres;

--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE rule_max_fine_id_seq OWNED BY rule_max_fine.id;


--
-- Name: rule_recurring_fine; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE rule_recurring_fine (
    id integer NOT NULL,
    name text NOT NULL,
    high numeric(6,2) NOT NULL,
    normal numeric(6,2) NOT NULL,
    low numeric(6,2) NOT NULL,
    recurrence_interval interval DEFAULT '1 day'::interval NOT NULL,
    grace_period interval DEFAULT '1 day'::interval NOT NULL,
    CONSTRAINT rule_recurring_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_recurring_fine OWNER TO postgres;

--
-- Name: TABLE rule_recurring_fine; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE rule_recurring_fine IS '
Circulation Recurring Fine rules

Each circulation is given a recurring fine amount based on one of
these rules.  Note that it is recommended to run the fine generator
(from cron) at least as frequently as the lowest recurrence interval
used by your circulation rules so that accrued fines will be up
to date.
';


--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE rule_recurring_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_recurring_fine_id_seq OWNER TO postgres;

--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE rule_recurring_fine_id_seq OWNED BY rule_recurring_fine.id;


--
-- Name: settings_group; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE settings_group (
    name text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.settings_group OWNER TO postgres;

--
-- Name: sms_carrier; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE sms_carrier (
    id integer NOT NULL,
    region text,
    name text,
    email_gateway text,
    active boolean DEFAULT true
);


ALTER TABLE config.sms_carrier OWNER TO postgres;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE sms_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.sms_carrier_id_seq OWNER TO postgres;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE sms_carrier_id_seq OWNED BY sms_carrier.id;


--
-- Name: standing; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE standing (
    id integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE config.standing OWNER TO postgres;

--
-- Name: TABLE standing; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE standing IS '
Patron Standings

This table contains the values that can be applied to a patron
by a staff member.  These values should not be changed, other
than for translation, as the ID column is currently a "magic
number" in the source. :(
';


--
-- Name: standing_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE standing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_id_seq OWNER TO postgres;

--
-- Name: standing_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE standing_id_seq OWNED BY standing.id;


--
-- Name: standing_penalty; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE standing_penalty (
    id integer NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    block_list text,
    staff_alert boolean DEFAULT false NOT NULL,
    org_depth integer
);


ALTER TABLE config.standing_penalty OWNER TO postgres;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_penalty_id_seq OWNER TO postgres;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE standing_penalty_id_seq OWNED BY standing_penalty.id;


--
-- Name: ts_config_list; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE ts_config_list (
    id text NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.ts_config_list OWNER TO postgres;

--
-- Name: TABLE ts_config_list; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE ts_config_list IS '
Full Text Configs

A list of full text configs with names and descriptions.
';


--
-- Name: upgrade_log; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE upgrade_log (
    version text NOT NULL,
    install_date timestamp with time zone DEFAULT now() NOT NULL,
    applied_to text
);


ALTER TABLE config.upgrade_log OWNER TO postgres;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE usr_activity_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.usr_activity_type_id_seq OWNER TO postgres;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE usr_activity_type_id_seq OWNED BY usr_activity_type.id;


--
-- Name: usr_setting_type; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_setting_type (
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    label text NOT NULL,
    description text,
    grp text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.usr_setting_type OWNER TO postgres;

--
-- Name: videorecording_format_map; Type: VIEW; Schema: config; Owner: postgres
--

CREATE VIEW videorecording_format_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'vr_format'::text);


ALTER TABLE config.videorecording_format_map OWNER TO postgres;

--
-- Name: weight_assoc; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE weight_assoc (
    id integer NOT NULL,
    active boolean NOT NULL,
    org_unit integer NOT NULL,
    circ_weights integer,
    hold_weights integer
);


ALTER TABLE config.weight_assoc OWNER TO postgres;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE weight_assoc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.weight_assoc_id_seq OWNER TO postgres;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE weight_assoc_id_seq OWNED BY weight_assoc.id;


--
-- Name: xml_transform; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE xml_transform (
    name text NOT NULL,
    namespace_uri text NOT NULL,
    prefix text NOT NULL,
    xslt text NOT NULL
);


ALTER TABLE config.xml_transform OWNER TO postgres;

--
-- Name: z3950_attr; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE z3950_attr (
    id integer NOT NULL,
    source text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    code integer NOT NULL,
    format integer NOT NULL,
    truncation integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.z3950_attr OWNER TO postgres;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE z3950_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_attr_id_seq OWNER TO postgres;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE z3950_attr_id_seq OWNED BY z3950_attr.id;


--
-- Name: z3950_source; Type: TABLE; Schema: config; Owner: postgres; Tablespace: 
--

CREATE TABLE z3950_source (
    name text NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    port integer NOT NULL,
    db text NOT NULL,
    record_format text DEFAULT 'FI'::text NOT NULL,
    transmission_format text DEFAULT 'usmarc'::text NOT NULL,
    auth boolean DEFAULT true NOT NULL,
    use_perm integer
);


ALTER TABLE config.z3950_source OWNER TO postgres;

--
-- Name: TABLE z3950_source; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON TABLE z3950_source IS '
Z39.50 Sources

Each row in this table represents a database searchable via Z39.50.
';


--
-- Name: COLUMN z3950_source.record_format; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN z3950_source.record_format IS '
Z39.50 element set.
';


--
-- Name: COLUMN z3950_source.transmission_format; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN z3950_source.transmission_format IS '
Z39.50 preferred record syntax..
';


--
-- Name: COLUMN z3950_source.use_perm; Type: COMMENT; Schema: config; Owner: postgres
--

COMMENT ON COLUMN z3950_source.use_perm IS '
If set, this permission is required for the source to be listed in the staff
client Z39.50 interface.  Similar to permission.grp_tree.application_perm.
';


--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE; Schema: config; Owner: postgres
--

CREATE SEQUENCE z3950_source_credentials_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_source_credentials_id_seq OWNER TO postgres;

--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: postgres
--

ALTER SEQUENCE z3950_source_credentials_id_seq OWNED BY z3950_source_credentials.id;


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    description text,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE biblio_record_entry_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_id_seq OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE biblio_record_entry_bucket_id_seq OWNED BY biblio_record_entry_bucket.id;


--
-- Name: biblio_record_entry_bucket_item; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_biblio_record_entry bigint NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE biblio_record_entry_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_id_seq OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE biblio_record_entry_bucket_item_id_seq OWNED BY biblio_record_entry_bucket_item.id;


--
-- Name: biblio_record_entry_bucket_item_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item_note OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE biblio_record_entry_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_note_id_seq OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE biblio_record_entry_bucket_item_note_id_seq OWNED BY biblio_record_entry_bucket_item_note.id;


--
-- Name: biblio_record_entry_bucket_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_note OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE biblio_record_entry_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_note_id_seq OWNER TO postgres;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE biblio_record_entry_bucket_note_id_seq OWNED BY biblio_record_entry_bucket_note.id;


--
-- Name: biblio_record_entry_bucket_type; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_type OWNER TO postgres;

--
-- Name: call_number_bucket; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    description text,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.call_number_bucket OWNER TO postgres;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE call_number_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_id_seq OWNER TO postgres;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE call_number_bucket_id_seq OWNED BY call_number_bucket.id;


--
-- Name: call_number_bucket_item; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_call_number integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.call_number_bucket_item OWNER TO postgres;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE call_number_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_id_seq OWNER TO postgres;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE call_number_bucket_item_id_seq OWNED BY call_number_bucket_item.id;


--
-- Name: call_number_bucket_item_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_item_note OWNER TO postgres;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE call_number_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_note_id_seq OWNER TO postgres;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE call_number_bucket_item_note_id_seq OWNED BY call_number_bucket_item_note.id;


--
-- Name: call_number_bucket_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_note OWNER TO postgres;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE call_number_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_note_id_seq OWNER TO postgres;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE call_number_bucket_note_id_seq OWNED BY call_number_bucket_note.id;


--
-- Name: call_number_bucket_type; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE call_number_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.call_number_bucket_type OWNER TO postgres;

--
-- Name: copy_bucket; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    description text,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.copy_bucket OWNER TO postgres;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE copy_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_id_seq OWNER TO postgres;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE copy_bucket_id_seq OWNED BY copy_bucket.id;


--
-- Name: copy_bucket_item; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_copy integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.copy_bucket_item OWNER TO postgres;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE copy_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_id_seq OWNER TO postgres;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE copy_bucket_item_id_seq OWNED BY copy_bucket_item.id;


--
-- Name: copy_bucket_item_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_item_note OWNER TO postgres;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE copy_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_note_id_seq OWNER TO postgres;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE copy_bucket_item_note_id_seq OWNED BY copy_bucket_item_note.id;


--
-- Name: copy_bucket_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_note OWNER TO postgres;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE copy_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_note_id_seq OWNER TO postgres;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE copy_bucket_note_id_seq OWNED BY copy_bucket_note.id;


--
-- Name: copy_bucket_type; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE copy_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.copy_bucket_type OWNER TO postgres;

--
-- Name: user_bucket; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE user_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    description text,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.user_bucket OWNER TO postgres;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE user_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_id_seq OWNER TO postgres;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE user_bucket_id_seq OWNED BY user_bucket.id;


--
-- Name: user_bucket_item; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE user_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_user integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.user_bucket_item OWNER TO postgres;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE user_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_id_seq OWNER TO postgres;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE user_bucket_item_id_seq OWNED BY user_bucket_item.id;


--
-- Name: user_bucket_item_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE user_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_item_note OWNER TO postgres;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE user_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_note_id_seq OWNER TO postgres;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE user_bucket_item_note_id_seq OWNED BY user_bucket_item_note.id;


--
-- Name: user_bucket_note; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE user_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_note OWNER TO postgres;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: postgres
--

CREATE SEQUENCE user_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_note_id_seq OWNER TO postgres;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: postgres
--

ALTER SEQUENCE user_bucket_note_id_seq OWNED BY user_bucket_note.id;


--
-- Name: user_bucket_type; Type: TABLE; Schema: container; Owner: postgres; Tablespace: 
--

CREATE TABLE user_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.user_bucket_type OWNER TO postgres;

SET search_path = extend_reporter, pg_catalog;

--
-- Name: legacy_circ_count; Type: TABLE; Schema: extend_reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE legacy_circ_count (
    id bigint NOT NULL,
    circ_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE extend_reporter.legacy_circ_count OWNER TO postgres;

--
-- Name: full_circ_count; Type: VIEW; Schema: extend_reporter; Owner: postgres
--

CREATE VIEW full_circ_count AS
    SELECT cp.id, ((COALESCE((c.circ_count)::bigint, (0)::bigint) + COALESCE(count(DISTINCT circ.id), (0)::bigint)) + COALESCE(count(DISTINCT acirc.id), (0)::bigint)) AS circ_count FROM (((asset.copy cp LEFT JOIN legacy_circ_count c USING (id)) LEFT JOIN action.circulation circ ON ((circ.target_copy = cp.id))) LEFT JOIN action.aged_circulation acirc ON ((acirc.target_copy = cp.id))) GROUP BY cp.id, c.circ_count;


ALTER TABLE extend_reporter.full_circ_count OWNER TO postgres;

--
-- Name: global_bibs_by_holding_update; Type: VIEW; Schema: extend_reporter; Owner: postgres
--

CREATE VIEW global_bibs_by_holding_update AS
    SELECT DISTINCT ON (x.id) x.id, x.holding_update, x.update_type FROM (SELECT b.id, public.last(cp.create_date) AS holding_update, 'add'::text AS update_type FROM ((biblio.record_entry b JOIN asset.call_number cn ON ((cn.record = b.id))) JOIN asset.copy cp ON ((cp.call_number = cn.id))) WHERE ((NOT cp.deleted) AND (b.id > 0)) GROUP BY b.id UNION SELECT b.id, public.last(cp.edit_date) AS holding_update, 'delete'::text AS update_type FROM ((biblio.record_entry b JOIN asset.call_number cn ON ((cn.record = b.id))) JOIN asset.copy cp ON ((cp.call_number = cn.id))) WHERE (cp.deleted AND (b.id > 0)) GROUP BY b.id) x ORDER BY x.id, x.holding_update;


ALTER TABLE extend_reporter.global_bibs_by_holding_update OWNER TO postgres;

SET search_path = metabib, pg_catalog;

--
-- Name: author_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE author_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.author_field_entry OWNER TO postgres;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE author_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.author_field_entry_id_seq OWNER TO postgres;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE author_field_entry_id_seq OWNED BY author_field_entry.id;


--
-- Name: browse_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE browse_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector
);


ALTER TABLE metabib.browse_entry OWNER TO postgres;

--
-- Name: browse_entry_def_map; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE browse_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint
);


ALTER TABLE metabib.browse_entry_def_map OWNER TO postgres;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE browse_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_def_map_id_seq OWNER TO postgres;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE browse_entry_def_map_id_seq OWNED BY browse_entry_def_map.id;


--
-- Name: browse_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE browse_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_id_seq OWNER TO postgres;

--
-- Name: browse_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE browse_entry_id_seq OWNED BY browse_entry.id;


--
-- Name: combined_author_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_author_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_author_field_entry OWNER TO postgres;

--
-- Name: combined_identifier_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_identifier_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_identifier_field_entry OWNER TO postgres;

--
-- Name: combined_keyword_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_keyword_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_keyword_field_entry OWNER TO postgres;

--
-- Name: combined_series_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_series_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_series_field_entry OWNER TO postgres;

--
-- Name: combined_subject_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_subject_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_subject_field_entry OWNER TO postgres;

--
-- Name: combined_title_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE combined_title_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_title_field_entry OWNER TO postgres;

--
-- Name: facet_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE facet_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.facet_entry OWNER TO postgres;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE facet_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.facet_entry_id_seq OWNER TO postgres;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE facet_entry_id_seq OWNED BY facet_entry.id;


--
-- Name: identifier_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE identifier_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.identifier_field_entry OWNER TO postgres;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE identifier_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.identifier_field_entry_id_seq OWNER TO postgres;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE identifier_field_entry_id_seq OWNED BY identifier_field_entry.id;


--
-- Name: keyword_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE keyword_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.keyword_field_entry OWNER TO postgres;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE keyword_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.keyword_field_entry_id_seq OWNER TO postgres;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE keyword_field_entry_id_seq OWNED BY keyword_field_entry.id;


--
-- Name: metarecord; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE metarecord (
    id bigint NOT NULL,
    fingerprint text NOT NULL,
    master_record bigint,
    mods text
);


ALTER TABLE metabib.metarecord OWNER TO postgres;

--
-- Name: metarecord_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE metarecord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_id_seq OWNER TO postgres;

--
-- Name: metarecord_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE metarecord_id_seq OWNED BY metarecord.id;


--
-- Name: metarecord_source_map; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE metarecord_source_map (
    id bigint NOT NULL,
    metarecord bigint NOT NULL,
    source bigint NOT NULL
);


ALTER TABLE metabib.metarecord_source_map OWNER TO postgres;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE metarecord_source_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_source_map_id_seq OWNER TO postgres;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE metarecord_source_map_id_seq OWNED BY metarecord_source_map.id;


--
-- Name: record_attr; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE record_attr (
    id bigint NOT NULL,
    attrs public.hstore DEFAULT ''::public.hstore NOT NULL
);


ALTER TABLE metabib.record_attr OWNER TO postgres;

--
-- Name: rec_descriptor; Type: VIEW; Schema: metabib; Owner: postgres
--

CREATE VIEW rec_descriptor AS
    SELECT record_attr.id, record_attr.id AS record, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_type AS item_type, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_form AS item_form, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).bib_level AS bib_level, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).control_type AS control_type, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).char_encoding AS char_encoding, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).enc_level AS enc_level, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).audience AS audience, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).lit_form AS lit_form, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).type_mat AS type_mat, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).cat_form AS cat_form, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).pub_status AS pub_status, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_lang AS item_lang, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).vr_format AS vr_format, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).date1 AS date1, (public.populate_record(NULL::rec_desc_type, record_attr.attrs)).date2 AS date2 FROM record_attr;


ALTER TABLE metabib.rec_descriptor OWNER TO postgres;

--
-- Name: series_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE series_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.series_field_entry OWNER TO postgres;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE series_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.series_field_entry_id_seq OWNER TO postgres;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE series_field_entry_id_seq OWNED BY series_field_entry.id;


--
-- Name: subject_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE subject_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.subject_field_entry OWNER TO postgres;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE subject_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.subject_field_entry_id_seq OWNER TO postgres;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE subject_field_entry_id_seq OWNED BY subject_field_entry.id;


--
-- Name: title_field_entry; Type: TABLE; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE TABLE title_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.title_field_entry OWNER TO postgres;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: postgres
--

CREATE SEQUENCE title_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.title_field_entry_id_seq OWNER TO postgres;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: postgres
--

ALTER SEQUENCE title_field_entry_id_seq OWNED BY title_field_entry.id;


SET search_path = money, pg_catalog;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE; Schema: money; Owner: postgres
--

CREATE SEQUENCE billable_xact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billable_xact_id_seq OWNER TO postgres;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: postgres
--

ALTER SEQUENCE billable_xact_id_seq OWNED BY billable_xact.id;


--
-- Name: materialized_billable_xact_summary; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE materialized_billable_xact_summary (
    id bigint NOT NULL,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    total_paid numeric,
    last_payment_ts timestamp with time zone,
    last_payment_note text,
    last_payment_type name,
    total_owed numeric,
    last_billing_ts timestamp with time zone,
    last_billing_note text,
    last_billing_type text,
    balance_owed numeric,
    xact_type name
);


ALTER TABLE money.materialized_billable_xact_summary OWNER TO postgres;

--
-- Name: billable_xact_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW billable_xact_summary AS
    SELECT materialized_billable_xact_summary.id, materialized_billable_xact_summary.usr, materialized_billable_xact_summary.xact_start, materialized_billable_xact_summary.xact_finish, materialized_billable_xact_summary.total_paid, materialized_billable_xact_summary.last_payment_ts, materialized_billable_xact_summary.last_payment_note, materialized_billable_xact_summary.last_payment_type, materialized_billable_xact_summary.total_owed, materialized_billable_xact_summary.last_billing_ts, materialized_billable_xact_summary.last_billing_note, materialized_billable_xact_summary.last_billing_type, materialized_billable_xact_summary.balance_owed, materialized_billable_xact_summary.xact_type FROM materialized_billable_xact_summary;


ALTER TABLE money.billable_xact_summary OWNER TO postgres;

--
-- Name: grocery; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE grocery (
    billing_location integer NOT NULL,
    note text
)
INHERITS (billable_xact);


ALTER TABLE money.grocery OWNER TO postgres;

--
-- Name: billable_xact_summary_location_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW billable_xact_summary_location_view AS
    SELECT m.id, m.usr, m.xact_start, m.xact_finish, m.total_paid, m.last_payment_ts, m.last_payment_note, m.last_payment_type, m.total_owed, m.last_billing_ts, m.last_billing_note, m.last_billing_type, m.balance_owed, m.xact_type, COALESCE(c.circ_lib, g.billing_location, r.pickup_lib) AS billing_location FROM (((materialized_billable_xact_summary m LEFT JOIN action.circulation c ON ((c.id = m.id))) LEFT JOIN grocery g ON ((g.id = m.id))) LEFT JOIN booking.reservation r ON ((r.id = m.id)));


ALTER TABLE money.billable_xact_summary_location_view OWNER TO postgres;

--
-- Name: billing; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE billing (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2) NOT NULL,
    billing_type text NOT NULL,
    btype integer NOT NULL,
    note text
);


ALTER TABLE money.billing OWNER TO postgres;

--
-- Name: payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE payment (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2) NOT NULL,
    note text
);


ALTER TABLE money.payment OWNER TO postgres;

--
-- Name: payment_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, c.relname AS payment_type FROM (payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.payment_view OWNER TO postgres;

--
-- Name: billable_xact_with_void_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW billable_xact_with_void_summary AS
    SELECT xact.id, xact.usr, xact.xact_start, xact.xact_finish, sum(credit.amount) AS total_paid, max(credit.payment_ts) AS last_payment_ts, public.last(credit.note) AS last_payment_note, public.last(credit.payment_type) AS last_payment_type, sum(debit.amount) AS total_owed, max(debit.billing_ts) AS last_billing_ts, public.last(debit.note) AS last_billing_note, public.last(debit.billing_type) AS last_billing_type, (COALESCE(sum(debit.amount), (0)::numeric) - COALESCE(sum(credit.amount), (0)::numeric)) AS balance_owed, p.relname AS xact_type FROM (((billable_xact xact JOIN pg_class p ON ((xact.tableoid = p.oid))) LEFT JOIN billing debit ON ((xact.id = debit.xact))) LEFT JOIN payment_view credit ON ((xact.id = credit.xact))) GROUP BY xact.id, xact.usr, xact.xact_start, xact.xact_finish, p.relname ORDER BY max(debit.billing_ts), max(credit.payment_ts);


ALTER TABLE money.billable_xact_with_void_summary OWNER TO postgres;

--
-- Name: billing_id_seq; Type: SEQUENCE; Schema: money; Owner: postgres
--

CREATE SEQUENCE billing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billing_id_seq OWNER TO postgres;

--
-- Name: billing_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: postgres
--

ALTER SEQUENCE billing_id_seq OWNED BY billing.id;


--
-- Name: bnm_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE bnm_payment (
    amount_collected numeric(6,2) NOT NULL,
    accepting_usr integer NOT NULL
)
INHERITS (payment);


ALTER TABLE money.bnm_payment OWNER TO postgres;

--
-- Name: bnm_desk_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE bnm_desk_payment (
    cash_drawer integer
)
INHERITS (bnm_payment);


ALTER TABLE money.bnm_desk_payment OWNER TO postgres;

--
-- Name: bnm_payment_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW bnm_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, c.relname AS payment_type FROM (bnm_payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.bnm_payment_view OWNER TO postgres;

--
-- Name: cash_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE cash_payment (
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.cash_payment OWNER TO postgres;

--
-- Name: cashdrawer_payment_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW cashdrawer_payment_view AS
    SELECT ou.id AS org_unit, ws.id AS cashdrawer, t.payment_type, p.payment_ts, p.amount, p.voided, p.note FROM (((actor.org_unit ou JOIN actor.workstation ws ON ((ou.id = ws.owning_lib))) LEFT JOIN bnm_desk_payment p ON ((ws.id = p.cash_drawer))) LEFT JOIN payment_view t ON ((p.id = t.id)));


ALTER TABLE money.cashdrawer_payment_view OWNER TO postgres;

--
-- Name: check_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE check_payment (
    check_number text NOT NULL
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.check_payment OWNER TO postgres;

--
-- Name: collections_tracker; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE collections_tracker (
    id bigint NOT NULL,
    usr integer NOT NULL,
    collector integer NOT NULL,
    location integer NOT NULL,
    enter_time timestamp with time zone
);


ALTER TABLE money.collections_tracker OWNER TO postgres;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE; Schema: money; Owner: postgres
--

CREATE SEQUENCE collections_tracker_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.collections_tracker_id_seq OWNER TO postgres;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: postgres
--

ALTER SEQUENCE collections_tracker_id_seq OWNED BY collections_tracker.id;


--
-- Name: credit_card_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE credit_card_payment (
    cc_type text,
    cc_number text,
    cc_processor text,
    cc_first_name text,
    cc_last_name text,
    cc_order_number text,
    expire_month integer,
    expire_year integer,
    approval_code text
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.credit_card_payment OWNER TO postgres;

--
-- Name: credit_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE credit_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.credit_payment OWNER TO postgres;

--
-- Name: desk_payment_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW desk_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, p.cash_drawer, c.relname AS payment_type FROM (bnm_desk_payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.desk_payment_view OWNER TO postgres;

--
-- Name: forgive_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE forgive_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.forgive_payment OWNER TO postgres;

--
-- Name: goods_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE goods_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.goods_payment OWNER TO postgres;

--
-- Name: non_drawer_payment_view; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW non_drawer_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, c.relname AS payment_type FROM (bnm_payment p JOIN pg_class c ON ((p.tableoid = c.oid))) WHERE (c.relname <> ALL (ARRAY['cash_payment'::name, 'check_payment'::name, 'credit_card_payment'::name]));


ALTER TABLE money.non_drawer_payment_view OWNER TO postgres;

--
-- Name: open_billable_xact_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_billable_xact_summary AS
    SELECT billable_xact_summary_location_view.id, billable_xact_summary_location_view.usr, billable_xact_summary_location_view.xact_start, billable_xact_summary_location_view.xact_finish, billable_xact_summary_location_view.total_paid, billable_xact_summary_location_view.last_payment_ts, billable_xact_summary_location_view.last_payment_note, billable_xact_summary_location_view.last_payment_type, billable_xact_summary_location_view.total_owed, billable_xact_summary_location_view.last_billing_ts, billable_xact_summary_location_view.last_billing_note, billable_xact_summary_location_view.last_billing_type, billable_xact_summary_location_view.balance_owed, billable_xact_summary_location_view.xact_type, billable_xact_summary_location_view.billing_location FROM billable_xact_summary_location_view WHERE (billable_xact_summary_location_view.xact_finish IS NULL);


ALTER TABLE money.open_billable_xact_summary OWNER TO postgres;

--
-- Name: open_transaction_billing_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_transaction_billing_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.open_transaction_billing_summary OWNER TO postgres;

--
-- Name: open_transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_transaction_billing_type_summary AS
    SELECT billing.xact, billing.billing_type AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact, billing.billing_type ORDER BY max(billing.billing_ts);


ALTER TABLE money.open_transaction_billing_type_summary OWNER TO postgres;

--
-- Name: open_transaction_payment_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_transaction_payment_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid FROM payment_view WHERE (payment_view.voided IS FALSE) GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.open_transaction_payment_summary OWNER TO postgres;

--
-- Name: open_usr_circulation_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_usr_circulation_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary WHERE ((materialized_billable_xact_summary.xact_type = 'circulation'::name) AND (materialized_billable_xact_summary.xact_finish IS NULL)) GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_circulation_summary OWNER TO postgres;

--
-- Name: open_usr_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW open_usr_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary WHERE (materialized_billable_xact_summary.xact_finish IS NULL) GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_summary OWNER TO postgres;

--
-- Name: payment_id_seq; Type: SEQUENCE; Schema: money; Owner: postgres
--

CREATE SEQUENCE payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.payment_id_seq OWNER TO postgres;

--
-- Name: payment_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: postgres
--

ALTER SEQUENCE payment_id_seq OWNED BY payment.id;


--
-- Name: transaction_billing_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW transaction_billing_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_summary OWNER TO postgres;

--
-- Name: transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW transaction_billing_type_summary AS
    SELECT billing.xact, billing.billing_type AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact, billing.billing_type ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_type_summary OWNER TO postgres;

--
-- Name: transaction_billing_with_void_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW transaction_billing_with_void_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(CASE WHEN billing.voided THEN (0)::numeric ELSE COALESCE(billing.amount, (0)::numeric) END) AS total_owed FROM billing GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_with_void_summary OWNER TO postgres;

--
-- Name: transaction_payment_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW transaction_payment_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid FROM payment_view WHERE (payment_view.voided IS FALSE) GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.transaction_payment_summary OWNER TO postgres;

--
-- Name: transaction_payment_with_void_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW transaction_payment_with_void_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(CASE WHEN payment_view.voided THEN (0)::numeric ELSE COALESCE(payment_view.amount, (0)::numeric) END) AS total_paid FROM payment_view GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.transaction_payment_with_void_summary OWNER TO postgres;

--
-- Name: usr_circulation_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW usr_circulation_summary AS
    SELECT billable_xact_summary.usr, sum(billable_xact_summary.total_paid) AS total_paid, sum(billable_xact_summary.total_owed) AS total_owed, sum(billable_xact_summary.balance_owed) AS balance_owed FROM billable_xact_summary WHERE (billable_xact_summary.xact_type = 'circulation'::name) GROUP BY billable_xact_summary.usr;


ALTER TABLE money.usr_circulation_summary OWNER TO postgres;

--
-- Name: usr_summary; Type: VIEW; Schema: money; Owner: postgres
--

CREATE VIEW usr_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.usr_summary OWNER TO postgres;

--
-- Name: work_payment; Type: TABLE; Schema: money; Owner: postgres; Tablespace: 
--

CREATE TABLE work_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.work_payment OWNER TO postgres;

SET search_path = offline, pg_catalog;

--
-- Name: script; Type: TABLE; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE TABLE script (
    id integer NOT NULL,
    session text NOT NULL,
    requestor integer NOT NULL,
    create_time integer NOT NULL,
    workstation text NOT NULL,
    logfile text NOT NULL,
    time_delta integer DEFAULT 0 NOT NULL,
    count integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.script OWNER TO postgres;

--
-- Name: script_id_seq; Type: SEQUENCE; Schema: offline; Owner: postgres
--

CREATE SEQUENCE script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE offline.script_id_seq OWNER TO postgres;

--
-- Name: script_id_seq; Type: SEQUENCE OWNED BY; Schema: offline; Owner: postgres
--

ALTER SEQUENCE script_id_seq OWNED BY script.id;


--
-- Name: session; Type: TABLE; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE TABLE session (
    key text NOT NULL,
    org integer NOT NULL,
    description text,
    creator integer NOT NULL,
    create_time integer NOT NULL,
    in_process integer DEFAULT 0 NOT NULL,
    start_time integer,
    end_time integer,
    num_complete integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.session OWNER TO postgres;

SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE grp_penalty_threshold (
    id integer NOT NULL,
    grp integer NOT NULL,
    org_unit integer NOT NULL,
    penalty integer NOT NULL,
    threshold numeric(8,2) NOT NULL
);


ALTER TABLE permission.grp_penalty_threshold OWNER TO postgres;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE grp_penalty_threshold_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_penalty_threshold_id_seq OWNER TO postgres;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE grp_penalty_threshold_id_seq OWNED BY grp_penalty_threshold.id;


--
-- Name: grp_perm_map; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE grp_perm_map (
    id integer NOT NULL,
    grp integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.grp_perm_map OWNER TO postgres;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE grp_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_perm_map_id_seq OWNER TO postgres;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE grp_perm_map_id_seq OWNED BY grp_perm_map.id;


--
-- Name: grp_tree_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE grp_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_tree_id_seq OWNER TO postgres;

--
-- Name: grp_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE grp_tree_id_seq OWNED BY grp_tree.id;


--
-- Name: perm_list; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE perm_list (
    id integer NOT NULL,
    code text NOT NULL,
    description text
);


ALTER TABLE permission.perm_list OWNER TO postgres;

--
-- Name: perm_list_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE perm_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.perm_list_id_seq OWNER TO postgres;

--
-- Name: perm_list_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE perm_list_id_seq OWNED BY perm_list.id;


--
-- Name: usr_grp_map; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_grp_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    grp integer NOT NULL
);


ALTER TABLE permission.usr_grp_map OWNER TO postgres;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE usr_grp_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_grp_map_id_seq OWNER TO postgres;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE usr_grp_map_id_seq OWNED BY usr_grp_map.id;


--
-- Name: usr_object_perm_map; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_object_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    object_type text NOT NULL,
    object_id text NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_object_perm_map OWNER TO postgres;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE usr_object_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_object_perm_map_id_seq OWNER TO postgres;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE usr_object_perm_map_id_seq OWNED BY usr_object_perm_map.id;


--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE usr_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_perm_map_id_seq OWNER TO postgres;

--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE usr_perm_map_id_seq OWNED BY usr_perm_map.id;


--
-- Name: usr_work_ou_map; Type: TABLE; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE TABLE usr_work_ou_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    work_ou integer NOT NULL
);


ALTER TABLE permission.usr_work_ou_map OWNER TO postgres;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: postgres
--

CREATE SEQUENCE usr_work_ou_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_work_ou_map_id_seq OWNER TO postgres;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: postgres
--

ALTER SEQUENCE usr_work_ou_map_id_seq OWNED BY usr_work_ou_map.id;


SET search_path = query, pg_catalog;

--
-- Name: bind_variable; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE bind_variable (
    name text NOT NULL,
    type text NOT NULL,
    description text NOT NULL,
    default_value text,
    label text NOT NULL,
    CONSTRAINT bind_variable_type CHECK ((type = ANY (ARRAY['string'::text, 'number'::text, 'string_list'::text, 'number_list'::text])))
);


ALTER TABLE query.bind_variable OWNER TO postgres;

--
-- Name: case_branch; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE case_branch (
    id integer NOT NULL,
    parent_expr integer NOT NULL,
    seq_no integer NOT NULL,
    condition integer,
    result integer NOT NULL
);


ALTER TABLE query.case_branch OWNER TO postgres;

--
-- Name: case_branch_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE case_branch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.case_branch_id_seq OWNER TO postgres;

--
-- Name: case_branch_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE case_branch_id_seq OWNED BY case_branch.id;


--
-- Name: datatype; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE datatype (
    id integer NOT NULL,
    datatype_name text NOT NULL,
    is_numeric boolean DEFAULT false NOT NULL,
    is_composite boolean DEFAULT false NOT NULL,
    CONSTRAINT qdt_comp_not_num CHECK (((is_numeric IS FALSE) OR (is_composite IS FALSE)))
);


ALTER TABLE query.datatype OWNER TO postgres;

--
-- Name: datatype_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE datatype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.datatype_id_seq OWNER TO postgres;

--
-- Name: datatype_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE datatype_id_seq OWNED BY datatype.id;


--
-- Name: expression; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE expression (
    id integer NOT NULL,
    type text NOT NULL,
    parenthesize boolean DEFAULT false NOT NULL,
    parent_expr integer,
    seq_no integer DEFAULT 1 NOT NULL,
    literal text,
    table_alias text,
    column_name text,
    left_operand integer,
    operator text,
    right_operand integer,
    function_id integer,
    subquery integer,
    cast_type integer,
    negate boolean DEFAULT false NOT NULL,
    bind_variable text,
    CONSTRAINT expression_type CHECK ((type = ANY (ARRAY['xbet'::text, 'xbind'::text, 'xbool'::text, 'xcase'::text, 'xcast'::text, 'xcol'::text, 'xex'::text, 'xfunc'::text, 'xin'::text, 'xisnull'::text, 'xnull'::text, 'xnum'::text, 'xop'::text, 'xser'::text, 'xstr'::text, 'xsubq'::text])))
);


ALTER TABLE query.expression OWNER TO postgres;

--
-- Name: expr_xbet; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xbet AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xbet'::text);


ALTER TABLE query.expr_xbet OWNER TO postgres;

--
-- Name: expr_xbind; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xbind AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.bind_variable FROM expression WHERE (expression.type = 'xbind'::text);


ALTER TABLE query.expr_xbind OWNER TO postgres;

--
-- Name: expr_xbool; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xbool AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal, expression.negate FROM expression WHERE (expression.type = 'xbool'::text);


ALTER TABLE query.expr_xbool OWNER TO postgres;

--
-- Name: expr_xcase; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xcase AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xcase'::text);


ALTER TABLE query.expr_xcase OWNER TO postgres;

--
-- Name: expr_xcast; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xcast AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.cast_type, expression.negate FROM expression WHERE (expression.type = 'xcast'::text);


ALTER TABLE query.expr_xcast OWNER TO postgres;

--
-- Name: expr_xcol; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xcol AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.table_alias, expression.column_name, expression.negate FROM expression WHERE (expression.type = 'xcol'::text);


ALTER TABLE query.expr_xcol OWNER TO postgres;

--
-- Name: expr_xex; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xex AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xex'::text);


ALTER TABLE query.expr_xex OWNER TO postgres;

--
-- Name: expr_xfunc; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xfunc AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.column_name, expression.function_id, expression.negate FROM expression WHERE (expression.type = 'xfunc'::text);


ALTER TABLE query.expr_xfunc OWNER TO postgres;

--
-- Name: expr_xin; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xin AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xin'::text);


ALTER TABLE query.expr_xin OWNER TO postgres;

--
-- Name: expr_xisnull; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xisnull AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xisnull'::text);


ALTER TABLE query.expr_xisnull OWNER TO postgres;

--
-- Name: expr_xnull; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xnull AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.negate FROM expression WHERE (expression.type = 'xnull'::text);


ALTER TABLE query.expr_xnull OWNER TO postgres;

--
-- Name: expr_xnum; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xnum AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal FROM expression WHERE (expression.type = 'xnum'::text);


ALTER TABLE query.expr_xnum OWNER TO postgres;

--
-- Name: expr_xop; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xop AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.operator, expression.right_operand, expression.negate FROM expression WHERE (expression.type = 'xop'::text);


ALTER TABLE query.expr_xop OWNER TO postgres;

--
-- Name: expr_xser; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xser AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.operator, expression.negate FROM expression WHERE (expression.type = 'xser'::text);


ALTER TABLE query.expr_xser OWNER TO postgres;

--
-- Name: expr_xstr; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xstr AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal FROM expression WHERE (expression.type = 'xstr'::text);


ALTER TABLE query.expr_xstr OWNER TO postgres;

--
-- Name: expr_xsubq; Type: VIEW; Schema: query; Owner: postgres
--

CREATE VIEW expr_xsubq AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xsubq'::text);


ALTER TABLE query.expr_xsubq OWNER TO postgres;

--
-- Name: expression_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE expression_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.expression_id_seq OWNER TO postgres;

--
-- Name: expression_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE expression_id_seq OWNED BY expression.id;


--
-- Name: from_relation; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE from_relation (
    id integer NOT NULL,
    type text NOT NULL,
    table_name text,
    class_name text,
    subquery integer,
    function_call integer,
    table_alias text,
    parent_relation integer,
    seq_no integer DEFAULT 1 NOT NULL,
    join_type text,
    on_clause integer,
    CONSTRAINT good_join_type CHECK (((join_type IS NULL) OR (join_type = ANY (ARRAY['INNER'::text, 'LEFT'::text, 'RIGHT'::text, 'FULL'::text])))),
    CONSTRAINT join_or_core CHECK (((((parent_relation IS NULL) AND (join_type IS NULL)) AND (on_clause IS NULL)) OR (((parent_relation IS NOT NULL) AND (join_type IS NOT NULL)) AND (on_clause IS NOT NULL)))),
    CONSTRAINT relation_type CHECK ((type = ANY (ARRAY['RELATION'::text, 'SUBQUERY'::text, 'FUNCTION'::text])))
);


ALTER TABLE query.from_relation OWNER TO postgres;

--
-- Name: from_relation_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE from_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.from_relation_id_seq OWNER TO postgres;

--
-- Name: from_relation_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE from_relation_id_seq OWNED BY from_relation.id;


--
-- Name: function_param_def; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE function_param_def (
    id integer NOT NULL,
    function_id integer NOT NULL,
    seq_no integer NOT NULL,
    datatype integer NOT NULL,
    CONSTRAINT qfpd_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.function_param_def OWNER TO postgres;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE function_param_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_param_def_id_seq OWNER TO postgres;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE function_param_def_id_seq OWNED BY function_param_def.id;


--
-- Name: function_sig; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE function_sig (
    id integer NOT NULL,
    function_name text NOT NULL,
    return_type integer,
    is_aggregate boolean DEFAULT false NOT NULL,
    CONSTRAINT qfd_rtn_or_aggr CHECK (((return_type IS NULL) OR (is_aggregate = false)))
);


ALTER TABLE query.function_sig OWNER TO postgres;

--
-- Name: function_sig_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE function_sig_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_sig_id_seq OWNER TO postgres;

--
-- Name: function_sig_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE function_sig_id_seq OWNED BY function_sig.id;


--
-- Name: order_by_item; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE order_by_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL
);


ALTER TABLE query.order_by_item OWNER TO postgres;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE order_by_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.order_by_item_id_seq OWNER TO postgres;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE order_by_item_id_seq OWNED BY order_by_item.id;


--
-- Name: query_sequence; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE query_sequence (
    id integer NOT NULL,
    parent_query integer NOT NULL,
    seq_no integer NOT NULL,
    child_query integer NOT NULL
);


ALTER TABLE query.query_sequence OWNER TO postgres;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE query_sequence_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.query_sequence_id_seq OWNER TO postgres;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE query_sequence_id_seq OWNED BY query_sequence.id;


--
-- Name: record_column; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE record_column (
    id integer NOT NULL,
    from_relation integer NOT NULL,
    seq_no integer NOT NULL,
    column_name text NOT NULL,
    column_type integer NOT NULL
);


ALTER TABLE query.record_column OWNER TO postgres;

--
-- Name: record_column_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE record_column_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.record_column_id_seq OWNER TO postgres;

--
-- Name: record_column_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE record_column_id_seq OWNED BY record_column.id;


--
-- Name: select_item; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE select_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL,
    column_alias text,
    grouped_by boolean DEFAULT false NOT NULL
);


ALTER TABLE query.select_item OWNER TO postgres;

--
-- Name: select_item_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE select_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.select_item_id_seq OWNER TO postgres;

--
-- Name: select_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE select_item_id_seq OWNED BY select_item.id;


--
-- Name: stored_query; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE stored_query (
    id integer NOT NULL,
    type text NOT NULL,
    use_all boolean DEFAULT false NOT NULL,
    use_distinct boolean DEFAULT false NOT NULL,
    from_clause integer,
    where_clause integer,
    having_clause integer,
    limit_count integer,
    offset_count integer,
    CONSTRAINT query_type CHECK ((type = ANY (ARRAY['SELECT'::text, 'UNION'::text, 'INTERSECT'::text, 'EXCEPT'::text])))
);


ALTER TABLE query.stored_query OWNER TO postgres;

--
-- Name: stored_query_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE stored_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.stored_query_id_seq OWNER TO postgres;

--
-- Name: stored_query_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE stored_query_id_seq OWNED BY stored_query.id;


--
-- Name: subfield; Type: TABLE; Schema: query; Owner: postgres; Tablespace: 
--

CREATE TABLE subfield (
    id integer NOT NULL,
    composite_type integer NOT NULL,
    seq_no integer NOT NULL,
    subfield_type integer NOT NULL,
    CONSTRAINT qsf_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.subfield OWNER TO postgres;

--
-- Name: subfield_id_seq; Type: SEQUENCE; Schema: query; Owner: postgres
--

CREATE SEQUENCE subfield_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.subfield_id_seq OWNER TO postgres;

--
-- Name: subfield_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: postgres
--

ALTER SEQUENCE subfield_id_seq OWNED BY subfield.id;


SET search_path = reporter, pg_catalog;

--
-- Name: circ_type; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW circ_type AS
    SELECT circulation.id, CASE WHEN ((circulation.opac_renewal OR circulation.phone_renewal) OR circulation.desk_renewal) THEN 'RENEWAL'::text ELSE 'CHECKOUT'::text END AS type FROM action.circulation;


ALTER TABLE reporter.circ_type OWNER TO postgres;

--
-- Name: report; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE report (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text DEFAULT ''::text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    template integer NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL,
    recur boolean DEFAULT false NOT NULL,
    recurrence interval
);


ALTER TABLE reporter.report OWNER TO postgres;

--
-- Name: schedule; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE schedule (
    id integer NOT NULL,
    report integer NOT NULL,
    folder integer NOT NULL,
    runner integer NOT NULL,
    run_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    complete_time timestamp with time zone,
    email text,
    excel_format boolean DEFAULT true NOT NULL,
    html_format boolean DEFAULT true NOT NULL,
    csv_format boolean DEFAULT true NOT NULL,
    chart_pie boolean DEFAULT false NOT NULL,
    chart_bar boolean DEFAULT false NOT NULL,
    chart_line boolean DEFAULT false NOT NULL,
    error_code integer,
    error_text text
);


ALTER TABLE reporter.schedule OWNER TO postgres;

--
-- Name: currently_running; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW currently_running AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE ((s.start_time IS NOT NULL) AND (s.complete_time IS NULL));


ALTER TABLE reporter.currently_running OWNER TO postgres;

--
-- Name: demographic; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW demographic AS
    SELECT u.id, u.dob, CASE WHEN (u.dob IS NULL) THEN 'Adult'::text WHEN (age(u.dob) > '18 years'::interval) THEN 'Adult'::text ELSE 'Juvenile'::text END AS general_division FROM actor.usr u;


ALTER TABLE reporter.demographic OWNER TO postgres;

SET search_path = serial, pg_catalog;

--
-- Name: issuance; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE issuance (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    subscription integer NOT NULL,
    label text,
    date_published timestamp with time zone,
    caption_and_pattern integer,
    holding_code text,
    holding_type text,
    holding_link_id integer,
    CONSTRAINT issuance_holding_code_check CHECK (((holding_code IS NULL) OR evergreen.could_be_serial_holding_code(holding_code))),
    CONSTRAINT issuance_holding_code_check1 CHECK (((holding_code IS NULL) OR evergreen.is_json(holding_code))),
    CONSTRAINT valid_holding_type CHECK (((holding_type IS NULL) OR (holding_type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text]))))
);


ALTER TABLE serial.issuance OWNER TO postgres;

--
-- Name: subscription; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE subscription (
    id integer NOT NULL,
    owning_lib integer DEFAULT 1 NOT NULL,
    start_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    record_entry bigint,
    expected_date_offset interval
);


ALTER TABLE serial.subscription OWNER TO postgres;

SET search_path = reporter, pg_catalog;

--
-- Name: hold_request_record; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW hold_request_record AS
    SELECT ahr.id, ahr.target, ahr.hold_type, CASE WHEN (ahr.hold_type = 'T'::text) THEN ahr.target WHEN (ahr.hold_type = 'I'::text) THEN (SELECT ssub.record_entry FROM (serial.subscription ssub JOIN serial.issuance si ON ((si.subscription = ssub.id))) WHERE (si.id = ahr.target)) WHEN (ahr.hold_type = 'V'::text) THEN (SELECT cn.record FROM asset.call_number cn WHERE (cn.id = ahr.target)) WHEN (ahr.hold_type = ANY (ARRAY['C'::text, 'R'::text, 'F'::text])) THEN (SELECT cn.record FROM (asset.call_number cn JOIN asset.copy cp ON ((cn.id = cp.call_number))) WHERE (cp.id = ahr.target)) WHEN (ahr.hold_type = 'M'::text) THEN (SELECT mr.master_record FROM metabib.metarecord mr WHERE (mr.id = ahr.target)) WHEN (ahr.hold_type = 'P'::text) THEN (SELECT bmp.record FROM biblio.monograph_part bmp WHERE (bmp.id = ahr.target)) ELSE NULL::bigint END AS bib_record FROM action.hold_request ahr;


ALTER TABLE reporter.hold_request_record OWNER TO postgres;

--
-- Name: materialized_simple_record; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE materialized_simple_record (
    id bigint NOT NULL,
    fingerprint text,
    quality integer,
    tcn_source text,
    tcn_value text,
    title text,
    author text,
    publisher text,
    pubdate text,
    isbn text[],
    issn text[]
);


ALTER TABLE reporter.materialized_simple_record OWNER TO postgres;

--
-- Name: old_super_simple_record; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW old_super_simple_record AS
    SELECT r.id, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, public.first(title.value) AS title, public.first(author.value) AS author, array_to_string(evergreen.array_accum(DISTINCT publisher.value), ', '::text) AS publisher, array_to_string(evergreen.array_accum(DISTINCT "substring"(pubdate.value, '\d+'::text)), ', '::text) AS pubdate, evergreen.array_accum(DISTINCT replace("substring"(isbn.value, '^\S+'::text), '-'::text, ''::text)) AS isbn, evergreen.array_accum(DISTINCT regexp_replace(issn.value, '^\S*(\d{4})[-\s](\d{3,4}x?)'::text, '\1 \2'::text)) AS issn FROM ((((((biblio.record_entry r LEFT JOIN metabib.full_rec title ON ((((r.id = title.record) AND (title.tag = '245'::bpchar)) AND (title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec author ON ((((r.id = author.record) AND (author.tag = ANY (ARRAY['100'::bpchar, '110'::bpchar, '111'::bpchar]))) AND (author.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec publisher ON ((((r.id = publisher.record) AND ((publisher.tag = '260'::bpchar) OR ((publisher.tag = '264'::bpchar) AND (publisher.ind2 = '1'::text)))) AND (publisher.subfield = 'b'::text)))) LEFT JOIN metabib.full_rec pubdate ON ((((r.id = pubdate.record) AND ((pubdate.tag = '260'::bpchar) OR ((pubdate.tag = '264'::bpchar) AND (pubdate.ind2 = '1'::text)))) AND (pubdate.subfield = 'c'::text)))) LEFT JOIN metabib.full_rec isbn ON ((((r.id = isbn.record) AND (isbn.tag = ANY (ARRAY['024'::bpchar, '020'::bpchar]))) AND (isbn.subfield = ANY (ARRAY['a'::text, 'z'::text]))))) LEFT JOIN metabib.full_rec issn ON ((((r.id = issn.record) AND (issn.tag = '022'::bpchar)) AND (issn.subfield = 'a'::text)))) GROUP BY r.id, r.fingerprint, r.quality, r.tcn_source, r.tcn_value;


ALTER TABLE reporter.old_super_simple_record OWNER TO postgres;

--
-- Name: output_folder; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE output_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.output_folder OWNER TO postgres;

--
-- Name: output_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE output_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.output_folder_id_seq OWNER TO postgres;

--
-- Name: output_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE output_folder_id_seq OWNED BY output_folder.id;


--
-- Name: overdue_circs; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW overdue_circs AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.grace_period, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.copy_location, circulation.checkin_scan_time, circulation.parent_circ FROM action.circulation WHERE (((circulation.checkin_time IS NULL) AND ((circulation.stop_fines <> ALL (ARRAY['LOST'::text, 'CLAIMSRETURNED'::text])) OR (circulation.stop_fines IS NULL))) AND (circulation.due_date < now()));


ALTER TABLE reporter.overdue_circs OWNER TO postgres;

--
-- Name: overdue_reports; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW overdue_reports AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE ((s.start_time IS NULL) AND (s.run_time < now()));


ALTER TABLE reporter.overdue_reports OWNER TO postgres;

--
-- Name: pending_reports; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW pending_reports AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE (s.start_time IS NULL);


ALTER TABLE reporter.pending_reports OWNER TO postgres;

--
-- Name: report_folder; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE report_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.report_folder OWNER TO postgres;

--
-- Name: report_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE report_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_folder_id_seq OWNER TO postgres;

--
-- Name: report_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE report_folder_id_seq OWNED BY report_folder.id;


--
-- Name: report_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_id_seq OWNER TO postgres;

--
-- Name: report_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE report_id_seq OWNED BY report.id;


--
-- Name: schedule_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE schedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.schedule_id_seq OWNER TO postgres;

--
-- Name: schedule_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE schedule_id_seq OWNED BY schedule.id;


--
-- Name: simple_record; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW simple_record AS
    SELECT r.id, s.metarecord, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, title.value AS title, uniform_title.value AS uniform_title, author.value AS author, publisher.value AS publisher, "substring"(pubdate.value, '\d+'::text) AS pubdate, series_title.value AS series_title, series_statement.value AS series_statement, summary.value AS summary, evergreen.array_accum(DISTINCT replace("substring"(isbn.value, '^\S+'::text), '-'::text, ''::text)) AS isbn, evergreen.array_accum(DISTINCT regexp_replace(issn.value, '^\S*(\d{4})[-\s](\d{3,4}x?)'::text, '\1 \2'::text)) AS issn, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '650'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS topic_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '651'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS geographic_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '655'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS genre, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '600'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS name_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '610'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS corporate_subject, ARRAY(SELECT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '856'::bpchar) AND (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text, 'u'::text]))) AND (full_rec.record = r.id)) ORDER BY CASE WHEN (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text])) THEN 0 ELSE 1 END) AS external_uri FROM (((((((((((biblio.record_entry r JOIN metabib.metarecord_source_map s ON ((s.source = r.id))) LEFT JOIN metabib.full_rec uniform_title ON ((((r.id = uniform_title.record) AND (uniform_title.tag = '240'::bpchar)) AND (uniform_title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec title ON ((((r.id = title.record) AND (title.tag = '245'::bpchar)) AND (title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec author ON ((((r.id = author.record) AND (author.tag = '100'::bpchar)) AND (author.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec publisher ON ((((r.id = publisher.record) AND (publisher.tag = '260'::bpchar)) AND (publisher.subfield = 'b'::text)))) LEFT JOIN metabib.full_rec pubdate ON ((((r.id = pubdate.record) AND (pubdate.tag = '260'::bpchar)) AND (pubdate.subfield = 'c'::text)))) LEFT JOIN metabib.full_rec isbn ON ((((r.id = isbn.record) AND (isbn.tag = ANY (ARRAY['024'::bpchar, '020'::bpchar]))) AND (isbn.subfield = ANY (ARRAY['a'::text, 'z'::text]))))) LEFT JOIN metabib.full_rec issn ON ((((r.id = issn.record) AND (issn.tag = '022'::bpchar)) AND (issn.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec series_title ON ((((r.id = series_title.record) AND (series_title.tag = ANY (ARRAY['830'::bpchar, '440'::bpchar]))) AND (series_title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec series_statement ON ((((r.id = series_statement.record) AND (series_statement.tag = '490'::bpchar)) AND (series_statement.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec summary ON ((((r.id = summary.record) AND (summary.tag = '520'::bpchar)) AND (summary.subfield = 'a'::text)))) GROUP BY r.id, s.metarecord, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, title.value, uniform_title.value, author.value, publisher.value, "substring"(pubdate.value, '\d+'::text), series_title.value, series_statement.value, summary.value;


ALTER TABLE reporter.simple_record OWNER TO postgres;

--
-- Name: super_simple_record; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW super_simple_record AS
    SELECT materialized_simple_record.id, materialized_simple_record.fingerprint, materialized_simple_record.quality, materialized_simple_record.tcn_source, materialized_simple_record.tcn_value, materialized_simple_record.title, materialized_simple_record.author, materialized_simple_record.publisher, materialized_simple_record.pubdate, materialized_simple_record.isbn, materialized_simple_record.issn FROM materialized_simple_record;


ALTER TABLE reporter.super_simple_record OWNER TO postgres;

--
-- Name: template; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE template (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL
);


ALTER TABLE reporter.template OWNER TO postgres;

--
-- Name: template_folder; Type: TABLE; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE TABLE template_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.template_folder OWNER TO postgres;

--
-- Name: template_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE template_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_folder_id_seq OWNER TO postgres;

--
-- Name: template_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE template_folder_id_seq OWNED BY template_folder.id;


--
-- Name: template_id_seq; Type: SEQUENCE; Schema: reporter; Owner: postgres
--

CREATE SEQUENCE template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_id_seq OWNER TO postgres;

--
-- Name: template_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: postgres
--

ALTER SEQUENCE template_id_seq OWNED BY template.id;


--
-- Name: xact_billing_totals; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW xact_billing_totals AS
    SELECT b.xact, sum(CASE WHEN b.voided THEN (0)::numeric ELSE b.amount END) AS unvoided, sum(CASE WHEN b.voided THEN b.amount ELSE (0)::numeric END) AS voided, sum(b.amount) AS total FROM money.billing b GROUP BY b.xact;


ALTER TABLE reporter.xact_billing_totals OWNER TO postgres;

--
-- Name: xact_paid_totals; Type: VIEW; Schema: reporter; Owner: postgres
--

CREATE VIEW xact_paid_totals AS
    SELECT b.xact, sum(CASE WHEN b.voided THEN (0)::numeric ELSE b.amount END) AS unvoided, sum(CASE WHEN b.voided THEN b.amount ELSE (0)::numeric END) AS voided, sum(b.amount) AS total FROM money.payment b GROUP BY b.xact;


ALTER TABLE reporter.xact_paid_totals OWNER TO postgres;

SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment; Type: TABLE; Schema: search; Owner: postgres; Tablespace: 
--

CREATE TABLE relevance_adjustment (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    field integer NOT NULL,
    bump_type text NOT NULL,
    multiplier numeric DEFAULT 1.0 NOT NULL,
    CONSTRAINT relevance_adjustment_bump_type_check CHECK ((bump_type = ANY (ARRAY['word_order'::text, 'first_word'::text, 'full_match'::text])))
);


ALTER TABLE search.relevance_adjustment OWNER TO postgres;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE; Schema: search; Owner: postgres
--

CREATE SEQUENCE relevance_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE search.relevance_adjustment_id_seq OWNER TO postgres;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: search; Owner: postgres
--

ALTER SEQUENCE relevance_adjustment_id_seq OWNED BY relevance_adjustment.id;


SET search_path = serial, pg_catalog;

--
-- Name: basic_summary; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE basic_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.basic_summary OWNER TO postgres;

--
-- Name: index_summary; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE index_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.index_summary OWNER TO postgres;

--
-- Name: supplement_summary; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE supplement_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.supplement_summary OWNER TO postgres;

--
-- Name: any_summary; Type: VIEW; Schema: serial; Owner: postgres
--

CREATE VIEW any_summary AS
    (SELECT 'basic'::text AS summary_type, basic_summary.id, basic_summary.distribution, basic_summary.generated_coverage, basic_summary.textual_holdings, basic_summary.show_generated FROM basic_summary UNION SELECT 'index'::text AS summary_type, index_summary.id, index_summary.distribution, index_summary.generated_coverage, index_summary.textual_holdings, index_summary.show_generated FROM index_summary) UNION SELECT 'supplement'::text AS summary_type, supplement_summary.id, supplement_summary.distribution, supplement_summary.generated_coverage, supplement_summary.textual_holdings, supplement_summary.show_generated FROM supplement_summary;


ALTER TABLE serial.any_summary OWNER TO postgres;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE basic_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.basic_summary_id_seq OWNER TO postgres;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE basic_summary_id_seq OWNED BY basic_summary.id;


--
-- Name: caption_and_pattern; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE caption_and_pattern (
    id integer NOT NULL,
    subscription integer NOT NULL,
    type text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    start_date timestamp with time zone DEFAULT now() NOT NULL,
    end_date timestamp with time zone,
    active boolean DEFAULT false NOT NULL,
    pattern_code text NOT NULL,
    enum_1 text,
    enum_2 text,
    enum_3 text,
    enum_4 text,
    enum_5 text,
    enum_6 text,
    chron_1 text,
    chron_2 text,
    chron_3 text,
    chron_4 text,
    chron_5 text,
    CONSTRAINT cap_type CHECK ((type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text])))
);


ALTER TABLE serial.caption_and_pattern OWNER TO postgres;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE caption_and_pattern_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.caption_and_pattern_id_seq OWNER TO postgres;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE caption_and_pattern_id_seq OWNED BY caption_and_pattern.id;


--
-- Name: distribution; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE distribution (
    id integer NOT NULL,
    record_entry bigint,
    summary_method text,
    subscription integer NOT NULL,
    holding_lib integer NOT NULL,
    label text NOT NULL,
    display_grouping text DEFAULT 'chron'::text NOT NULL,
    receive_call_number bigint,
    receive_unit_template integer,
    bind_call_number bigint,
    bind_unit_template integer,
    unit_label_prefix text,
    unit_label_suffix text,
    CONSTRAINT distribution_display_grouping_check CHECK ((display_grouping = ANY (ARRAY['enum'::text, 'chron'::text]))),
    CONSTRAINT sdist_summary_method_check CHECK (((summary_method IS NULL) OR (summary_method = ANY (ARRAY['add_to_sre'::text, 'merge_with_sre'::text, 'use_sre_only'::text, 'use_sdist_only'::text]))))
);


ALTER TABLE serial.distribution OWNER TO postgres;

--
-- Name: distribution_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE distribution_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_id_seq OWNER TO postgres;

--
-- Name: distribution_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE distribution_id_seq OWNED BY distribution.id;


--
-- Name: distribution_note; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE distribution_note (
    id integer NOT NULL,
    distribution integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.distribution_note OWNER TO postgres;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE distribution_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_note_id_seq OWNER TO postgres;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE distribution_note_id_seq OWNED BY distribution_note.id;


--
-- Name: index_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE index_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.index_summary_id_seq OWNER TO postgres;

--
-- Name: index_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE index_summary_id_seq OWNED BY index_summary.id;


--
-- Name: issuance_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE issuance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.issuance_id_seq OWNER TO postgres;

--
-- Name: issuance_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE issuance_id_seq OWNED BY issuance.id;


--
-- Name: item; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE item (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    issuance integer NOT NULL,
    stream integer NOT NULL,
    unit integer,
    uri integer,
    date_expected timestamp with time zone,
    date_received timestamp with time zone,
    status text DEFAULT 'Expected'::text,
    shadowed boolean DEFAULT false NOT NULL,
    CONSTRAINT valid_status CHECK ((status = ANY (ARRAY['Bindery'::text, 'Bound'::text, 'Claimed'::text, 'Discarded'::text, 'Expected'::text, 'Not Held'::text, 'Not Published'::text, 'Received'::text])))
);


ALTER TABLE serial.item OWNER TO postgres;

--
-- Name: item_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_id_seq OWNER TO postgres;

--
-- Name: item_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE item_id_seq OWNED BY item.id;


--
-- Name: item_note; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.item_note OWNER TO postgres;

--
-- Name: item_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_note_id_seq OWNER TO postgres;

--
-- Name: item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE item_note_id_seq OWNED BY item_note.id;


--
-- Name: materialized_holding_code; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE materialized_holding_code (
    id bigint NOT NULL,
    issuance integer NOT NULL,
    subfield character(1),
    value text
);


ALTER TABLE serial.materialized_holding_code OWNER TO postgres;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE materialized_holding_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.materialized_holding_code_id_seq OWNER TO postgres;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE materialized_holding_code_id_seq OWNED BY materialized_holding_code.id;


--
-- Name: record_entry; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    record bigint,
    owning_lib integer DEFAULT 1 NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    marc text,
    last_xact_id text NOT NULL
);


ALTER TABLE serial.record_entry OWNER TO postgres;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.record_entry_id_seq OWNER TO postgres;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: routing_list_user; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE routing_list_user (
    id integer NOT NULL,
    stream integer NOT NULL,
    pos integer DEFAULT 1 NOT NULL,
    reader integer,
    department text,
    note text,
    CONSTRAINT reader_or_dept CHECK ((((reader IS NOT NULL) AND (department IS NULL)) OR ((reader IS NULL) AND (department IS NOT NULL))))
);


ALTER TABLE serial.routing_list_user OWNER TO postgres;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE routing_list_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.routing_list_user_id_seq OWNER TO postgres;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE routing_list_user_id_seq OWNED BY routing_list_user.id;


--
-- Name: stream; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE stream (
    id integer NOT NULL,
    distribution integer NOT NULL,
    routing_label text
);


ALTER TABLE serial.stream OWNER TO postgres;

--
-- Name: stream_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE stream_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.stream_id_seq OWNER TO postgres;

--
-- Name: stream_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE stream_id_seq OWNED BY stream.id;


--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_id_seq OWNER TO postgres;

--
-- Name: subscription_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE subscription_id_seq OWNED BY subscription.id;


--
-- Name: subscription_note; Type: TABLE; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE TABLE subscription_note (
    id integer NOT NULL,
    subscription integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.subscription_note OWNER TO postgres;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE subscription_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_note_id_seq OWNER TO postgres;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE subscription_note_id_seq OWNED BY subscription_note.id;


--
-- Name: supplement_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: postgres
--

CREATE SEQUENCE supplement_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.supplement_summary_id_seq OWNER TO postgres;

--
-- Name: supplement_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: postgres
--

ALTER SEQUENCE supplement_summary_id_seq OWNED BY supplement_summary.id;


SET search_path = staging, pg_catalog;

--
-- Name: mailing_address_stage; Type: TABLE; Schema: staging; Owner: postgres; Tablespace: 
--

CREATE TABLE mailing_address_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text DEFAULT 'OK'::text NOT NULL,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.mailing_address_stage OWNER TO postgres;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: postgres
--

CREATE SEQUENCE mailing_address_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.mailing_address_stage_row_id_seq OWNER TO postgres;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: postgres
--

ALTER SEQUENCE mailing_address_stage_row_id_seq OWNED BY mailing_address_stage.row_id;


--
-- Name: billing_address_stage; Type: TABLE; Schema: staging; Owner: postgres; Tablespace: 
--

CREATE TABLE billing_address_stage (
    row_id bigint DEFAULT nextval('mailing_address_stage_row_id_seq'::regclass) NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text DEFAULT 'OK'::text NOT NULL,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.billing_address_stage OWNER TO postgres;

--
-- Name: card_stage; Type: TABLE; Schema: staging; Owner: postgres; Tablespace: 
--

CREATE TABLE card_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    barcode text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.card_stage OWNER TO postgres;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: postgres
--

CREATE SEQUENCE card_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.card_stage_row_id_seq OWNER TO postgres;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: postgres
--

ALTER SEQUENCE card_stage_row_id_seq OWNED BY card_stage.row_id;


--
-- Name: statcat_stage; Type: TABLE; Schema: staging; Owner: postgres; Tablespace: 
--

CREATE TABLE statcat_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    statcat text NOT NULL,
    value text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.statcat_stage OWNER TO postgres;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: postgres
--

CREATE SEQUENCE statcat_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.statcat_stage_row_id_seq OWNER TO postgres;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: postgres
--

ALTER SEQUENCE statcat_stage_row_id_seq OWNED BY statcat_stage.row_id;


--
-- Name: user_stage; Type: TABLE; Schema: staging; Owner: postgres; Tablespace: 
--

CREATE TABLE user_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    profile text,
    email text,
    passwd text,
    ident_type integer DEFAULT 3,
    first_given_name text,
    second_given_name text,
    family_name text,
    day_phone text,
    evening_phone text,
    home_ou integer DEFAULT 2,
    dob text,
    complete boolean DEFAULT false
);


ALTER TABLE staging.user_stage OWNER TO postgres;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: postgres
--

CREATE SEQUENCE user_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.user_stage_row_id_seq OWNER TO postgres;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: postgres
--

ALTER SEQUENCE user_stage_row_id_seq OWNED BY user_stage.row_id;


SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout; Type: TABLE; Schema: unapi; Owner: postgres; Tablespace: 
--

CREATE TABLE bre_output_layout (
    name text NOT NULL,
    transform text,
    mime_type text NOT NULL,
    feed_top text NOT NULL,
    holdings_element text,
    title_element text,
    description_element text,
    creator_element text,
    update_ts_element text
);


ALTER TABLE unapi.bre_output_layout OWNER TO postgres;

SET search_path = url_verify, pg_catalog;

--
-- Name: session; Type: TABLE; Schema: url_verify; Owner: postgres; Tablespace: 
--

CREATE TABLE session (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    container integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    search text NOT NULL
);


ALTER TABLE url_verify.session OWNER TO postgres;

--
-- Name: session_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: postgres
--

CREATE SEQUENCE session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.session_id_seq OWNER TO postgres;

--
-- Name: session_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: postgres
--

ALTER SEQUENCE session_id_seq OWNED BY session.id;


--
-- Name: url_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: postgres
--

CREATE SEQUENCE url_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_id_seq OWNER TO postgres;

--
-- Name: url_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: postgres
--

ALTER SEQUENCE url_id_seq OWNED BY url.id;


--
-- Name: url_selector; Type: TABLE; Schema: url_verify; Owner: postgres; Tablespace: 
--

CREATE TABLE url_selector (
    id integer NOT NULL,
    xpath text NOT NULL,
    session integer NOT NULL
);


ALTER TABLE url_verify.url_selector OWNER TO postgres;

--
-- Name: url_selector_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: postgres
--

CREATE SEQUENCE url_selector_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_selector_id_seq OWNER TO postgres;

--
-- Name: url_selector_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: postgres
--

ALTER SEQUENCE url_selector_id_seq OWNED BY url_selector.id;


--
-- Name: url_verification; Type: TABLE; Schema: url_verify; Owner: postgres; Tablespace: 
--

CREATE TABLE url_verification (
    id integer NOT NULL,
    url integer NOT NULL,
    attempt integer NOT NULL,
    req_time timestamp with time zone DEFAULT now() NOT NULL,
    res_time timestamp with time zone,
    res_code integer,
    res_text text,
    redirect_to integer,
    CONSTRAINT url_verification_res_code_check CHECK (((res_code >= 100) AND (res_code <= 999)))
);


ALTER TABLE url_verify.url_verification OWNER TO postgres;

--
-- Name: url_verification_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: postgres
--

CREATE SEQUENCE url_verification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_verification_id_seq OWNER TO postgres;

--
-- Name: url_verification_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: postgres
--

ALTER SEQUENCE url_verification_id_seq OWNED BY url_verification.id;


--
-- Name: verification_attempt; Type: TABLE; Schema: url_verify; Owner: postgres; Tablespace: 
--

CREATE TABLE verification_attempt (
    id integer NOT NULL,
    usr integer NOT NULL,
    session integer NOT NULL,
    start_time timestamp with time zone DEFAULT now() NOT NULL,
    finish_time timestamp with time zone
);


ALTER TABLE url_verify.verification_attempt OWNER TO postgres;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: postgres
--

CREATE SEQUENCE verification_attempt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.verification_attempt_id_seq OWNER TO postgres;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: postgres
--

ALTER SEQUENCE verification_attempt_id_seq OWNED BY verification_attempt.id;


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_attr_definition; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE authority_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.authority_attr_definition OWNER TO postgres;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE authority_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_attr_definition_id_seq OWNER TO postgres;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE authority_attr_definition_id_seq OWNED BY authority_attr_definition.id;


--
-- Name: authority_match; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE authority_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.authority_match OWNER TO postgres;

--
-- Name: authority_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE authority_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_match_id_seq OWNER TO postgres;

--
-- Name: authority_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE authority_match_id_seq OWNED BY authority_match.id;


--
-- Name: queue; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queue (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    complete boolean DEFAULT false NOT NULL,
    match_set integer
);


ALTER TABLE vandelay.queue OWNER TO postgres;

--
-- Name: authority_queue; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE authority_queue (
    queue_type authority_queue_queue_type DEFAULT 'authority'::authority_queue_queue_type NOT NULL
)
INHERITS (queue);


ALTER TABLE vandelay.authority_queue OWNER TO postgres;

--
-- Name: bib_attr_definition; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE bib_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.bib_attr_definition OWNER TO postgres;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE bib_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_attr_definition_id_seq OWNER TO postgres;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE bib_attr_definition_id_seq OWNED BY bib_attr_definition.id;


--
-- Name: bib_match; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE bib_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 1 NOT NULL,
    match_score integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.bib_match OWNER TO postgres;

--
-- Name: bib_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE bib_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_match_id_seq OWNER TO postgres;

--
-- Name: bib_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE bib_match_id_seq OWNED BY bib_match.id;


--
-- Name: bib_queue; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE bib_queue (
    queue_type bib_queue_queue_type DEFAULT 'bib'::bib_queue_queue_type NOT NULL,
    item_attr_def bigint
)
INHERITS (queue);


ALTER TABLE vandelay.bib_queue OWNER TO postgres;

--
-- Name: import_bib_trash_fields; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE import_bib_trash_fields (
    id bigint NOT NULL,
    grp integer NOT NULL,
    field text NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_fields OWNER TO postgres;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE import_bib_trash_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_fields_id_seq OWNER TO postgres;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE import_bib_trash_fields_id_seq OWNED BY import_bib_trash_fields.id;


--
-- Name: import_bib_trash_group; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE import_bib_trash_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    label text NOT NULL,
    always_apply boolean DEFAULT false NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_group OWNER TO postgres;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE import_bib_trash_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_group_id_seq OWNER TO postgres;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE import_bib_trash_group_id_seq OWNED BY import_bib_trash_group.id;


--
-- Name: import_error; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE import_error (
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE vandelay.import_error OWNER TO postgres;

--
-- Name: import_item_attr_definition; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE import_item_attr_definition (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    tag text NOT NULL,
    keep boolean DEFAULT false NOT NULL,
    owning_lib text,
    circ_lib text,
    call_number text,
    copy_number text,
    status text,
    location text,
    circulate text,
    deposit text,
    deposit_amount text,
    ref text,
    holdable text,
    price text,
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible text,
    pub_note_title text,
    pub_note text,
    priv_note_title text,
    priv_note text,
    internal_id text
);


ALTER TABLE vandelay.import_item_attr_definition OWNER TO postgres;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE import_item_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_attr_definition_id_seq OWNER TO postgres;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE import_item_attr_definition_id_seq OWNED BY import_item_attr_definition.id;


--
-- Name: import_item_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE import_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_id_seq OWNER TO postgres;

--
-- Name: import_item_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE import_item_id_seq OWNED BY import_item.id;


--
-- Name: match_set; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE match_set (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    mtype text DEFAULT 'biblio'::text NOT NULL
);


ALTER TABLE vandelay.match_set OWNER TO postgres;

--
-- Name: match_set_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE match_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_id_seq OWNER TO postgres;

--
-- Name: match_set_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE match_set_id_seq OWNED BY match_set.id;


--
-- Name: match_set_point_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE match_set_point_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_point_id_seq OWNER TO postgres;

--
-- Name: match_set_point_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE match_set_point_id_seq OWNED BY match_set_point.id;


--
-- Name: match_set_quality; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE match_set_quality (
    id integer NOT NULL,
    match_set integer NOT NULL,
    svf text,
    tag text,
    subfield text,
    value text NOT NULL,
    quality integer DEFAULT 1 NOT NULL,
    CONSTRAINT vmsq_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsq_need_a_tag_or_a_ff CHECK ((((tag IS NOT NULL) AND (svf IS NULL)) OR ((tag IS NULL) AND (svf IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_quality OWNER TO postgres;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE match_set_quality_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_quality_id_seq OWNER TO postgres;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE match_set_quality_id_seq OWNED BY match_set_quality.id;


--
-- Name: merge_profile; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE merge_profile (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    add_spec text,
    replace_spec text,
    strip_spec text,
    preserve_spec text,
    lwm_ratio numeric,
    CONSTRAINT add_replace_strip_or_preserve CHECK ((((preserve_spec IS NOT NULL) OR (replace_spec IS NOT NULL)) OR ((preserve_spec IS NULL) AND (replace_spec IS NULL))))
);


ALTER TABLE vandelay.merge_profile OWNER TO postgres;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE merge_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.merge_profile_id_seq OWNER TO postgres;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE merge_profile_id_seq OWNED BY merge_profile.id;


--
-- Name: queue_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queue_id_seq OWNER TO postgres;

--
-- Name: queue_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE queue_id_seq OWNED BY queue.id;


--
-- Name: queued_record; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queued_record (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    import_time timestamp with time zone,
    purpose text DEFAULT 'import'::text NOT NULL,
    marc text NOT NULL,
    quality integer DEFAULT 0 NOT NULL,
    CONSTRAINT queued_record_purpose_check CHECK ((purpose = ANY (ARRAY['import'::text, 'overlay'::text])))
);


ALTER TABLE vandelay.queued_record OWNER TO postgres;

--
-- Name: queued_authority_record; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queued_authority_record (
    queue integer NOT NULL,
    imported_as integer,
    import_error text,
    error_detail text
)
INHERITS (queued_record);


ALTER TABLE vandelay.queued_authority_record OWNER TO postgres;

--
-- Name: queued_authority_record_attr; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queued_authority_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_authority_record_attr OWNER TO postgres;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE queued_authority_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_authority_record_attr_id_seq OWNER TO postgres;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE queued_authority_record_attr_id_seq OWNED BY queued_authority_record_attr.id;


--
-- Name: queued_bib_record; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queued_bib_record (
    queue integer NOT NULL,
    bib_source integer,
    imported_as bigint,
    import_error text,
    error_detail text
)
INHERITS (queued_record);


ALTER TABLE vandelay.queued_bib_record OWNER TO postgres;

--
-- Name: queued_bib_record_attr; Type: TABLE; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE TABLE queued_bib_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_bib_record_attr OWNER TO postgres;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE queued_bib_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_bib_record_attr_id_seq OWNER TO postgres;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE queued_bib_record_attr_id_seq OWNED BY queued_bib_record_attr.id;


--
-- Name: queued_record_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: postgres
--

CREATE SEQUENCE queued_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_record_id_seq OWNER TO postgres;

--
-- Name: queued_record_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: postgres
--

ALTER SEQUENCE queued_record_id_seq OWNED BY queued_record.id;


SET search_path = acq, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY cancel_reason ALTER COLUMN id SET DEFAULT nextval('cancel_reason_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim ALTER COLUMN id SET DEFAULT nextval('claim_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event ALTER COLUMN id SET DEFAULT nextval('claim_event_id_seq'::regclass);


--
-- Name: claim; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event ALTER COLUMN claim SET DEFAULT nextval('claim_event_claim_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event_type ALTER COLUMN id SET DEFAULT nextval('claim_event_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_policy ALTER COLUMN id SET DEFAULT nextval('claim_policy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_policy_action ALTER COLUMN id SET DEFAULT nextval('claim_policy_action_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_type ALTER COLUMN id SET DEFAULT nextval('claim_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula ALTER COLUMN id SET DEFAULT nextval('distribution_formula_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_application ALTER COLUMN id SET DEFAULT nextval('distribution_formula_application_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry ALTER COLUMN id SET DEFAULT nextval('distribution_formula_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY edi_account ALTER COLUMN id SET DEFAULT nextval('config.remote_account_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY edi_message ALTER COLUMN id SET DEFAULT nextval('edi_message_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY exchange_rate ALTER COLUMN id SET DEFAULT nextval('exchange_rate_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fiscal_calendar ALTER COLUMN id SET DEFAULT nextval('fiscal_calendar_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fiscal_year ALTER COLUMN id SET DEFAULT nextval('fiscal_year_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund ALTER COLUMN id SET DEFAULT nextval('fund_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation ALTER COLUMN id SET DEFAULT nextval('fund_allocation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation_percent ALTER COLUMN id SET DEFAULT nextval('fund_allocation_percent_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_debit ALTER COLUMN id SET DEFAULT nextval('fund_debit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_tag ALTER COLUMN id SET DEFAULT nextval('fund_tag_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_tag_map ALTER COLUMN id SET DEFAULT nextval('fund_tag_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_transfer ALTER COLUMN id SET DEFAULT nextval('fund_transfer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY funding_source ALTER COLUMN id SET DEFAULT nextval('funding_source_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY funding_source_credit ALTER COLUMN id SET DEFAULT nextval('funding_source_credit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice ALTER COLUMN id SET DEFAULT nextval('invoice_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_entry ALTER COLUMN id SET DEFAULT nextval('invoice_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item ALTER COLUMN id SET DEFAULT nextval('invoice_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem ALTER COLUMN id SET DEFAULT nextval('lineitem_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_alert_text ALTER COLUMN id SET DEFAULT nextval('lineitem_alert_text_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_attr ALTER COLUMN id SET DEFAULT nextval('lineitem_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_attr_definition ALTER COLUMN id SET DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail ALTER COLUMN id SET DEFAULT nextval('lineitem_detail_id_seq'::regclass);


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_generated_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_generated_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_local_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_local_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_marc_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_marc_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_note ALTER COLUMN id SET DEFAULT nextval('lineitem_note_id_seq'::regclass);


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_provider_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_provider_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_usr_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_usr_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY picklist ALTER COLUMN id SET DEFAULT nextval('picklist_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_item ALTER COLUMN id SET DEFAULT nextval('po_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_note ALTER COLUMN id SET DEFAULT nextval('po_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider ALTER COLUMN id SET DEFAULT nextval('provider_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_address ALTER COLUMN id SET DEFAULT nextval('provider_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_contact ALTER COLUMN id SET DEFAULT nextval('provider_contact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_contact_address ALTER COLUMN id SET DEFAULT nextval('provider_contact_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_holding_subfield_map ALTER COLUMN id SET DEFAULT nextval('provider_holding_subfield_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_note ALTER COLUMN id SET DEFAULT nextval('provider_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order ALTER COLUMN id SET DEFAULT nextval('purchase_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim ALTER COLUMN id SET DEFAULT nextval('serial_claim_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim_event ALTER COLUMN id SET DEFAULT nextval('serial_claim_event_id_seq'::regclass);


--
-- Name: claim; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim_event ALTER COLUMN claim SET DEFAULT nextval('serial_claim_event_claim_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request ALTER COLUMN id SET DEFAULT nextval('user_request_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request_type ALTER COLUMN id SET DEFAULT nextval('user_request_type_id_seq'::regclass);


SET search_path = action, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY archive_actor_stat_cat ALTER COLUMN id SET DEFAULT nextval('archive_actor_stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY archive_asset_stat_cat ALTER COLUMN id SET DEFAULT nextval('archive_asset_stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset ALTER COLUMN id SET DEFAULT nextval('fieldset_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset_col_val ALTER COLUMN id SET DEFAULT nextval('fieldset_col_val_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_copy_map ALTER COLUMN id SET DEFAULT nextval('hold_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_notification ALTER COLUMN id SET DEFAULT nextval('hold_notification_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request ALTER COLUMN id SET DEFAULT nextval('hold_request_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request_cancel_cause ALTER COLUMN id SET DEFAULT nextval('hold_request_cancel_cause_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request_note ALTER COLUMN id SET DEFAULT nextval('hold_request_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: persistant_transfer; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY in_house_use ALTER COLUMN id SET DEFAULT nextval('in_house_use_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cat_in_house_use ALTER COLUMN id SET DEFAULT nextval('non_cat_in_house_use_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_circulation ALTER COLUMN id SET DEFAULT nextval('non_cataloged_circulation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY reservation_transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: persistant_transfer; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY reservation_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey ALTER COLUMN id SET DEFAULT nextval('survey_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_answer ALTER COLUMN id SET DEFAULT nextval('survey_answer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_question ALTER COLUMN id SET DEFAULT nextval('survey_question_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_response ALTER COLUMN id SET DEFAULT nextval('survey_response_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY unfulfilled_hold_list ALTER COLUMN id SET DEFAULT nextval('unfulfilled_hold_list_id_seq'::regclass);


SET search_path = action_trigger, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY environment ALTER COLUMN id SET DEFAULT nextval('environment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event ALTER COLUMN id SET DEFAULT nextval('event_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition ALTER COLUMN id SET DEFAULT nextval('event_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_output ALTER COLUMN id SET DEFAULT nextval('event_output_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_params ALTER COLUMN id SET DEFAULT nextval('event_params_id_seq'::regclass);


SET search_path = actor, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY address_alert ALTER COLUMN id SET DEFAULT nextval('address_alert_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY card ALTER COLUMN id SET DEFAULT nextval('card_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_address ALTER COLUMN id SET DEFAULT nextval('org_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_lasso ALTER COLUMN id SET DEFAULT nextval('org_lasso_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_lasso_map ALTER COLUMN id SET DEFAULT nextval('org_lasso_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit ALTER COLUMN id SET DEFAULT nextval('org_unit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_closed ALTER COLUMN id SET DEFAULT nextval('org_unit_closed_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_custom_tree ALTER COLUMN id SET DEFAULT nextval('org_unit_custom_tree_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_custom_tree_node ALTER COLUMN id SET DEFAULT nextval('org_unit_custom_tree_node_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity ALTER COLUMN id SET DEFAULT nextval('org_unit_proximity_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment ALTER COLUMN id SET DEFAULT nextval('org_unit_proximity_adjustment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting ALTER COLUMN id SET DEFAULT nextval('org_unit_setting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_type ALTER COLUMN id SET DEFAULT nextval('org_unit_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_filter_group ALTER COLUMN id SET DEFAULT nextval('search_filter_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_filter_group_entry ALTER COLUMN id SET DEFAULT nextval('search_filter_group_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_query ALTER COLUMN id SET DEFAULT nextval('search_query_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat ALTER COLUMN id SET DEFAULT nextval('stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_default ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_default_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_usr_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_usr_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY toolbar ALTER COLUMN id SET DEFAULT nextval('toolbar_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr ALTER COLUMN id SET DEFAULT nextval('usr_id_seq'::regclass);


--
-- Name: usrgroup; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr ALTER COLUMN usrgroup SET DEFAULT nextval('usr_usrgroup_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_activity ALTER COLUMN id SET DEFAULT nextval('usr_activity_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_address ALTER COLUMN id SET DEFAULT nextval('usr_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_note ALTER COLUMN id SET DEFAULT nextval('usr_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_org_unit_opt_in ALTER COLUMN id SET DEFAULT nextval('usr_org_unit_opt_in_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_password_reset ALTER COLUMN id SET DEFAULT nextval('usr_password_reset_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_saved_search ALTER COLUMN id SET DEFAULT nextval('usr_saved_search_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_setting ALTER COLUMN id SET DEFAULT nextval('usr_setting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_standing_penalty ALTER COLUMN id SET DEFAULT nextval('usr_standing_penalty_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY workstation ALTER COLUMN id SET DEFAULT nextval('workstation_id_seq'::regclass);


SET search_path = asset, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number ALTER COLUMN id SET DEFAULT nextval('call_number_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_class ALTER COLUMN id SET DEFAULT nextval('call_number_class_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_note ALTER COLUMN id SET DEFAULT nextval('call_number_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_prefix ALTER COLUMN id SET DEFAULT nextval('call_number_prefix_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_suffix ALTER COLUMN id SET DEFAULT nextval('call_number_suffix_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy ALTER COLUMN id SET DEFAULT nextval('copy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location ALTER COLUMN id SET DEFAULT nextval('copy_location_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_group ALTER COLUMN id SET DEFAULT nextval('copy_location_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_group_map ALTER COLUMN id SET DEFAULT nextval('copy_location_group_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_order ALTER COLUMN id SET DEFAULT nextval('copy_location_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_note ALTER COLUMN id SET DEFAULT nextval('copy_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_part_map ALTER COLUMN id SET DEFAULT nextval('copy_part_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template ALTER COLUMN id SET DEFAULT nextval('copy_template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY opac_visible_copies ALTER COLUMN id SET DEFAULT nextval('opac_visible_copies_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat ALTER COLUMN id SET DEFAULT nextval('stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_copy_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_transparency_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_transparency_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY uri ALTER COLUMN id SET DEFAULT nextval('uri_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY uri_call_number_map ALTER COLUMN id SET DEFAULT nextval('uri_call_number_map_id_seq'::regclass);


SET search_path = authority, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY bib_linking ALTER COLUMN id SET DEFAULT nextval('bib_linking_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY browse_axis_authority_field_map ALTER COLUMN id SET DEFAULT nextval('browse_axis_authority_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set ALTER COLUMN id SET DEFAULT nextval('control_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set_authority_field ALTER COLUMN id SET DEFAULT nextval('control_set_authority_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set_bib_field ALTER COLUMN id SET DEFAULT nextval('control_set_bib_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY full_rec ALTER COLUMN id SET DEFAULT nextval('full_rec_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY rec_descriptor ALTER COLUMN id SET DEFAULT nextval('rec_descriptor_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY record_note ALTER COLUMN id SET DEFAULT nextval('record_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY simple_heading ALTER COLUMN id SET DEFAULT nextval('simple_heading_id_seq'::regclass);


SET search_path = biblio, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY monograph_part ALTER COLUMN id SET DEFAULT nextval('monograph_part_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY peer_bib_copy_map ALTER COLUMN id SET DEFAULT nextval('peer_bib_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY peer_type ALTER COLUMN id SET DEFAULT nextval('peer_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_note ALTER COLUMN id SET DEFAULT nextval('record_note_id_seq'::regclass);


SET search_path = booking, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation_attr_value_map ALTER COLUMN id SET DEFAULT nextval('reservation_attr_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource ALTER COLUMN id SET DEFAULT nextval('resource_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr ALTER COLUMN id SET DEFAULT nextval('resource_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_map ALTER COLUMN id SET DEFAULT nextval('resource_attr_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_value ALTER COLUMN id SET DEFAULT nextval('resource_attr_value_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_type ALTER COLUMN id SET DEFAULT nextval('resource_type_id_seq'::regclass);


SET search_path = config, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY barcode_completion ALTER COLUMN id SET DEFAULT nextval('barcode_completion_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY best_hold_order ALTER COLUMN id SET DEFAULT nextval('best_hold_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY bib_source ALTER COLUMN id SET DEFAULT nextval('bib_source_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY biblio_fingerprint ALTER COLUMN id SET DEFAULT nextval('biblio_fingerprint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY billing_type ALTER COLUMN id SET DEFAULT nextval('billing_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_group ALTER COLUMN id SET DEFAULT nextval('circ_limit_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_circ_mod_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_copy_loc_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_group_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_group_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_limit_set_map ALTER COLUMN id SET DEFAULT nextval('circ_matrix_limit_set_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('circ_matrix_matchpoint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_weights ALTER COLUMN id SET DEFAULT nextval('circ_matrix_weights_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY coded_value_map ALTER COLUMN id SET DEFAULT nextval('coded_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY copy_status ALTER COLUMN id SET DEFAULT nextval('copy_status_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY filter_dialog_filter_set ALTER COLUMN id SET DEFAULT nextval('filter_dialog_filter_set_id_seq'::regclass);


--
-- Name: enabled; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY global_flag ALTER COLUMN enabled SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hard_due_date ALTER COLUMN id SET DEFAULT nextval('hard_due_date_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hard_due_date_values ALTER COLUMN id SET DEFAULT nextval('hard_due_date_values_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('hold_matrix_matchpoint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_weights ALTER COLUMN id SET DEFAULT nextval('hold_matrix_weights_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY i18n_core ALTER COLUMN id SET DEFAULT nextval('i18n_core_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY identification_type ALTER COLUMN id SET DEFAULT nextval('identification_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY idl_field_doc ALTER COLUMN id SET DEFAULT nextval('idl_field_doc_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY index_normalizer ALTER COLUMN id SET DEFAULT nextval('index_normalizer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY marc21_ff_pos_map ALTER COLUMN id SET DEFAULT nextval('marc21_ff_pos_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map ALTER COLUMN id SET DEFAULT nextval('marc21_physical_characteristic_subfield_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map ALTER COLUMN id SET DEFAULT nextval('marc21_physical_characteristic_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_class_ts_map ALTER COLUMN id SET DEFAULT nextval('metabib_class_ts_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field ALTER COLUMN id SET DEFAULT nextval('metabib_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_index_norm_map ALTER COLUMN id SET DEFAULT nextval('metabib_field_index_norm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_ts_map ALTER COLUMN id SET DEFAULT nextval('metabib_field_ts_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY net_access_level ALTER COLUMN id SET DEFAULT nextval('net_access_level_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_type ALTER COLUMN id SET DEFAULT nextval('non_cataloged_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type_log ALTER COLUMN id SET DEFAULT nextval('org_unit_setting_type_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY record_attr_index_norm_map ALTER COLUMN id SET DEFAULT nextval('record_attr_index_norm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY remote_account ALTER COLUMN id SET DEFAULT nextval('remote_account_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY rule_age_hold_protect ALTER COLUMN id SET DEFAULT nextval('rule_age_hold_protect_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY rule_circ_duration ALTER COLUMN id SET DEFAULT nextval('rule_circ_duration_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY rule_max_fine ALTER COLUMN id SET DEFAULT nextval('rule_max_fine_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY rule_recurring_fine ALTER COLUMN id SET DEFAULT nextval('rule_recurring_fine_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY sms_carrier ALTER COLUMN id SET DEFAULT nextval('sms_carrier_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY standing ALTER COLUMN id SET DEFAULT nextval('standing_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY standing_penalty ALTER COLUMN id SET DEFAULT nextval('standing_penalty_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY usr_activity_type ALTER COLUMN id SET DEFAULT nextval('usr_activity_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY weight_assoc ALTER COLUMN id SET DEFAULT nextval('weight_assoc_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_attr ALTER COLUMN id SET DEFAULT nextval('z3950_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_source_credentials ALTER COLUMN id SET DEFAULT nextval('z3950_source_credentials_id_seq'::regclass);


SET search_path = container, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_item ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_note ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_item ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_note ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket ALTER COLUMN id SET DEFAULT nextval('copy_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_item ALTER COLUMN id SET DEFAULT nextval('copy_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('copy_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_note ALTER COLUMN id SET DEFAULT nextval('copy_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket ALTER COLUMN id SET DEFAULT nextval('user_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_item ALTER COLUMN id SET DEFAULT nextval('user_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('user_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_note ALTER COLUMN id SET DEFAULT nextval('user_bucket_note_id_seq'::regclass);


SET search_path = metabib, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY author_field_entry ALTER COLUMN id SET DEFAULT nextval('author_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY browse_entry ALTER COLUMN id SET DEFAULT nextval('browse_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY browse_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY facet_entry ALTER COLUMN id SET DEFAULT nextval('facet_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY identifier_field_entry ALTER COLUMN id SET DEFAULT nextval('identifier_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY keyword_field_entry ALTER COLUMN id SET DEFAULT nextval('keyword_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY metarecord ALTER COLUMN id SET DEFAULT nextval('metarecord_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY metarecord_source_map ALTER COLUMN id SET DEFAULT nextval('metarecord_source_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY series_field_entry ALTER COLUMN id SET DEFAULT nextval('series_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY subject_field_entry ALTER COLUMN id SET DEFAULT nextval('subject_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY title_field_entry ALTER COLUMN id SET DEFAULT nextval('title_field_entry_id_seq'::regclass);


SET search_path = money, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY billable_xact ALTER COLUMN id SET DEFAULT nextval('billable_xact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY billing ALTER COLUMN id SET DEFAULT nextval('billing_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY cash_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY cash_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY cash_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY check_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY check_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY check_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY collections_tracker ALTER COLUMN id SET DEFAULT nextval('collections_tracker_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY credit_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY goods_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY goods_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY goods_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY grocery ALTER COLUMN id SET DEFAULT nextval('billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY grocery ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY work_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY work_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY work_payment ALTER COLUMN voided SET DEFAULT false;


SET search_path = offline, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: offline; Owner: postgres
--

ALTER TABLE ONLY script ALTER COLUMN id SET DEFAULT nextval('script_id_seq'::regclass);


SET search_path = permission, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_penalty_threshold ALTER COLUMN id SET DEFAULT nextval('grp_penalty_threshold_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_perm_map ALTER COLUMN id SET DEFAULT nextval('grp_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_tree ALTER COLUMN id SET DEFAULT nextval('grp_tree_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY perm_list ALTER COLUMN id SET DEFAULT nextval('perm_list_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_grp_map ALTER COLUMN id SET DEFAULT nextval('usr_grp_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_object_perm_map ALTER COLUMN id SET DEFAULT nextval('usr_object_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_perm_map ALTER COLUMN id SET DEFAULT nextval('usr_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_work_ou_map ALTER COLUMN id SET DEFAULT nextval('usr_work_ou_map_id_seq'::regclass);


SET search_path = query, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY case_branch ALTER COLUMN id SET DEFAULT nextval('case_branch_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY datatype ALTER COLUMN id SET DEFAULT nextval('datatype_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression ALTER COLUMN id SET DEFAULT nextval('expression_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY from_relation ALTER COLUMN id SET DEFAULT nextval('from_relation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY function_param_def ALTER COLUMN id SET DEFAULT nextval('function_param_def_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY function_sig ALTER COLUMN id SET DEFAULT nextval('function_sig_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY order_by_item ALTER COLUMN id SET DEFAULT nextval('order_by_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY query_sequence ALTER COLUMN id SET DEFAULT nextval('query_sequence_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY record_column ALTER COLUMN id SET DEFAULT nextval('record_column_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY select_item ALTER COLUMN id SET DEFAULT nextval('select_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query ALTER COLUMN id SET DEFAULT nextval('stored_query_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY subfield ALTER COLUMN id SET DEFAULT nextval('subfield_id_seq'::regclass);


SET search_path = reporter, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY output_folder ALTER COLUMN id SET DEFAULT nextval('output_folder_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report ALTER COLUMN id SET DEFAULT nextval('report_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report_folder ALTER COLUMN id SET DEFAULT nextval('report_folder_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY schedule ALTER COLUMN id SET DEFAULT nextval('schedule_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template ALTER COLUMN id SET DEFAULT nextval('template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template_folder ALTER COLUMN id SET DEFAULT nextval('template_folder_id_seq'::regclass);


SET search_path = search, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: search; Owner: postgres
--

ALTER TABLE ONLY relevance_adjustment ALTER COLUMN id SET DEFAULT nextval('relevance_adjustment_id_seq'::regclass);


SET search_path = serial, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY basic_summary ALTER COLUMN id SET DEFAULT nextval('basic_summary_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY caption_and_pattern ALTER COLUMN id SET DEFAULT nextval('caption_and_pattern_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution ALTER COLUMN id SET DEFAULT nextval('distribution_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution_note ALTER COLUMN id SET DEFAULT nextval('distribution_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY index_summary ALTER COLUMN id SET DEFAULT nextval('index_summary_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY issuance ALTER COLUMN id SET DEFAULT nextval('issuance_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item ALTER COLUMN id SET DEFAULT nextval('item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item_note ALTER COLUMN id SET DEFAULT nextval('item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY materialized_holding_code ALTER COLUMN id SET DEFAULT nextval('materialized_holding_code_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY routing_list_user ALTER COLUMN id SET DEFAULT nextval('routing_list_user_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY stream ALTER COLUMN id SET DEFAULT nextval('stream_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN id SET DEFAULT nextval('subscription_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription_note ALTER COLUMN id SET DEFAULT nextval('subscription_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY supplement_summary ALTER COLUMN id SET DEFAULT nextval('supplement_summary_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN mint_condition SET DEFAULT true;


SET search_path = staging, pg_catalog;

--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: postgres
--

ALTER TABLE ONLY card_stage ALTER COLUMN row_id SET DEFAULT nextval('card_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: postgres
--

ALTER TABLE ONLY mailing_address_stage ALTER COLUMN row_id SET DEFAULT nextval('mailing_address_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: postgres
--

ALTER TABLE ONLY statcat_stage ALTER COLUMN row_id SET DEFAULT nextval('statcat_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: postgres
--

ALTER TABLE ONLY user_stage ALTER COLUMN row_id SET DEFAULT nextval('user_stage_row_id_seq'::regclass);


SET search_path = url_verify, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY session ALTER COLUMN id SET DEFAULT nextval('session_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url ALTER COLUMN id SET DEFAULT nextval('url_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_selector ALTER COLUMN id SET DEFAULT nextval('url_selector_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_verification ALTER COLUMN id SET DEFAULT nextval('url_verification_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY verification_attempt ALTER COLUMN id SET DEFAULT nextval('verification_attempt_id_seq'::regclass);


SET search_path = vandelay, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_attr_definition ALTER COLUMN id SET DEFAULT nextval('authority_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_match ALTER COLUMN id SET DEFAULT nextval('authority_match_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: complete; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_attr_definition ALTER COLUMN id SET DEFAULT nextval('bib_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_match ALTER COLUMN id SET DEFAULT nextval('bib_match_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: complete; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_bib_trash_fields ALTER COLUMN id SET DEFAULT nextval('import_bib_trash_fields_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_bib_trash_group ALTER COLUMN id SET DEFAULT nextval('import_bib_trash_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item ALTER COLUMN id SET DEFAULT nextval('import_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item_attr_definition ALTER COLUMN id SET DEFAULT nextval('import_item_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set ALTER COLUMN id SET DEFAULT nextval('match_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_point ALTER COLUMN id SET DEFAULT nextval('match_set_point_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_quality ALTER COLUMN id SET DEFAULT nextval('match_set_quality_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY merge_profile ALTER COLUMN id SET DEFAULT nextval('merge_profile_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: purpose; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: quality; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record_attr ALTER COLUMN id SET DEFAULT nextval('queued_authority_record_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: purpose; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: quality; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record_attr ALTER COLUMN id SET DEFAULT nextval('queued_bib_record_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


SET search_path = acq, pg_catalog;

--
-- Data for Name: acq_lineitem_history; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY acq_lineitem_history (audit_id, audit_time, audit_action, id, creator, editor, selector, provider, purchase_order, picklist, expected_recv_time, create_time, edit_time, marc, eg_bib_id, source_label, state, cancel_reason, estimated_unit_price, claim_policy, queued_record) FROM stdin;
\.


--
-- Name: acq_lineitem_pkey_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('acq_lineitem_pkey_seq', 1, false);


--
-- Data for Name: acq_purchase_order_history; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY acq_purchase_order_history (audit_id, audit_time, audit_action, id, owner, creator, editor, ordering_agency, create_time, edit_time, provider, state, order_date, name, cancel_reason, prepayment_required) FROM stdin;
\.


--
-- Name: acq_purchase_order_pkey_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('acq_purchase_order_pkey_seq', 1, false);


--
-- Data for Name: cancel_reason; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY cancel_reason (id, org_unit, label, description, keep_debits) FROM stdin;
1	1	invalid_isbn	ISBN is unrecognizable	f
2	1	postpone	Title has been postponed	f
3	1	delivered_but_lost	Delivered but not received; presumed lost	t
1002	1	Deleted	The information is to be or has been deleted.	f
1003	1	Changed	The information is to be or has been changed.	t
1004	1	No action	This line item is not affected by the actual message.	t
1005	1	Accepted without amendment	This line item is entirely accepted by the seller.	t
1007	1	Not accepted	This line item is not accepted by the seller.	f
1010	1	Not found	This line item is not found in the referenced message.	f
1024	1	Accepted with amendment, no confirmation required	Accepted with changes which require no confirmation.	t
1211	1	Split quantity	Part of the whole quantity.	t
1221	1	Ordered quantity	[6024] The quantity which has been ordered.	t
1246	1	Pieces delivered	Number of pieces actually received at the final destination.	t
1283	1	Backorder quantity	The quantity of goods that is on back-order.	t
\.


--
-- Name: cancel_reason_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('cancel_reason_id_seq', 2000, true);


--
-- Data for Name: claim; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim (id, type, lineitem_detail) FROM stdin;
\.


--
-- Data for Name: claim_event; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim_event (id, type, claim, event_date, creator, note) FROM stdin;
\.


--
-- Name: claim_event_claim_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_event_claim_seq', 1, false);


--
-- Name: claim_event_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_event_id_seq', 1, false);


--
-- Data for Name: claim_event_type; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim_event_type (id, org_unit, code, description, library_initiated) FROM stdin;
\.


--
-- Name: claim_event_type_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_event_type_id_seq', 1, false);


--
-- Name: claim_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_id_seq', 1, false);


--
-- Data for Name: claim_policy; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim_policy (id, org_unit, name, description) FROM stdin;
\.


--
-- Data for Name: claim_policy_action; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim_policy_action (id, claim_policy, action_interval, action) FROM stdin;
\.


--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_policy_action_id_seq', 1, false);


--
-- Name: claim_policy_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_policy_id_seq', 1, false);


--
-- Data for Name: claim_type; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY claim_type (id, org_unit, code, description) FROM stdin;
\.


--
-- Name: claim_type_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('claim_type_id_seq', 1, false);


--
-- Data for Name: currency_type; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY currency_type (code, label) FROM stdin;
USD	US Dollars
CAN	Canadian Dollars
EUR	Euros
\.


--
-- Data for Name: debit_attribution; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY debit_attribution (id, fund_debit, debit_amount, funding_source_credit, credit_amount) FROM stdin;
\.


--
-- Data for Name: distribution_formula; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY distribution_formula (id, owner, name, skip_count) FROM stdin;
\.


--
-- Data for Name: distribution_formula_application; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY distribution_formula_application (id, creator, create_time, formula, lineitem) FROM stdin;
\.


--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('distribution_formula_application_id_seq', 1, false);


--
-- Data for Name: distribution_formula_entry; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY distribution_formula_entry (id, formula, "position", item_count, owning_lib, location, fund, circ_modifier, collection_code) FROM stdin;
\.


--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('distribution_formula_entry_id_seq', 1, false);


--
-- Name: distribution_formula_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('distribution_formula_id_seq', 1, false);


--
-- Data for Name: edi_account; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY edi_account (id, label, host, username, password, account, path, owner, last_activity, provider, in_dir, vendcode, vendacct) FROM stdin;
\.


--
-- Data for Name: edi_message; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY edi_message (id, account, remote_file, create_time, translate_time, process_time, error_time, status, edi, jedi, error, purchase_order, message_type) FROM stdin;
\.


--
-- Name: edi_message_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('edi_message_id_seq', 1, false);


--
-- Data for Name: exchange_rate; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY exchange_rate (id, from_currency, to_currency, ratio) FROM stdin;
1	USD	CAN	1.2
2	USD	EUR	0.5
\.


--
-- Name: exchange_rate_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('exchange_rate_id_seq', 2, true);


--
-- Data for Name: fiscal_calendar; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fiscal_calendar (id, name) FROM stdin;
1	Default
\.


--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fiscal_calendar_id_seq', 1, true);


--
-- Data for Name: fiscal_year; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fiscal_year (id, calendar, year, year_begin, year_end) FROM stdin;
\.


--
-- Name: fiscal_year_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fiscal_year_id_seq', 1, false);


--
-- Data for Name: fund; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund (id, org, name, year, currency_type, code, rollover, propagate, active, balance_warning_percent, balance_stop_percent) FROM stdin;
\.


--
-- Data for Name: fund_allocation; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_allocation (id, funding_source, fund, amount, allocator, note, create_time) FROM stdin;
\.


--
-- Name: fund_allocation_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_allocation_id_seq', 1, false);


--
-- Data for Name: fund_allocation_percent; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_allocation_percent (id, funding_source, org, fund_code, percent, allocator, note, create_time) FROM stdin;
\.


--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_allocation_percent_id_seq', 1, false);


--
-- Data for Name: fund_debit; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_debit (id, fund, origin_amount, origin_currency_type, amount, encumbrance, debit_type, xfer_destination, create_time) FROM stdin;
\.


--
-- Name: fund_debit_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_debit_id_seq', 1, false);


--
-- Name: fund_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_id_seq', 1, false);


--
-- Data for Name: fund_tag; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_tag (id, owner, name) FROM stdin;
\.


--
-- Name: fund_tag_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_tag_id_seq', 1, false);


--
-- Data for Name: fund_tag_map; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_tag_map (id, fund, tag) FROM stdin;
\.


--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_tag_map_id_seq', 1, false);


--
-- Data for Name: fund_transfer; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY fund_transfer (id, src_fund, src_amount, dest_fund, dest_amount, transfer_time, transfer_user, note, funding_source_credit) FROM stdin;
\.


--
-- Name: fund_transfer_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('fund_transfer_id_seq', 1, false);


--
-- Data for Name: funding_source; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY funding_source (id, name, owner, currency_type, code) FROM stdin;
\.


--
-- Data for Name: funding_source_credit; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY funding_source_credit (id, funding_source, amount, note, deadline_date, effective_date) FROM stdin;
\.


--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('funding_source_credit_id_seq', 1, false);


--
-- Name: funding_source_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('funding_source_id_seq', 1, false);


--
-- Data for Name: invoice; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice (id, receiver, provider, shipper, recv_date, recv_method, inv_type, inv_ident, payment_auth, payment_method, note, complete) FROM stdin;
\.


--
-- Data for Name: invoice_entry; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice_entry (id, invoice, purchase_order, lineitem, inv_item_count, phys_item_count, note, billed_per_item, cost_billed, actual_cost, amount_paid) FROM stdin;
\.


--
-- Name: invoice_entry_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('invoice_entry_id_seq', 1, false);


--
-- Name: invoice_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('invoice_id_seq', 1, false);


--
-- Data for Name: invoice_item; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice_item (id, invoice, purchase_order, fund_debit, inv_item_type, title, author, note, cost_billed, actual_cost, fund, amount_paid, po_item, target) FROM stdin;
\.


--
-- Name: invoice_item_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('invoice_item_id_seq', 1, false);


--
-- Data for Name: invoice_item_type; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice_item_type (code, name, prorate) FROM stdin;
TAX	Tax	f
PRO	Processing Fee	f
SHP	Shipping Charge	f
HND	Handling Charge	f
ITM	Non-library Item	f
SUB	Serial Subscription	f
\.


--
-- Data for Name: invoice_method; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice_method (code, name) FROM stdin;
EDI	EDI
PPR	Paper
\.


--
-- Data for Name: invoice_payment_method; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY invoice_payment_method (code, name) FROM stdin;
\.


--
-- Data for Name: lineitem; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem (id, creator, editor, selector, provider, purchase_order, picklist, expected_recv_time, create_time, edit_time, marc, eg_bib_id, source_label, state, cancel_reason, estimated_unit_price, claim_policy, queued_record) FROM stdin;
\.


--
-- Data for Name: lineitem_alert_text; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_alert_text (id, code, description, owning_lib) FROM stdin;
\.


--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_alert_text_id_seq', 1, false);


--
-- Data for Name: lineitem_attr; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_attr (id, definition, lineitem, attr_type, attr_name, attr_value, order_ident) FROM stdin;
\.


--
-- Data for Name: lineitem_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_attr_definition (id, code, description, remove, ident) FROM stdin;
\.


--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_attr_definition_id_seq', 13, true);


--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_attr_id_seq', 1, false);


--
-- Data for Name: lineitem_detail; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_detail (id, lineitem, fund, fund_debit, eg_copy_id, barcode, cn_label, note, collection_code, circ_modifier, owning_lib, location, recv_time, receiver, cancel_reason) FROM stdin;
\.


--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_detail_id_seq', 1, false);


--
-- Data for Name: lineitem_generated_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_generated_attr_definition (id, code, description, remove, ident, xpath) FROM stdin;
\.


--
-- Name: lineitem_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_id_seq', 1, false);


--
-- Data for Name: lineitem_local_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_local_attr_definition (id, code, description, remove, ident) FROM stdin;
13	estimated_price	Estimated Price		f
\.


--
-- Data for Name: lineitem_marc_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_marc_attr_definition (id, code, description, remove, ident, xpath) FROM stdin;
1	title	Title of work		f	//*[@tag="245"]/*[contains("abcmnopr",@code)]
2	author	Author of work		f	//*[@tag="100" or @tag="110" or @tag="113"]/*[contains("ad",@code)]
3	language	Language of work		f	//*[@tag="240"]/*[@code="l"][1]
4	pagination	Pagination		f	//*[@tag="300"]/*[@code="a"][1]
5	isbn	ISBN	(?:-|\\s.+$)	f	//*[@tag="020"]/*[@code="a"]
6	issn	ISSN	(?:-|\\s.+$)	f	//*[@tag="022"]/*[@code="a"]
7	upc	UPC	(?:-|\\s.+$)	f	//*[@tag="024" and @ind1="1"]/*[@code="a"]
8	price	Price		f	//*[@tag="020" or @tag="022"]/*[@code="c"][1]
9	identifier	Identifier		f	//*[@tag="001"]
10	publisher	Publisher		f	//*[@tag="260"]/*[@code="b"][1]
11	pubdate	Publication Date		f	//*[@tag="260"]/*[@code="c"][1]
12	edition	Edition		f	//*[@tag="250"]/*[@code="a"][1]
\.


--
-- Data for Name: lineitem_note; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_note (id, lineitem, creator, editor, create_time, edit_time, value, alert_text, vendor_public) FROM stdin;
\.


--
-- Name: lineitem_note_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('lineitem_note_id_seq', 1, false);


--
-- Data for Name: lineitem_provider_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_provider_attr_definition (id, code, description, remove, ident, xpath, provider) FROM stdin;
\.


--
-- Data for Name: lineitem_usr_attr_definition; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY lineitem_usr_attr_definition (id, code, description, remove, ident, usr) FROM stdin;
\.


--
-- Data for Name: picklist; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY picklist (id, owner, creator, editor, org_unit, name, create_time, edit_time) FROM stdin;
\.


--
-- Name: picklist_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('picklist_id_seq', 1, false);


--
-- Data for Name: po_item; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY po_item (id, purchase_order, fund_debit, inv_item_type, title, author, note, estimated_cost, fund, target) FROM stdin;
\.


--
-- Name: po_item_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('po_item_id_seq', 1, false);


--
-- Data for Name: po_note; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY po_note (id, purchase_order, creator, editor, create_time, edit_time, value, vendor_public) FROM stdin;
\.


--
-- Name: po_note_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('po_note_id_seq', 1, false);


--
-- Data for Name: provider; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider (id, name, owner, currency_type, code, holding_tag, san, edi_default, active, prepayment_required, url, email, phone, fax_phone, default_copy_count, default_claim_policy) FROM stdin;
\.


--
-- Data for Name: provider_address; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider_address (id, valid, address_type, provider, street1, street2, city, county, state, country, post_code, fax_phone) FROM stdin;
\.


--
-- Name: provider_address_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_address_id_seq', 1, false);


--
-- Data for Name: provider_contact; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider_contact (id, provider, name, role, email, phone) FROM stdin;
\.


--
-- Data for Name: provider_contact_address; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider_contact_address (id, valid, address_type, contact, street1, street2, city, county, state, country, post_code, fax_phone) FROM stdin;
\.


--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_contact_address_id_seq', 1, false);


--
-- Name: provider_contact_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_contact_id_seq', 1, false);


--
-- Data for Name: provider_holding_subfield_map; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider_holding_subfield_map (id, provider, name, subfield) FROM stdin;
\.


--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_holding_subfield_map_id_seq', 1, false);


--
-- Name: provider_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_id_seq', 1, false);


--
-- Data for Name: provider_note; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY provider_note (id, provider, creator, editor, create_time, edit_time, value) FROM stdin;
\.


--
-- Name: provider_note_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('provider_note_id_seq', 1, false);


--
-- Data for Name: purchase_order; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY purchase_order (id, owner, creator, editor, ordering_agency, create_time, edit_time, provider, state, order_date, name, cancel_reason, prepayment_required) FROM stdin;
\.


--
-- Name: purchase_order_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('purchase_order_id_seq', 1, false);


--
-- Data for Name: serial_claim; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY serial_claim (id, type, item) FROM stdin;
\.


--
-- Data for Name: serial_claim_event; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY serial_claim_event (id, type, claim, event_date, creator, note) FROM stdin;
\.


--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('serial_claim_event_claim_seq', 1, false);


--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('serial_claim_event_id_seq', 1, false);


--
-- Name: serial_claim_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('serial_claim_id_seq', 1, false);


--
-- Data for Name: user_request; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY user_request (id, usr, hold, pickup_lib, holdable_formats, phone_notify, email_notify, lineitem, eg_bib, request_date, need_before, max_fee, request_type, isxn, title, volume, author, article_title, article_pages, publisher, location, pubdate, mentioned, other_info, cancel_reason) FROM stdin;
\.


--
-- Name: user_request_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('user_request_id_seq', 1, false);


--
-- Data for Name: user_request_type; Type: TABLE DATA; Schema: acq; Owner: postgres
--

COPY user_request_type (id, label) FROM stdin;
1	Books
2	Journal/Magazine & Newspaper Articles
3	Audiobooks
4	Music
5	DVDs
\.


--
-- Name: user_request_type_id_seq; Type: SEQUENCE SET; Schema: acq; Owner: postgres
--

SELECT pg_catalog.setval('user_request_type_id_seq', 6, true);


SET search_path = action, pg_catalog;

--
-- Data for Name: aged_circulation; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY aged_circulation (usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_owning_lib, copy_circ_lib, copy_bib_record, id, xact_start, xact_finish, unrecovered, target_copy, circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date, stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine, max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule, max_fine_rule, stop_fines, workstation, checkin_workstation, copy_location, checkin_scan_time, parent_circ) FROM stdin;
\.


--
-- Data for Name: archive_actor_stat_cat; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY archive_actor_stat_cat (id, xact, stat_cat, value) FROM stdin;
\.


--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('archive_actor_stat_cat_id_seq', 1, false);


--
-- Data for Name: archive_asset_stat_cat; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY archive_asset_stat_cat (id, xact, stat_cat, value) FROM stdin;
\.


--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('archive_asset_stat_cat_id_seq', 1, false);


--
-- Data for Name: circulation; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY circulation (id, usr, xact_start, xact_finish, unrecovered, target_copy, circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date, stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine, max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule, max_fine_rule, stop_fines, workstation, checkin_workstation, copy_location, checkin_scan_time, parent_circ) FROM stdin;
\.


--
-- Data for Name: circulation_limit_group_map; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY circulation_limit_group_map (circ, limit_group) FROM stdin;
\.


--
-- Data for Name: fieldset; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY fieldset (id, owner, owning_lib, status, creation_time, scheduled_time, applied_time, classname, name, stored_query, pkey_value) FROM stdin;
\.


--
-- Data for Name: fieldset_col_val; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY fieldset_col_val (id, fieldset, col, val) FROM stdin;
\.


--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('fieldset_col_val_id_seq', 1, false);


--
-- Name: fieldset_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('fieldset_id_seq', 1, false);


--
-- Data for Name: hold_copy_map; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_copy_map (id, hold, target_copy, proximity) FROM stdin;
\.


--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('hold_copy_map_id_seq', 1, false);


--
-- Data for Name: hold_notification; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_notification (id, hold, notify_staff, notify_time, method, note) FROM stdin;
\.


--
-- Name: hold_notification_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('hold_notification_id_seq', 1, false);


--
-- Data for Name: hold_request; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_request (id, request_time, capture_time, fulfillment_time, checkin_time, return_time, prev_check_time, expire_time, cancel_time, cancel_cause, cancel_note, target, current_copy, fulfillment_staff, fulfillment_lib, request_lib, requestor, usr, selection_ou, selection_depth, pickup_lib, hold_type, holdable_formats, phone_notify, email_notify, sms_notify, sms_carrier, frozen, thaw_date, shelf_time, cut_in_line, mint_condition, shelf_expire_time, current_shelf_lib) FROM stdin;
\.


--
-- Data for Name: hold_request_cancel_cause; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_request_cancel_cause (id, label) FROM stdin;
1	Untargeted expiration
2	Hold Shelf expiration
3	Patron via phone
4	Patron in person
5	Staff forced
6	Patron via OPAC
\.


--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('hold_request_cancel_cause_id_seq', 100, true);


--
-- Name: hold_request_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('hold_request_id_seq', 1, false);


--
-- Data for Name: hold_request_note; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_request_note (id, hold, title, body, slip, pub, staff) FROM stdin;
\.


--
-- Name: hold_request_note_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('hold_request_note_id_seq', 1, false);


--
-- Data for Name: hold_transit_copy; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY hold_transit_copy (id, source_send_time, dest_recv_time, target_copy, source, dest, prev_hop, copy_status, persistant_transfer, prev_dest, hold) FROM stdin;
\.


--
-- Data for Name: in_house_use; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY in_house_use (id, item, staff, org_unit, use_time) FROM stdin;
\.


--
-- Name: in_house_use_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('in_house_use_id_seq', 1, false);


--
-- Data for Name: non_cat_in_house_use; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY non_cat_in_house_use (id, item_type, staff, org_unit, use_time) FROM stdin;
\.


--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('non_cat_in_house_use_id_seq', 1, false);


--
-- Data for Name: non_cataloged_circulation; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY non_cataloged_circulation (id, patron, staff, circ_lib, item_type, circ_time) FROM stdin;
\.


--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('non_cataloged_circulation_id_seq', 1, false);


--
-- Data for Name: reservation_transit_copy; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY reservation_transit_copy (id, source_send_time, dest_recv_time, target_copy, source, dest, prev_hop, copy_status, persistant_transfer, prev_dest, reservation) FROM stdin;
\.


--
-- Data for Name: survey; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY survey (id, owner, start_date, end_date, usr_summary, opac, poll, required, name, description) FROM stdin;
\.


--
-- Data for Name: survey_answer; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY survey_answer (id, question, answer) FROM stdin;
\.


--
-- Name: survey_answer_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('survey_answer_id_seq', 1, false);


--
-- Name: survey_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('survey_id_seq', 1, false);


--
-- Data for Name: survey_question; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY survey_question (id, survey, question) FROM stdin;
\.


--
-- Name: survey_question_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('survey_question_id_seq', 1, false);


--
-- Data for Name: survey_response; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY survey_response (id, response_group_id, usr, survey, question, answer, answer_date, effective_date) FROM stdin;
\.


--
-- Name: survey_response_group_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('survey_response_group_id_seq', 1, false);


--
-- Name: survey_response_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('survey_response_id_seq', 1, false);


--
-- Data for Name: transit_copy; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY transit_copy (id, source_send_time, dest_recv_time, target_copy, source, dest, prev_hop, copy_status, persistant_transfer, prev_dest) FROM stdin;
\.


--
-- Name: transit_copy_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('transit_copy_id_seq', 1, false);


--
-- Data for Name: unfulfilled_hold_list; Type: TABLE DATA; Schema: action; Owner: postgres
--

COPY unfulfilled_hold_list (id, current_copy, hold, circ_lib, fail_time) FROM stdin;
\.


--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE SET; Schema: action; Owner: postgres
--

SELECT pg_catalog.setval('unfulfilled_hold_list_id_seq', 1, false);


SET search_path = action_trigger, pg_catalog;

--
-- Data for Name: cleanup; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY cleanup (module, description) FROM stdin;
fourty_two	Returns the answer to life, the universe and everything
NOOP_True	Always returns true -- cleanup always passes
NOOP_False	Always returns false -- cleanup always fails
ClearAllPending	Remove all future, pending notifications for this target
CreateHoldNotification	Creates a hold_notification record for each notified hold
DeleteTempBiblioBucket	Deletes a cbreb object used as a target if it has a btype of "temp"
\.


--
-- Data for Name: collector; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY collector (module, description) FROM stdin;
fourty_two	Returns the answer to life, the universe and everything
\.


--
-- Data for Name: environment; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY environment (id, event_def, path, collector, label) FROM stdin;
1	1	target_copy.call_number	\N	\N
2	1	target_copy.location	\N	\N
3	1	usr	\N	\N
4	1	billable_transaction.summary	\N	\N
5	1	circ_lib.billing_address	\N	\N
6	3	target_copy.call_number	\N	\N
7	3	usr	\N	\N
8	3	billable_transaction.summary	\N	\N
9	3	circ_lib.billing_address	\N	\N
10	3	target_copy.location	\N	\N
11	4	lineitems.lineitem_details.fund	\N	\N
12	4	lineitems.lineitem_details.location	\N	\N
13	4	lineitems.lineitem_details.owning_lib	\N	\N
14	4	ordering_agency.mailing_address	\N	\N
15	4	ordering_agency.billing_address	\N	\N
16	4	provider.addresses	\N	\N
17	4	lineitems.attributes	\N	\N
18	4	lineitems.lineitem_notes	\N	\N
19	4	notes	\N	\N
20	5	current_copy.call_number	\N	\N
21	5	usr	\N	\N
22	5	pickup_lib.billing_address	\N	\N
23	7	current_copy	\N	\N
24	7	pickup_lib.billing_address	\N	\N
25	7	usr	\N	\N
26	9	pickup_lib	\N	\N
27	9	usr	\N	\N
28	9	current_copy.call_number	\N	\N
29	15	lineitem	\N	\N
30	15	lineitem.attributes	\N	\N
31	15	usr	\N	\N
32	16	lineitem	\N	\N
33	16	lineitem.attributes	\N	\N
34	16	usr	\N	\N
35	17	lineitem	\N	\N
36	17	lineitem.attributes	\N	\N
37	17	usr	\N	\N
38	18	usr	\N	\N
39	19	usr	\N	\N
40	19	cancel_reason	\N	\N
41	20	usr	\N	\N
42	20	usr.home_ou	\N	\N
43	21	claim	\N	\N
44	21	claim.type	\N	\N
45	21	claim.lineitem_detail	\N	\N
46	21	claim.lineitem_detail.fund	\N	\N
47	21	claim.lineitem_detail.lineitem.attributes	\N	\N
48	21	claim.lineitem_detail.lineitem.purchase_order	\N	\N
49	21	creator	\N	\N
50	21	type	\N	\N
51	22	provider	\N	\N
52	22	provider.addresses	\N	\N
53	22	shipper	\N	\N
54	22	shipper.addresses	\N	\N
55	22	receiver	\N	\N
56	22	entries	\N	\N
57	22	entries.purchase_order	\N	\N
58	22	entries.lineitem	\N	\N
59	22	entries.lineitem.attributes	\N	\N
60	22	items	\N	\N
61	6	target_copy.call_number	\N	\N
62	6	usr	\N	\N
63	6	circ_lib.billing_address	\N	\N
64	10	target_copy	\N	\N
65	10	circ_lib.billing_address	\N	\N
66	10	circ_lib.hours_of_operation	\N	\N
67	10	usr	\N	\N
68	11	target_copy	\N	\N
69	11	circ_lib.billing_address	\N	\N
70	11	circ_lib.hours_of_operation	\N	\N
71	11	usr	\N	\N
72	12	bib_rec.bib_record.simple_record	\N	\N
73	12	pickup_lib	\N	\N
74	12	usr	\N	\N
75	14	attributes	\N	\N
76	14	lineitem_notes	\N	\N
77	14	lineitem_notes.alert_text	\N	\N
78	14	distribution_formulas.formula	\N	\N
79	14	lineitem_details	\N	\N
80	14	lineitem_details.owning_lib	\N	\N
81	14	lineitem_details.fund	\N	\N
82	14	lineitem_details.location	\N	\N
83	14	lineitem_details.eg_copy_id	\N	\N
84	14	lineitem_details.eg_copy_id.call_number	\N	\N
85	14	lineitem_details.eg_copy_id.location	\N	\N
86	13	open_billable_transactions_summary.circulation	\N	\N
87	23	lineitems.attributes	\N	\N
88	23	lineitems.lineitem_details.owning_lib	\N	\N
89	23	lineitems.lineitem_details.location	\N	\N
90	23	lineitems.lineitem_details.fund	\N	\N
91	23	lineitems.lineitem_details.eg_copy_id.location	\N	\N
92	23	lineitems.lineitem_details.eg_copy_id.call_number	\N	\N
93	23	lineitems.lineitem_notes	\N	\N
94	23	ordering_agency.mailing_address	\N	\N
95	23	provider	\N	\N
96	23	provider.edi_default	\N	\N
97	24	target_copy.call_number.record.simple_record	\N	\N
98	24	usr	\N	\N
99	25	target_copy	\N	\N
100	25	usr	\N	\N
101	26	target_copy	\N	\N
102	26	usr	\N	\N
103	27	current_copy	\N	\N
104	27	usr	\N	\N
105	28	current_copy	\N	\N
106	28	usr	\N	\N
107	29	xact	\N	\N
108	29	xact.usr	\N	\N
109	29	xact.grocery	\N	\N
110	29	xact.circulation	\N	\N
111	29	xact.summary	\N	\N
112	29	credit_card_payment	\N	\N
113	29	xact.billings	\N	\N
114	29	xact.billings.btype	\N	\N
115	30	xact	\N	\N
116	30	xact.usr	\N	\N
117	30	xact.grocery	\N	\N
118	30	xact.circulation	\N	\N
119	30	xact.summary	\N	\N
120	30	credit_card_payment	\N	\N
121	30	xact.billings	\N	\N
122	30	xact.billings.btype	\N	\N
123	31	owner	\N	\N
124	31	items	\N	\N
125	32	items	\N	\N
126	33	usr	\N	\N
127	33	target_copy	\N	\N
128	33	target_copy.circ_lib	\N	\N
129	33	target_copy.circ_lib.mailing_address	\N	\N
130	33	target_copy.circ_lib.billing_address	\N	\N
131	33	target_copy.call_number	\N	\N
132	33	target_copy.call_number.owning_lib	\N	\N
133	33	target_copy.call_number.owning_lib.mailing_address	\N	\N
134	33	target_copy.call_number.owning_lib.billing_address	\N	\N
135	33	circ_lib	\N	\N
136	33	circ_lib.mailing_address	\N	\N
137	33	circ_lib.billing_address	\N	\N
138	34	usr	\N	\N
139	34	target_copy	\N	\N
140	34	target_copy.circ_lib	\N	\N
141	34	target_copy.circ_lib.mailing_address	\N	\N
142	34	target_copy.circ_lib.billing_address	\N	\N
143	34	target_copy.call_number	\N	\N
144	34	target_copy.call_number.owning_lib	\N	\N
145	34	target_copy.call_number.owning_lib.mailing_address	\N	\N
146	34	target_copy.call_number.owning_lib.billing_address	\N	\N
147	34	circ_lib	\N	\N
148	34	circ_lib.mailing_address	\N	\N
149	34	circ_lib.billing_address	\N	\N
150	35	current_copy.location	\N	\N
151	35	current_copy.call_number	\N	\N
152	35	usr.card	\N	\N
153	35	pickup_lib	\N	\N
154	35	current_copy.parts	\N	\N
155	35	current_copy.parts.part	\N	\N
156	37	target_copy.call_number.record.simple_record	\N	\N
157	37	usr	\N	\N
158	37	circ_lib.billing_address	\N	\N
159	38	usr	\N	\N
160	38	pickup_lib	\N	\N
161	38	bib_rec.bib_record.simple_record	\N	\N
162	39	attributes	\N	\N
163	39	queue	\N	\N
164	39	matches	\N	\N
165	40	attributes	\N	\N
166	40	queue	\N	\N
167	40	matches	\N	\N
168	41	attributes	\N	\N
169	41	queue	\N	\N
170	41	queue.owner	\N	\N
171	42	attributes	\N	\N
172	42	queue	\N	\N
173	43	attributes	\N	\N
174	43	queue	\N	\N
175	44	attributes	\N	\N
176	44	queue	\N	\N
177	44	queue.owner	\N	\N
178	45	record	\N	\N
179	45	record.attributes	\N	\N
180	45	record.queue	\N	\N
181	45	record.queue.owner	\N	\N
182	46	record	\N	\N
183	46	record.attributes	\N	\N
184	46	record.queue	\N	\N
185	46	record.queue.owner	\N	\N
186	47	record	\N	\N
187	47	record.attributes	\N	\N
188	47	record.queue	\N	\N
189	47	record.queue.owner	\N	\N
190	101	current_copy.call_number.record.simple_record	\N	\N
191	101	usr	\N	\N
192	101	pickup_lib.billing_address	\N	\N
193	102	record.simple_record	\N	\N
194	102	owning_lib.billing_address	\N	\N
195	103	target_copy.call_number	\N	\N
\.


--
-- Name: environment_id_seq; Type: SEQUENCE SET; Schema: action_trigger; Owner: postgres
--

SELECT pg_catalog.setval('environment_id_seq', 195, true);


--
-- Data for Name: event; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY event (id, target, event_def, add_time, run_time, start_time, update_time, complete_time, update_process, state, user_data, template_output, error_output, async_output) FROM stdin;
\.


--
-- Data for Name: event_definition; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY event_definition (id, active, owner, name, hook, validator, reactor, cleanup_success, cleanup_failure, delay, max_delay, usr_field, opt_in_setting, delay_field, group_field, template, granularity) FROM stdin;
1	f	1	7 Day Overdue Email Notification	checkout.due	CircIsOverdue	SendEmail	\N	\N	7 days	8 days	\N	\N	due_date	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Overdue Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate the following items are overdue.\n\n[% FOR circ IN target %]\n    [%- copy_details = helpers.get_copy_bib_basics(circ.target_copy.id) -%]\n    Title: [% copy_details.title %]\n    Author: [% copy_details.author %]\n    Call Number: [% circ.target_copy.call_number.label %]\n    Barcode: [% circ.target_copy.barcode %]\n    Due: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]\n    Item Cost: [% helpers.get_copy_price(circ.target_copy) %]\n    Total Owed For Transaction: [% circ.billable_transaction.summary.balance_owed %]\n    Library: [% circ.circ_lib.name %]\n\n[% END %]\n\n	\N
2	f	1	90 Day Overdue Mark Lost	checkout.due	CircIsOverdue	MarkItemLost	\N	\N	90 days	\N	\N	\N	due_date	\N	\N	\N
3	f	1	90 Day Overdue Mark Lost Notice	lost.auto	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Overdue Items Marked Lost\n\nDear [% user.family_name %], [% user.first_given_name %]\nThe following items are 90 days overdue and have been marked LOST.\n\n[% FOR circ IN target %]\n    [%- copy_details = helpers.get_copy_bib_basics(circ.target_copy.id) -%]\n    Title: [% copy_details.title %], by [% copy_details.author %]\n    Call Number: [% circ.target_copy.call_number.label %]\n    Shelving Location: [% circ.target_copy.location.name %]\n    Barcode: [% circ.target_copy.barcode %]\n    Due: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]\n    Item Cost: [% helpers.get_copy_price(circ.target_copy) %]\n    Total Owed For Transaction: [% circ.billable_transaction.summary.balance_owed %]\n    Library: [% circ.circ_lib.name %]\n\n[% END %]\n\n	\N
4	t	1	PO HTML	format.po.html	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%-\n    # find a lineitem attribute by name and optional type\n    BLOCK get_li_attr;\n        FOR attr IN li.attributes;\n            IF attr.attr_name == attr_name;\n                IF !attr_type OR attr_type == attr.attr_type;\n                    attr.attr_value;\n                    LAST;\n                END;\n            END;\n        END;\n    END\n-%]\n\n<h2>Purchase Order [% target.id %]</h2>\n<br/>\ndate <b>[% date.format(date.now, '%Y%m%d') %]</b>\n<br/>\n\n<style>\n    table td { padding:5px; border:1px solid #aaa;}\n    table { width:95%; border-collapse:collapse; }\n    #vendor-notes { padding:5px; border:1px solid #aaa; }\n</style>\n<table id='vendor-table'>\n  <tr>\n    <td valign='top'>Vendor</td>\n    <td>\n      <div>[% target.provider.name %]</div>\n      <div>[% target.provider.addresses.0.street1 %]</div>\n      <div>[% target.provider.addresses.0.street2 %]</div>\n      <div>[% target.provider.addresses.0.city %]</div>\n      <div>[% target.provider.addresses.0.state %]</div>\n      <div>[% target.provider.addresses.0.country %]</div>\n      <div>[% target.provider.addresses.0.post_code %]</div>\n    </td>\n    <td valign='top'>Ship to / Bill to</td>\n    <td>\n      <div>[% target.ordering_agency.name %]</div>\n      <div>[% target.ordering_agency.billing_address.street1 %]</div>\n      <div>[% target.ordering_agency.billing_address.street2 %]</div>\n      <div>[% target.ordering_agency.billing_address.city %]</div>\n      <div>[% target.ordering_agency.billing_address.state %]</div>\n      <div>[% target.ordering_agency.billing_address.country %]</div>\n      <div>[% target.ordering_agency.billing_address.post_code %]</div>\n    </td>\n  </tr>\n</table>\n\n<br/><br/>\n<fieldset id='vendor-notes'>\n    <legend>Notes to the Vendor</legend>\n    <ul>\n    [% FOR note IN target.notes %]\n        [% IF note.vendor_public == 't' %]\n            <li>[% note.value %]</li>\n        [% END %]\n    [% END %]\n    </ul>\n</fieldset>\n<br/><br/>\n\n<table>\n  <thead>\n    <tr>\n      <th>PO#</th>\n      <th>ISBN or Item #</th>\n      <th>Title</th>\n      <th>Quantity</th>\n      <th>Unit Price</th>\n      <th>Line Total</th>\n      <th>Notes</th>\n    </tr>\n  </thead>\n  <tbody>\n\n  [% subtotal = 0 %]\n  [% FOR li IN target.lineitems %]\n\n  <tr>\n    [% count = li.lineitem_details.size %]\n    [% price = li.estimated_unit_price %]\n    [% litotal = (price * count) %]\n    [% subtotal = subtotal + litotal %]\n    [% \n        ident_attr = helpers.get_li_order_ident(li.attributes);\n        SET ident_value = ident_attr.attr_value IF ident_attr;\n    %]\n    <td>[% target.id %]</td>\n    <td>[% ident_value %]</td>\n    <td>[% PROCESS get_li_attr attr_name = 'title' %]</td>\n    <td>[% count %]</td>\n    <td>[% price %]</td>\n    <td>[% litotal %]</td>\n    <td>\n        <ul>\n        [% FOR note IN li.lineitem_notes %]\n            [% IF note.vendor_public == 't' %]\n                <li>[% note.value %]</li>\n            [% END %]\n        [% END %]\n        </ul>\n    </td>\n  </tr>\n  [% END %]\n  <tr>\n    <td/><td/><td/><td/>\n    <td>Subtotal</td>\n    <td>[% subtotal %]</td>\n  </tr>\n  </tbody>\n</table>\n\n<br/>\n\nTotal Line Item Count: [% target.lineitems.size %]\n	\N
5	f	1	Hold Ready for Pickup Email Notification	hold.available	HoldIsAvailable	SendEmail	CreateHoldNotification	\N	00:30:00	\N	\N	\N	shelf_time	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Hold Available Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nThe item(s) you requested are available for pickup from the Library.\n\n[% FOR hold IN target %]\n    [%- copy_details = helpers.get_copy_bib_basics(hold.current_copy.id) -%]\n    Title: [% copy_details.title %]\n    Author: [% copy_details.author %]\n    Call Number: [% hold.current_copy.call_number.label %]\n    Barcode: [% hold.current_copy.barcode %]\n    Library: [% hold.pickup_lib.name %]\n[% END %]\n\n	\N
7	f	1	Hold Expires from Shelf Soon	hold_request.shelf_expires_soon	HoldIsAvailable	SendEmail	\N	\N	-1 days	\N	\N	\N	shelf_expire_time	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Hold Available Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nYou requested holds on the following item(s), which are available for\npickup, but these holds will soon expire.\n\n[% FOR hold IN target %]\n    [%- data = helpers.get_copy_bib_basics(hold.current_copy.id) -%]\n    Title: [% data.title %]\n    Author: [% data.author %]\n    Library: [% hold.pickup_lib.name %]\n[% END %]\n	\N
9	f	1	Hold waiting for pickup for long time	hold_request.long_wait	HoldNotifyCheck	SendEmail	\N	\N	6 mons	\N	\N	\N	request_time	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Long Wait Hold Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\n\nYou requested hold(s) on the following item(s), but unfortunately\nwe have not been able to fulfill your request after a considerable\nlength of time.  If you would still like to receive these items,\nno action is required.\n\n[% FOR hold IN target %]\n    [%- copy_details = helpers.get_copy_bib_basics(hold.current_copy.id) -%]\n    Title: [% copy_details.title %]\n    Author: [% copy_details.author %]\n[% END %]\n	\N
15	f	1	Email Notice: Patron Acquisition Request marked On-Order.	aur.ordered	Acq::UserRequestOrdered	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET li = target.lineitem; -%]\n[%- SET user = target.usr -%]\n[%- SET title = helpers.get_li_attr("title", "", li.attributes) -%]\n[%- SET author = helpers.get_li_attr("author", "", li.attributes) -%]\n[%- SET edition = helpers.get_li_attr("edition", "", li.attributes) -%]\n[%- SET isbn = helpers.get_li_attr("isbn", "", li.attributes) -%]\n[%- SET publisher = helpers.get_li_attr("publisher", "", li.attributes) -%]\n[%- SET pubdate = helpers.get_li_attr("pubdate", "", li.attributes) -%]\n\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Acquisition Request Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate the following acquisition request has been placed on order.\n\nTitle: [% title %]\n[% IF author %]Author: [% author %][% END %]\n[% IF edition %]Edition: [% edition %][% END %]\n[% IF isbn %]ISBN: [% isbn %][% END %]\n[% IF publisher %]Publisher: [% publisher %][% END %]\n[% IF pubdate %]Publication Date: [% pubdate %][% END %]\nLineitem ID: [% li.id %]\n	\N
24	f	1	Telephone Overdue Notice	checkout.due	NOOP_True	AstCall	\N	\N	00:00:05	\N	\N	\N	due_date	usr	\n[% phone = target.0.usr.day_phone | replace('[\\s\\-\\(\\)]', '') -%]\n[% IF phone.match('^[2-9]') %][% country = 1 %][% ELSE %][% country = '' %][% END -%]\nChannel: [% channel_prefix %]/[% country %][% phone %]\nContext: overdue-test\nMaxRetries: 1\nRetryTime: 60\nWaitTime: 30\nExtension: 10\nArchive: 1\nSet: eg_user_id=[% target.0.usr.id %]\nSet: items=[% target.size %]\nSet: titlestring=[% titles = [] %][% FOR circ IN target %][% titles.push(circ.target_copy.call_number.record.simple_record.title) %][% END %][% titles.join(". ") %]\n	\N
16	f	1	Email Notice: Patron Acquisition Request marked Received.	aur.received	Acq::UserRequestReceived	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET li = target.lineitem; -%]\n[%- SET user = target.usr -%]\n[%- SET title = helpers.get_li_attr("title", "", li.attributes) %]\n[%- SET author = helpers.get_li_attr("author", "", li.attributes) %]\n[%- SET edition = helpers.get_li_attr("edition", "", li.attributes) %]\n[%- SET isbn = helpers.get_li_attr("isbn", "", li.attributes) %]\n[%- SET publisher = helpers.get_li_attr("publisher", "", li.attributes) -%]\n[%- SET pubdate = helpers.get_li_attr("pubdate", "", li.attributes) -%]\n\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Acquisition Request Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate the materials for the following acquisition request have been received.\n\nTitle: [% title %]\n[% IF author %]Author: [% author %][% END %]\n[% IF edition %]Edition: [% edition %][% END %]\n[% IF isbn %]ISBN: [% isbn %][% END %]\n[% IF publisher %]Publisher: [% publisher %][% END %]\n[% IF pubdate %]Publication Date: [% pubdate %][% END %]\nLineitem ID: [% li.id %]\n	\N
17	f	1	Email Notice: Patron Acquisition Request marked Cancelled.	aur.cancelled	Acq::UserRequestCancelled	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET li = target.lineitem; -%]\n[%- SET user = target.usr -%]\n[%- SET title = helpers.get_li_attr("title", "", li.attributes) %]\n[%- SET author = helpers.get_li_attr("author", "", li.attributes) %]\n[%- SET edition = helpers.get_li_attr("edition", "", li.attributes) %]\n[%- SET isbn = helpers.get_li_attr("isbn", "", li.attributes) %]\n[%- SET publisher = helpers.get_li_attr("publisher", "", li.attributes) -%]\n[%- SET pubdate = helpers.get_li_attr("pubdate", "", li.attributes) -%]\n\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Acquisition Request Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate the following acquisition request has been cancelled.\n\nTitle: [% title %]\n[% IF author %]Author: [% author %][% END %]\n[% IF edition %]Edition: [% edition %][% END %]\n[% IF isbn %]ISBN: [% isbn %][% END %]\n[% IF publisher %]Publisher: [% publisher %][% END %]\n[% IF pubdate %]Publication Date: [% pubdate %][% END %]\nLineitem ID: [% li.id %]\n	\N
18	f	1	Email Notice: Acquisition Request created.	aur.created	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET user = target.usr -%]\n[%- SET title = target.title -%]\n[%- SET author = target.author -%]\n[%- SET isxn = target.isxn -%]\n[%- SET publisher = target.publisher -%]\n[%- SET pubdate = target.pubdate -%]\n\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Acquisition Request Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate that you have made the following acquisition request:\n\nTitle: [% title %]\n[% IF author %]Author: [% author %][% END %]\n[% IF edition %]Edition: [% edition %][% END %]\n[% IF isbn %]ISXN: [% isxn %][% END %]\n[% IF publisher %]Publisher: [% publisher %][% END %]\n[% IF pubdate %]Publication Date: [% pubdate %][% END %]\n	\N
19	f	1	Email Notice: Acquisition Request Rejected.	aur.rejected	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET user = target.usr -%]\n[%- SET title = target.title -%]\n[%- SET author = target.author -%]\n[%- SET isxn = target.isxn -%]\n[%- SET publisher = target.publisher -%]\n[%- SET pubdate = target.pubdate -%]\n[%- SET cancel_reason = target.cancel_reason.description -%]\n\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Acquisition Request Notification\n\nDear [% user.family_name %], [% user.first_given_name %]\nOur records indicate the following acquisition request has been rejected for this reason: [% cancel_reason %]\n\nTitle: [% title %]\n[% IF author %]Author: [% author %][% END %]\n[% IF edition %]Edition: [% edition %][% END %]\n[% IF isbn %]ISBN: [% isbn %][% END %]\n[% IF publisher %]Publisher: [% publisher %][% END %]\n[% IF pubdate %]Publication Date: [% pubdate %][% END %]\n	\N
20	f	1	Password reset request notification	password.reset_request	NOOP_True	SendEmail	\N	\N	00:00:01	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- user = target.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || user.home_ou.email || default_sender %]\nSubject: [% user.home_ou.name %]: library account password reset request\n\nYou have received this message because you, or somebody else, requested a reset\nof your library system password. If you did not request a reset of your library\nsystem password, just ignore this message and your current password will\ncontinue to work.\n\nIf you did request a reset of your library system password, please perform\nthe following steps to continue the process of resetting your password:\n\n1. Open the following link in a web browser: https://[% params.hostname %]/eg/opac/password_reset/[% target.uuid %]\nThe browser displays a password reset form.\n\n2. Enter your new password in the password reset form in the browser. You must\nenter the password twice to ensure that you do not make a mistake. If the\npasswords match, you will then be able to log in to your library system account\nwith the new password.\n\n	\N
21	t	1	Claim Voucher	format.acqcle.html	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	claim	\n[%- USE date -%]\n[%- SET claim = target.0.claim -%]\n<!-- This will need refined/prettified. -->\n<div class="acq-claim-voucher">\n    <h2>Claim: [% claim.id %] ([% claim.type.code %])</h2>\n    <h3>Against: [%- helpers.get_li_attr("title", "", claim.lineitem_detail.lineitem.attributes) -%]</h3>\n    <ul>\n        [% FOR event IN target %]\n        <li>\n            Event type: [% event.type.code %]\n            [% IF event.type.library_initiated %](Library initiated)[% END %]\n            <br />\n            Event date: [% event.event_date %]<br />\n            Order date: [% event.claim.lineitem_detail.lineitem.purchase_order.order_date %]<br />\n            Expected receive date: [% event.claim.lineitem_detail.lineitem.expected_recv_time %]<br />\n            Initiated by: [% event.creator.family_name %], [% event.creator.first_given_name %] [% event.creator.second_given_name %]<br />\n            Barcode: [% event.claim.lineitem_detail.barcode %]; Fund:\n            [% event.claim.lineitem_detail.fund.code %]\n            ([% event.claim.lineitem_detail.fund.year %])\n        </li>\n        [% END %]\n    </ul>\n</div>\n	print-on-demand
25	t	1	circ.history.email	circ.format.history.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Circulation History\n\n    [% FOR circ IN target %]\n            [% helpers.get_copy_bib_basics(circ.target_copy.id).title %]\n            Barcode: [% circ.target_copy.barcode %]\n            Checked Out: [% date.format(helpers.format_date(circ.xact_start), '%Y-%m-%d') %]\n            Due Date: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]\n            Returned: [% date.format(helpers.format_date(circ.checkin_time), '%Y-%m-%d') %]\n    [% END %]\n	\N
22	t	1	Invoice	format.acqinv.html	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[% FILTER collapse %]\n[%- SET invoice = target -%]\n<!-- This lacks general refinement -->\n<div class="acq-invoice-voucher">\n    <h1>Invoice</h1>\n    <div>\n        <strong>No.</strong> [% invoice.inv_ident %]\n        [% IF invoice.inv_type %]\n            / <strong>Type:</strong>[% invoice.inv_type %]\n        [% END %]\n    </div>\n    <div>\n        <dl>\n            [% BLOCK ent_with_address %]\n            <dt>[% ent_label %]: [% ent.name %] ([% ent.code %])</dt>\n            <dd>\n                [% IF ent.addresses.0 %]\n                    [% SET addr = ent.addresses.0 %]\n                    [% addr.street1 %]<br />\n                    [% IF addr.street2 %][% addr.street2 %]<br />[% END %]\n                    [% addr.city %],\n                    [% IF addr.county %] [% addr.county %], [% END %]\n                    [% IF addr.state %] [% addr.state %] [% END %]\n                    [% IF addr.post_code %][% addr.post_code %][% END %]<br />\n                    [% IF addr.country %] [% addr.country %] [% END %]\n                [% END %]\n                <p>\n                    [% IF ent.phone %] Phone: [% ent.phone %]<br />[% END %]\n                    [% IF ent.fax_phone %] Fax: [% ent.fax_phone %]<br />[% END %]\n                    [% IF ent.url %] URL: [% ent.url %]<br />[% END %]\n                    [% IF ent.email %] E-mail: [% ent.email %] [% END %]\n                </p>\n            </dd>\n            [% END %]\n            [% INCLUDE ent_with_address\n                ent = invoice.provider\n                ent_label = "Provider" %]\n            [% INCLUDE ent_with_address\n                ent = invoice.shipper\n                ent_label = "Shipper" %]\n            <dt>Receiver</dt>\n            <dd>\n                [% invoice.receiver.name %] ([% invoice.receiver.shortname %])\n            </dd>\n            <dt>Received</dt>\n            <dd>\n                [% helpers.format_date(invoice.recv_date) %] by\n                [% invoice.recv_method %]\n            </dd>\n            [% IF invoice.note %]\n                <dt>Note</dt>\n                <dd>\n                    [% invoice.note %]\n                </dd>\n            [% END %]\n        </dl>\n    </div>\n    <ul>\n        [% FOR entry IN invoice.entries %]\n            <li>\n                [% IF entry.lineitem %]\n                    Title: [% helpers.get_li_attr(\n                        "title", "", entry.lineitem.attributes\n                    ) %]<br />\n                    Author: [% helpers.get_li_attr(\n                        "author", "", entry.lineitem.attributes\n                    ) %]\n                [% END %]\n                [% IF entry.purchase_order %]\n                    (PO: [% entry.purchase_order.name %])\n                [% END %]<br />\n                Invoice item count: [% entry.inv_item_count %]\n                [% IF entry.phys_item_count %]\n                    / Physical item count: [% entry.phys_item_count %]\n                [% END %]\n                <br />\n                [% IF entry.cost_billed %]\n                    Cost billed: [% entry.cost_billed %]\n                    [% IF entry.billed_per_item %](per item)[% END %]\n                    <br />\n                [% END %]\n                [% IF entry.actual_cost %]\n                    Actual cost: [% entry.actual_cost %]<br />\n                [% END %]\n                [% IF entry.amount_paid %]\n                    Amount paid: [% entry.amount_paid %]<br />\n                [% END %]\n                [% IF entry.note %]Note: [% entry.note %][% END %]\n            </li>\n        [% END %]\n        [% FOR item IN invoice.items %]\n            <li>\n                [% IF item.inv_item_type %]\n                    Item Type: [% item.inv_item_type %]<br />\n                [% END %]\n                [% IF item.title %]Title/Description:\n                    [% item.title %]<br />\n                [% END %]\n                [% IF item.author %]Author: [% item.author %]<br />[% END %]\n                [% IF item.purchase_order %]PO: [% item.purchase_order %]<br />[% END %]\n                [% IF item.note %]Note: [% item.note %]<br />[% END %]\n                [% IF item.cost_billed %]\n                    Cost billed: [% item.cost_billed %]<br />\n                [% END %]\n                [% IF item.actual_cost %]\n                    Actual cost: [% item.actual_cost %]<br />\n                [% END %]\n                [% IF item.amount_paid %]\n                    Amount paid: [% item.amount_paid %]<br />\n                [% END %]\n            </li>\n        [% END %]\n    </ul>\n    <div>\n        Amounts spent per fund:\n        <table>\n        [% FOR blob IN user_data %]\n            <tr>\n                <th style="text-align: left;">[% blob.fund.code %] ([% blob.fund.year %]):</th>\n                <td>$[% blob.total %]</td>\n            </tr>\n        [% END %]\n        </table>\n    </div>\n</div>\n[% END %]	print-on-demand
6	f	1	3 Day Courtesy Notice	checkout.due	CircIsOpen	SendEmail	\N	\N	-3 days	-2 days	\N	\N	due_date	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Courtesy Notice\n\nDear [% user.family_name %], [% user.first_given_name %]\nAs a reminder, the following items are due in 3 days.\n\n[% FOR circ IN target %]\n    [%- copy_details = helpers.get_copy_bib_basics(circ.target_copy.id) -%]\n    Title: [% copy_details.title %]\n    Author: [% copy_details.author %]\n    Barcode: [% circ.target_copy.barcode %] \n    Due: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]\n    Item Cost: [% helpers.get_copy_price(circ.target_copy) %]\n    Library: [% circ.circ_lib.name %]\n    Library Phone: [% circ.circ_lib.phone %]\n\n[% END %]\n\n	\N
10	t	1	Self-Checkout Receipt	format.selfcheck.checkout	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\n[%- SET lib = target.0.circ_lib -%]\n[%- SET lib_addr = target.0.circ_lib.billing_address -%]\n[%- SET hours = lib.hours_of_operation -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <div>[% lib.name %]</div>\n    <div>[% lib_addr.street1 %] [% lib_addr.street2 %]</div>\n    <div>[% lib_addr.city %], [% lib_addr.state %] [% lb_addr.post_code %]</div>\n    <div>[% lib.phone %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR circ IN target %]\n        [%-\n            SET idx = loop.count - 1;\n            SET udata =  user_data.$idx\n        -%]\n        <li>\n            <div>[% helpers.get_copy_bib_basics(circ.target_copy.id).title %]</div>\n            <div>Barcode: [% circ.target_copy.barcode %]</div>\n            [% IF user_data.renewal_failure %]\n                <div style='color:red;'>Renewal Failed</div>\n            [% ELSE %]\n                <div>Due Date: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]</div>\n            [% END %]\n        </li>\n    [% END %]\n    </ol>\n    \n    <div>\n        Library Hours\n        [%- BLOCK format_time; date.format(time _ ' 1/1/1000', format='%I:%M %p'); END -%]\n        <div>\n            Monday \n            [% PROCESS format_time time = hours.dow_0_open %] \n            [% PROCESS format_time time = hours.dow_0_close %] \n        </div>\n        <div>\n            Tuesday \n            [% PROCESS format_time time = hours.dow_1_open %] \n            [% PROCESS format_time time = hours.dow_1_close %] \n        </div>\n        <div>\n            Wednesday \n            [% PROCESS format_time time = hours.dow_2_open %] \n            [% PROCESS format_time time = hours.dow_2_close %] \n        </div>\n        <div>\n            Thursday\n            [% PROCESS format_time time = hours.dow_3_open %] \n            [% PROCESS format_time time = hours.dow_3_close %] \n        </div>\n        <div>\n            Friday\n            [% PROCESS format_time time = hours.dow_4_open %] \n            [% PROCESS format_time time = hours.dow_4_close %] \n        </div>\n        <div>\n            Saturday\n            [% PROCESS format_time time = hours.dow_5_open %] \n            [% PROCESS format_time time = hours.dow_5_close %] \n        </div>\n        <div>\n            Sunday \n            [% PROCESS format_time time = hours.dow_6_open %] \n            [% PROCESS format_time time = hours.dow_6_close %] \n        </div>\n    </div>\n</div>\n	print-on-demand
11	t	1	Self-Checkout Items Out Receipt	format.selfcheck.items_out	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR circ IN target %]\n        <li>\n            <div>[% helpers.get_copy_bib_basics(circ.target_copy.id).title %]</div>\n            <div>Barcode: [% circ.target_copy.barcode %]</div>\n            <div>Due Date: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]</div>\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
12	t	1	Self-Checkout Holds Receipt	format.selfcheck.holds	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR hold IN target %]\n        [%-\n            SET idx = loop.count - 1;\n            SET udata =  user_data.$idx\n        -%]\n        <li>\n            <div>Title: [% hold.bib_rec.bib_record.simple_record.title %]</div>\n            <div>Author: [% hold.bib_rec.bib_record.simple_record.author %]</div>\n            <div>Pickup Location: [% hold.pickup_lib.name %]</div>\n            <div>Status: \n                [%- IF udata.ready -%]\n                    Ready for pickup\n                [% ELSE %]\n                    #[% udata.queue_position %] of [% udata.potential_copies %] copies.\n                [% END %]\n            </div>\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
13	t	1	Self-Checkout Fines Receipt	format.selfcheck.fines	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET user = target -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR xact IN user.open_billable_transactions_summary %]\n        <li>\n            <div>Details: \n                [% IF xact.xact_type == 'circulation' %]\n                    [%- helpers.get_copy_bib_basics(xact.circulation.target_copy).title -%]\n                [% ELSE %]\n                    [%- xact.last_billing_type -%]\n                [% END %]\n            </div>\n            <div>Total Billed: [% xact.total_owed %]</div>\n            <div>Total Paid: [% xact.total_paid %]</div>\n            <div>Balance Owed : [% xact.balance_owed %]</div>\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
14	t	1	Lineitem Worksheet	format.acqli.html	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%- SET li = target; -%]\n<div class="wrapper">\n    <div class="summary" style='font-size:110%; font-weight:bold;'>\n\n        <div>Title: [% helpers.get_li_attr("title", "", li.attributes) %]</div>\n        <div>Author: [% helpers.get_li_attr("author", "", li.attributes) %]</div>\n        <div class="count">Item Count: [% li.lineitem_details.size %]</div>\n        <div class="lineid">Lineitem ID: [% li.id %]</div>\n        <div>Open Holds: [% helpers.bre_open_hold_count(li.eg_bib_id) %]</div>\n\n        [% IF li.distribution_formulas.size > 0 %]\n            [% SET forms = [] %]\n            [% FOREACH form IN li.distribution_formulas; forms.push(form.formula.name); END %]\n            <div>Distribution Formulas: [% forms.join(',') %]</div>\n        [% END %]\n\n        [% IF li.lineitem_notes.size > 0 %]\n            Lineitem Notes:\n            <ul>\n                [%- FOR note IN li.lineitem_notes -%]\n                    <li>\n                    [% IF note.alert_text %]\n                        [% note.alert_text.code -%] \n                        [% IF note.value -%]\n                            : [% note.value %]\n                        [% END %]\n                    [% ELSE %]\n                        [% note.value -%] \n                    [% END %]\n                    </li>\n                [% END %]\n            </ul>\n        [% END %]\n    </div>\n    <br/>\n    <table>\n        <thead>\n            <tr>\n                <th>Branch</th>\n                <th>Barcode</th>\n                <th>Call Number</th>\n                <th>Fund</th>\n                <th>Shelving Location</th>\n                <th>Recd.</th>\n                <th>Notes</th>\n            </tr>\n        </thead>\n        <tbody>\n        <!-- set detail.owning_lib from fm object to org name -->\n        [% FOREACH detail IN li.lineitem_details %]\n            [% detail.owning_lib = detail.owning_lib.shortname %]\n        [% END %]\n\n        [% FOREACH detail IN li.lineitem_details.sort('owning_lib') %]\n            [% \n                IF detail.eg_copy_id;\n                    SET copy = detail.eg_copy_id;\n                    SET cn_label = copy.call_number.label;\n                ELSE; \n                    SET copy = detail; \n                    SET cn_label = detail.cn_label;\n                END \n            %]\n            <tr>\n                <!-- acq.lineitem_detail.id = [%- detail.id -%] -->\n                <td style='padding:5px;'>[% detail.owning_lib %]</td>\n                <td style='padding:5px;'>[% IF copy.barcode   %]<span class="barcode"  >[% detail.barcode   %]</span>[% END %]</td>\n                <td style='padding:5px;'>[% IF cn_label %]<span class="cn_label" >[% cn_label  %]</span>[% END %]</td>\n                <td style='padding:5px;'>[% IF detail.fund %]<span class="fund">[% detail.fund.code %] ([% detail.fund.year %])</span>[% END %]</td>\n                <td style='padding:5px;'>[% copy.location.name %]</td>\n                <td style='padding:5px;'>[% IF detail.recv_time %]<span class="recv_time">[% detail.recv_time %]</span>[% END %]</td>\n                <td style='padding:5px;'>[% detail.note %]</td>\n            </tr>\n        [% END %]\n        </tbody>\n    </table>\n</div>\n	print-on-demand
23	t	1	PO JEDI	acqpo.activated	Acq::PurchaseOrderEDIRequired	GeneratePurchaseOrderJEDI	\N	\N	00:00:00	\N	\N	\N	\N	\N	\n[%- USE date -%]\n[%\n    # extract some commonly used variables\n\n    VENDOR_SAN = target.provider.san;\n    VENDCODE = target.provider.edi_default.vendcode;\n    VENDACCT = target.provider.edi_default.vendacct;\n    ORG_UNIT_SAN = target.ordering_agency.mailing_address.san;\n\n    # set the vendor / provider\n\n    VENDOR_BT      = 0; # Baker & Taylor\n    VENDOR_INGRAM  = 0;\n    VENDOR_BRODART = 0;\n    VENDOR_MW_TAPE = 0; # Midwest Tape\n    VENDOR_RB      = 0; # Recorded Books\n    VENDOR_ULS     = 0; # ULS\n\n    IF    VENDOR_SAN == '1556150'; VENDOR_BT = 1;\n    ELSIF VENDOR_SAN == '1697684'; VENDOR_BRODART = 1;\n    ELSIF VENDOR_SAN == '1697978'; VENDOR_INGRAM = 1;\n    ELSIF VENDOR_SAN == '2549913'; VENDOR_MW_TAPE = 1;\n    ELSIF VENDOR_SAN == '1113984'; VENDOR_RB = 1;\n    ELSIF VENDOR_SAN == '1699342'; VENDOR_ULS = 1;\n    END;\n\n    # if true, pass the PO name as a secondary identifier\n    # RFF+LI:<name>/li_id\n    INC_PO_NAME = 0;\n    IF VENDOR_INGRAM;\n        INC_PO_NAME = 1;\n    END;\n\n    # GIR configuration --------------------------------------\n\n    INC_COPIES = 1; # copies on/off switch\n    INC_FUND = 0;\n    INC_CALLNUMBER = 0;\n    INC_ITEM_TYPE = 1;\n    INC_LOCATION = 0;\n    INC_COLLECTION_CODE = 1;\n    INC_OWNING_LIB = 1;\n    INC_QUANTITY = 1;\n    INC_COPY_ID = 0;\n\n    IF VENDOR_BT;\n        INC_CALLNUMBER = 1;\n    END;\n\n    IF VENDOR_BRODART;\n        INC_FUND = 1;\n    END;\n\n    IF VENDOR_MW_TAPE;\n        INC_FUND = 1;\n        INC_COLLECTION_CODE = 0;\n        INC_ITEM_TYPE = 0;\n    END;\n\n    # END GIR configuration ---------------------------------\n\n-%]\n[%- BLOCK big_block -%]\n{\n   "recipient":"[% VENDOR_SAN %]",\n   "sender":"[% ORG_UNIT_SAN %]",\n   "body": [{\n     "ORDERS":[ "order", {\n\n        "po_number":[% target.id %],\n\n        [% IF INC_PO_NAME %]\n        "po_name":"[% target.name | replace('\\/', ' ') | replace('"', '\\"') %]",\n        [% END %]\n\n        "date":"[% date.format(date.now, '%Y%m%d') %]",\n\n        "buyer":[\n            [% IF VENDOR_BT %]\n                {"id-qualifier": 91, "id":"[% ORG_UNIT_SAN %] [% VENDCODE %]"}\n            [% ELSE %]\n                {"id":"[% ORG_UNIT_SAN %]"},\n                {"id-qualifier": 91, "id":"[% VENDACCT %]"}\n            [% END %]\n        ],\n\n        "vendor":[\n            "[% VENDOR_SAN %]",\n            {"id-qualifier": 92, "id":"[% target.provider.id %]"}\n        ],\n\n        "currency":"[% target.provider.currency_type %]",\n                \n        "items":[\n        [%- FOR li IN target.lineitems %]\n        {\n            "line_index":"[% li.id %]",\n            "identifiers":[   \n            [%- \n                idval = '';\n                idqual = 'EN'; # default ISBN/UPC/EAN-13\n                ident_attr = helpers.get_li_order_ident(li.attributes);\n                IF ident_attr;\n                    idname = ident_attr.attr_name;\n                    idval = ident_attr.attr_value;\n                    IF idname == 'isbn' AND idval.length != 13;\n                        idqual = 'IB';\n                    ELSIF idname == 'issn';\n                        idqual = 'IS';\n                    END;\n                ELSE;\n                    idqual = 'IN';\n                    idval = li.id;\n                END -%]\n                {"id-qualifier":"[% idqual %]","id":"[% idval %]"}\n            ],\n            "price":[% li.estimated_unit_price || '0.00' %],\n            "desc":[\n                {"BTI":"[% helpers.get_li_attr_jedi('title',     '', li.attributes) %]"},\n                {"BPU":"[% helpers.get_li_attr_jedi('publisher', '', li.attributes) %]"},\n                {"BPD":"[% helpers.get_li_attr_jedi('pubdate',   '', li.attributes) %]"},\n                [% IF VENDOR_ULS -%]\n                {"BEN":"[% helpers.get_li_attr_jedi('edition',   '', li.attributes) %]"},\n                {"BAU":"[% helpers.get_li_attr_jedi('author',    '', li.attributes) %]"}\n                [%- ELSE -%]\n                {"BPH":"[% helpers.get_li_attr_jedi('pagination','', li.attributes) %]"}\n                [%- END %]\n            ],\n            [%- ftx_vals = []; \n                FOR note IN li.lineitem_notes;\n                    NEXT UNLESS note.vendor_public == 't'; \n                    ftx_vals.push(note.value); \n                END; \n                IF VENDOR_BRODART; # look for copy-level spec code\n                    FOR lid IN li.lineitem_details;\n                        IF lid.note;\n                            spec_note = lid.note.match('spec code ([a-zA-Z0-9_])');\n                            IF spec_note.0; ftx_vals.push(spec_note.0); END;\n                        END;\n                    END;\n                END; \n                IF xtra_ftx;           ftx_vals.unshift(xtra_ftx); END; \n\n                # BT & ULS want FTX+LIN for every LI, even if empty\n                IF ((VENDOR_BT OR VENDOR_ULS) AND ftx_vals.size == 0);\n                    ftx_vals.unshift('');\n                END;  \n            -%]\n\n            "free-text":[ \n                [% FOR note IN ftx_vals -%] "[% note %]"[% UNLESS loop.last %], [% END %][% END %] \n            ],            \n\n            "quantity":[% li.lineitem_details.size %]\n\n            [%- IF INC_COPIES -%]\n            ,"copies" : [\n                [%- compressed_copies = [];\n                    FOR lid IN li.lineitem_details;\n                        fund = lid.fund.code;\n                        item_type = lid.circ_modifier;\n                        callnumber = lid.cn_label;\n                        owning_lib = lid.owning_lib.shortname;\n                        location = lid.location;\n                        collection_code = lid.collection_code;\n    \n                        # when we have real copy data, treat it as authoritative for some fields\n                        acp = lid.eg_copy_id;\n                        IF acp;\n                            item_type = acp.circ_modifier;\n                            callnumber = acp.call_number.label;\n                            location = acp.location.name;\n                        END ;\n\n\n                        # collapse like copies into groups w/ quantity\n\n                        found_match = 0;\n                        IF !INC_COPY_ID; # INC_COPY_ID implies 1 copy per GIR\n                            FOR copy IN compressed_copies;\n                                IF  (fund == copy.fund OR (!fund AND !copy.fund)) AND\n                                    (item_type == copy.item_type OR (!item_type AND !copy.item_type)) AND\n                                    (callnumber == copy.callnumber OR (!callnumber AND !copy.callnumber)) AND\n                                    (owning_lib == copy.owning_lib OR (!owning_lib AND !copy.owning_lib)) AND\n                                    (location == copy.location OR (!location AND !copy.location)) AND\n                                    (collection_code == copy.collection_code OR (!collection_code AND !copy.collection_code));\n\n                                    copy.quantity = copy.quantity + 1;\n                                    found_match = 1;\n                                END;\n                            END;\n                        END;\n\n                        IF !found_match;\n                            compressed_copies.push({\n                                fund => fund,\n                                item_type => item_type,\n                                callnumber => callnumber,\n                                owning_lib => owning_lib,\n                                location => location,\n                                collection_code => collection_code,\n                                copy_id => lid.id, # for INC_COPY_ID\n                                quantity => 1\n                            });\n                        END;\n                    END;\n                    FOR copy IN compressed_copies;\n\n                    # If we assume owning_lib is required and set, \n                    # it is safe to prepend each following copy field w/ a ","\n\n                    # B&T EDI requires expected GIR fields to be \n                    # present regardless of whether a value exists.  \n                    # some fields are required to have a value in ACQ, \n                    # though, so they are not forced into place below.\n\n                 %]{[%- IF INC_OWNING_LIB AND copy.owning_lib %] "owning_lib":"[% copy.owning_lib %]"[% END -%]\n                    [%- IF INC_FUND AND copy.fund %],"fund":"[% copy.fund %]"[% END -%]\n                    [%- IF INC_CALLNUMBER AND (VENDOR_BT OR copy.callnumber) %],"call_number":"[% copy.callnumber %]"[% END -%]\n                    [%- IF INC_ITEM_TYPE AND (VENDOR_BT OR copy.item_type) %],"item_type":"[% copy.item_type %]"[% END -%]\n                    [%- IF INC_LOCATION AND copy.location %],"copy_location":"[% copy.location %]"[% END -%]\n                    [%- IF INC_COLLECTION_CODE AND (VENDOR_BT OR copy.collection_code) %],"collection_code":"[% copy.collection_code %]"[% END -%]\n                    [%- IF INC_QUANTITY %],"quantity":"[% copy.quantity %]"[% END -%]\n                    [%- IF INC_COPY_ID %],"copy_id":"[% copy.copy_id %]" [% END %]}[% ',' UNLESS loop.last -%]\n                [%- END -%] [%# FOR compressed_copies -%]\n            ]\n            [%- END -%] [%# IF INC_COPIES %]\n\n        }[% UNLESS loop.last %],[% END -%]\n\n        [% END %] [%# END lineitems %]\n        ],\n        "line_items":[% target.lineitems.size %]\n     }]  [%# close ORDERS array %]\n   }]    [%# close  body  array %]\n}\n[% END %]\n[% tempo = PROCESS big_block; helpers.escape_json(tempo) %]\n	\N
26	t	1	circ.history.print	circ.format.history.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR circ IN target %]\n        <li>\n            <div>[% helpers.get_copy_bib_basics(circ.target_copy.id).title %]</div>\n            <div>Barcode: [% circ.target_copy.barcode %]</div>\n            <div>Checked Out: [% date.format(helpers.format_date(circ.xact_start), '%Y-%m-%d') %]</div>\n            <div>Due Date: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]</div>\n            <div>Returned: [% date.format(helpers.format_date(circ.checkin_time), '%Y-%m-%d') %]</div>\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
27	t	1	ahr.history.email	ahr.format.history.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Hold Request History\n\n    [% FOR hold IN target %]\n            [% helpers.get_copy_bib_basics(hold.current_copy.id).title %]\n            Requested: [% date.format(helpers.format_date(hold.request_time), '%Y-%m-%d') %]\n            [% IF hold.fulfillment_time %]Fulfilled: [% date.format(helpers.format_date(hold.fulfillment_time), '%Y-%m-%d') %][% END %]\n    [% END %]\n	\N
28	t	1	ahr.history.print	ahr.format.history.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <div>[% date.format %]</div>\n    <br/>\n\n    [% user.family_name %], [% user.first_given_name %]\n    <ol>\n    [% FOR hold IN target %]\n        <li>\n            <div>[% helpers.get_copy_bib_basics(hold.current_copy.id).title %]</div>\n            <div>Requested: [% date.format(helpers.format_date(hold.request_time), '%Y-%m-%d') %]</div>\n            [% IF hold.fulfillment_time %]<div>Fulfilled: [% date.format(helpers.format_date(hold.fulfillment_time), '%Y-%m-%d') %]</div>[% END %]\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
29	t	1	money.payment_receipt.email	money.format.payment_receipt.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	xact.usr	\n[%- USE date -%]\n[%- SET user = target.0.xact.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Payment Receipt\n\n[% date.format -%]\n[%- SET xact_mp_hash = {} -%]\n[%- FOR mp IN target %][%# Template is hooked around payments, but let us make the receipt focused on transactions -%]\n    [%- SET xact_id = mp.xact.id -%]\n    [%- IF ! xact_mp_hash.defined( xact_id ) -%][%- xact_mp_hash.$xact_id = { 'xact' => mp.xact, 'payments' => [] } -%][%- END -%]\n    [%- xact_mp_hash.$xact_id.payments.push(mp) -%]\n[%- END -%]\n[%- FOR xact_id IN xact_mp_hash.keys.sort -%]\n    [%- SET xact = xact_mp_hash.$xact_id.xact %]\nTransaction ID: [% xact_id %]\n    [% IF xact.circulation %][% helpers.get_copy_bib_basics(xact.circulation.target_copy).title %]\n    [% ELSE %]Miscellaneous\n    [% END %]\n    Line item billings:\n        [%- SET mb_type_hash = {} -%]\n        [%- FOR mb IN xact.billings %][%# Group billings by their btype -%]\n            [%- IF mb.voided == 'f' -%]\n                [%- SET mb_type = mb.btype.id -%]\n                [%- IF ! mb_type_hash.defined( mb_type ) -%][%- mb_type_hash.$mb_type = { 'sum' => 0.00, 'billings' => [] } -%][%- END -%]\n                [%- IF ! mb_type_hash.$mb_type.defined( 'first_ts' ) -%][%- mb_type_hash.$mb_type.first_ts = mb.billing_ts -%][%- END -%]\n                [%- mb_type_hash.$mb_type.last_ts = mb.billing_ts -%]\n                [%- mb_type_hash.$mb_type.sum = mb_type_hash.$mb_type.sum + mb.amount -%]\n                [%- mb_type_hash.$mb_type.billings.push( mb ) -%]\n            [%- END -%]\n        [%- END -%]\n        [%- FOR mb_type IN mb_type_hash.keys.sort -%]\n            [%- IF mb_type == 1 %][%-# Consolidated view of overdue billings -%]\n                $[% mb_type_hash.$mb_type.sum %] for [% mb_type_hash.$mb_type.billings.0.btype.name %] \n                    on [% mb_type_hash.$mb_type.first_ts %] through [% mb_type_hash.$mb_type.last_ts %]\n            [%- ELSE -%][%# all other billings show individually %]\n                [% FOR mb IN mb_type_hash.$mb_type.billings %]\n                    $[% mb.amount %] for [% mb.btype.name %] on [% mb.billing_ts %] [% mb.note %]\n                [% END %]\n            [% END %]\n        [% END %]\n    Line item payments:\n        [% FOR mp IN xact_mp_hash.$xact_id.payments %]\n            Payment ID: [% mp.id %]\n                Paid [% mp.amount %] via [% SWITCH mp.payment_type -%]\n                    [% CASE "cash_payment" %]cash\n                    [% CASE "check_payment" %]check\n                    [% CASE "credit_card_payment" %]credit card (\n                        [%- SET cc_chunks = mp.credit_card_payment.cc_number.replace(' ','').chunk(4); -%]\n                        [%- cc_chunks.slice(0, -1+cc_chunks.max).join.replace('\\S','X') -%] \n                        [% cc_chunks.last -%]\n                        exp [% mp.credit_card_payment.expire_month %]/[% mp.credit_card_payment.expire_year -%]\n                    )\n                    [% CASE "credit_payment" %]credit\n                    [% CASE "forgive_payment" %]forgiveness\n                    [% CASE "goods_payment" %]goods\n                    [% CASE "work_payment" %]work\n                [%- END %] on [% mp.payment_ts %] [% mp.note %]\n        [% END %]\n[% END %]\n	\N
30	t	1	money.payment_receipt.print	money.format.payment_receipt.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	xact.usr	\n[%- USE date -%][%- SET user = target.0.xact.usr -%]\n<div style="li { padding: 8px; margin 5px; }">\n    <div>[% date.format %]</div><br/>\n    <ol>\n    [% SET xact_mp_hash = {} %]\n    [% FOR mp IN target %][%# Template is hooked around payments, but let us make the receipt focused on transactions %]\n        [% SET xact_id = mp.xact.id %]\n        [% IF ! xact_mp_hash.defined( xact_id ) %][% xact_mp_hash.$xact_id = { 'xact' => mp.xact, 'payments' => [] } %][% END %]\n        [% xact_mp_hash.$xact_id.payments.push(mp) %]\n    [% END %]\n    [% FOR xact_id IN xact_mp_hash.keys.sort %]\n        [% SET xact = xact_mp_hash.$xact_id.xact %]\n        <li>Transaction ID: [% xact_id %]\n            [% IF xact.circulation %][% helpers.get_copy_bib_basics(xact.circulation.target_copy).title %]\n            [% ELSE %]Miscellaneous\n            [% END %]\n            Line item billings:<ol>\n                [% SET mb_type_hash = {} %]\n                [% FOR mb IN xact.billings %][%# Group billings by their btype %]\n                    [% IF mb.voided == 'f' %]\n                        [% SET mb_type = mb.btype.id %]\n                        [% IF ! mb_type_hash.defined( mb_type ) %][% mb_type_hash.$mb_type = { 'sum' => 0.00, 'billings' => [] } %][% END %]\n                        [% IF ! mb_type_hash.$mb_type.defined( 'first_ts' ) %][% mb_type_hash.$mb_type.first_ts = mb.billing_ts %][% END %]\n                        [% mb_type_hash.$mb_type.last_ts = mb.billing_ts %]\n                        [% mb_type_hash.$mb_type.sum = mb_type_hash.$mb_type.sum + mb.amount %]\n                        [% mb_type_hash.$mb_type.billings.push( mb ) %]\n                    [% END %]\n                [% END %]\n                [% FOR mb_type IN mb_type_hash.keys.sort %]\n                    <li>[% IF mb_type == 1 %][%# Consolidated view of overdue billings %]\n                        $[% mb_type_hash.$mb_type.sum %] for [% mb_type_hash.$mb_type.billings.0.btype.name %] \n                            on [% mb_type_hash.$mb_type.first_ts %] through [% mb_type_hash.$mb_type.last_ts %]\n                    [% ELSE %][%# all other billings show individually %]\n                        [% FOR mb IN mb_type_hash.$mb_type.billings %]\n                            $[% mb.amount %] for [% mb.btype.name %] on [% mb.billing_ts %] [% mb.note %]\n                        [% END %]\n                    [% END %]</li>\n                [% END %]\n            </ol>\n            Line item payments:<ol>\n                [% FOR mp IN xact_mp_hash.$xact_id.payments %]\n                    <li>Payment ID: [% mp.id %]\n                        Paid [% mp.amount %] via [% SWITCH mp.payment_type -%]\n                            [% CASE "cash_payment" %]cash\n                            [% CASE "check_payment" %]check\n                            [% CASE "credit_card_payment" %]credit card (\n                                [%- SET cc_chunks = mp.credit_card_payment.cc_number.replace(' ','').chunk(4); -%]\n                                [%- cc_chunks.slice(0, -1+cc_chunks.max).join.replace('\\S','X') -%] \n                                [% cc_chunks.last -%]\n                                exp [% mp.credit_card_payment.expire_month %]/[% mp.credit_card_payment.expire_year -%]\n                            )\n                            [% CASE "credit_payment" %]credit\n                            [% CASE "forgive_payment" %]forgiveness\n                            [% CASE "goods_payment" %]goods\n                            [% CASE "work_payment" %]work\n                        [%- END %] on [% mp.payment_ts %] [% mp.note %]\n                    </li>\n                [% END %]\n            </ol>\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
31	t	1	biblio.record_entry.email	biblio.format.record_entry.email	NOOP_True	SendEmail	DeleteTempBiblioBucket	DeleteTempBiblioBucket	00:00:00	\N	\N	\N	\N	owner	\n[%- SET user = target.0.owner -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Bibliographic Records\n\n[% FOR cbreb IN target %][% title = '' %]\n[% FOR item IN cbreb.items;\n    bre_id = item.target_biblio_record_entry;\n\n    bibxml = helpers.unapi_bre(bre_id, {flesh => '{mra}'});\n    FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a" or @code="b"]');\n        title = title _ part.textContent;\n    END;\n\n    author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n    item_type = bibxml.findnodes('//*[local-name()="attributes"]/*[local-name()="field"][@name="item_type"]').getAttribute('coded-value');\n    publisher = bibxml.findnodes('//*[@tag="260"]/*[@code="b"]').textContent;\n    pubdate = bibxml.findnodes('//*[@tag="260"]/*[@code="c"]').textContent;\n    isbn = bibxml.findnodes('//*[@tag="020"]/*[@code="a"]').textContent;\n    issn = bibxml.findnodes('//*[@tag="022"]/*[@code="a"]').textContent;\n    upc = bibxml.findnodes('//*[@tag="024"]/*[@code="a"]').textContent;\n%]\n\n[% loop.count %]/[% loop.size %].  Bib ID# [% bre_id %] \n[% IF isbn %]ISBN: [% isbn _ "\\n" %][% END -%]\n[% IF issn %]ISSN: [% issn _ "\\n" %][% END -%]\n[% IF upc  %]UPC:  [% upc _ "\\n" %] [% END -%]\nTitle: [% title %]\nAuthor: [% author %]\nPublication Info: [% publisher %] [% pubdate %]\nItem Type: [% item_type %]\n\n[% END %]\n[% END %]\n	\N
32	t	1	biblio.record_entry.print	biblio.format.record_entry.print	NOOP_True	ProcessTemplate	DeleteTempBiblioBucket	DeleteTempBiblioBucket	00:00:00	\N	\N	\N	\N	owner	\n<div>\n    <style> li { padding: 8px; margin 5px; }</style>\n    <ol>\n    [% FOR cbreb IN target %][% title = '' %]\n    [% FOR item IN cbreb.items;\n        bre_id = item.target_biblio_record_entry;\n\n        bibxml = helpers.unapi_bre(bre_id, {flesh => '{mra}'});\n        FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a" or @code="b"]');\n            title = title _ part.textContent;\n        END;\n\n        author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n        item_type = bibxml.findnodes('//*[local-name()="attributes"]/*[local-name()="field"][@name="item_type"]').getAttribute('coded-value');\n        publisher = bibxml.findnodes('//*[@tag="260"]/*[@code="b"]').textContent;\n        pubdate = bibxml.findnodes('//*[@tag="260"]/*[@code="c"]').textContent;\n        isbn = bibxml.findnodes('//*[@tag="020"]/*[@code="a"]').textContent;\n        %]\n\n        <li>\n            Bib ID# [% bre_id %] ISBN: [% isbn %]<br />\n            Title: [% title %]<br />\n            Author: [% author %]<br />\n            Publication Info: [% publisher %] [% pubdate %]<br/>\n            Item Type: [% item_type %]\n        </li>\n    [% END %]\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
33	t	1	circ.missing_pieces.slip.print	circ.format.missing_pieces.slip.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\n<div style="li { padding: 8px; margin 5px; }">\n    <div>[% date.format %]</div><br/>\n    Missing pieces for:\n    <ol>\n    [% FOR circ IN target %]\n        <li>Barcode: [% circ.target_copy.barcode %] Transaction ID: [% circ.id %] Due: [% circ.due_date.format %]<br />\n            [% helpers.get_copy_bib_basics(circ.target_copy.id).title %]\n        </li>\n    [% END %]\n    </ol>\n</div>\n	print-on-demand
34	t	1	circ.missing_pieces.letter.print	circ.format.missing_pieces.letter.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- SET user = target.0.usr -%]\n[% date.format %]\nDear [% user.prefix %] [% user.first_given_name %] [% user.family_name %],\n\nWe are missing pieces for the following returned items:\n[% FOR circ IN target %]\nBarcode: [% circ.target_copy.barcode %] Transaction ID: [% circ.id %] Due: [% circ.due_date.format %]\n[% helpers.get_copy_bib_basics(circ.target_copy.id).title %]\n[% END %]\n\nPlease return these pieces as soon as possible.\n\nThanks!\n\nLibrary Staff\n	print-on-demand
35	t	1	Holds Pull List	ahr.format.pull_list	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	pickup_lib	\n[%- USE date -%]\n<style>\n    table { border-collapse: collapse; }\n    td { padding: 5px; border-bottom: 1px solid #888; }\n    th { font-weight: bold; }\n</style>\n[%\n    # Sort the holds into copy-location buckets\n    # In the main print loop, sort each bucket by callnumber before printing\n    SET holds_list = [];\n    SET loc_data = [];\n    SET current_location = target.0.current_copy.location.id;\n    FOR hold IN target;\n        IF current_location != hold.current_copy.location.id;\n            SET current_location = hold.current_copy.location.id;\n            holds_list.push(loc_data);\n            SET loc_data = [];\n        END;\n        SET hold_data = {\n            'hold' => hold,\n            'callnumber' => hold.current_copy.call_number.label\n        };\n        loc_data.push(hold_data);\n    END;\n    holds_list.push(loc_data)\n%]\n<table>\n    <thead>\n        <tr>\n            <th>Title</th>\n            <th>Author</th>\n            <th>Shelving Location</th>\n            <th>Call Number</th>\n            <th>Barcode/Part</th>\n            <th>Patron</th>\n        </tr>\n    </thead>\n    <tbody>\n    [% FOR loc_data IN holds_list  %]\n        [% FOR hold_data IN loc_data.sort('callnumber') %]\n            [%\n                SET hold = hold_data.hold;\n                SET copy_data = helpers.get_copy_bib_basics(hold.current_copy.id);\n            %]\n            <tr>\n                <td>[% copy_data.title | truncate %]</td>\n                <td>[% copy_data.author | truncate %]</td>\n                <td>[% hold.current_copy.location.name %]</td>\n                <td>[% hold.current_copy.call_number.label %]</td>\n                <td>[% hold.current_copy.barcode %]\n                    [% FOR part IN hold.current_copy.parts %]\n                       [% part.part.label %]\n                    [% END %]\n                </td>\n                <td>[% hold.usr.card.barcode %]</td>\n            </tr>\n        [% END %]\n    [% END %]\n    <tbody>\n</table>\n	print-on-demand
36	f	1	circ.staff_age_to_lost	circ.staff_age_to_lost	CircIsOverdue	MarkItemLost	\N	\N	00:05:00	\N	\N	\N	due_date	\N	\N	\N
37	t	1	Item Recall Email Notice	circ.recall.target	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Item Recall Notification \n\nDear [% user.family_name %], [% user.first_given_name %]\n\nThe following item which you have checked out has been recalled so that\nanother patron can have access to the item:\n\n[% FOR circ IN target %]\n    Title: [% circ.target_copy.call_number.record.simple_record.title %] \n    Barcode: [% circ.target_copy.barcode %] \n    Now Due: [% date.format(helpers.format_date(circ.due_date), '%Y-%m-%d') %]\n    Library: [% circ.circ_lib.name %]\n\n    If this item is not returned by the new due date, fines will be assessed at\n    the rate of [% circ.recurring_fine %] every [% circ.fine_interval %].\n[% END %]\n	\N
38	f	1	Hold Cancelled (No Target) Email Notification	hold_request.cancel.expire_no_target	HoldIsCancelled	SendEmail	\N	\N	00:30:00	\N	\N	\N	cancel_time	usr	\n[%- USE date -%]\n[%- user = target.0.usr -%]\nTo: [%- params.recipient_email || user.email %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Hold Request Cancelled\n\nDear [% user.family_name %], [% user.first_given_name %]\nThe following holds were cancelled because no items were found to fullfil the hold.\n\n[% FOR hold IN target %]\n    Title: [% hold.bib_rec.bib_record.simple_record.title %]\n    Author: [% hold.bib_rec.bib_record.simple_record.author %]\n    Library: [% hold.pickup_lib.name %]\n    Request Date: [% date.format(helpers.format_date(hold.rrequest_time), '%Y-%m-%d') %]\n[% END %]\n\n	\N
39	t	1	Print Output for Queued Bib Records	vandelay.queued_bib_record.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n<pre>\nQueue ID: [% target.0.queue.id %]\nQueue Name: [% target.0.queue.name %]\nQueue Type: [% target.0.queue.queue_type %]\nComplete? [% target.0.queue.complete %]\n\n    [% FOR vqbr IN target %]\n=-=-=\n Title of work    | [% helpers.get_queued_bib_attr('title',vqbr.attributes) %]\n Author of work   | [% helpers.get_queued_bib_attr('author',vqbr.attributes) %]\n Language of work | [% helpers.get_queued_bib_attr('language',vqbr.attributes) %]\n Pagination       | [% helpers.get_queued_bib_attr('pagination',vqbr.attributes) %]\n ISBN             | [% helpers.get_queued_bib_attr('isbn',vqbr.attributes) %]\n ISSN             | [% helpers.get_queued_bib_attr('issn',vqbr.attributes) %]\n Price            | [% helpers.get_queued_bib_attr('price',vqbr.attributes) %]\n Accession Number | [% helpers.get_queued_bib_attr('rec_identifier',vqbr.attributes) %]\n TCN Value        | [% helpers.get_queued_bib_attr('eg_tcn',vqbr.attributes) %]\n TCN Source       | [% helpers.get_queued_bib_attr('eg_tcn_source',vqbr.attributes) %]\n Internal ID      | [% helpers.get_queued_bib_attr('eg_identifier',vqbr.attributes) %]\n Publisher        | [% helpers.get_queued_bib_attr('publisher',vqbr.attributes) %]\n Publication Date | [% helpers.get_queued_bib_attr('pubdate',vqbr.attributes) %]\n Edition          | [% helpers.get_queued_bib_attr('edition',vqbr.attributes) %]\n Item Barcode     | [% helpers.get_queued_bib_attr('item_barcode',vqbr.attributes) %]\n Import Error     | [% vqbr.import_error %]\n Error Detail     | [% vqbr.error_detail %]\n Match Count      | [% vqbr.matches.size %]\n\n    [% END %]\n</pre>\n	print-on-demand
40	t	1	CSV Output for Queued Bib Records	vandelay.queued_bib_record.csv	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n"Title of work","Author of work","Language of work","Pagination","ISBN","ISSN","Price","Accession Number","TCN Value","TCN Source","Internal ID","Publisher","Publication Date","Edition","Item Barcode","Import Error","Error Detail","Match Count"\n[% FOR vqbr IN target %]"[% helpers.get_queued_bib_attr('title',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('author',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('language',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('pagination',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('isbn',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('issn',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('price',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('rec_identifier',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('eg_tcn',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('eg_tcn_source',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('eg_identifier',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('publisher',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('pubdate',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('edition',vqbr.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('item_barcode',vqbr.attributes) | replace('"', '""') %]","[% vqbr.import_error | replace('"', '""') %]","[% vqbr.error_detail | replace('"', '""') %]","[% vqbr.matches.size %]"\n[% END %]\n	print-on-demand
41	t	1	Email Output for Queued Bib Records	vandelay.queued_bib_record.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n[%- SET user = target.0.queue.owner -%]\nTo: [%- params.recipient_email || user.email || 'root@localhost' %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Bibs from Import Queue\n\nQueue ID: [% target.0.queue.id %]\nQueue Name: [% target.0.queue.name %]\nQueue Type: [% target.0.queue.queue_type %]\nComplete? [% target.0.queue.complete %]\n\n    [% FOR vqbr IN target %]\n=-=-=\n Title of work    | [% helpers.get_queued_bib_attr('title',vqbr.attributes) %]\n Author of work   | [% helpers.get_queued_bib_attr('author',vqbr.attributes) %]\n Language of work | [% helpers.get_queued_bib_attr('language',vqbr.attributes) %]\n Pagination       | [% helpers.get_queued_bib_attr('pagination',vqbr.attributes) %]\n ISBN             | [% helpers.get_queued_bib_attr('isbn',vqbr.attributes) %]\n ISSN             | [% helpers.get_queued_bib_attr('issn',vqbr.attributes) %]\n Price            | [% helpers.get_queued_bib_attr('price',vqbr.attributes) %]\n Accession Number | [% helpers.get_queued_bib_attr('rec_identifier',vqbr.attributes) %]\n TCN Value        | [% helpers.get_queued_bib_attr('eg_tcn',vqbr.attributes) %]\n TCN Source       | [% helpers.get_queued_bib_attr('eg_tcn_source',vqbr.attributes) %]\n Internal ID      | [% helpers.get_queued_bib_attr('eg_identifier',vqbr.attributes) %]\n Publisher        | [% helpers.get_queued_bib_attr('publisher',vqbr.attributes) %]\n Publication Date | [% helpers.get_queued_bib_attr('pubdate',vqbr.attributes) %]\n Edition          | [% helpers.get_queued_bib_attr('edition',vqbr.attributes) %]\n Item Barcode     | [% helpers.get_queued_bib_attr('item_barcode',vqbr.attributes) %]\n\n    [% END %]\n\n	\N
42	t	1	Print Output for Queued Authority Records	vandelay.queued_auth_record.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n<pre>\nQueue ID: [% target.0.queue.id %]\nQueue Name: [% target.0.queue.name %]\nQueue Type: [% target.0.queue.queue_type %]\nComplete? [% target.0.queue.complete %]\n\n    [% FOR vqar IN target %]\n=-=-=\n Record Identifier | [% helpers.get_queued_auth_attr('rec_identifier',vqar.attributes) %]\n\n    [% END %]\n</pre>\n	print-on-demand
43	t	1	CSV Output for Queued Authority Records	vandelay.queued_auth_record.csv	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n"Record Identifier"\n[% FOR vqar IN target %]"[% helpers.get_queued_auth_attr('rec_identifier',vqar.attributes) | replace('"', '""') %]"\n[% END %]\n	print-on-demand
44	t	1	Email Output for Queued Authority Records	vandelay.queued_auth_record.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	queue.owner	\n[%- USE date -%]\n[%- SET user = target.0.queue.owner -%]\nTo: [%- params.recipient_email || user.email || 'root@localhost' %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Authorities from Import Queue\n\nQueue ID: [% target.0.queue.id %]\nQueue Name: [% target.0.queue.name %]\nQueue Type: [% target.0.queue.queue_type %]\nComplete? [% target.0.queue.complete %]\n\n    [% FOR vqar IN target %]\n=-=-=\n Record Identifier | [% helpers.get_queued_auth_attr('rec_identifier',vqar.attributes) %]\n\n    [% END %]\n\n	\N
45	t	1	Print Output for Import Items from Queued Bib Records	vandelay.import_items.print	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	record.queue.owner	\n[%- USE date -%]\n<pre>\nQueue ID: [% target.0.record.queue.id %]\nQueue Name: [% target.0.record.queue.name %]\nQueue Type: [% target.0.record.queue.queue_type %]\nComplete? [% target.0.record.queue.complete %]\n\n    [% FOR vii IN target %]\n=-=-=\n Import Item ID         | [% vii.id %]\n Title of work          | [% helpers.get_queued_bib_attr('title',vii.record.attributes) %]\n ISBN                   | [% helpers.get_queued_bib_attr('isbn',vii.record.attributes) %]\n Attribute Definition   | [% vii.definition %]\n Import Error           | [% vii.import_error %]\n Import Error Detail    | [% vii.error_detail %]\n Owning Library         | [% vii.owning_lib %]\n Circulating Library    | [% vii.circ_lib %]\n Call Number            | [% vii.call_number %]\n Copy Number            | [% vii.copy_number %]\n Status                 | [% vii.status.name %]\n Shelving Location      | [% vii.location.name %]\n Circulate              | [% vii.circulate %]\n Deposit                | [% vii.deposit %]\n Deposit Amount         | [% vii.deposit_amount %]\n Reference              | [% vii.ref %]\n Holdable               | [% vii.holdable %]\n Price                  | [% vii.price %]\n Barcode                | [% vii.barcode %]\n Circulation Modifier   | [% vii.circ_modifier %]\n Circulate As MARC Type | [% vii.circ_as_type %]\n Alert Message          | [% vii.alert_message %]\n Public Note            | [% vii.pub_note %]\n Private Note           | [% vii.priv_note %]\n OPAC Visible           | [% vii.opac_visible %]\n\n    [% END %]\n</pre>\n	print-on-demand
46	t	1	CSV Output for Import Items from Queued Bib Records	vandelay.import_items.csv	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	record.queue.owner	\n[%- USE date -%]\n"Import Item ID","Title of work","ISBN","Attribute Definition","Import Error","Import Error Detail","Owning Library","Circulating Library","Call Number","Copy Number","Status","Shelving Location","Circulate","Deposit","Deposit Amount","Reference","Holdable","Price","Barcode","Circulation Modifier","Circulate As MARC Type","Alert Message","Public Note","Private Note","OPAC Visible"\n[% FOR vii IN target %]"[% vii.id | replace('"', '""') %]","[% helpers.get_queued_bib_attr('title',vii.record.attributes) | replace('"', '""') %]","[% helpers.get_queued_bib_attr('isbn',vii.record.attributes) | replace('"', '""') %]","[% vii.definition | replace('"', '""') %]","[% vii.import_error | replace('"', '""') %]","[% vii.error_detail | replace('"', '""') %]","[% vii.owning_lib | replace('"', '""') %]","[% vii.circ_lib | replace('"', '""') %]","[% vii.call_number | replace('"', '""') %]","[% vii.copy_number | replace('"', '""') %]","[% vii.status.name | replace('"', '""') %]","[% vii.location.name | replace('"', '""') %]","[% vii.circulate | replace('"', '""') %]","[% vii.deposit | replace('"', '""') %]","[% vii.deposit_amount | replace('"', '""') %]","[% vii.ref | replace('"', '""') %]","[% vii.holdable | replace('"', '""') %]","[% vii.price | replace('"', '""') %]","[% vii.barcode | replace('"', '""') %]","[% vii.circ_modifier | replace('"', '""') %]","[% vii.circ_as_type | replace('"', '""') %]","[% vii.alert_message | replace('"', '""') %]","[% vii.pub_note | replace('"', '""') %]","[% vii.priv_note | replace('"', '""') %]","[% vii.opac_visible | replace('"', '""') %]"\n[% END %]\n	print-on-demand
47	t	1	Email Output for Import Items from Queued Bib Records	vandelay.import_items.email	NOOP_True	SendEmail	\N	\N	00:05:00	\N	\N	\N	\N	record.queue.owner	\n[%- USE date -%]\n[%- SET user = target.0.record.queue.owner -%]\nTo: [%- params.recipient_email || user.email || 'root@localhost' %]\nFrom: [%- params.sender_email || default_sender %]\nSubject: Import Items from Import Queue\n\nQueue ID: [% target.0.record.queue.id %]\nQueue Name: [% target.0.record.queue.name %]\nQueue Type: [% target.0.record.queue.queue_type %]\nComplete? [% target.0.record.queue.complete %]\n\n    [% FOR vii IN target %]\n=-=-=\n Import Item ID         | [% vii.id %]\n Title of work          | [% helpers.get_queued_bib_attr('title',vii.record.attributes) %]\n ISBN                   | [% helpers.get_queued_bib_attr('isbn',vii.record.attributes) %]\n Attribute Definition   | [% vii.definition %]\n Import Error           | [% vii.import_error %]\n Import Error Detail    | [% vii.error_detail %]\n Owning Library         | [% vii.owning_lib %]\n Circulating Library    | [% vii.circ_lib %]\n Call Number            | [% vii.call_number %]\n Copy Number            | [% vii.copy_number %]\n Status                 | [% vii.status.name %]\n Shelving Location      | [% vii.location.name %]\n Circulate              | [% vii.circulate %]\n Deposit                | [% vii.deposit %]\n Deposit Amount         | [% vii.deposit_amount %]\n Reference              | [% vii.ref %]\n Holdable               | [% vii.holdable %]\n Price                  | [% vii.price %]\n Barcode                | [% vii.barcode %]\n Circulation Modifier   | [% vii.circ_modifier %]\n Circulate As MARC Type | [% vii.circ_as_type %]\n Alert Message          | [% vii.alert_message %]\n Public Note            | [% vii.pub_note %]\n Private Note           | [% vii.priv_note %]\n OPAC Visible           | [% vii.opac_visible %]\n\n    [% END %]\n	\N
48	t	1	Bookbag CSV	container.biblio_record_entry_bucket.csv	NOOP_True	ContainerCSV	\N	\N	00:05:00	\N	\N	\N	\N	\N	\n[%-\n# target is the bookbag itself. The 'items' variable does not need to be in\n# the environment because a special reactor will take care of filling it in.\n\nFOR item IN items;\n    bibxml = helpers.unapi_bre(item.target_biblio_record_entry, {flesh => '{mra}'});\n    title = "";\n    FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a" or @code="b"]');\n        title = title _ part.textContent;\n    END;\n    author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n    item_type = bibxml.findnodes('//*[local-name()="attributes"]/*[local-name()="field"][@name="item_type"]').getAttribute('coded-value');\n    pub_date = "";\n    FOR pdatum IN bibxml.findnodes('//*[@tag="260"]/*[@code="c"]');\n        IF pub_date ;\n            pub_date = pub_date _ ", " _ pdatum.textContent;\n        ELSE ;\n            pub_date = pdatum.textContent;\n        END;\n    END;\n    helpers.csv_datum(title) %],[% helpers.csv_datum(author) %],[% helpers.csv_datum(pub_date) %],[% helpers.csv_datum(item_type) %],[% FOR note IN item.notes; helpers.csv_datum(note.note); ","; END; "\\n";\nEND -%]\n	\N
101	t	1	Hold Ready for Pickup SMS Notification	hold.available	HoldIsAvailable	SendSMS	CreateHoldNotification	\N	00:30:00	\N	\N	\N	shelf_time	sms_notify	[%- USE date -%]\n[%- user = target.0.usr -%]\nFrom: [%- params.sender_email || default_sender %]\nTo: [%- params.recipient_email || helpers.get_sms_gateway_email(target.0.sms_carrier,target.0.sms_notify) %]\nSubject: [% target.size %] hold(s) ready\n\n[% FOR hold IN target %][%-\n  bibxml = helpers.xml_doc( hold.current_copy.call_number.record.marc );\n  title = "";\n  FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a"]');\n    title = title _ part.textContent;\n  END;\n  author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n%][% hold.usr.first_given_name %]:[% title %] @ [% hold.pickup_lib.name %]\n[% END %]\n	\N
102	t	1	SMS Call Number	acn.format.sms_text	NOOP_True	SendSMS	\N	\N	00:05:00	\N	\N	\N	\N	\N	[%- USE date -%]\nFrom: [%- params.sender_email || default_sender %]\nTo: [%- params.recipient_email || helpers.get_sms_gateway_email(user_data.sms_carrier,user_data.sms_notify) %]\nSubject: Call Number\n\n[%-\n  bibxml = helpers.xml_doc( target.record.marc );\n  title = "";\n  FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a" or @code="b"]');\n    title = title _ part.textContent;\n  END;\n  author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n%]\nCall Number: [% target.label %]\nLocation: [% helpers.get_most_populous_location( target.id ).name %]\nLibrary: [% target.owning_lib.name %]\n[%- IF title %]\nTitle: [% title %]\n[%- END %]\n[%- IF author %]\nAuthor: [% author %]\n[%- END %]\n	\N
103	t	1	Circ History CSV	circ.format.history.csv	NOOP_True	ProcessTemplate	\N	\N	00:05:00	\N	\N	\N	\N	usr	\nTitle,Author,Call Number,Barcode,Format\n[%-\nFOR circ IN target;\n    bibxml = helpers.unapi_bre(circ.target_copy.call_number.record, {flesh => '{mra}'});\n    title = "";\n    FOR part IN bibxml.findnodes('//*[@tag="245"]/*[@code="a" or @code="b"]');\n        title = title _ part.textContent;\n    END;\n    author = bibxml.findnodes('//*[@tag="100"]/*[@code="a"]').textContent;\n    item_type = bibxml.findnodes('//*[local-name()="attributes"]/*[local-name()="field"][@name="item_type"]').getAttribute('coded-value') %]\n\n    [%- helpers.csv_datum(title) -%],\n    [%- helpers.csv_datum(author) -%],\n    [%- helpers.csv_datum(circ.target_copy.call_number.label) -%],\n    [%- helpers.csv_datum(circ.target_copy.barcode) -%],\n    [%- helpers.csv_datum(item_type) %]\n[%- END -%]\n	\N
\.


--
-- Name: event_definition_id_seq; Type: SEQUENCE SET; Schema: action_trigger; Owner: postgres
--

SELECT pg_catalog.setval('event_definition_id_seq', 103, true);


--
-- Name: event_id_seq; Type: SEQUENCE SET; Schema: action_trigger; Owner: postgres
--

SELECT pg_catalog.setval('event_id_seq', 1, false);


--
-- Data for Name: event_output; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY event_output (id, create_time, is_error, data) FROM stdin;
\.


--
-- Name: event_output_id_seq; Type: SEQUENCE SET; Schema: action_trigger; Owner: postgres
--

SELECT pg_catalog.setval('event_output_id_seq', 1, false);


--
-- Data for Name: event_params; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY event_params (id, event_def, param, value) FROM stdin;
1	2	editor	'1'
2	5	check_email_notify	1
3	7	check_email_notify	1
4	9	check_email_notify	1
5	38	check_email_notify	1
6	101	check_sms_notify	1
\.


--
-- Name: event_params_id_seq; Type: SEQUENCE SET; Schema: action_trigger; Owner: postgres
--

SELECT pg_catalog.setval('event_params_id_seq', 6, true);


--
-- Data for Name: hook; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY hook (key, core_type, description, passive) FROM stdin;
checkout	circ	Item checked out to user	f
checkin	circ	Item checked in	f
lost	circ	Circulating Item marked Lost	f
lost.found	circ	Lost Circulating Item checked in	f
lost.auto	circ	Circulating Item automatically marked lost	f
claims_returned	circ	Circulating Item marked Claims Returned	f
claims_returned.found	circ	Claims Returned Circulating Item is checked in	f
missing	acp	Item marked Missing	f
missing.found	acp	Missing Item checked in	f
transit.start	acp	An Item is placed into transit	f
transit.finish	acp	An Item is received from a transit	f
hold_request.success	ahr	A hold is successfully placed	f
hold_request.failure	ahr	A hold is attempted but not successfully placed	f
hold.capture	ahr	A targeted Item is captured for a hold	f
hold.available	ahr	A held item is ready for pickup	f
hold_transit.start	ahtc	A hold-captured Item is placed into transit	f
hold_transit.finish	ahtc	A hold-captured Item is received from a transit	f
checkout.due	circ	Checked out Item is Due	t
penalty.PATRON_EXCEEDS_FINES	ausp	Patron has exceeded allowed fines	t
penalty.PATRON_EXCEEDS_OVERDUE_COUNT	ausp	Patron has exceeded allowed overdue count	t
penalty.PATRON_EXCEEDS_CHECKOUT_COUNT	ausp	Patron has exceeded allowed checkout count	t
penalty.PATRON_EXCEEDS_COLLECTIONS_WARNING	ausp	Patron has exceeded maximum fine amount for collections department warning	t
acqpo.activated	acqpo	Purchase order was activated	f
format.po.html	acqpo	Formats a Purchase Order as an HTML document	t
format.po.pdf	acqpo	Formats a Purchase Order as a PDF document	t
damaged	acp	Item marked damaged	f
checkout.damaged	circ	A circulating item is marked damaged and the patron is fined	f
renewal	circ	Item renewed to user	f
hold_request.shelf_expires_soon	ahr	A hold on the shelf will expire there soon.	t
hold_request.long_wait	ahr	A patron has been waiting on a hold to be fulfilled for a long time.	t
aur.ordered	aur	A patron acquisition request has been marked On-Order.	t
aur.received	aur	A patron acquisition request has been marked Received.	t
aur.cancelled	aur	A patron acquisition request has been marked Cancelled.	t
aur.created	aur	A patron has made an acquisitions request.	t
aur.rejected	aur	A patron acquisition request has been rejected.	t
password.reset_request	aupr	Patron has requested a self-serve password reset	f
format.acqcle.html	acqcle	Formats claim events into a voucher	t
format.acqinv.html	acqinv	Formats invoices into a voucher	t
hold_request.cancel.expire_no_target	ahr	A hold is cancelled because no copies were found	f
hold_request.cancel.expire_holds_shelf	ahr	A hold is cancelled because it was on the holds shelf too long	f
hold_request.cancel.staff	ahr	A hold is cancelled because it was cancelled by staff	f
hold_request.cancel.patron	ahr	A hold is cancelled by the patron	f
format.selfcheck.checkout	circ	Formats circ objects for self-checkout receipt	t
format.selfcheck.items_out	circ	Formats items out for self-checkout receipt	t
format.selfcheck.holds	ahr	Formats holds for self-checkout receipt	t
format.selfcheck.fines	au	Formats fines for self-checkout receipt	t
format.acqli.html	jub	Formats lineitem worksheet for titles received	t
circ.format.history.email	circ	An email has been requested for a circ history.	f
circ.format.history.print	circ	A circ history needs to be formatted for printing.	f
ahr.format.history.email	ahr	An email has been requested for a hold request history.	f
ahr.format.history.print	ahr	A hold request history needs to be formatted for printing.	f
money.format.payment_receipt.email	mp	An email has been requested for a payment receipt.	f
money.format.payment_receipt.print	mp	A payment receipt needs to be formatted for printing.	f
biblio.format.record_entry.email	cbreb	An email has been requested for one or more biblio record entries.	f
biblio.format.record_entry.print	cbreb	One or more biblio record entries need to be formatted for printing.	f
circ.format.missing_pieces.slip.print	circ	A missing pieces slip needs to be formatted for printing.	f
circ.format.missing_pieces.letter.print	circ	A missing pieces patron letter needs to be formatted for printing.	f
ahr.format.pull_list	ahr	Format holds pull list for printing	f
circ.staff_age_to_lost	circ	An overdue circulation should be aged to a Lost status.	t
circ.recall.target	circ	A checked-out copy has been recalled for a hold.	f
vandelay.queued_bib_record.print	vqbr	Print output has been requested for records in an Importer Bib Queue.	f
vandelay.queued_bib_record.csv	vqbr	CSV output has been requested for records in an Importer Bib Queue.	f
vandelay.queued_bib_record.email	vqbr	An email has been requested for records in an Importer Bib Queue.	f
vandelay.queued_auth_record.print	vqar	Print output has been requested for records in an Importer Authority Queue.	f
vandelay.queued_auth_record.csv	vqar	CSV output has been requested for records in an Importer Authority Queue.	f
vandelay.queued_auth_record.email	vqar	An email has been requested for records in an Importer Authority Queue.	f
vandelay.import_items.print	vii	Print output has been requested for Import Items from records in an Importer Bib Queue.	f
vandelay.import_items.csv	vii	CSV output has been requested for Import Items from records in an Importer Bib Queue.	f
vandelay.import_items.email	vii	An email has been requested for Import Items from records in an Importer Bib Queue.	f
container.biblio_record_entry_bucket.csv	cbreb	Produce a CSV file representing a bookbag	f
reservation.available	bresv	A reservation is available for pickup	f
acn.format.sms_text	acn	A text message has been requested for a call number.	f
circ.format.history.csv	circ	Produce CSV of circulation history	f
au.barred	au	A user was barred by staff	f
au.unbarred	au	A user was un-barred by staff	f
\.


--
-- Data for Name: reactor; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY reactor (module, description) FROM stdin;
fourty_two	Returns the answer to life, the universe and everything
NOOP_True	Always returns true -- reaction always passes
NOOP_False	Always returns false -- reaction always fails
SendEmail	Send an email based on a user-defined template
MarkItemLost	Marks a circulation and associated item as lost
ApplyCircFee	Applies a billing with a pre-defined amount to a circulation
ProcessTemplate	Processes the configured template
ApplyPatronPenalty	Applies the configured penalty to a patron.  Required named environment variables are "user", which refers to the user object, and "context_org", which refers to the org_unit object that acts as the focus for the penalty.
SendFile	Build and transfer a file to a remote server.  Required parameter "remote_host" specifying target server.  Optional parameters: remote_user, remote_password, remote_account, port, type (FTP, SFTP or SCP), and debug.
GeneratePurchaseOrderJEDI	Creates purchase order JEDI (JSON EDI) for subsequent EDI processing
AstCall	Possibly place a phone call with Asterisk
ContainerCSV	Facilitates produce a CSV file representing a bookbag by introducing an "items" variable into the TT environment, sorted as dictated according to user params
SendSMS	Send an SMS text message based on a user-defined template
\.


--
-- Data for Name: validator; Type: TABLE DATA; Schema: action_trigger; Owner: postgres
--

COPY validator (module, description) FROM stdin;
fourty_two	Returns the answer to life, the universe and everything
NOOP_True	Always returns true -- validation always passes
NOOP_False	Always returns false -- validation always fails
CircIsOpen	Check that the circulation is still open
HoldIsAvailable	Check that an item is on the hold shelf
CircIsOverdue	Check that the circulation is overdue
MaxPassiveDelayAge	Check that the event is not too far past the delay_field time -- requires a max_delay_age interval parameter
MinPassiveTargetAge	Check that the target is old enough to be used by this event -- requires a min_target_age interval parameter, and accepts an optional target_age_field to specify what time to use for offsetting
HoldNotifyCheck	Check Hold notification flag(s)
Acq::UserRequestOrdered	Tests to see if the corresponding Line Item has a state of "on-order".
Acq::UserRequestReceived	Tests to see if the corresponding Line Item has a state of "received".
Acq::UserRequestCancelled	Tests to see if the corresponding Line Item has a state of "cancelled".
Acq::PurchaseOrderEDIRequired	Purchase order is delivered via EDI
HoldIsCancelled	Check whether a hold request is cancelled.
ReservationIsAvailable	Checked that a reserved resource is available for checkout
PatronBarred	Tests if a patron is currently marked as barred
PatronNotBarred	Tests if a patron is currently not marked as barred
\.


SET search_path = actor, pg_catalog;

--
-- Data for Name: address_alert; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY address_alert (id, owner, active, match_all, alert_message, street1, street2, city, county, state, country, post_code, mailing_address, billing_address) FROM stdin;
\.


--
-- Name: address_alert_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('address_alert_id_seq', 1, false);


--
-- Data for Name: card; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY card (id, usr, barcode, active) FROM stdin;
1	1	d6ce4e34b6a42cfd4edc1eb5576ca625	t
\.


--
-- Name: card_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('card_id_seq', 1, true);


--
-- Data for Name: hours_of_operation; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY hours_of_operation (id, dow_0_open, dow_0_close, dow_1_open, dow_1_close, dow_2_open, dow_2_close, dow_3_open, dow_3_close, dow_4_open, dow_4_close, dow_5_open, dow_5_close, dow_6_open, dow_6_close) FROM stdin;
\.


--
-- Data for Name: org_address; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_address (id, valid, address_type, org_unit, street1, street2, city, county, state, country, post_code, san) FROM stdin;
1	t	MAILING	1	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
2	t	MAILING	2	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
3	t	MAILING	3	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
4	t	MAILING	4	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
5	t	MAILING	5	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
6	t	MAILING	6	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
7	t	MAILING	7	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
8	t	MAILING	8	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
9	t	MAILING	9	123 Main St.	\N	Anywhere	\N	GA	US	30303	\N
\.


--
-- Name: org_address_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_address_id_seq', 9, true);


--
-- Data for Name: org_lasso; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_lasso (id, name) FROM stdin;
\.


--
-- Name: org_lasso_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_lasso_id_seq', 1, false);


--
-- Data for Name: org_lasso_map; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_lasso_map (id, lasso, org_unit) FROM stdin;
\.


--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_lasso_map_id_seq', 1, false);


--
-- Data for Name: org_unit; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit (id, parent_ou, ou_type, ill_address, holds_address, mailing_address, billing_address, shortname, name, email, phone, opac_visible, fiscal_calendar) FROM stdin;
1	\N	1	1	1	1	1	CONS	Example Consortium	\N	\N	t	1
2	1	2	2	2	2	2	SYS1	Example System 1	\N	\N	t	1
3	1	2	3	3	3	3	SYS2	Example System 2	\N	\N	t	1
4	2	3	4	4	4	4	BR1	Example Branch 1	\N	\N	t	1
5	2	3	5	5	5	5	BR2	Example Branch 2	\N	\N	t	1
6	3	3	6	6	6	6	BR3	Example Branch 3	\N	\N	t	1
7	3	3	7	7	7	7	BR4	Example Branch 4	\N	\N	t	1
8	4	4	8	8	8	8	SL1	Example Sub-library 1	\N	\N	t	1
9	6	5	9	9	9	9	BM1	Example Bookmobile 1	\N	\N	t	1
\.


--
-- Data for Name: org_unit_closed; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_closed (id, org_unit, close_start, close_end, reason) FROM stdin;
\.


--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_closed_id_seq', 1, false);


--
-- Data for Name: org_unit_custom_tree; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_custom_tree (id, active, purpose) FROM stdin;
\.


--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_custom_tree_id_seq', 1, false);


--
-- Data for Name: org_unit_custom_tree_node; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_custom_tree_node (id, tree, org_unit, parent_node, sibling_order) FROM stdin;
\.


--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_custom_tree_node_id_seq', 1, false);


--
-- Name: org_unit_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_id_seq', 100, true);


--
-- Data for Name: org_unit_proximity; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_proximity (id, from_org, to_org, prox) FROM stdin;
1	1	1	0
2	1	2	1
3	2	1	1
4	2	2	0
5	1	3	1
6	2	3	2
7	3	1	1
8	3	2	2
9	3	3	0
10	1	4	2
11	2	4	1
12	3	4	3
13	4	1	2
14	4	2	1
15	4	3	3
16	4	4	0
17	1	5	2
18	2	5	1
19	3	5	3
20	4	5	2
21	5	1	2
22	5	2	1
23	5	3	3
24	5	4	2
25	5	5	0
26	1	6	2
27	2	6	3
28	3	6	1
29	4	6	4
30	5	6	4
31	6	1	2
32	6	2	3
33	6	3	1
34	6	4	4
35	6	5	4
36	6	6	0
37	1	7	2
38	2	7	3
39	3	7	1
40	4	7	4
41	5	7	4
42	6	7	2
43	7	1	2
44	7	2	3
45	7	3	1
46	7	4	4
47	7	5	4
48	7	6	2
49	7	7	0
50	1	8	3
51	2	8	2
52	3	8	4
53	4	8	1
54	5	8	3
55	6	8	5
56	7	8	5
57	8	1	3
58	8	2	2
59	8	3	4
60	8	4	1
61	8	5	3
62	8	6	5
63	8	7	5
64	8	8	0
65	1	9	3
66	2	9	4
67	3	9	2
68	4	9	5
69	5	9	5
70	6	9	1
71	7	9	3
72	8	9	6
73	9	1	3
74	9	2	4
75	9	3	2
76	9	4	5
77	9	5	5
78	9	6	1
79	9	7	3
80	9	8	6
81	9	9	0
\.


--
-- Data for Name: org_unit_proximity_adjustment; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_proximity_adjustment (id, item_circ_lib, item_owning_lib, copy_location, hold_pickup_lib, hold_request_lib, pos, absolute_adjustment, prox_adjustment, circ_mod) FROM stdin;
\.


--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_proximity_adjustment_id_seq', 1, false);


--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_proximity_id_seq', 81, true);


--
-- Data for Name: org_unit_setting; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_setting (id, org_unit, name, value) FROM stdin;
1	1	circ.booking_reservation.default_elbow_room	"1 day"
2	1	cat.spine.line.margin	0
3	1	cat.spine.line.height	9
4	1	cat.spine.line.width	8
5	1	cat.label.font.family	"monospace"
6	1	cat.label.font.size	10
7	1	cat.label.font.weight	"normal"
8	1	circ.grace.extend	true
9	1	circ.hold_go_home_interval	"6 months"
\.


--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_setting_id_seq', 9, true);


--
-- Data for Name: org_unit_type; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY org_unit_type (id, name, opac_label, depth, parent, can_have_vols, can_have_users) FROM stdin;
1	Consortium	Everywhere	0	\N	f	f
2	System	Local Library System	1	1	f	f
3	Branch	This Branch	2	2	t	t
4	Sub-library	This Specialized Library	3	3	t	t
5	Bookmobile	Your Bookmobile	3	3	t	t
\.


--
-- Name: org_unit_type_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_type_id_seq', 100, true);


--
-- Data for Name: search_filter_group; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY search_filter_group (id, owner, code, label, create_date) FROM stdin;
1	1	kpac_main	Kid's OPAC Search Filter	2015-06-22 09:56:07.383338-07
\.


--
-- Data for Name: search_filter_group_entry; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY search_filter_group_entry (id, grp, pos, query) FROM stdin;
1	1	0	1
2	1	1	2
3	1	2	3
\.


--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('search_filter_group_entry_id_seq', 3, true);


--
-- Name: search_filter_group_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('search_filter_group_id_seq', 1, true);


--
-- Data for Name: search_query; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY search_query (id, label, query_text) FROM stdin;
1	Children's Materials	audience(a,b,c)
2	Young Adult Materials	audience(j,d)
3	General/Adult Materials	audience(e,f,g, )
\.


--
-- Name: search_query_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('search_query_id_seq', 3, true);


--
-- Data for Name: stat_cat; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY stat_cat (id, owner, name, opac_visible, usr_summary, sip_field, sip_format, checkout_archive, required, allow_freetext) FROM stdin;
\.


--
-- Data for Name: stat_cat_entry; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY stat_cat_entry (id, stat_cat, owner, value) FROM stdin;
\.


--
-- Data for Name: stat_cat_entry_default; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY stat_cat_entry_default (id, stat_cat_entry, stat_cat, owner) FROM stdin;
\.


--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_default_id_seq', 1, false);


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_id_seq', 1, false);


--
-- Data for Name: stat_cat_entry_usr_map; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY stat_cat_entry_usr_map (id, stat_cat_entry, stat_cat, target_usr) FROM stdin;
\.


--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_usr_map_id_seq', 1, false);


--
-- Name: stat_cat_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_id_seq', 1, false);


--
-- Data for Name: stat_cat_sip_fields; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY stat_cat_sip_fields (field, name, one_only) FROM stdin;
\.


--
-- Data for Name: toolbar; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY toolbar (id, ws, org, usr, label, layout) FROM stdin;
1	\N	1	\N	circ	["circ_checkout","circ_checkin","toolbarseparator.1","search_opac","copy_status","toolbarseparator.2","patron_search","patron_register","toolbarspacer.3","hotkeys_toggle"]
2	\N	1	\N	cat	["circ_checkin","toolbarseparator.1","search_opac","copy_status","toolbarseparator.2","create_marc","authority_manage","retrieve_last_record","toolbarspacer.3","hotkeys_toggle"]
\.


--
-- Name: toolbar_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('toolbar_id_seq', 2, true);


--
-- Data for Name: usr; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr (id, card, profile, usrname, email, passwd, standing, ident_type, ident_value, ident_type2, ident_value2, net_access_level, photo_url, prefix, first_given_name, second_given_name, family_name, suffix, alias, day_phone, evening_phone, other_phone, mailing_address, billing_address, home_ou, dob, active, master_account, super_user, barred, deleted, juvenile, usrgroup, claims_returned_count, credit_forward_balance, last_xact_id, alert_message, create_date, expire_date, claims_never_checked_out_count, last_update_time) FROM stdin;
1	1	1	4098fe3a6049bf7a8059703a55a4974e	\N	e904a3748bb50e75b7fadac29661396c	1	1	identification	\N	\N	1	\N	\N	Administrator	\N	System Account	\N	\N	\N	\N	\N	\N	\N	1	1979-01-22 00:00:00-08	t	t	t	f	f	f	1	0	0.00	none	\N	2015-06-22 09:56:07.117525-07	2018-06-22 09:56:07.117525-07	0	2015-06-22 09:56:07.132243-07
\.


--
-- Data for Name: usr_activity; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_activity (id, usr, etype, event_time) FROM stdin;
\.


--
-- Name: usr_activity_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_activity_id_seq', 1, false);


--
-- Data for Name: usr_address; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_address (id, valid, within_city_limits, address_type, usr, street1, street2, city, county, state, country, post_code, pending, replaces) FROM stdin;
\.


--
-- Name: usr_address_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_address_id_seq', 1, false);


--
-- Name: usr_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_id_seq', 1, true);


--
-- Data for Name: usr_note; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_note (id, usr, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: usr_note_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_note_id_seq', 1, false);


--
-- Data for Name: usr_org_unit_opt_in; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_org_unit_opt_in (id, org_unit, usr, staff, opt_in_ts, opt_in_ws) FROM stdin;
\.


--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_org_unit_opt_in_id_seq', 1, false);


--
-- Data for Name: usr_password_reset; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_password_reset (id, uuid, usr, request_time, has_been_reset) FROM stdin;
\.


--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_password_reset_id_seq', 1, false);


--
-- Data for Name: usr_saved_search; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_saved_search (id, owner, name, create_date, query_text, query_type, target) FROM stdin;
\.


--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_saved_search_id_seq', 1, false);


--
-- Data for Name: usr_setting; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_setting (id, usr, name, value) FROM stdin;
\.


--
-- Name: usr_setting_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_setting_id_seq', 1, false);


--
-- Data for Name: usr_standing_penalty; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY usr_standing_penalty (id, org_unit, usr, standing_penalty, staff, set_date, stop_date, note) FROM stdin;
\.


--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_standing_penalty_id_seq', 1, false);


--
-- Name: usr_usrgroup_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('usr_usrgroup_seq', 1, true);


--
-- Data for Name: workstation; Type: TABLE DATA; Schema: actor; Owner: postgres
--

COPY workstation (id, name, owning_lib) FROM stdin;
\.


--
-- Name: workstation_id_seq; Type: SEQUENCE SET; Schema: actor; Owner: postgres
--

SELECT pg_catalog.setval('workstation_id_seq', 1, false);


SET search_path = asset, pg_catalog;

--
-- Data for Name: call_number; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY call_number (id, creator, create_date, editor, edit_date, record, owning_lib, label, deleted, prefix, suffix, label_class, label_sortkey) FROM stdin;
-1	1	2015-06-22 09:56:07.202465-07	1	2015-06-22 09:56:07.202465-07	-1	1	UNCATALOGED	f	-1	-1	1	UNCATALOGED
\.


--
-- Data for Name: call_number_class; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY call_number_class (id, name, normalizer, field) FROM stdin;
1	Generic	asset.label_normalizer_generic	050ab,055ab,060ab,070ab,080ab,082ab,086ab,088ab,090,092,096,098,099
2	Dewey (DDC)	asset.label_normalizer_dewey	080ab,082ab,092abef
3	Library of Congress (LC)	asset.label_normalizer_lc	050ab,055ab,090abef
\.


--
-- Name: call_number_class_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('call_number_class_id_seq', 3, true);


--
-- Name: call_number_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('call_number_id_seq', 1, false);


--
-- Data for Name: call_number_note; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY call_number_note (id, call_number, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: call_number_note_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('call_number_note_id_seq', 1, false);


--
-- Data for Name: call_number_prefix; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY call_number_prefix (id, owning_lib, label, label_sortkey) FROM stdin;
-1	1		
\.


--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('call_number_prefix_id_seq', 1, false);


--
-- Data for Name: call_number_suffix; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY call_number_suffix (id, owning_lib, label, label_sortkey) FROM stdin;
-1	1		
\.


--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('call_number_suffix_id_seq', 1, false);


--
-- Data for Name: copy; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy (id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost) FROM stdin;
\.


--
-- Name: copy_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_id_seq', 1, false);


--
-- Data for Name: copy_location; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_location (id, name, owning_lib, holdable, hold_verify, opac_visible, circulate, label_prefix, label_suffix, checkin_alert) FROM stdin;
1	Stacks	1	t	f	t	t	\N	\N	f
\.


--
-- Data for Name: copy_location_group; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_location_group (id, name, owner, pos, top, opac_visible) FROM stdin;
\.


--
-- Name: copy_location_group_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_location_group_id_seq', 1, false);


--
-- Data for Name: copy_location_group_map; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_location_group_map (id, location, lgroup) FROM stdin;
\.


--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_location_group_map_id_seq', 1, false);


--
-- Name: copy_location_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_location_id_seq', 100, true);


--
-- Data for Name: copy_location_order; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_location_order (id, location, org, "position") FROM stdin;
\.


--
-- Name: copy_location_order_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_location_order_id_seq', 1, false);


--
-- Data for Name: copy_note; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_note (id, owning_copy, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: copy_note_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_note_id_seq', 1, false);


--
-- Data for Name: copy_part_map; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_part_map (id, target_copy, part) FROM stdin;
\.


--
-- Name: copy_part_map_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_part_map_id_seq', 1, false);


--
-- Data for Name: copy_template; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY copy_template (id, owning_lib, creator, editor, create_date, edit_date, name, circ_lib, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, circ_modifier, circ_as_type, alert_message, opac_visible, floating, mint_condition) FROM stdin;
\.


--
-- Name: copy_template_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('copy_template_id_seq', 1, false);


--
-- Data for Name: opac_visible_copies; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY opac_visible_copies (id, copy_id, record, circ_lib) FROM stdin;
\.


--
-- Name: opac_visible_copies_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('opac_visible_copies_id_seq', 1, false);


--
-- Data for Name: stat_cat; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY stat_cat (id, owner, opac_visible, name, required, sip_field, sip_format, checkout_archive) FROM stdin;
\.


--
-- Data for Name: stat_cat_entry; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY stat_cat_entry (id, stat_cat, owner, value) FROM stdin;
\.


--
-- Data for Name: stat_cat_entry_copy_map; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY stat_cat_entry_copy_map (id, stat_cat, stat_cat_entry, owning_copy) FROM stdin;
\.


--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_copy_map_id_seq', 1, false);


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_id_seq', 1, false);


--
-- Data for Name: stat_cat_entry_transparency_map; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY stat_cat_entry_transparency_map (id, stat_cat, stat_cat_entry, owning_transparency) FROM stdin;
\.


--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_entry_transparency_map_id_seq', 1, false);


--
-- Name: stat_cat_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('stat_cat_id_seq', 1, false);


--
-- Data for Name: stat_cat_sip_fields; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY stat_cat_sip_fields (field, name, one_only) FROM stdin;
\.


--
-- Data for Name: uri; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY uri (id, href, label, use_restriction, active) FROM stdin;
\.


--
-- Data for Name: uri_call_number_map; Type: TABLE DATA; Schema: asset; Owner: postgres
--

COPY uri_call_number_map (id, uri, call_number) FROM stdin;
\.


--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('uri_call_number_map_id_seq', 1, false);


--
-- Name: uri_id_seq; Type: SEQUENCE SET; Schema: asset; Owner: postgres
--

SELECT pg_catalog.setval('uri_id_seq', 1, false);


SET search_path = auditor, pg_catalog;

--
-- Data for Name: acq_invoice_entry_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY acq_invoice_entry_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, lineitem, inv_item_count, phys_item_count, note, billed_per_item, cost_billed, actual_cost, amount_paid) FROM stdin;
\.


--
-- Name: acq_invoice_entry_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('acq_invoice_entry_pkey_seq', 1, false);


--
-- Data for Name: acq_invoice_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY acq_invoice_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, receiver, provider, shipper, recv_date, recv_method, inv_type, inv_ident, payment_auth, payment_method, note, complete) FROM stdin;
\.


--
-- Data for Name: acq_invoice_item_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY acq_invoice_item_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, fund_debit, inv_item_type, title, author, note, cost_billed, actual_cost, fund, amount_paid, po_item, target) FROM stdin;
\.


--
-- Name: acq_invoice_item_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('acq_invoice_item_pkey_seq', 1, false);


--
-- Name: acq_invoice_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('acq_invoice_pkey_seq', 1, false);


--
-- Data for Name: actor_org_unit_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY actor_org_unit_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, parent_ou, ou_type, ill_address, holds_address, mailing_address, billing_address, shortname, name, email, phone, opac_visible, fiscal_calendar) FROM stdin;
1	2015-06-22 09:56:07.073253-07	U	\N	\N	1	\N	1	\N	\N	\N	\N	CONS	Example Consortium	\N	\N	t	1
2	2015-06-22 09:56:07.073253-07	U	\N	\N	2	1	2	\N	\N	\N	\N	SYS1	Example System 1	\N	\N	t	1
3	2015-06-22 09:56:07.073253-07	U	\N	\N	3	1	2	\N	\N	\N	\N	SYS2	Example System 2	\N	\N	t	1
4	2015-06-22 09:56:07.073253-07	U	\N	\N	4	2	3	\N	\N	\N	\N	BR1	Example Branch 1	\N	\N	t	1
5	2015-06-22 09:56:07.073253-07	U	\N	\N	5	2	3	\N	\N	\N	\N	BR2	Example Branch 2	\N	\N	t	1
6	2015-06-22 09:56:07.073253-07	U	\N	\N	6	3	3	\N	\N	\N	\N	BR3	Example Branch 3	\N	\N	t	1
7	2015-06-22 09:56:07.073253-07	U	\N	\N	7	3	3	\N	\N	\N	\N	BR4	Example Branch 4	\N	\N	t	1
8	2015-06-22 09:56:07.073253-07	U	\N	\N	8	4	4	\N	\N	\N	\N	SL1	Example Sub-library 1	\N	\N	t	1
9	2015-06-22 09:56:07.073253-07	U	\N	\N	9	6	5	\N	\N	\N	\N	BM1	Example Bookmobile 1	\N	\N	t	1
\.


--
-- Name: actor_org_unit_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('actor_org_unit_pkey_seq', 9, true);


--
-- Data for Name: actor_usr_address_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY actor_usr_address_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, valid, within_city_limits, address_type, usr, street1, street2, city, county, state, country, post_code, pending, replaces) FROM stdin;
\.


--
-- Name: actor_usr_address_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('actor_usr_address_pkey_seq', 1, false);


--
-- Data for Name: actor_usr_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY actor_usr_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, card, profile, usrname, email, passwd, standing, ident_type, ident_value, ident_type2, ident_value2, net_access_level, photo_url, prefix, first_given_name, second_given_name, family_name, suffix, alias, day_phone, evening_phone, other_phone, mailing_address, billing_address, home_ou, dob, active, master_account, super_user, barred, deleted, juvenile, usrgroup, claims_returned_count, credit_forward_balance, last_xact_id, alert_message, create_date, expire_date, claims_never_checked_out_count, last_update_time) FROM stdin;
1	2015-06-22 09:56:07.132243-07	U	\N	\N	1	1	1	4098fe3a6049bf7a8059703a55a4974e	\N	e904a3748bb50e75b7fadac29661396c	1	1	identification	\N	\N	1	\N	\N	Administrator	\N	System Account	\N	\N	\N	\N	\N	\N	\N	1	1979-01-22 00:00:00-08	t	t	t	f	f	f	1	0	0.00	none	\N	2015-06-22 09:56:07.117525-07	2018-06-22 09:56:07.117525-07	0	2015-06-22 09:56:07.117525-07
\.


--
-- Name: actor_usr_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('actor_usr_pkey_seq', 1, true);


--
-- Data for Name: asset_call_number_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY asset_call_number_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, create_date, editor, edit_date, record, owning_lib, label, deleted, prefix, suffix, label_class, label_sortkey) FROM stdin;
\.


--
-- Name: asset_call_number_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('asset_call_number_pkey_seq', 1, false);


--
-- Data for Name: asset_copy_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY asset_copy_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost) FROM stdin;
\.


--
-- Name: asset_copy_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('asset_copy_pkey_seq', 1, false);


--
-- Data for Name: biblio_record_entry_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY biblio_record_entry_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, editor, source, quality, create_date, edit_date, active, deleted, fingerprint, tcn_source, tcn_value, marc, last_xact_id, owner, share_depth) FROM stdin;
\.


--
-- Name: biblio_record_entry_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('biblio_record_entry_pkey_seq', 1, false);


--
-- Data for Name: serial_unit_history; Type: TABLE DATA; Schema: auditor; Owner: postgres
--

COPY serial_unit_history (audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost, sort_key, detailed_contents, summary_contents) FROM stdin;
\.


--
-- Name: serial_unit_pkey_seq; Type: SEQUENCE SET; Schema: auditor; Owner: postgres
--

SELECT pg_catalog.setval('serial_unit_pkey_seq', 1, false);


SET search_path = authority, pg_catalog;

--
-- Data for Name: bib_linking; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY bib_linking (id, bib, authority) FROM stdin;
\.


--
-- Name: bib_linking_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('bib_linking_id_seq', 1, false);


--
-- Data for Name: browse_axis; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY browse_axis (code, name, sorter, description) FROM stdin;
title	Title	titlesort	Title axis
author	Author	titlesort	Author axis
subject	Subject	titlesort	Subject axis
topic	Topic	titlesort	Topic Subject axis
\.


--
-- Data for Name: browse_axis_authority_field_map; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY browse_axis_authority_field_map (id, axis, field) FROM stdin;
1	author	1
2	author	2
3	author	3
4	title	4
5	topic	5
6	subject	5
7	subject	6
8	subject	7
9	subject	12
\.


--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('browse_axis_authority_field_map_id_seq', 9, true);


--
-- Data for Name: control_set; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY control_set (id, name, description) FROM stdin;
1	LoC	Library of Congress standard authority record control semantics
\.


--
-- Data for Name: control_set_authority_field; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY control_set_authority_field (id, main_entry, control_set, tag, nfi, sf_list, name, description) FROM stdin;
4	\N	1	130	2	adfgklmnoprstvxyz	Heading -- Uniform Title	\N
24	4	1	530	2	adfgiklmnoprstvwxyz4	See Also From Tracing -- Uniform Title	\N
44	4	1	730	2	adfghklmnoprstvwxyz25	Established Heading Linking Entry -- Uniform Title	\N
64	4	1	430	2	adfgiklmnoprstvwxyz4	See From Tracing -- Uniform Title	\N
1	\N	1	100	\N	abcdefklmnopqrstvxyz	Heading -- Personal Name	\N
2	\N	1	110	\N	abcdefgklmnoprstvxyz	Heading -- Corporate Name	\N
3	\N	1	111	\N	acdefgklnpqstvxyz	Heading -- Meeting Name	\N
5	\N	1	150	\N	abvxyz	Heading -- Topical Term	\N
6	\N	1	151	\N	avxyz	Heading -- Geographic Name	\N
7	\N	1	155	\N	avxyz	Heading -- Genre/Form Term	\N
8	\N	1	180	\N	vxyz	Heading -- General Subdivision	\N
9	\N	1	181	\N	vxyz	Heading -- Geographic Subdivision	\N
10	\N	1	182	\N	vxyz	Heading -- Chronological Subdivision	\N
11	\N	1	185	\N	vxyz	Heading -- Form Subdivision	\N
12	\N	1	148	\N	avxyz	Heading -- Chronological Term	\N
21	1	1	500	\N	abcdefiklmnopqrstvwxyz4	See Also From Tracing -- Personal Name	\N
22	2	1	510	\N	abcdefgiklmnoprstvwxyz4	See Also From Tracing -- Corporate Name	\N
23	3	1	511	\N	acdefgiklnpqstvwxyz4	See Also From Tracing -- Meeting Name	\N
25	5	1	550	\N	abivwxyz4	See Also From Tracing -- Topical Term	\N
26	6	1	551	\N	aivwxyz4	See Also From Tracing -- Geographic Name	\N
27	7	1	555	\N	aivwxyz4	See Also From Tracing -- Genre/Form Term	\N
28	8	1	580	\N	ivwxyz4	See Also From Tracing -- General Subdivision	\N
29	9	1	581	\N	ivwxyz4	See Also From Tracing -- Geographic Subdivision	\N
30	10	1	582	\N	ivwxyz4	See Also From Tracing -- Chronological Subdivision	\N
31	11	1	585	\N	ivwxyz4	See Also From Tracing -- Form Subdivision	\N
32	12	1	548	\N	aivwxyz4	See Also From Tracing -- Chronological Term	\N
41	1	1	700	\N	abcdefghjklmnopqrstvwxyz25	Established Heading Linking Entry -- Personal Name	\N
42	2	1	710	\N	abcdefghklmnoprstvwxyz25	Established Heading Linking Entry -- Corporate Name	\N
43	3	1	711	\N	acdefghklnpqstvwxyz25	Established Heading Linking Entry -- Meeting Name	\N
45	5	1	750	\N	abvwxyz25	Established Heading Linking Entry -- Topical Term	\N
46	6	1	751	\N	avwxyz25	Established Heading Linking Entry -- Geographic Name	\N
47	7	1	755	\N	avwxyz25	Established Heading Linking Entry -- Genre/Form Term	\N
48	8	1	780	\N	vwxyz25	Subdivision Linking Entry -- General Subdivision	\N
49	9	1	781	\N	vwxyz25	Subdivision Linking Entry -- Geographic Subdivision	\N
50	10	1	782	\N	vwxyz25	Subdivision Linking Entry -- Chronological Subdivision	\N
51	11	1	785	\N	vwxyz25	Subdivision Linking Entry -- Form Subdivision	\N
52	12	1	748	\N	avwxyz25	Established Heading Linking Entry -- Chronological Term	\N
61	1	1	400	\N	abcdefiklmnopqrstvwxyz4	See From Tracing -- Personal Name	\N
62	2	1	410	\N	abcdefgiklmnoprstvwxyz4	See From Tracing -- Corporate Name	\N
63	3	1	411	\N	acdefgiklnpqstvwxyz4	See From Tracing -- Meeting Name	\N
65	5	1	450	\N	abivwxyz4	See From Tracing -- Topical Term	\N
66	6	1	451	\N	aivwxyz4	See From Tracing -- Geographic Name	\N
67	7	1	455	\N	aivwxyz4	See From Tracing -- Genre/Form Term	\N
68	8	1	480	\N	ivwxyz4	See From Tracing -- General Subdivision	\N
69	9	1	481	\N	ivwxyz4	See From Tracing -- Geographic Subdivision	\N
70	10	1	482	\N	ivwxyz4	See From Tracing -- Chronological Subdivision	\N
71	11	1	485	\N	ivwxyz4	See From Tracing -- Form Subdivision	\N
72	12	1	448	\N	aivwxyz4	See From Tracing -- Chronological Term	\N
\.


--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('control_set_authority_field_id_seq', 1000, true);


--
-- Data for Name: control_set_bib_field; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY control_set_bib_field (id, authority_field, tag) FROM stdin;
1001	3	111
1002	5	650
1003	2	710
1004	9	600
1005	4	240
1006	1	600
1007	10	600
1008	4	130
1009	2	810
1010	2	110
1011	4	630
1012	11	651
1013	9	650
1014	8	651
1015	1	100
1016	12	648
1017	10	650
1018	8	655
1019	3	611
1020	11	655
1021	7	655
1022	1	700
1023	8	600
1024	1	800
1025	11	600
1026	6	651
1027	4	830
1028	4	730
1029	3	811
1030	10	651
1031	9	655
1032	3	711
1033	8	650
1034	9	651
1035	10	655
1036	2	610
1037	11	650
\.


--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('control_set_bib_field_id_seq', 1037, true);


--
-- Name: control_set_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('control_set_id_seq', 100, true);


--
-- Data for Name: full_rec; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY full_rec (id, record, tag, ind1, ind2, subfield, value, index_vector) FROM stdin;
\.


--
-- Name: full_rec_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('full_rec_id_seq', 1, false);


--
-- Data for Name: rec_descriptor; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY rec_descriptor (id, record, record_status, encoding_level, thesaurus) FROM stdin;
\.


--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('rec_descriptor_id_seq', 1, false);


--
-- Data for Name: record_entry; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY record_entry (id, create_date, edit_date, creator, editor, active, deleted, source, control_set, marc, last_xact_id, owner) FROM stdin;
\.


--
-- Name: record_entry_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('record_entry_id_seq', 1, false);


--
-- Data for Name: record_note; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY record_note (id, record, value, creator, editor, create_date, edit_date) FROM stdin;
\.


--
-- Name: record_note_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('record_note_id_seq', 1, false);


--
-- Data for Name: simple_heading; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY simple_heading (id, record, atag, value, sort_value, index_vector) FROM stdin;
\.


--
-- Name: simple_heading_id_seq; Type: SEQUENCE SET; Schema: authority; Owner: postgres
--

SELECT pg_catalog.setval('simple_heading_id_seq', 1, false);


--
-- Data for Name: thesaurus; Type: TABLE DATA; Schema: authority; Owner: postgres
--

COPY thesaurus (code, control_set, name, description) FROM stdin;
a	1	Library of Congress Subject Headings	\N
b	1	LC subject headings for children's literature	\N
c	1	Medical Subject Headings	\N
d	1	National Agricultural Library subject authority file	\N
k	1	Canadian Subject Headings	\N
n	1	Not applicable	\N
r	1	Art and Architecture Thesaurus	\N
s	1	Sears List of Subject Headings	\N
v	1	Repertoire de vedettes-matiere	\N
z	1	Other	\N
|	\N	No attempt to code	\N
 	\N	Alternate no attempt to code	\N
\.


SET search_path = biblio, pg_catalog;

--
-- Name: autogen_tcn_value_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('autogen_tcn_value_seq', 1, false);


--
-- Data for Name: monograph_part; Type: TABLE DATA; Schema: biblio; Owner: postgres
--

COPY monograph_part (id, record, label, label_sortkey) FROM stdin;
\.


--
-- Name: monograph_part_id_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('monograph_part_id_seq', 1, false);


--
-- Data for Name: peer_bib_copy_map; Type: TABLE DATA; Schema: biblio; Owner: postgres
--

COPY peer_bib_copy_map (id, peer_type, peer_record, target_copy) FROM stdin;
\.


--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('peer_bib_copy_map_id_seq', 1, false);


--
-- Data for Name: peer_type; Type: TABLE DATA; Schema: biblio; Owner: postgres
--

COPY peer_type (id, name) FROM stdin;
1	Bound Volume
2	Bilingual
3	Back-to-back
4	Set
5	e-Reader Preload
\.


--
-- Name: peer_type_id_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('peer_type_id_seq', 100, true);


--
-- Data for Name: record_entry; Type: TABLE DATA; Schema: biblio; Owner: postgres
--

COPY record_entry (id, creator, editor, source, quality, create_date, edit_date, active, deleted, fingerprint, tcn_source, tcn_value, marc, last_xact_id, owner, share_depth) FROM stdin;
-1	1	1	1	-1	2015-06-22 09:56:07.134649-07	2015-06-22 09:56:07.134649-07	f	f		AUTOGEN	-1	<record    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://www.loc.gov/MARC21/slim http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd"    xmlns="http://www.loc.gov/MARC21/slim"><leader>         a              </leader><datafield tag="901" ind1=" " ind2=" "><subfield code="a">-1</subfield><subfield code="b">AUTOGEN</subfield><subfield code="c">-1</subfield><subfield code="t">biblio</subfield></datafield></record>	FOO	\N	\N
\.


--
-- Name: record_entry_id_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('record_entry_id_seq', 1, false);


--
-- Data for Name: record_note; Type: TABLE DATA; Schema: biblio; Owner: postgres
--

COPY record_note (id, record, value, creator, editor, pub, create_date, edit_date) FROM stdin;
\.


--
-- Name: record_note_id_seq; Type: SEQUENCE SET; Schema: biblio; Owner: postgres
--

SELECT pg_catalog.setval('record_note_id_seq', 1, false);


SET search_path = booking, pg_catalog;

--
-- Data for Name: reservation; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY reservation (id, usr, xact_start, xact_finish, unrecovered, request_time, start_time, end_time, capture_time, cancel_time, pickup_time, return_time, booking_interval, fine_interval, fine_amount, max_fine, target_resource_type, target_resource, current_resource, request_lib, pickup_lib, capture_staff, email_notify) FROM stdin;
\.


--
-- Data for Name: reservation_attr_value_map; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY reservation_attr_value_map (id, reservation, attr_value) FROM stdin;
\.


--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('reservation_attr_value_map_id_seq', 1, false);


--
-- Data for Name: resource; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY resource (id, owner, type, overbook, barcode, deposit, deposit_amount, user_fee) FROM stdin;
\.


--
-- Data for Name: resource_attr; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY resource_attr (id, owner, name, resource_type, required) FROM stdin;
\.


--
-- Name: resource_attr_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('resource_attr_id_seq', 1, false);


--
-- Data for Name: resource_attr_map; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY resource_attr_map (id, resource, resource_attr, value) FROM stdin;
\.


--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('resource_attr_map_id_seq', 1, false);


--
-- Data for Name: resource_attr_value; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY resource_attr_value (id, owner, attr, valid_value) FROM stdin;
\.


--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('resource_attr_value_id_seq', 1, false);


--
-- Name: resource_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('resource_id_seq', 1, false);


--
-- Data for Name: resource_type; Type: TABLE DATA; Schema: booking; Owner: postgres
--

COPY resource_type (id, name, elbow_room, fine_interval, fine_amount, max_fine, owner, catalog_item, transferable, record) FROM stdin;
\.


--
-- Name: resource_type_id_seq; Type: SEQUENCE SET; Schema: booking; Owner: postgres
--

SELECT pg_catalog.setval('resource_type_id_seq', 1, false);


SET search_path = config, pg_catalog;

--
-- Data for Name: barcode_completion; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY barcode_completion (id, active, org_unit, prefix, suffix, length, padding, padding_end, asset, actor) FROM stdin;
\.


--
-- Name: barcode_completion_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('barcode_completion_id_seq', 1, false);


--
-- Data for Name: best_hold_order; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY best_hold_order (id, name, pprox, hprox, aprox, approx, priority, cut, depth, htime, rtime, shtime) FROM stdin;
1	Traditional	2	\N	3	1	4	5	6	\N	7	\N
2	Traditional with Holds-always-go-home	3	1	4	2	5	6	7	\N	8	\N
3	Traditional with Holds-go-home	3	\N	4	2	5	6	7	1	8	\N
4	FIFO	5	6	7	\N	1	2	4	8	3	\N
5	FIFO with Holds-always-go-home	6	1	7	\N	2	3	5	8	4	\N
6	FIFO with Holds-go-home	6	8	7	\N	2	3	5	1	4	\N
\.


--
-- Name: best_hold_order_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('best_hold_order_id_seq', 6, true);


--
-- Data for Name: bib_source; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY bib_source (id, quality, source, transcendant, can_have_copies) FROM stdin;
1	90	oclc	f	t
2	10	System Local	f	t
3	1	Project Gutenberg	t	t
\.


--
-- Name: bib_source_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('bib_source_id_seq', 100, true);


--
-- Data for Name: biblio_fingerprint; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY biblio_fingerprint (id, name, xpath, first_word, format) FROM stdin;
1	Title	//marc:datafield[@tag="700"]/marc:subfield[@code="t"]|//marc:datafield[@tag="240"]/marc:subfield[@code="a"]|//marc:datafield[@tag="242"]/marc:subfield[@code="a"]|//marc:datafield[@tag="246"]/marc:subfield[@code="a"]|//marc:datafield[@tag="245"]/marc:subfield[@code="a"]	f	marcxml
2	Author	//marc:datafield[@tag="700" and ./*[@code="t"]]/marc:subfield[@code="a"]|//marc:datafield[@tag="100"]/marc:subfield[@code="a"]|//marc:datafield[@tag="110"]/marc:subfield[@code="a"]|//marc:datafield[@tag="111"]/marc:subfield[@code="a"]|//marc:datafield[@tag="260"]/marc:subfield[@code="b"]	t	marcxml
\.


--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('biblio_fingerprint_id_seq', 2, true);


--
-- Data for Name: billing_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY billing_type (id, name, owner, default_price) FROM stdin;
1	Overdue Materials	1	\N
2	Long Overdue Collection Fee	1	\N
3	Lost Materials	1	\N
4	Lost Materials Processing Fee	1	\N
5	System: Deposit	1	\N
6	System: Rental	1	\N
7	Damaged Item	1	\N
8	Damaged Item Processing Fee	1	\N
9	Notification Fee	1	\N
101	Misc	1	\N
\.


--
-- Name: billing_type_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('billing_type_id_seq', 101, true);


--
-- Data for Name: circ_limit_group; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_limit_group (id, name, description) FROM stdin;
\.


--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_limit_group_id_seq', 1, false);


--
-- Data for Name: circ_limit_set; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_limit_set (id, name, owning_lib, items_out, depth, global, description) FROM stdin;
\.


--
-- Data for Name: circ_limit_set_circ_mod_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_limit_set_circ_mod_map (id, limit_set, circ_mod) FROM stdin;
\.


--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_limit_set_circ_mod_map_id_seq', 1, false);


--
-- Data for Name: circ_limit_set_copy_loc_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_limit_set_copy_loc_map (id, limit_set, copy_loc) FROM stdin;
\.


--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_limit_set_copy_loc_map_id_seq', 1, false);


--
-- Data for Name: circ_limit_set_group_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_limit_set_group_map (id, limit_set, limit_group, check_only) FROM stdin;
\.


--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_limit_set_group_map_id_seq', 1, false);


--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_limit_set_id_seq', 1, false);


--
-- Data for Name: circ_matrix_limit_set_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_matrix_limit_set_map (id, matchpoint, limit_set, fallthrough, active) FROM stdin;
\.


--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_matrix_limit_set_map_id_seq', 1, false);


--
-- Data for Name: circ_matrix_matchpoint; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_matrix_matchpoint (id, active, org_unit, grp, circ_modifier, copy_location, marc_type, marc_form, marc_bib_level, marc_vr_format, copy_circ_lib, copy_owning_lib, user_home_ou, ref_flag, juvenile_flag, is_renewal, usr_age_lower_bound, usr_age_upper_bound, item_age, circulate, duration_rule, recurring_fine_rule, max_fine_rule, hard_due_date, renewals, grace_period, script_test, total_copy_hold_ratio, available_copy_hold_ratio) FROM stdin;
1	t	1	1	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	t	11	1	1	\N	\N	\N	\N	\N	\N
\.


--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_matrix_matchpoint_id_seq', 1, true);


--
-- Data for Name: circ_matrix_weights; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_matrix_weights (id, name, org_unit, grp, circ_modifier, copy_location, marc_type, marc_form, marc_bib_level, marc_vr_format, copy_circ_lib, copy_owning_lib, user_home_ou, ref_flag, juvenile_flag, is_renewal, usr_age_lower_bound, usr_age_upper_bound, item_age) FROM stdin;
1	Default	10.00	11.00	5.00	5.00	4.00	3.00	2.00	2.00	8.00	8.00	8.00	1.00	6.00	7.00	0.00	0.00	0.00
2	Org_Unit_First	11.00	10.00	5.00	5.00	4.00	3.00	2.00	2.00	8.00	8.00	8.00	1.00	6.00	7.00	0.00	0.00	0.00
3	Item_Owner_First	8.00	8.00	5.00	5.00	4.00	3.00	2.00	2.00	10.00	11.00	8.00	1.00	6.00	7.00	0.00	0.00	0.00
4	All_Equal	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00
\.


--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('circ_matrix_weights_id_seq', 4, true);


--
-- Data for Name: circ_modifier; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY circ_modifier (code, name, description, sip2_media_type, magnetic_media, avg_wait_time) FROM stdin;
\.


--
-- Data for Name: coded_value_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY coded_value_map (id, ctype, code, value, description, opac_visible, search_label, is_simple) FROM stdin;
1	item_lang	aar	Afar	\N	t	\N	f
2	item_lang	abk	Abkhaz	\N	t	\N	f
3	item_lang	ace	Achinese	\N	t	\N	f
4	item_lang	ach	Acoli	\N	t	\N	f
5	item_lang	ada	Adangme	\N	t	\N	f
6	item_lang	ady	Adygei	\N	t	\N	f
7	item_lang	afa	Afroasiatic (Other)	\N	t	\N	f
8	item_lang	afh	Afrihili (Artificial language)	\N	t	\N	f
9	item_lang	afr	Afrikaans	\N	t	\N	f
10	item_lang	-ajm	Aljamía	\N	t	\N	f
11	item_lang	aka	Akan	\N	t	\N	f
12	item_lang	akk	Akkadian	\N	t	\N	f
13	item_lang	alb	Albanian	\N	t	\N	f
14	item_lang	ale	Aleut	\N	t	\N	f
15	item_lang	alg	Algonquian (Other)	\N	t	\N	f
16	item_lang	amh	Amharic	\N	t	\N	f
17	item_lang	ang	English, Old (ca. 450-1100)	\N	t	\N	f
18	item_lang	apa	Apache languages	\N	t	\N	f
19	item_lang	ara	Arabic	\N	t	\N	f
20	item_lang	arc	Aramaic	\N	t	\N	f
21	item_lang	arg	Aragonese Spanish	\N	t	\N	f
22	item_lang	arm	Armenian	\N	t	\N	f
23	item_lang	arn	Mapuche	\N	t	\N	f
24	item_lang	arp	Arapaho	\N	t	\N	f
25	item_lang	art	Artificial (Other)	\N	t	\N	f
26	item_lang	arw	Arawak	\N	t	\N	f
27	item_lang	asm	Assamese	\N	t	\N	f
28	item_lang	ast	Bable	\N	t	\N	f
29	item_lang	ath	Athapascan (Other)	\N	t	\N	f
30	item_lang	aus	Australian languages	\N	t	\N	f
31	item_lang	ava	Avaric	\N	t	\N	f
32	item_lang	ave	Avestan	\N	t	\N	f
33	item_lang	awa	Awadhi	\N	t	\N	f
34	item_lang	aym	Aymara	\N	t	\N	f
35	item_lang	aze	Azerbaijani	\N	t	\N	f
36	item_lang	bad	Banda	\N	t	\N	f
37	item_lang	bai	Bamileke languages	\N	t	\N	f
38	item_lang	bak	Bashkir	\N	t	\N	f
39	item_lang	bal	Baluchi	\N	t	\N	f
40	item_lang	bam	Bambara	\N	t	\N	f
41	item_lang	ban	Balinese	\N	t	\N	f
42	item_lang	baq	Basque	\N	t	\N	f
43	item_lang	bas	Basa	\N	t	\N	f
44	item_lang	bat	Baltic (Other)	\N	t	\N	f
45	item_lang	bej	Beja	\N	t	\N	f
46	item_lang	bel	Belarusian	\N	t	\N	f
47	item_lang	bem	Bemba	\N	t	\N	f
48	item_lang	ben	Bengali	\N	t	\N	f
49	item_lang	ber	Berber (Other)	\N	t	\N	f
50	item_lang	bho	Bhojpuri	\N	t	\N	f
51	item_lang	bih	Bihari	\N	t	\N	f
52	item_lang	bik	Bikol	\N	t	\N	f
53	item_lang	bin	Edo	\N	t	\N	f
54	item_lang	bis	Bislama	\N	t	\N	f
55	item_lang	bla	Siksika	\N	t	\N	f
56	item_lang	bnt	Bantu (Other)	\N	t	\N	f
57	item_lang	bos	Bosnian	\N	t	\N	f
58	item_lang	bra	Braj	\N	t	\N	f
59	item_lang	bre	Breton	\N	t	\N	f
60	item_lang	btk	Batak	\N	t	\N	f
61	item_lang	bua	Buriat	\N	t	\N	f
62	item_lang	bug	Bugis	\N	t	\N	f
63	item_lang	bul	Bulgarian	\N	t	\N	f
64	item_lang	bur	Burmese	\N	t	\N	f
65	item_lang	cad	Caddo	\N	t	\N	f
66	item_lang	cai	Central American Indian (Other)	\N	t	\N	f
67	item_lang	-cam	Khmer	\N	t	\N	f
68	item_lang	car	Carib	\N	t	\N	f
69	item_lang	cat	Catalan	\N	t	\N	f
70	item_lang	cau	Caucasian (Other)	\N	t	\N	f
71	item_lang	ceb	Cebuano	\N	t	\N	f
72	item_lang	cel	Celtic (Other)	\N	t	\N	f
73	item_lang	cha	Chamorro	\N	t	\N	f
74	item_lang	chb	Chibcha	\N	t	\N	f
75	item_lang	che	Chechen	\N	t	\N	f
76	item_lang	chg	Chagatai	\N	t	\N	f
77	item_lang	chi	Chinese	\N	t	\N	f
78	item_lang	chk	Truk	\N	t	\N	f
79	item_lang	chm	Mari	\N	t	\N	f
80	item_lang	chn	Chinook jargon	\N	t	\N	f
81	item_lang	cho	Choctaw	\N	t	\N	f
82	item_lang	chp	Chipewyan	\N	t	\N	f
83	item_lang	chr	Cherokee	\N	t	\N	f
84	item_lang	chu	Church Slavic	\N	t	\N	f
85	item_lang	chv	Chuvash	\N	t	\N	f
86	item_lang	chy	Cheyenne	\N	t	\N	f
87	item_lang	cmc	Chamic languages	\N	t	\N	f
88	item_lang	cop	Coptic	\N	t	\N	f
89	item_lang	cor	Cornish	\N	t	\N	f
90	item_lang	cos	Corsican	\N	t	\N	f
91	item_lang	cpe	Creoles and Pidgins, English-based (Other)	\N	t	\N	f
92	item_lang	cpf	Creoles and Pidgins, French-based (Other)	\N	t	\N	f
93	item_lang	cpp	Creoles and Pidgins, Portuguese-based (Other)	\N	t	\N	f
94	item_lang	cre	Cree	\N	t	\N	f
95	item_lang	crh	Crimean Tatar	\N	t	\N	f
96	item_lang	crp	Creoles and Pidgins (Other)	\N	t	\N	f
97	item_lang	cus	Cushitic (Other)	\N	t	\N	f
98	item_lang	cze	Czech	\N	t	\N	f
99	item_lang	dak	Dakota	\N	t	\N	f
100	item_lang	dan	Danish	\N	t	\N	f
101	item_lang	dar	Dargwa	\N	t	\N	f
102	item_lang	day	Dayak	\N	t	\N	f
103	item_lang	del	Delaware	\N	t	\N	f
104	item_lang	den	Slave	\N	t	\N	f
105	item_lang	dgr	Dogrib	\N	t	\N	f
106	item_lang	din	Dinka	\N	t	\N	f
107	item_lang	div	Divehi	\N	t	\N	f
108	item_lang	doi	Dogri	\N	t	\N	f
109	item_lang	dra	Dravidian (Other)	\N	t	\N	f
110	item_lang	dua	Duala	\N	t	\N	f
111	item_lang	dum	Dutch, Middle (ca. 1050-1350)	\N	t	\N	f
112	item_lang	dut	Dutch	\N	t	\N	f
113	item_lang	dyu	Dyula	\N	t	\N	f
114	item_lang	dzo	Dzongkha	\N	t	\N	f
115	item_lang	efi	Efik	\N	t	\N	f
116	item_lang	egy	Egyptian	\N	t	\N	f
117	item_lang	eka	Ekajuk	\N	t	\N	f
118	item_lang	elx	Elamite	\N	t	\N	f
119	item_lang	eng	English	\N	t	\N	f
120	item_lang	enm	English, Middle (1100-1500)	\N	t	\N	f
121	item_lang	epo	Esperanto	\N	t	\N	f
122	item_lang	-esk	Eskimo languages	\N	t	\N	f
123	item_lang	-esp	Esperanto	\N	t	\N	f
124	item_lang	est	Estonian	\N	t	\N	f
125	item_lang	-eth	Ethiopic	\N	t	\N	f
126	item_lang	ewe	Ewe	\N	t	\N	f
127	item_lang	ewo	Ewondo	\N	t	\N	f
128	item_lang	fan	Fang	\N	t	\N	f
129	item_lang	fao	Faroese	\N	t	\N	f
130	item_lang	-far	Faroese	\N	t	\N	f
131	item_lang	fat	Fanti	\N	t	\N	f
132	item_lang	fij	Fijian	\N	t	\N	f
133	item_lang	fin	Finnish	\N	t	\N	f
134	item_lang	fiu	Finno-Ugrian (Other)	\N	t	\N	f
135	item_lang	fon	Fon	\N	t	\N	f
136	item_lang	fre	French	\N	t	\N	f
137	item_lang	-fri	Frisian	\N	t	\N	f
138	item_lang	frm	French, Middle (ca. 1400-1600)	\N	t	\N	f
139	item_lang	fro	French, Old (ca. 842-1400)	\N	t	\N	f
140	item_lang	fry	Frisian	\N	t	\N	f
141	item_lang	ful	Fula	\N	t	\N	f
142	item_lang	fur	Friulian	\N	t	\N	f
143	item_lang	gaa	Gã	\N	t	\N	f
144	item_lang	-gae	Scottish Gaelic	\N	t	\N	f
145	item_lang	-gag	Galician	\N	t	\N	f
146	item_lang	-gal	Oromo	\N	t	\N	f
147	item_lang	gay	Gayo	\N	t	\N	f
148	item_lang	gba	Gbaya	\N	t	\N	f
149	item_lang	gem	Germanic (Other)	\N	t	\N	f
150	item_lang	geo	Georgian	\N	t	\N	f
151	item_lang	ger	German	\N	t	\N	f
152	item_lang	gez	Ethiopic	\N	t	\N	f
153	item_lang	gil	Gilbertese	\N	t	\N	f
154	item_lang	gla	Scottish Gaelic	\N	t	\N	f
155	item_lang	gle	Irish	\N	t	\N	f
156	item_lang	glg	Galician	\N	t	\N	f
157	item_lang	glv	Manx	\N	t	\N	f
158	item_lang	gmh	German, Middle High (ca. 1050-1500)	\N	t	\N	f
159	item_lang	goh	German, Old High (ca. 750-1050)	\N	t	\N	f
160	item_lang	gon	Gondi	\N	t	\N	f
161	item_lang	gor	Gorontalo	\N	t	\N	f
162	item_lang	got	Gothic	\N	t	\N	f
163	item_lang	grb	Grebo	\N	t	\N	f
164	item_lang	grc	Greek, Ancient (to 1453)	\N	t	\N	f
165	item_lang	gre	Greek, Modern (1453- )	\N	t	\N	f
166	item_lang	grn	Guarani	\N	t	\N	f
167	item_lang	-gua	Guarani	\N	t	\N	f
168	item_lang	guj	Gujarati	\N	t	\N	f
169	item_lang	gwi	Gwich'in	\N	t	\N	f
170	item_lang	hai	Haida	\N	t	\N	f
171	item_lang	hat	Haitian French Creole	\N	t	\N	f
172	item_lang	hau	Hausa	\N	t	\N	f
173	item_lang	haw	Hawaiian	\N	t	\N	f
174	item_lang	heb	Hebrew	\N	t	\N	f
175	item_lang	her	Herero	\N	t	\N	f
176	item_lang	hil	Hiligaynon	\N	t	\N	f
177	item_lang	him	Himachali	\N	t	\N	f
178	item_lang	hin	Hindi	\N	t	\N	f
179	item_lang	hit	Hittite	\N	t	\N	f
180	item_lang	hmn	Hmong	\N	t	\N	f
181	item_lang	hmo	Hiri Motu	\N	t	\N	f
182	item_lang	hun	Hungarian	\N	t	\N	f
183	item_lang	hup	Hupa	\N	t	\N	f
184	item_lang	iba	Iban	\N	t	\N	f
185	item_lang	ibo	Igbo	\N	t	\N	f
186	item_lang	ice	Icelandic	\N	t	\N	f
187	item_lang	ido	Ido	\N	t	\N	f
188	item_lang	iii	Sichuan Yi	\N	t	\N	f
189	item_lang	ijo	Ijo	\N	t	\N	f
190	item_lang	iku	Inuktitut	\N	t	\N	f
191	item_lang	ile	Interlingue	\N	t	\N	f
192	item_lang	ilo	Iloko	\N	t	\N	f
193	item_lang	ina	Interlingua (International Auxiliary Language Association)	\N	t	\N	f
194	item_lang	inc	Indic (Other)	\N	t	\N	f
195	item_lang	ind	Indonesian	\N	t	\N	f
196	item_lang	ine	Indo-European (Other)	\N	t	\N	f
197	item_lang	inh	Ingush	\N	t	\N	f
198	item_lang	-int	Interlingua (International Auxiliary Language Association)	\N	t	\N	f
199	item_lang	ipk	Inupiaq	\N	t	\N	f
200	item_lang	ira	Iranian (Other)	\N	t	\N	f
201	item_lang	-iri	Irish	\N	t	\N	f
202	item_lang	iro	Iroquoian (Other)	\N	t	\N	f
203	item_lang	ita	Italian	\N	t	\N	f
204	item_lang	jav	Javanese	\N	t	\N	f
205	item_lang	jpn	Japanese	\N	t	\N	f
206	item_lang	jpr	Judeo-Persian	\N	t	\N	f
207	item_lang	jrb	Judeo-Arabic	\N	t	\N	f
208	item_lang	kaa	Kara-Kalpak	\N	t	\N	f
209	item_lang	kab	Kabyle	\N	t	\N	f
210	item_lang	kac	Kachin	\N	t	\N	f
211	item_lang	kal	Kalâtdlisut	\N	t	\N	f
212	item_lang	kam	Kamba	\N	t	\N	f
213	item_lang	kan	Kannada	\N	t	\N	f
214	item_lang	kar	Karen	\N	t	\N	f
215	item_lang	kas	Kashmiri	\N	t	\N	f
216	item_lang	kau	Kanuri	\N	t	\N	f
217	item_lang	kaw	Kawi	\N	t	\N	f
218	item_lang	kaz	Kazakh	\N	t	\N	f
219	item_lang	kbd	Kabardian	\N	t	\N	f
220	item_lang	kha	Khasi	\N	t	\N	f
221	item_lang	khi	Khoisan (Other)	\N	t	\N	f
222	item_lang	khm	Khmer	\N	t	\N	f
223	item_lang	kho	Khotanese	\N	t	\N	f
224	item_lang	kik	Kikuyu	\N	t	\N	f
225	item_lang	kin	Kinyarwanda	\N	t	\N	f
226	item_lang	kir	Kyrgyz	\N	t	\N	f
227	item_lang	kmb	Kimbundu	\N	t	\N	f
228	item_lang	kok	Konkani	\N	t	\N	f
229	item_lang	kom	Komi	\N	t	\N	f
230	item_lang	kon	Kongo	\N	t	\N	f
231	item_lang	kor	Korean	\N	t	\N	f
232	item_lang	kos	Kusaie	\N	t	\N	f
233	item_lang	kpe	Kpelle	\N	t	\N	f
234	item_lang	kro	Kru	\N	t	\N	f
235	item_lang	kru	Kurukh	\N	t	\N	f
236	item_lang	kua	Kuanyama	\N	t	\N	f
237	item_lang	kum	Kumyk	\N	t	\N	f
238	item_lang	kur	Kurdish	\N	t	\N	f
239	item_lang	-kus	Kusaie	\N	t	\N	f
240	item_lang	kut	Kutenai	\N	t	\N	f
241	item_lang	lad	Ladino	\N	t	\N	f
242	item_lang	lah	Lahnda	\N	t	\N	f
243	item_lang	lam	Lamba	\N	t	\N	f
244	item_lang	-lan	Occitan (post-1500)	\N	t	\N	f
245	item_lang	lao	Lao	\N	t	\N	f
246	item_lang	-lap	Sami	\N	t	\N	f
247	item_lang	lat	Latin	\N	t	\N	f
248	item_lang	lav	Latvian	\N	t	\N	f
249	item_lang	lez	Lezgian	\N	t	\N	f
250	item_lang	lim	Limburgish	\N	t	\N	f
251	item_lang	lin	Lingala	\N	t	\N	f
252	item_lang	lit	Lithuanian	\N	t	\N	f
253	item_lang	lol	Mongo-Nkundu	\N	t	\N	f
254	item_lang	loz	Lozi	\N	t	\N	f
255	item_lang	ltz	Letzeburgesch	\N	t	\N	f
256	item_lang	lua	Luba-Lulua	\N	t	\N	f
257	item_lang	lub	Luba-Katanga	\N	t	\N	f
258	item_lang	lug	Ganda	\N	t	\N	f
259	item_lang	lui	Luiseño	\N	t	\N	f
260	item_lang	lun	Lunda	\N	t	\N	f
261	item_lang	luo	Luo (Kenya and Tanzania)	\N	t	\N	f
262	item_lang	lus	Lushai	\N	t	\N	f
263	item_lang	mac	Macedonian	\N	t	\N	f
264	item_lang	mad	Madurese	\N	t	\N	f
265	item_lang	mag	Magahi	\N	t	\N	f
266	item_lang	mah	Marshallese	\N	t	\N	f
267	item_lang	mai	Maithili	\N	t	\N	f
268	item_lang	mak	Makasar	\N	t	\N	f
269	item_lang	mal	Malayalam	\N	t	\N	f
270	item_lang	man	Mandingo	\N	t	\N	f
271	item_lang	mao	Maori	\N	t	\N	f
272	item_lang	map	Austronesian (Other)	\N	t	\N	f
273	item_lang	mar	Marathi	\N	t	\N	f
274	item_lang	mas	Masai	\N	t	\N	f
275	item_lang	-max	Manx	\N	t	\N	f
276	item_lang	may	Malay	\N	t	\N	f
277	item_lang	mdr	Mandar	\N	t	\N	f
278	item_lang	men	Mende	\N	t	\N	f
279	item_lang	mga	Irish, Middle (ca. 1100-1550)	\N	t	\N	f
280	item_lang	mic	Micmac	\N	t	\N	f
281	item_lang	min	Minangkabau	\N	t	\N	f
282	item_lang	mis	Miscellaneous languages	\N	t	\N	f
283	item_lang	mkh	Mon-Khmer (Other)	\N	t	\N	f
284	item_lang	-mla	Malagasy	\N	t	\N	f
285	item_lang	mlg	Malagasy	\N	t	\N	f
286	item_lang	mlt	Maltese	\N	t	\N	f
287	item_lang	mnc	Manchu	\N	t	\N	f
288	item_lang	mni	Manipuri	\N	t	\N	f
289	item_lang	mno	Manobo languages	\N	t	\N	f
290	item_lang	moh	Mohawk	\N	t	\N	f
291	item_lang	mol	Moldavian	\N	t	\N	f
292	item_lang	mon	Mongolian	\N	t	\N	f
293	item_lang	mos	Mooré	\N	t	\N	f
294	item_lang	mul	Multiple languages	\N	t	\N	f
295	item_lang	mun	Munda (Other)	\N	t	\N	f
296	item_lang	mus	Creek	\N	t	\N	f
297	item_lang	mwr	Marwari	\N	t	\N	f
298	item_lang	myn	Mayan languages	\N	t	\N	f
299	item_lang	nah	Nahuatl	\N	t	\N	f
300	item_lang	nai	North American Indian (Other)	\N	t	\N	f
301	item_lang	nap	Neapolitan Italian	\N	t	\N	f
302	item_lang	nau	Nauru	\N	t	\N	f
303	item_lang	nav	Navajo	\N	t	\N	f
304	item_lang	nbl	Ndebele (South Africa)	\N	t	\N	f
305	item_lang	nde	Ndebele (Zimbabwe)  	\N	t	\N	f
306	item_lang	ndo	Ndonga	\N	t	\N	f
307	item_lang	nds	Low German	\N	t	\N	f
308	item_lang	nep	Nepali	\N	t	\N	f
309	item_lang	new	Newari	\N	t	\N	f
310	item_lang	nia	Nias	\N	t	\N	f
311	item_lang	nic	Niger-Kordofanian (Other)	\N	t	\N	f
312	item_lang	niu	Niuean	\N	t	\N	f
313	item_lang	nno	Norwegian (Nynorsk)	\N	t	\N	f
314	item_lang	nob	Norwegian (Bokmål)	\N	t	\N	f
315	item_lang	nog	Nogai	\N	t	\N	f
316	item_lang	non	Old Norse	\N	t	\N	f
317	item_lang	nor	Norwegian	\N	t	\N	f
318	item_lang	nso	Northern Sotho	\N	t	\N	f
319	item_lang	nub	Nubian languages	\N	t	\N	f
320	item_lang	nya	Nyanja	\N	t	\N	f
321	item_lang	nym	Nyamwezi	\N	t	\N	f
322	item_lang	nyn	Nyankole	\N	t	\N	f
323	item_lang	nyo	Nyoro	\N	t	\N	f
324	item_lang	nzi	Nzima	\N	t	\N	f
325	item_lang	oci	Occitan (post-1500)	\N	t	\N	f
326	item_lang	oji	Ojibwa	\N	t	\N	f
327	item_lang	ori	Oriya	\N	t	\N	f
328	item_lang	orm	Oromo	\N	t	\N	f
329	item_lang	osa	Osage	\N	t	\N	f
330	item_lang	oss	Ossetic	\N	t	\N	f
331	item_lang	ota	Turkish, Ottoman	\N	t	\N	f
332	item_lang	oto	Otomian languages	\N	t	\N	f
333	item_lang	paa	Papuan (Other)	\N	t	\N	f
334	item_lang	pag	Pangasinan	\N	t	\N	f
335	item_lang	pal	Pahlavi	\N	t	\N	f
336	item_lang	pam	Pampanga	\N	t	\N	f
337	item_lang	pan	Panjabi	\N	t	\N	f
338	item_lang	pap	Papiamento	\N	t	\N	f
339	item_lang	pau	Palauan	\N	t	\N	f
340	item_lang	peo	Old Persian (ca. 600-400 B.C.)	\N	t	\N	f
341	item_lang	per	Persian	\N	t	\N	f
342	item_lang	phi	Philippine (Other)	\N	t	\N	f
343	item_lang	phn	Phoenician	\N	t	\N	f
344	item_lang	pli	Pali	\N	t	\N	f
345	item_lang	pol	Polish	\N	t	\N	f
346	item_lang	pon	Ponape	\N	t	\N	f
347	item_lang	por	Portuguese	\N	t	\N	f
348	item_lang	pra	Prakrit languages	\N	t	\N	f
349	item_lang	pro	Provençal (to 1500)	\N	t	\N	f
350	item_lang	pus	Pushto	\N	t	\N	f
351	item_lang	que	Quechua	\N	t	\N	f
352	item_lang	raj	Rajasthani	\N	t	\N	f
353	item_lang	rap	Rapanui	\N	t	\N	f
354	item_lang	rar	Rarotongan	\N	t	\N	f
355	item_lang	roa	Romance (Other)	\N	t	\N	f
356	item_lang	roh	Raeto-Romance	\N	t	\N	f
357	item_lang	rom	Romani	\N	t	\N	f
358	item_lang	rum	Romanian	\N	t	\N	f
359	item_lang	run	Rundi	\N	t	\N	f
360	item_lang	rus	Russian	\N	t	\N	f
361	item_lang	sad	Sandawe	\N	t	\N	f
362	item_lang	sag	Sango (Ubangi Creole)	\N	t	\N	f
363	item_lang	sah	Yakut	\N	t	\N	f
364	item_lang	sai	South American Indian (Other)	\N	t	\N	f
365	item_lang	sal	Salishan languages	\N	t	\N	f
366	item_lang	sam	Samaritan Aramaic	\N	t	\N	f
367	item_lang	san	Sanskrit	\N	t	\N	f
368	item_lang	-sao	Samoan	\N	t	\N	f
369	item_lang	sas	Sasak	\N	t	\N	f
370	item_lang	sat	Santali	\N	t	\N	f
371	item_lang	scc	Serbian	\N	t	\N	f
372	item_lang	sco	Scots	\N	t	\N	f
373	item_lang	scr	Croatian	\N	t	\N	f
374	item_lang	sel	Selkup	\N	t	\N	f
375	item_lang	sem	Semitic (Other)	\N	t	\N	f
376	item_lang	sga	Irish, Old (to 1100)	\N	t	\N	f
377	item_lang	sgn	Sign languages	\N	t	\N	f
378	item_lang	shn	Shan	\N	t	\N	f
379	item_lang	-sho	Shona	\N	t	\N	f
380	item_lang	sid	Sidamo	\N	t	\N	f
381	item_lang	sin	Sinhalese	\N	t	\N	f
382	item_lang	sio	Siouan (Other)	\N	t	\N	f
383	item_lang	sit	Sino-Tibetan (Other)	\N	t	\N	f
384	item_lang	sla	Slavic (Other)	\N	t	\N	f
385	item_lang	slo	Slovak	\N	t	\N	f
386	item_lang	slv	Slovenian	\N	t	\N	f
387	item_lang	sma	Southern Sami	\N	t	\N	f
388	item_lang	sme	Northern Sami	\N	t	\N	f
389	item_lang	smi	Sami	\N	t	\N	f
390	item_lang	smj	Lule Sami	\N	t	\N	f
391	item_lang	smn	Inari Sami	\N	t	\N	f
392	item_lang	smo	Samoan	\N	t	\N	f
393	item_lang	sms	Skolt Sami	\N	t	\N	f
394	item_lang	sna	Shona	\N	t	\N	f
395	item_lang	snd	Sindhi	\N	t	\N	f
396	item_lang	-snh	Sinhalese	\N	t	\N	f
397	item_lang	snk	Soninke	\N	t	\N	f
398	item_lang	sog	Sogdian	\N	t	\N	f
399	item_lang	som	Somali	\N	t	\N	f
400	item_lang	son	Songhai	\N	t	\N	f
401	item_lang	sot	Sotho	\N	t	\N	f
402	item_lang	spa	Spanish	\N	t	\N	f
403	item_lang	srd	Sardinian	\N	t	\N	f
404	item_lang	srr	Serer	\N	t	\N	f
405	item_lang	ssa	Nilo-Saharan (Other)	\N	t	\N	f
406	item_lang	-sso	Sotho	\N	t	\N	f
407	item_lang	ssw	Swazi	\N	t	\N	f
408	item_lang	suk	Sukuma	\N	t	\N	f
409	item_lang	sun	Sundanese	\N	t	\N	f
410	item_lang	sus	Susu	\N	t	\N	f
411	item_lang	sux	Sumerian	\N	t	\N	f
412	item_lang	swa	Swahili	\N	t	\N	f
413	item_lang	swe	Swedish	\N	t	\N	f
414	item_lang	-swz	Swazi	\N	t	\N	f
415	item_lang	syr	Syriac	\N	t	\N	f
416	item_lang	-tag	Tagalog	\N	t	\N	f
417	item_lang	tah	Tahitian	\N	t	\N	f
418	item_lang	tai	Tai (Other)	\N	t	\N	f
419	item_lang	-taj	Tajik	\N	t	\N	f
420	item_lang	tam	Tamil	\N	t	\N	f
421	item_lang	-tar	Tatar	\N	t	\N	f
422	item_lang	tat	Tatar	\N	t	\N	f
423	item_lang	tel	Telugu	\N	t	\N	f
424	item_lang	tem	Temne	\N	t	\N	f
425	item_lang	ter	Terena	\N	t	\N	f
426	item_lang	tet	Tetum	\N	t	\N	f
427	item_lang	tgk	Tajik	\N	t	\N	f
428	item_lang	tgl	Tagalog	\N	t	\N	f
429	item_lang	tha	Thai	\N	t	\N	f
430	item_lang	tib	Tibetan	\N	t	\N	f
431	item_lang	tig	Tigré	\N	t	\N	f
432	item_lang	tir	Tigrinya	\N	t	\N	f
433	item_lang	tiv	Tiv	\N	t	\N	f
434	item_lang	tkl	Tokelauan	\N	t	\N	f
435	item_lang	tli	Tlingit	\N	t	\N	f
436	item_lang	tmh	Tamashek	\N	t	\N	f
437	item_lang	tog	Tonga (Nyasa)	\N	t	\N	f
438	item_lang	ton	Tongan	\N	t	\N	f
439	item_lang	tpi	Tok Pisin	\N	t	\N	f
440	item_lang	-tru	Truk	\N	t	\N	f
441	item_lang	tsi	Tsimshian	\N	t	\N	f
442	item_lang	tsn	Tswana	\N	t	\N	f
443	item_lang	tso	Tsonga	\N	t	\N	f
444	item_lang	-tsw	Tswana	\N	t	\N	f
445	item_lang	tuk	Turkmen	\N	t	\N	f
446	item_lang	tum	Tumbuka	\N	t	\N	f
447	item_lang	tup	Tupi languages	\N	t	\N	f
448	item_lang	tur	Turkish	\N	t	\N	f
449	item_lang	tut	Altaic (Other)	\N	t	\N	f
450	item_lang	tvl	Tuvaluan	\N	t	\N	f
451	item_lang	twi	Twi	\N	t	\N	f
452	item_lang	tyv	Tuvinian	\N	t	\N	f
453	item_lang	udm	Udmurt	\N	t	\N	f
454	item_lang	uga	Ugaritic	\N	t	\N	f
455	item_lang	uig	Uighur	\N	t	\N	f
456	item_lang	ukr	Ukrainian	\N	t	\N	f
457	item_lang	umb	Umbundu	\N	t	\N	f
458	item_lang	und	Undetermined	\N	t	\N	f
459	item_lang	urd	Urdu	\N	t	\N	f
460	item_lang	uzb	Uzbek	\N	t	\N	f
461	item_lang	vai	Vai	\N	t	\N	f
462	item_lang	ven	Venda	\N	t	\N	f
463	item_lang	vie	Vietnamese	\N	t	\N	f
464	item_lang	vol	Volapük	\N	t	\N	f
465	item_lang	vot	Votic	\N	t	\N	f
466	item_lang	wak	Wakashan languages	\N	t	\N	f
467	item_lang	wal	Walamo	\N	t	\N	f
468	item_lang	war	Waray	\N	t	\N	f
469	item_lang	was	Washo	\N	t	\N	f
470	item_lang	wel	Welsh	\N	t	\N	f
471	item_lang	wen	Sorbian languages	\N	t	\N	f
472	item_lang	wln	Walloon	\N	t	\N	f
473	item_lang	wol	Wolof	\N	t	\N	f
474	item_lang	xal	Kalmyk	\N	t	\N	f
475	item_lang	xho	Xhosa	\N	t	\N	f
476	item_lang	yao	Yao (Africa)	\N	t	\N	f
477	item_lang	yap	Yapese	\N	t	\N	f
478	item_lang	yid	Yiddish	\N	t	\N	f
479	item_lang	yor	Yoruba	\N	t	\N	f
480	item_lang	ypk	Yupik languages	\N	t	\N	f
481	item_lang	zap	Zapotec	\N	t	\N	f
482	item_lang	zen	Zenaga	\N	t	\N	f
483	item_lang	zha	Zhuang	\N	t	\N	f
484	item_lang	znd	Zande	\N	t	\N	f
485	item_lang	zul	Zulu	\N	t	\N	f
486	item_lang	zun	Zuni	\N	t	\N	f
487	audience	 	Unknown or unspecified	The target audience for the item not known or not specified.	t	\N	f
488	audience	a	Preschool	The item is intended for children, approximate ages 0-5 years.	t	\N	f
489	audience	b	Primary	The item is intended for children, approximate ages 6-8 years.	t	\N	f
490	audience	c	Pre-adolescent	The item is intended for young people, approximate ages 9-13 years.	t	\N	f
491	audience	d	Adolescent	The item is intended for young people, approximate ages 14-17 years.	t	\N	f
492	audience	e	Adult	The item is intended for adults.	t	\N	f
493	audience	f	Specialized	The item is aimed at a particular audience and the nature of the presentation makes the item of little interest to another audience.	t	\N	f
494	audience	g	General	The item is of general interest and not aimed at an audience of a particular intellectual level.	t	\N	f
495	audience	j	Juvenile	The item is intended for children and young people, approximate ages 0-15 years.	t	\N	f
496	item_type	a	Language material	\N	t	\N	f
497	item_type	t	Manuscript language material	\N	t	\N	f
498	item_type	g	Projected medium	\N	t	\N	f
499	item_type	k	Two-dimensional nonprojectable graphic	\N	t	\N	f
500	item_type	r	Three-dimensional artifact or naturally occurring object	\N	t	\N	f
501	item_type	o	Kit	\N	t	\N	f
502	item_type	p	Mixed materials	\N	t	\N	f
503	item_type	e	Cartographic material	\N	t	\N	f
504	item_type	f	Manuscript cartographic material	\N	t	\N	f
505	item_type	c	Notated music	\N	t	\N	f
506	item_type	d	Manuscript notated music	\N	t	\N	f
507	item_type	i	Nonmusical sound recording	\N	t	\N	f
508	item_type	j	Musical sound recording	\N	t	\N	f
509	item_type	m	Computer file	\N	t	\N	f
510	lit_form	0	Not fiction (not further specified)	The item is not a work of fiction and no further identification of the literary form is desired	t	\N	f
511	lit_form	1	Fiction (not further specified)	The item is a work of fiction and no further identification of the literary form is desired	t	\N	f
512	lit_form	c	Comic strips	\N	t	\N	f
513	lit_form	d	Dramas	\N	t	\N	f
514	lit_form	e	Essays	\N	t	\N	f
515	lit_form	f	Novels	\N	t	\N	f
516	lit_form	h	Humor, satires, etc.	The item is a humorous work, satire or of similar literary form.	t	\N	f
517	lit_form	i	Letters	The item is a single letter or collection of correspondence.	t	\N	f
518	lit_form	j	Short stories	The item is a short story or collection of short stories.	t	\N	f
519	lit_form	m	Mixed forms	The item is a variety of literary forms (e.g., poetry and short stories).	t	\N	f
520	lit_form	p	Poetry	The item is a poem or collection of poems.	t	\N	f
521	lit_form	s	Speeches	The item is a speech or collection of speeches.	t	\N	f
522	lit_form	u	Unknown	The literary form of the item is unknown.	t	\N	f
523	item_form	a	Microfilm	\N	t	\N	f
524	item_form	b	Microfiche	\N	t	\N	f
525	item_form	c	Microopaque	\N	t	\N	f
526	item_form	d	Large print	\N	t	\N	f
527	item_form	f	Braille	\N	t	\N	f
528	item_form	r	Regular print reproduction	\N	t	\N	f
529	item_form	s	Electronic	\N	t	\N	f
530	bib_level	a	Monographic component part	\N	t	\N	f
531	bib_level	b	Serial component part	\N	t	\N	f
532	bib_level	c	Collection	\N	t	\N	f
533	bib_level	d	Subunit	\N	t	\N	f
534	bib_level	i	Integrating resource	\N	t	\N	f
535	bib_level	m	Monograph/Item	\N	t	\N	f
536	bib_level	s	Serial	\N	t	\N	f
537	vr_format	a	Beta	\N	t	\N	f
538	vr_format	b	VHS	\N	t	\N	f
539	vr_format	c	U-matic	\N	t	\N	f
540	vr_format	d	EIAJ	\N	t	\N	f
541	vr_format	e	Type C	\N	t	\N	f
542	vr_format	f	Quadruplex	\N	t	\N	f
543	vr_format	g	Laserdisc	\N	t	\N	f
544	vr_format	h	CED videodisc	\N	t	\N	f
545	vr_format	i	Betacam	\N	t	\N	f
546	vr_format	j	Betacam SP	\N	t	\N	f
547	vr_format	k	Super-VHS	\N	t	\N	f
548	vr_format	m	M-II	\N	t	\N	f
549	vr_format	o	D-2	\N	t	\N	f
550	vr_format	p	8 mm.	\N	t	\N	f
551	vr_format	q	Hi-8 mm.	\N	t	\N	f
552	vr_format	s	Blu-ray disc	\N	t	\N	f
553	vr_format	u	Unknown	\N	t	\N	f
554	vr_format	v	DVD	\N	t	\N	f
555	vr_format	z	Other	\N	t	\N	f
556	vr_format	 	Unspecified	\N	t	\N	f
\.


--
-- Name: coded_value_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('coded_value_map_id_seq', 556, true);


--
-- Data for Name: copy_status; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY copy_status (id, name, holdable, opac_visible, copy_active, restrict_copy_delete) FROM stdin;
0	Available	t	t	t	f
1	Checked out	t	t	t	t
2	Bindery	f	f	f	f
3	Lost	f	f	f	t
4	Missing	f	f	f	f
5	In process	t	t	f	f
6	In transit	t	t	f	t
7	Reshelving	t	t	t	f
8	On holds shelf	t	t	t	t
9	On order	t	t	f	f
10	ILL	f	f	t	f
11	Cataloging	f	f	f	f
12	Reserves	f	t	t	f
13	Discard/Weed	f	f	f	f
14	Damaged	f	f	f	f
15	On reservation shelf	f	f	t	f
\.


--
-- Name: copy_status_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('copy_status_id_seq', 100, true);


--
-- Data for Name: db_patch_dependencies; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY db_patch_dependencies (db_patch, supersedes, deprecates) FROM stdin;
\.


--
-- Data for Name: filter_dialog_filter_set; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY filter_dialog_filter_set (id, name, owning_lib, creator, create_time, interface, filters) FROM stdin;
\.


--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('filter_dialog_filter_set_id_seq', 1, false);


--
-- Data for Name: filter_dialog_interface; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY filter_dialog_interface (key, description) FROM stdin;
url_verify	All Link Checker filter dialogs
\.


--
-- Data for Name: global_flag; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY global_flag (name, value, enabled, label) FROM stdin;
circ.holds.usr_not_requestor	\N	t	Holds: When testing hold matrix matchpoints, use the profile group of the receiving user instead of that of the requestor (affects staff-placed holds)
circ.holds.empty_issuance_ok	\N	t	Holds: Allow holds on empty issuances
ingest.disable_authority_linking	\N	f	Authority Automation: Disable bib-authority link tracking
ingest.disable_authority_auto_update	\N	f	Authority Automation: Disable automatic authority updating (requires link tracking)
cat.bib.use_id_for_tcn	\N	t	Cat: Use Internal ID for TCN Value
history.circ.retention_age	\N	t	Historical Circulation Retention Age
history.circ.retention_count	\N	t	Historical Circulations per Copy
cat.maintain_control_numbers	\N	t	Cat: Maintain 001/003/035 according to the MARC21 specification
circ.opac_renewal.use_original_circ_lib	\N	f	Circ: Use original circulation library on opac renewal instead of user home library
opac.use_autosuggest	opac_visible	t	OPAC: Show auto-completing suggestions dialog under basic search box (put 'opac_visible' into the value field to limit suggestions to OPAC-visible items, or blank the field for a possible performance improvement)
opac.org_unit.non_inherited_visibility	\N	f	Org Units Do Not Inherit Visibility
\.


--
-- Data for Name: hard_due_date; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY hard_due_date (id, name, ceiling_date, forceto, owner) FROM stdin;
\.


--
-- Name: hard_due_date_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('hard_due_date_id_seq', 1, false);


--
-- Data for Name: hard_due_date_values; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY hard_due_date_values (id, hard_due_date, ceiling_date, active_date) FROM stdin;
\.


--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('hard_due_date_values_id_seq', 1, false);


--
-- Data for Name: hold_matrix_matchpoint; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY hold_matrix_matchpoint (id, active, strict_ou_match, user_home_ou, request_ou, pickup_ou, item_owning_ou, item_circ_ou, usr_grp, requestor_grp, circ_modifier, marc_type, marc_form, marc_bib_level, marc_vr_format, juvenile_flag, ref_flag, item_age, holdable, distance_is_from_owner, transit_range, max_holds, include_frozen_holds, stop_blocked_user, age_hold_protect_rule) FROM stdin;
1	t	f	\N	\N	\N	\N	\N	\N	1	\N	\N	\N	\N	\N	\N	\N	\N	t	f	\N	\N	t	f	\N
\.


--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('hold_matrix_matchpoint_id_seq', 1, true);


--
-- Data for Name: hold_matrix_weights; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY hold_matrix_weights (id, name, user_home_ou, request_ou, pickup_ou, item_owning_ou, item_circ_ou, usr_grp, requestor_grp, circ_modifier, marc_type, marc_form, marc_bib_level, marc_vr_format, juvenile_flag, ref_flag, item_age) FROM stdin;
1	Default	5.00	5.00	5.00	5.00	5.00	7.00	8.00	4.00	3.00	2.00	1.00	1.00	4.00	0.00	0.00
2	Item_Owner_First	5.00	5.00	5.00	8.00	7.00	5.00	5.00	4.00	3.00	2.00	1.00	1.00	4.00	0.00	0.00
3	User_Before_Requestor	5.00	5.00	5.00	5.00	5.00	8.00	7.00	4.00	3.00	2.00	1.00	1.00	4.00	0.00	0.00
4	All_Equal	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00
\.


--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('hold_matrix_weights_id_seq', 4, true);


--
-- Data for Name: i18n_core; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY i18n_core (id, fq_field, identity_value, translation, string) FROM stdin;
\.


--
-- Name: i18n_core_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('i18n_core_id_seq', 1, false);


--
-- Data for Name: i18n_locale; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY i18n_locale (code, marc_code, name, description) FROM stdin;
en-US	eng	English (US)	American English
cs-CZ	cze	Czech	Czech
en-CA	eng	English (Canada)	Canadian English
fi-FI	fin	Finnish	Finnish
fr-CA	fre	French (Canada)	Canadian French
hy-AM	arm	Armenian	Armenian
ru-RU	rus	Russian	Russian
\.


--
-- Data for Name: identification_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY identification_type (id, name) FROM stdin;
1	Drivers License
2	SSN
3	Other
\.


--
-- Name: identification_type_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('identification_type_id_seq', 100, true);


--
-- Data for Name: idl_field_doc; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY idl_field_doc (id, fm_class, field, owner, string) FROM stdin;
\.


--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('idl_field_doc_id_seq', 1, false);


--
-- Data for Name: index_normalizer; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY index_normalizer (id, name, description, func, param_count) FROM stdin;
1	NACO Normalize	Apply NACO normalization rules to the extracted text.  See http://www.loc.gov/catdir/pcc/naco/normrule-2.html for details.	naco_normalize	0
2	Normalize date range	Split date ranges in the form of "XXXX-YYYY" into "XXXX YYYY" for proper index.	split_date_range	0
3	NACO Normalize -- retain first comma	Apply NACO normalization rules to the extracted text, retaining the first comma.  See http://www.loc.gov/catdir/pcc/naco/normrule-2.html for details.	naco_normalize_keep_comma	0
4	Strip Diacritics	Convert text to NFD form and remove non-spacing combining marks.	remove_diacritics	0
5	Remove Parenthesized Substring	Remove any parenthesized substrings from the extracted text, such as the agency code preceding authority record control numbers in subfield 0.	remove_paren_substring	0
6	Up-case	Convert text upper case.	uppercase	0
7	Down-case	Convert text lower case.	lowercase	0
8	Extract Dewey-like number	Extract a string of numeric characters that resembles a DDC number.	call_number_dewey	0
9	Left truncation	Discard the specified number of characters from the left side of the string.	left_trunc	1
10	Right truncation	Include only the specified number of characters from the left side of the string.	right_trunc	1
11	First word	Include only the first space-separated word of a string.	first_word	0
12	ISBN 10/13 conversion	Translate ISBN10 to ISBN13 and vice versa.	translate_isbn1013	0
13	Replace	Replace all occurences of first parameter in the string with the second parameter.	replace	2
14	Trim Surrounding Space	Trim leading and trailing spaces from extracted text.	btrim	0
15	Generic Mapping Normalizer	Map values or sets of values to new values	generic_map_normalizer	1
16	Coded Value Map Normalizer	Applies coded_value_map mapping of values	coded_value_map_normalizer	1
17	Search Normalize	Apply search normalization rules to the extracted text. A less extreme version of NACO normalization.	search_normalize	0
\.


--
-- Name: index_normalizer_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('index_normalizer_id_seq', 17, true);


--
-- Data for Name: internal_flag; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY internal_flag (name, value, enabled) FROM stdin;
ingest.metarecord_mapping.skip_on_insert	\N	f
ingest.metarecord_mapping.skip_on_update	\N	f
ingest.reingest.force_on_same_marc	\N	f
ingest.disable_located_uri	\N	f
ingest.disable_metabib_full_rec	\N	f
ingest.disable_metabib_rec_descriptor	\N	f
ingest.disable_metabib_field_entry	\N	f
ingest.assume_inserts_only	\N	f
ingest.skip_browse_indexing	\N	f
ingest.skip_search_indexing	\N	f
ingest.skip_facet_indexing	\N	f
serial.rematerialize_on_same_holding_code	\N	f
ingest.metarecord_mapping.preserve_on_delete	\N	f
\.


--
-- Data for Name: marc21_ff_pos_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY marc21_ff_pos_map (id, fixed_field, tag, rec_type, start_pos, length, default_val) FROM stdin;
1	Alph	006	SER	16	1	 
2	Alph	008	SER	33	1	 
3	Audn	006	BKS	5	1	 
4	Audn	006	COM	5	1	 
5	Audn	006	REC	5	1	 
6	Audn	006	SCO	5	1	 
7	Audn	006	SER	5	1	 
8	Audn	006	VIS	5	1	 
9	Audn	008	BKS	22	1	 
10	Audn	008	COM	22	1	 
11	Audn	008	REC	22	1	 
12	Audn	008	SCO	22	1	 
13	Audn	008	SER	22	1	 
14	Audn	008	VIS	22	1	 
15	BLvl	ldr	BKS	7	1	m
16	BLvl	ldr	COM	7	1	m
17	BLvl	ldr	MAP	7	1	m
18	BLvl	ldr	MIX	7	1	c
19	BLvl	ldr	REC	7	1	m
20	BLvl	ldr	SCO	7	1	m
21	BLvl	ldr	SER	7	1	s
22	BLvl	ldr	VIS	7	1	m
23	Biog	006	BKS	17	1	 
24	Biog	008	BKS	34	1	 
25	Conf	006	BKS	11	1	 
26	Conf	006	SER	11	1	 
27	Conf	008	BKS	29	1	 
28	Conf	008	SER	29	1	 
29	Cont	006	BKS	7	4	 
30	Cont	006	SER	8	3	 
31	Cont	008	BKS	24	4	 
32	Cont	008	SER	25	3	 
33	Ctrl	ldr	BKS	8	1	 
34	Ctrl	ldr	COM	8	1	 
35	Ctrl	ldr	MAP	8	1	 
36	Ctrl	ldr	MIX	8	1	 
37	Ctrl	ldr	REC	8	1	 
38	Ctrl	ldr	SCO	8	1	 
39	Ctrl	ldr	SER	8	1	 
40	Ctrl	ldr	VIS	8	1	 
41	Ctry	008	BKS	15	3	 
42	Ctry	008	COM	15	3	 
43	Ctry	008	MAP	15	3	 
44	Ctry	008	MIX	15	3	 
45	Ctry	008	REC	15	3	 
46	Ctry	008	SCO	15	3	 
47	Ctry	008	SER	15	3	 
48	Ctry	008	VIS	15	3	 
49	Date1	008	BKS	7	4	 
50	Date1	008	COM	7	4	 
51	Date1	008	MAP	7	4	 
52	Date1	008	MIX	7	4	 
53	Date1	008	REC	7	4	 
54	Date1	008	SCO	7	4	 
55	Date1	008	SER	7	4	 
56	Date1	008	VIS	7	4	 
57	Date2	008	BKS	11	4	 
58	Date2	008	COM	11	4	 
59	Date2	008	MAP	11	4	 
60	Date2	008	MIX	11	4	 
61	Date2	008	REC	11	4	 
62	Date2	008	SCO	11	4	 
63	Date2	008	SER	11	4	9
64	Date2	008	VIS	11	4	 
65	Desc	ldr	BKS	18	1	 
66	Desc	ldr	COM	18	1	 
67	Desc	ldr	MAP	18	1	 
68	Desc	ldr	MIX	18	1	 
69	Desc	ldr	REC	18	1	 
70	Desc	ldr	SCO	18	1	 
71	Desc	ldr	SER	18	1	 
72	Desc	ldr	VIS	18	1	 
73	DtSt	008	BKS	6	1	 
74	DtSt	008	COM	6	1	 
75	DtSt	008	MAP	6	1	 
76	DtSt	008	MIX	6	1	 
77	DtSt	008	REC	6	1	 
78	DtSt	008	SCO	6	1	 
79	DtSt	008	SER	6	1	c
80	DtSt	008	VIS	6	1	 
81	ELvl	ldr	BKS	17	1	 
82	ELvl	ldr	COM	17	1	 
83	ELvl	ldr	MAP	17	1	 
84	ELvl	ldr	MIX	17	1	 
85	ELvl	ldr	REC	17	1	 
86	ELvl	ldr	SCO	17	1	 
87	ELvl	ldr	SER	17	1	 
88	ELvl	ldr	VIS	17	1	 
89	ELvl	ldr	AUT	17	1	 
90	Fest	006	BKS	13	1	0
91	Fest	008	BKS	30	1	0
92	Form	006	BKS	6	1	 
93	Form	006	MAP	12	1	 
94	Form	006	MIX	6	1	 
95	Form	006	REC	6	1	 
96	Form	006	SCO	6	1	 
97	Form	006	SER	6	1	 
98	Form	006	VIS	12	1	 
99	Form	008	BKS	23	1	 
100	Form	008	MAP	29	1	 
101	Form	008	MIX	23	1	 
102	Form	008	REC	23	1	 
103	Form	008	SCO	23	1	 
104	Form	008	SER	23	1	 
105	Form	008	VIS	29	1	 
106	GPub	006	BKS	11	1	 
107	GPub	006	COM	11	1	 
108	GPub	006	MAP	11	1	 
109	GPub	006	SER	11	1	 
110	GPub	006	VIS	11	1	 
111	GPub	008	BKS	28	1	 
112	GPub	008	COM	28	1	 
113	GPub	008	MAP	28	1	 
114	GPub	008	SER	28	1	 
115	GPub	008	VIS	28	1	 
116	Ills	006	BKS	1	4	 
117	Ills	008	BKS	18	4	 
118	Indx	006	BKS	14	1	0
119	Indx	006	MAP	14	1	0
120	Indx	008	BKS	31	1	0
121	Indx	008	MAP	31	1	0
122	Lang	008	BKS	35	3	 
123	Lang	008	COM	35	3	 
124	Lang	008	MAP	35	3	 
125	Lang	008	MIX	35	3	 
126	Lang	008	REC	35	3	 
127	Lang	008	SCO	35	3	 
128	Lang	008	SER	35	3	 
129	Lang	008	VIS	35	3	 
130	LitF	006	BKS	16	1	0
131	LitF	008	BKS	33	1	0
132	MRec	008	BKS	38	1	 
133	MRec	008	COM	38	1	 
134	MRec	008	MAP	38	1	 
135	MRec	008	MIX	38	1	 
136	MRec	008	REC	38	1	 
137	MRec	008	SCO	38	1	 
138	MRec	008	SER	38	1	 
139	MRec	008	VIS	38	1	 
140	S/L	006	SER	17	1	0
141	S/L	008	SER	34	1	0
142	TMat	006	VIS	16	1	 
143	TMat	008	VIS	33	1	 
144	Type	ldr	BKS	6	1	a
145	Type	ldr	COM	6	1	m
146	Type	ldr	MAP	6	1	e
147	Type	ldr	MIX	6	1	p
148	Type	ldr	REC	6	1	i
149	Type	ldr	SCO	6	1	c
150	Type	ldr	SER	6	1	a
151	Type	ldr	VIS	6	1	g
152	Subj	008	AUT	11	1	|
153	RecStat	ldr	AUT	5	1	n
\.


--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('marc21_ff_pos_map_id_seq', 153, true);


--
-- Data for Name: marc21_physical_characteristic_subfield_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY marc21_physical_characteristic_subfield_map (id, ptype_key, subfield, start_pos, length, label) FROM stdin;
1	a	b	1	1	SMD
2	a	d	3	1	Color
3	a	e	4	1	Physical medium
4	a	f	5	1	Type of reproduction
5	a	g	6	1	Production/reproduction details
6	a	h	7	1	Positive/negative
7	c	b	1	1	SMD
8	c	d	3	1	Color
9	c	e	4	1	Dimensions
10	c	f	5	1	Sound
11	c	g	6	3	Image bit depth
12	c	h	9	1	File formats
13	c	i	10	1	Quality assurance target(s)
14	c	j	11	1	Antecedent/Source
15	c	k	12	1	Level of compression
16	c	l	13	1	Reformatting quality
17	d	b	1	1	SMD
18	d	d	3	1	Color
19	d	e	4	1	Physical medium
20	d	f	5	1	Type of reproduction
21	f	b	1	1	SMD
22	f	d	3	2	Class of braille writing
23	f	e	4	1	Level of contraction
24	f	f	6	3	Braille music format
25	f	g	9	1	Special physical characteristics
26	g	b	1	1	SMD
27	g	d	3	1	Color
28	g	e	4	1	Base of emulsion
29	g	f	5	1	Sound on medium or separate
30	g	g	6	1	Medium for sound
31	g	h	7	1	Dimensions
32	g	i	8	1	Secondary support material
33	h	b	1	1	SMD
34	h	d	3	1	Positive/negative
35	h	e	4	1	Dimensions
36	h	f	5	4	Reduction ratio range/Reduction ratio
37	h	g	9	1	Color
38	h	h	10	1	Emulsion on film
39	h	i	11	1	Quality assurance target(s)
40	h	j	12	1	Base of film
41	k	b	1	1	SMD
42	k	d	3	1	Color
43	k	e	4	1	Primary support material
44	k	f	5	1	Secondary support material
45	m	b	1	1	SMD
46	m	d	3	1	Color
47	m	e	4	1	Motion picture presentation format
48	m	f	5	1	Sound on medium or separate
49	m	g	6	1	Medium for sound
50	m	h	7	1	Dimensions
51	m	i	8	1	Configuration of playback channels
52	m	j	9	1	Production elements
53	r	b	1	1	SMD
54	r	d	3	1	Altitude of sensor
55	r	e	4	1	Attitude of sensor
56	r	f	5	1	Cloud cover
57	r	g	6	1	Platform construction type
58	r	h	7	1	Platform use category
59	r	i	8	1	Sensor type
60	r	j	9	2	Data type
61	s	b	1	1	SMD
62	s	d	3	1	Speed
63	s	e	4	1	Configuration of playback channels
64	s	f	5	1	Groove width or pitch
65	s	g	6	1	Dimensions
66	s	h	7	1	Tape width
67	s	i	8	1	Tape configuration 
68	s	m	12	1	Special playback
69	s	n	13	1	Capture and storage
70	v	b	1	1	SMD
71	v	d	3	1	Color
72	v	e	4	1	Videorecording format
73	v	f	5	1	Sound on medium or separate
74	v	g	6	1	Medium for sound
75	v	h	7	1	Dimensions
76	v	i	8	1	Configuration of playback channel
\.


--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('marc21_physical_characteristic_subfield_map_id_seq', 76, true);


--
-- Data for Name: marc21_physical_characteristic_type_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY marc21_physical_characteristic_type_map (ptype_key, label) FROM stdin;
a	Map
c	Electronic Resource
d	Globe
f	Tactile Material
g	Projected Graphic
h	Microform
k	Non-projected Graphic
m	Motion Picture
r	Remote-sensing Image
s	Sound Recording
v	Videorecording
\.


--
-- Data for Name: marc21_physical_characteristic_value_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY marc21_physical_characteristic_value_map (id, value, ptype_subfield, label) FROM stdin;
1	d	1	Atlas
2	g	1	Diagram
3	j	1	Map
4	k	1	Profile
5	q	1	Model
6	r	1	Remote-sensing image
7	s	1	Section
8	u	1	Unspecified
9	y	1	View
10	z	1	Other
11	a	2	One color
12	c	2	Multicolored
13	a	3	Paper
14	b	3	Wood
15	c	3	Stone
16	d	3	Metal
17	e	3	Synthetics
18	f	3	Skins
19	g	3	Textile
20	p	3	Plaster
21	q	3	Flexible base photographic medium, positive
22	r	3	Flexible base photographic medium, negative
23	s	3	Non-flexible base photographic medium, positive
24	t	3	Non-flexible base photographic medium, negative
25	u	3	Unknown
26	y	3	Other photographic medium
27	z	3	Other
28	f	4	Facsimile
29	n	4	Not applicable
30	u	4	Unknown
31	z	4	Other
32	a	5	Photocopy, blueline print
33	b	5	Photocopy
34	c	5	Pre-production
35	d	5	Film
36	u	5	Unknown
37	z	5	Other
38	a	6	Positive
39	b	6	Negative
40	m	6	Mixed
41	n	6	Not applicable
42	a	7	Tape Cartridge
43	b	7	Chip cartridge
44	c	7	Computer optical disk cartridge
45	f	7	Tape cassette
46	h	7	Tape reel
47	j	7	Magnetic disk
48	m	7	Magneto-optical disk
49	o	7	Optical disk
50	r	7	Remote
51	u	7	Unspecified
52	z	7	Other
53	a	8	One color
54	b	8	Black-and-white
55	c	8	Multicolored
56	g	8	Gray scale
57	m	8	Mixed
58	n	8	Not applicable
59	u	8	Unknown
60	z	8	Other
61	a	9	3 1/2 in.
62	e	9	12 in.
63	g	9	4 3/4 in. or 12 cm.
64	i	9	1 1/8 x 2 3/8 in.
65	j	9	3 7/8 x 2 1/2 in.
66	n	9	Not applicable
67	o	9	5 1/4 in.
68	u	9	Unknown
69	v	9	8 in.
70	z	9	Other
71	 	10	No sound (Silent)
72	a	10	Sound
73	u	10	Unknown
74	---	11	Unknown
75	mmm	11	Multiple
76	nnn	11	Not applicable
77	a	12	One file format
78	m	12	Multiple file formats
79	u	12	Unknown
80	a	13	Absent
81	n	13	Not applicable
82	p	13	Present
83	u	13	Unknown
84	a	14	File reproduced from original
85	b	14	File reproduced from microform
86	c	14	File reproduced from electronic resource
87	d	14	File reproduced from an intermediate (not microform)
88	m	14	Mixed
89	n	14	Not applicable
90	u	14	Unknown
91	a	15	Uncompressed
92	b	15	Lossless
93	d	15	Lossy
94	m	15	Mixed
95	u	15	Unknown
96	a	16	Access
97	n	16	Not applicable
98	p	16	Preservation
99	r	16	Replacement
100	u	16	Unknown
101	a	17	Celestial globe
102	b	17	Planetary or lunar globe
103	c	17	Terrestrial globe
104	e	17	Earth moon globe
105	u	17	Unspecified
106	z	17	Other
107	a	18	One color
108	c	18	Multicolored
109	a	19	Paper
110	b	19	Wood
111	c	19	Stone
112	d	19	Metal
113	e	19	Synthetics
114	f	19	Skins
115	g	19	Textile
116	p	19	Plaster
117	u	19	Unknown
118	z	19	Other
119	f	20	Facsimile
120	n	20	Not applicable
121	u	20	Unknown
122	z	20	Other
123	a	21	Moon
124	b	21	Braille
125	c	21	Combination
126	d	21	Tactile, with no writing system
127	u	21	Unspecified
128	z	21	Other
129	a	22	Literary braille
130	b	22	Format code braille
131	c	22	Mathematics and scientific braille
132	d	22	Computer braille
133	e	22	Music braille
134	m	22	Multiple braille types
135	n	22	Not applicable
136	u	22	Unknown
137	z	22	Other
138	a	23	Uncontracted
139	b	23	Contracted
140	m	23	Combination
141	n	23	Not applicable
142	u	23	Unknown
143	z	23	Other
144	a	24	Bar over bar
145	b	24	Bar by bar
146	c	24	Line over line
147	d	24	Paragraph
148	e	24	Single line
149	f	24	Section by section
150	g	24	Line by line
151	h	24	Open score
152	i	24	Spanner short form scoring
153	j	24	Short form scoring
154	k	24	Outline
155	l	24	Vertical score
156	n	24	Not applicable
157	u	24	Unknown
158	z	24	Other
159	a	25	Print/braille
160	b	25	Jumbo or enlarged braille
161	n	25	Not applicable
162	u	25	Unknown
163	z	25	Other
164	c	26	Film cartridge
165	d	26	Filmstrip
166	f	26	Film filmstrip type
167	o	26	Filmstrip roll
168	s	26	Slide
169	t	26	Transparency
170	z	26	Other
171	b	27	Black-and-white
172	c	27	Multicolored
173	h	27	Hand-colored
174	m	27	Mixed
175	n	27	Not applicable
176	u	27	Unknown
177	z	27	Other
178	d	28	Glass
179	e	28	Synthetics
180	j	28	Safety film
181	k	28	Film base, other than safety film
182	m	28	Mixed collection
183	o	28	Paper
184	u	28	Unknown
185	z	28	Other
186	a	29	Sound on medium
187	b	29	Sound separate from medium
188	u	29	Unknown
189	a	30	Optical sound track on motion picture film
190	b	30	Magnetic sound track on motion picture film
191	c	30	Magnetic audio tape in cartridge
192	d	30	Sound disc
193	e	30	Magnetic audio tape on reel
194	f	30	Magnetic audio tape in cassette
195	g	30	Optical and magnetic sound track on film
196	h	30	Videotape
197	i	30	Videodisc
198	u	30	Unknown
199	z	30	Other
200	a	31	Standard 8 mm.
201	b	31	Super 8 mm./single 8 mm.
202	c	31	9.5 mm.
203	d	31	16 mm.
204	e	31	28 mm.
205	f	31	35 mm.
206	g	31	70 mm.
207	j	31	2 x 2 in. (5 x 5 cm.)
208	k	31	2 1/4 x 2 1/4 in. (6 x 6 cm.)
209	s	31	4 x 5 in. (10 x 13 cm.)
210	t	31	5 x 7 in. (13 x 18 cm.)
211	u	31	Unknown
212	v	31	8 x 10 in. (21 x 26 cm.)
213	w	31	9 x 9 in. (23 x 23 cm.)
214	x	31	10 x 10 in. (26 x 26 cm.)
215	y	31	7 x 7 in. (18 x 18 cm.)
216	z	31	Other
217	c	32	Cardboard
218	d	32	Glass
219	e	32	Synthetics
220	h	32	metal
221	j	32	Metal and glass
222	k	32	Synthetics and glass
223	m	32	Mixed collection
224	u	32	Unknown
225	z	32	Other
226	a	33	Aperture card
227	b	33	Microfilm cartridge
228	c	33	Microfilm cassette
229	d	33	Microfilm reel
230	e	33	Microfiche
231	f	33	Microfiche cassette
232	g	33	Microopaque
233	u	33	Unspecified
234	z	33	Other
235	a	34	Positive
236	b	34	Negative
237	m	34	Mixed
238	u	34	Unknown
239	a	35	8 mm.
240	e	35	16 mm.
241	f	35	35 mm.
242	g	35	70mm.
243	h	35	105 mm.
244	l	35	3 x 5 in. (8 x 13 cm.)
245	m	35	4 x 6 in. (11 x 15 cm.)
246	o	35	6 x 9 in. (16 x 23 cm.)
247	p	35	3 1/4 x 7 3/8 in. (9 x 19 cm.)
248	u	35	Unknown
249	z	35	Other
250	a	36	Low (1-16x)
251	b	36	Normal (16-30x)
252	c	36	High (31-60x)
253	d	36	Very high (61-90x)
254	e	36	Ultra (90x-)
255	u	36	Unknown
256	v	36	Reduction ratio varies
257	b	37	Black-and-white
258	c	37	Multicolored
259	m	37	Mixed
260	u	37	Unknown
261	z	37	Other
262	a	38	Silver halide
263	b	38	Diazo
264	c	38	Vesicular
265	m	38	Mixed
266	n	38	Not applicable
267	u	38	Unknown
268	z	38	Other
269	a	39	1st gen. master
270	b	39	Printing master
271	c	39	Service copy
272	m	39	Mixed generation
273	u	39	Unknown
274	a	40	Safety base, undetermined
275	c	40	Safety base, acetate undetermined
276	d	40	Safety base, diacetate
277	l	40	Nitrate base
278	m	40	Mixed base
279	n	40	Not applicable
280	p	40	Safety base, polyester
281	r	40	Safety base, mixed
282	t	40	Safety base, triacetate
283	u	40	Unknown
284	z	40	Other
285	c	41	Collage
286	d	41	Drawing
287	e	41	Painting
288	f	41	Photo-mechanical print
289	g	41	Photonegative
290	h	41	Photoprint
291	i	41	Picture
292	j	41	Print
293	l	41	Technical drawing
294	n	41	Chart
295	o	41	Flash/activity card
296	u	41	Unspecified
297	z	41	Other
298	a	42	One color
299	b	42	Black-and-white
300	c	42	Multicolored
301	h	42	Hand-colored
302	m	42	Mixed
303	u	42	Unknown
304	z	42	Other
305	a	43	Canvas
306	b	43	Bristol board
307	c	43	Cardboard/illustration board
308	d	43	Glass
309	e	43	Synthetics
310	f	43	Skins
311	g	43	Textile
312	h	43	Metal
313	m	43	Mixed collection
314	o	43	Paper
315	p	43	Plaster
316	q	43	Hardboard
317	r	43	Porcelain
318	s	43	Stone
319	t	43	Wood
320	u	43	Unknown
321	z	43	Other
322	a	44	Canvas
323	b	44	Bristol board
324	c	44	Cardboard/illustration board
325	d	44	Glass
326	e	44	Synthetics
327	f	44	Skins
328	g	44	Textile
329	h	44	Metal
330	m	44	Mixed collection
331	o	44	Paper
332	p	44	Plaster
333	q	44	Hardboard
334	r	44	Porcelain
335	s	44	Stone
336	t	44	Wood
337	u	44	Unknown
338	z	44	Other
339	a	45	Film cartridge
340	f	45	Film cassette
341	r	45	Film reel
342	u	45	Unspecified
343	z	45	Other
344	b	46	Black-and-white
345	c	46	Multicolored
346	h	46	Hand-colored
347	m	46	Mixed
348	u	46	Unknown
349	z	46	Other
350	a	47	Standard sound aperture, reduced frame
351	b	47	Nonanamorphic (wide-screen)
352	c	47	3D
353	d	47	Anamorphic (wide-screen)
354	e	47	Other-wide screen format
355	f	47	Standard. silent aperture, full frame
356	u	47	Unknown
357	z	47	Other
358	a	48	Sound on medium
359	b	48	Sound separate from medium
360	u	48	Unknown
361	a	49	Optical sound track on motion picture film
362	b	49	Magnetic sound track on motion picture film
363	c	49	Magnetic audio tape in cartridge
364	d	49	Sound disc
365	e	49	Magnetic audio tape on reel
366	f	49	Magnetic audio tape in cassette
367	g	49	Optical and magnetic sound track on film
368	h	49	Videotape
369	i	49	Videodisc
370	u	49	Unknown
371	z	49	Other
372	a	50	Standard 8 mm.
373	b	50	Super 8 mm./single 8 mm.
374	c	50	9.5 mm.
375	d	50	16 mm.
376	e	50	28 mm.
377	f	50	35 mm.
378	g	50	70 mm.
379	u	50	Unknown
380	z	50	Other
381	k	51	Mixed
382	m	51	Monaural
383	n	51	Not applicable
384	q	51	Multichannel, surround or quadraphonic
385	s	51	Stereophonic
386	u	51	Unknown
387	z	51	Other
388	a	52	Work print
389	b	52	Trims
390	c	52	Outtakes
391	d	52	Rushes
392	e	52	Mixing tracks
393	f	52	Title bands/inter-title rolls
394	g	52	Production rolls
395	n	52	Not applicable
396	z	52	Other
397	u	53	Unspecified
398	a	54	Surface
399	b	54	Airborne
400	c	54	Spaceborne
401	n	54	Not applicable
402	u	54	Unknown
403	z	54	Other
404	a	55	Low oblique
405	b	55	High oblique
406	c	55	Vertical
407	n	55	Not applicable
408	u	55	Unknown
409	0	56	0-09%
410	1	56	10-19%
411	2	56	20-29%
412	3	56	30-39%
413	4	56	40-49%
414	5	56	50-59%
415	6	56	60-69%
416	7	56	70-79%
417	8	56	80-89%
418	9	56	90-100%
419	n	56	Not applicable
420	u	56	Unknown
421	a	57	Balloon
422	b	57	Aircraft-low altitude
423	c	57	Aircraft-medium altitude
424	d	57	Aircraft-high altitude
425	e	57	Manned spacecraft
426	f	57	Unmanned spacecraft
427	g	57	Land-based remote-sensing device
428	h	57	Water surface-based remote-sensing device
429	i	57	Submersible remote-sensing device
430	n	57	Not applicable
431	u	57	Unknown
432	z	57	Other
433	a	58	Meteorological
434	b	58	Surface observing
435	c	58	Space observing
436	m	58	Mixed uses
437	n	58	Not applicable
438	u	58	Unknown
439	z	58	Other
440	a	59	Active
441	b	59	Passive
442	u	59	Unknown
443	z	59	Other
444	aa	60	Visible light
445	da	60	Near infrared
446	db	60	Middle infrared
447	dc	60	Far infrared
448	dd	60	Thermal infrared
449	de	60	Shortwave infrared (SWIR)
450	df	60	Reflective infrared
451	dv	60	Combinations
452	dz	60	Other infrared data
453	ga	60	Sidelooking airborne radar (SLAR)
454	gb	60	Synthetic aperture radar (SAR-single frequency)
455	gc	60	SAR-multi-frequency (multichannel)
456	gd	60	SAR-like polarization
457	ge	60	SAR-cross polarization
458	gf	60	Infometric SAR
459	gg	60	Polarmetric SAR
460	gu	60	Passive microwave mapping
461	gz	60	Other microwave data
462	ja	60	Far ultraviolet
463	jb	60	Middle ultraviolet
464	jc	60	Near ultraviolet
465	jv	60	Ultraviolet combinations
466	jz	60	Other ultraviolet data
467	ma	60	Multi-spectral, multidata
468	mb	60	Multi-temporal
469	mm	60	Combination of various data types
470	nn	60	Not applicable
471	pa	60	Sonar-water depth
472	pb	60	Sonar-bottom topography images, sidescan
473	pc	60	Sonar-bottom topography, near-surface
474	pd	60	Sonar-bottom topography, near-bottom
475	pe	60	Seismic surveys
476	pz	60	Other acoustical data
477	ra	60	Gravity anomales (general)
478	rb	60	Free-air
479	rc	60	Bouger
480	rd	60	Isostatic
481	sa	60	Magnetic field
482	ta	60	Radiometric surveys
483	uu	60	Unknown
484	zz	60	Other
485	d	61	Sound disc
486	e	61	Cylinder
487	g	61	Sound cartridge
488	i	61	Sound-track film
489	q	61	Roll
490	s	61	Sound cassette
491	t	61	Sound-tape reel
492	u	61	Unspecified
493	w	61	Wire recording
494	z	61	Other
495	a	62	16 rpm
496	b	62	33 1/3 rpm
497	c	62	45 rpm
498	d	62	78 rpm
499	e	62	8 rpm
500	f	62	1.4 mps
501	h	62	120 rpm
502	i	62	160 rpm
503	k	62	15/16 ips
504	l	62	1 7/8 ips
505	m	62	3 3/4 ips
506	o	62	7 1/2 ips
507	p	62	15 ips
508	r	62	30 ips
509	u	62	Unknown
510	z	62	Other
511	m	63	Monaural
512	q	63	Quadraphonic
513	s	63	Stereophonic
514	u	63	Unknown
515	z	63	Other
516	m	64	Microgroove/fine
517	n	64	Not applicable
518	s	64	Coarse/standard
519	u	64	Unknown
520	z	64	Other
521	a	65	3 in.
522	b	65	5 in.
523	c	65	7 in.
524	d	65	10 in.
525	e	65	12 in.
526	f	65	16 in.
527	g	65	4 3/4 in. (12 cm.)
528	j	65	3 7/8 x 2 1/2 in.
529	n	65	Not applicable
530	o	65	5 1/4 x 3 7/8 in.
531	s	65	2 3/4 x 4 in.
532	u	65	Unknown
533	z	65	Other
534	l	66	1/8 in.
535	m	66	1/4in.
536	n	66	Not applicable
537	o	66	1/2 in.
538	p	66	1 in.
539	u	66	Unknown
540	z	66	Other
541	a	67	Full (1) track
542	b	67	Half (2) track
543	c	67	Quarter (4) track
544	d	67	8 track
545	e	67	12 track
546	f	67	16 track
547	n	67	Not applicable
548	u	67	Unknown
549	z	67	Other
550	a	68	NAB standard
551	b	68	CCIR standard
552	c	68	Dolby-B encoded, standard Dolby
553	d	68	dbx encoded
554	e	68	Digital recording
555	f	68	Dolby-A encoded
556	g	68	Dolby-C encoded
557	h	68	CX encoded
558	n	68	Not applicable
559	u	68	Unknown
560	z	68	Other
561	a	69	Acoustical capture, direct storage
562	b	69	Direct storage, not acoustical
563	d	69	Digital storage
564	e	69	Analog electrical storage
565	u	69	Unknown
566	z	69	Other
567	c	70	Videocartridge
568	d	70	Videodisc
569	f	70	Videocassette
570	r	70	Videoreel
571	u	70	Unspecified
572	z	70	Other
573	b	71	Black-and-white
574	c	71	Multicolored
575	m	71	Mixed
576	n	71	Not applicable
577	u	71	Unknown
578	z	71	Other
579	a	72	Beta
580	b	72	VHS
581	c	72	U-matic
582	d	72	EIAJ
583	e	72	Type C
584	f	72	Quadruplex
585	g	72	Laserdisc
586	h	72	CED
587	i	72	Betacam
588	j	72	Betacam SP
589	k	72	Super-VHS
590	m	72	M-II
591	o	72	D-2
592	p	72	8 mm.
593	q	72	Hi-8 mm.
594	s	72	Blu-ray
595	u	72	Unknown
596	v	72	DVD
597	z	72	Other
598	a	73	Sound on medium
599	b	73	Sound separate from medium
600	u	73	Unknown
601	a	74	Optical sound track on motion picture film
602	b	74	Magnetic sound track on motion picture film
603	c	74	Magnetic audio tape in cartridge
604	d	74	Sound disc
605	e	74	Magnetic audio tape on reel
606	f	74	Magnetic audio tape in cassette
607	g	74	Optical and magnetic sound track on motion picture film
608	h	74	Videotape
609	i	74	Videodisc
610	u	74	Unknown
611	z	74	Other
612	a	75	8 mm.
613	m	75	1/4 in.
614	o	75	1/2 in.
615	p	75	1 in.
616	q	75	2 in.
617	r	75	3/4 in.
618	u	75	Unknown
619	z	75	Other
620	k	76	Mixed
621	m	76	Monaural
622	n	76	Not applicable
623	q	76	Multichannel, surround or quadraphonic
624	s	76	Stereophonic
625	u	76	Unknown
626	z	76	Other
\.


--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('marc21_physical_characteristic_value_map_id_seq', 626, true);


--
-- Data for Name: marc21_rec_type_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY marc21_rec_type_map (code, type_val, blvl_val) FROM stdin;
BKS	at	acdm
SER	a	bsi
VIS	gkro	abcdmsi
MIX	p	cdi
MAP	ef	abcdmsi
SCO	cd	abcdmsi
REC	ij	abcdmsi
COM	m	abcdmsi
AUT	z	 
MFHD	uvxy	 
\.


--
-- Data for Name: metabib_class; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_class (name, label, buoyant, restrict, combined, a_weight, b_weight, c_weight, d_weight) FROM stdin;
identifier	Identifier	f	f	f	1.0	0.4	0.2	0.1
keyword	Keyword	f	f	f	1.0	0.4	0.2	0.1
title	Title	f	f	f	1.0	0.4	0.2	0.1
author	Author	f	f	f	1.0	0.4	0.2	0.1
subject	Subject	f	f	f	1.0	0.4	0.2	0.1
series	Series	f	f	f	1.0	0.4	0.2	0.1
\.


--
-- Data for Name: metabib_class_ts_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_class_ts_map (id, field_class, ts_config, active, index_weight, index_lang, search_lang, always) FROM stdin;
1	keyword	simple	t	A	\N	\N	t
2	keyword	english_nostop	t	C	\N	\N	t
3	title	simple	t	A	\N	\N	t
4	title	english_nostop	t	C	\N	\N	t
5	author	simple	t	A	\N	\N	t
6	author	english_nostop	t	C	\N	\N	t
7	series	simple	t	A	\N	\N	t
8	series	english_nostop	t	C	\N	\N	t
9	subject	simple	t	A	\N	\N	t
10	subject	english_nostop	t	C	\N	\N	t
11	identifier	simple	t	A	\N	\N	t
\.


--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('metabib_class_ts_map_id_seq', 11, true);


--
-- Data for Name: metabib_field; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_field (id, field_class, name, label, xpath, weight, format, search_field, facet_field, browse_field, browse_xpath, facet_xpath, restrict) FROM stdin;
1	series	seriestitle	Series Title	//mods32:mods/mods32:relatedItem[@type="series"]/mods32:titleInfo	1	mods32	t	t	t	\N	\N	f
2	title	abbreviated	Abbreviated Title	//mods32:mods/mods32:titleInfo[mods32:title and (@type='abbreviated')]	1	mods32	t	f	t	\N	\N	f
3	title	translated	Translated Title	//mods32:mods/mods32:titleInfo[mods32:title and (@type='translated')]	1	mods32	t	f	t	\N	\N	f
4	title	alternative	Alternate Title	//mods32:mods/mods32:titleInfo[mods32:title and (@type='alternative')]	1	mods32	t	f	t	\N	\N	f
5	title	uniform	Uniform Title	//mods32:mods/mods32:titleInfo[mods32:title and (@type='uniform')]	1	mods32	t	f	t	\N	\N	f
6	title	proper	Title Proper	//mods32:mods/mods32:titleNonfiling[mods32:title and not (@type)]	1	mods32	t	f	t	\N	\N	f
7	author	corporate	Corporate Author	//mods32:mods/mods32:name[@type='corporate' and (mods32:role/mods32:roleTerm[text()='creator'] or mods32:role/mods32:roleTerm[text()='aut'] or mods32:role/mods32:roleTerm[text()='cre'])]	1	mods32	t	t	t	\N	//*[local-name()='namePart']	f
8	author	personal	Personal Author	//mods32:mods/mods32:name[@type='personal' and mods32:role/mods32:roleTerm[text()='creator']]	1	mods32	t	t	t	\N	//*[local-name()='namePart']	f
9	author	conference	Conference Author	//mods32:mods/mods32:name[@type='conference' and mods32:role/mods32:roleTerm[text()='creator']]	1	mods32	t	t	t	\N	//*[local-name()='namePart']	f
10	author	other	Other Author	//mods32:mods/mods32:name[@type='personal' and not(mods32:role/mods32:roleTerm[text()='creator'])]	1	mods32	t	t	t	\N	//*[local-name()='namePart']	f
11	subject	geographic	Geographic Subject	//mods32:mods/mods32:subject/mods32:geographic	1	mods32	t	t	t	\N	\N	f
12	subject	name	Name Subject	//mods32:mods/mods32:subject/mods32:name	1	mods32	t	t	t	\N	//*[local-name()='namePart']	f
13	subject	temporal	Temporal Subject	//mods32:mods/mods32:subject/mods32:temporal	1	mods32	t	t	t	\N	\N	f
14	subject	topic	Topic Subject	//mods32:mods/mods32:subject/mods32:topic	1	mods32	t	t	t	\N	\N	f
15	keyword	keyword	General Keywords	//mods32:mods/*[not(local-name()='originInfo')]	1	mods32	t	f	f	\N	\N	f
16	subject	complete	All Subjects	//mods32:mods/mods32:subject	1	mods32	t	f	f	\N	\N	f
17	identifier	accession	Accession Number	//marc:controlfield[@tag='001']	1	marcxml	t	f	f	\N	\N	f
18	identifier	isbn	ISBN	//marc:datafield[@tag='020']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
19	identifier	issn	ISSN	//marc:datafield[@tag='022']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
20	identifier	upc	UPC	//marc:datafield[@tag='024' and @ind1='1']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
21	identifier	ismn	ISMN	//marc:datafield[@tag='024' and @ind1='2']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
22	identifier	ean	EAN	//marc:datafield[@tag='024' and @ind1='3']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
23	identifier	isrc	ISRC	//marc:datafield[@tag='024' and @ind1='0']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
24	identifier	sici	SICI	//marc:datafield[@tag='024' and @ind1='4']/marc:subfield[@code='a' or @code='z']	1	marcxml	t	f	f	\N	\N	f
25	identifier	bibcn	Local Free-Text Call Number	//marc:datafield[@tag='099']	1	marcxml	t	f	f	\N	\N	f
26	identifier	tcn	Title Control Number	//marc:datafield[@tag='901']/marc:subfield[@code='a']	1	marcxml	t	f	f	\N	\N	f
27	identifier	bibid	Internal ID	//marc:datafield[@tag='901']/marc:subfield[@code='c']	1	marcxml	t	f	f	\N	\N	f
28	identifier	authority_id	Authority Record ID	//marc:datafield/marc:subfield[@code="0"]	1	marcxml	f	t	f	\N	\N	f
29	identifier	scn	System Control Number	//marc:datafield[@tag='035']/marc:subfield[@code="a"]	1	marcxml	t	f	f	\N	\N	f
30	identifier	lccn	LC Control Number	//marc:datafield[@tag='010']/marc:subfield[@code="a" or @code='z']	1	marcxml	t	f	f	\N	\N	f
\.


--
-- Name: metabib_field_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('metabib_field_id_seq', 30, true);


--
-- Data for Name: metabib_field_index_norm_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_field_index_norm_map (id, field, norm, params, pos) FROM stdin;
1	1	2	\N	0
2	1	17	\N	0
3	2	2	\N	0
4	2	17	\N	0
5	3	2	\N	0
6	3	17	\N	0
7	4	2	\N	0
8	4	17	\N	0
9	5	2	\N	0
10	5	17	\N	0
11	6	2	\N	0
12	6	17	\N	0
13	7	2	\N	0
14	7	17	\N	0
15	8	2	\N	0
16	8	17	\N	0
17	9	2	\N	0
18	9	17	\N	0
19	10	2	\N	0
20	10	17	\N	0
21	11	2	\N	0
22	11	17	\N	0
23	12	2	\N	0
24	12	17	\N	0
25	13	2	\N	0
26	13	17	\N	0
27	14	2	\N	0
28	14	17	\N	0
29	15	2	\N	0
30	15	17	\N	0
31	16	2	\N	0
32	16	17	\N	0
33	17	2	\N	0
34	17	17	\N	0
35	20	2	\N	0
36	20	17	\N	0
37	21	2	\N	0
38	21	17	\N	0
39	22	2	\N	0
40	22	17	\N	0
41	23	2	\N	0
42	23	17	\N	0
43	24	2	\N	0
44	24	17	\N	0
45	25	2	\N	0
46	25	17	\N	0
47	26	2	\N	0
48	26	17	\N	0
49	27	2	\N	0
50	27	17	\N	0
51	28	2	\N	0
52	28	17	\N	0
53	29	2	\N	0
54	29	17	\N	0
55	30	2	\N	0
56	30	17	\N	0
57	18	12	\N	2
58	19	13	["-",""]	0
59	1	13	["]",""]	-1
60	1	13	["[",""]	-1
61	28	5	\N	-1
\.


--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('metabib_field_index_norm_map_id_seq', 61, true);


--
-- Data for Name: metabib_field_ts_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_field_ts_map (id, metabib_field, ts_config, active, index_weight, index_lang, search_lang) FROM stdin;
\.


--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('metabib_field_ts_map_id_seq', 1, false);


--
-- Data for Name: metabib_search_alias; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY metabib_search_alias (alias, field_class, field) FROM stdin;
kw	keyword	\N
eg.keyword	keyword	\N
dc.publisher	keyword	\N
bib.subjecttitle	keyword	\N
bib.genre	keyword	\N
bib.edition	keyword	\N
srw.serverchoice	keyword	\N
id	identifier	\N
dc.identifier	identifier	\N
eg.isbn	identifier	18
eg.issn	identifier	19
eg.upc	identifier	20
eg.callnumber	identifier	25
eg.tcn	identifier	26
eg.bibid	identifier	27
au	author	\N
name	author	\N
creator	author	\N
eg.author	author	\N
eg.name	author	\N
dc.creator	author	\N
dc.contributor	author	\N
bib.name	author	\N
bib.namepersonal	author	8
bib.namepersonalfamily	author	8
bib.namepersonalgiven	author	8
bib.namecorporate	author	7
bib.nameconference	author	9
ti	title	\N
eg.title	title	\N
dc.title	title	\N
bib.titleabbreviated	title	2
bib.titleuniform	title	5
bib.titletranslated	title	3
bib.titlealternative	title	4
bib.title	title	2
su	subject	\N
eg.subject	subject	\N
dc.subject	subject	\N
bib.subjectplace	subject	11
bib.subjectname	subject	12
bib.subjectoccupation	subject	16
se	series	\N
eg.series	series	\N
bib.titleseries	series	1
\.


--
-- Data for Name: net_access_level; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY net_access_level (id, name) FROM stdin;
1	Filtered
2	Unfiltered
3	No Access
\.


--
-- Name: net_access_level_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('net_access_level_id_seq', 100, true);


--
-- Data for Name: non_cataloged_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY non_cataloged_type (id, owning_lib, name, circ_duration, in_house) FROM stdin;
1	1	Paperback Book	14 days	f
\.


--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('non_cataloged_type_id_seq', 100, true);


--
-- Data for Name: org_unit_setting_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY org_unit_setting_type (name, label, grp, description, datatype, fm_class, view_perm, update_perm) FROM stdin;
acq.copy_creator_uses_receiver	Set copy creator as receiver	acq	When receiving a copy in acquisitions, set the copy "creator" to be the staff that received the copy	bool	\N	\N	\N
acq.default_circ_modifier	Default circulation modifier	acq	Default circulation modifier	string	\N	\N	\N
acq.default_copy_location	Default copy location	acq	Default copy location	link	acpl	\N	\N
acq.fund.balance_limit.block	Fund Spending Limit for Block	acq	When the amount remaining in the fund, including spent money and encumbrances, goes below this percentage, attempts to spend from the fund will be blocked.	integer	\N	\N	\N
acq.fund.balance_limit.warn	Fund Spending Limit for Warning	acq	When the amount remaining in the fund, including spent money and encumbrances, goes below this percentage, attempts to spend from the fund will result in a warning to the staff.	integer	\N	\N	\N
acq.holds.allow_holds_from_purchase_request	Allows patrons to create automatic holds from purchase requests.	acq	Allows patrons to create automatic holds from purchase requests.	bool	\N	\N	\N
acq.tmp_barcode_prefix	Temporary barcode prefix	acq	Temporary barcode prefix	string	\N	\N	\N
acq.tmp_callnumber_prefix	Temporary call number prefix	acq	Temporary call number prefix	string	\N	\N	\N
auth.opac_timeout	OPAC Inactivity Timeout (in seconds)	sec	OPAC Inactivity Timeout (in seconds)	integer	\N	\N	\N
auth.persistent_login_interval	Persistent Login Duration	sec	How long a persistent login lasts.  E.g. '2 weeks'	interval	\N	\N	\N
auth.staff_timeout	Staff Login Inactivity Timeout (in seconds)	sec	Staff Login Inactivity Timeout (in seconds)	integer	\N	\N	\N
booking.allow_email_notify	Allow Email Notify	booking	Permit email notification when a reservation is ready for pickup.	bool	\N	\N	\N
cat.bib.alert_on_empty	Alert on empty bib records	gui	Alert staff when the last copy for a record is being deleted	bool	\N	\N	\N
cat.bib.delete_on_no_copy_via_acq_lineitem_cancel	Delete bib if all copies are deleted via Acquisitions lineitem cancellation.	cat	Delete bib if all copies are deleted via Acquisitions lineitem cancellation.	bool	\N	\N	\N
cat.bib.keep_on_empty	Retain empty bib records	prog	Retain a bib record even when all attached copies are deleted	bool	\N	\N	\N
cat.default_classification_scheme	Default Classification Scheme	cat	Defines the default classification scheme for new call numbers: 1 = Generic; 2 = Dewey; 3 = LC	link	acnc	\N	\N
cat.default_copy_status_fast	Default copy status (fast add)	cat	Default status when a copy is created using the "Fast Add" interface.	link	ccs	\N	\N
cat.default_copy_status_normal	Default copy status (normal)	cat	Default status when a copy is created using the normal volume/copy creator interface.	link	ccs	\N	\N
cat.default_item_price	Default Item Price	finance	Default Item Price	currency	\N	\N	\N
cat.label.font.family	Spine and pocket label font family	cat	Set the preferred font family for spine and pocket labels. You can specify a list of fonts, separated by commas, in order of preference; the system will use the first font it finds with a matching name. For example, "Arial, Helvetica, serif".	string	\N	\N	\N
cat.label.font.size	Spine and pocket label font size	cat	Set the default font size for spine and pocket labels	integer	\N	\N	\N
cat.label.font.weight	Spine and pocket label font weight	cat	Set the preferred font weight for spine and pocket labels. You can specify "normal", "bold", "bolder", or "lighter".	string	\N	\N	\N
cat.marc_control_number_identifier	Defines the control number identifier used in 003 and 035 fields.	cat	Cat: Defines the control number identifier used in 003 and 035 fields.	string	\N	\N	\N
cat.spine.line.height	Spine label maximum lines	cat	Set the default maximum number of lines for spine labels.	integer	\N	\N	\N
cat.spine.line.margin	Spine label left margin	cat	Set the left margin for spine labels in number of characters.	integer	\N	\N	\N
cat.spine.line.width	Spine label line width	cat	Set the default line width for spine labels in number of characters. This specifies the boundary at which lines must be wrapped.	integer	\N	\N	\N
cat.volume.delete_on_empty	Delete volume with last copy	cat	Automatically delete a volume when the last linked copy is deleted	bool	\N	\N	\N
circ.auto_hide_patron_summary	Toggle off the patron summary sidebar after first view.	gui	When true, the patron summary sidebar will collapse after a new patron sub-interface is selected.	bool	\N	\N	\N
circ.block_renews_for_holds	Block Renewal of Items Needed for Holds	holds	When an item could fulfill a hold, do not allow the current patron to renew	bool	\N	\N	\N
circ.booking_reservation.default_elbow_room	Booking elbow room	booking	Elbow room specifies how far in the future you must make a reservation on an item if that item will have to transit to reach its pickup location.  It secondarily defines how soon a reservation on a given item must start before the check-in process will opportunistically capture it for the reservation shelf.	interval	\N	\N	\N
circ.charge_lost_on_zero	Charge lost on zero	finance	Charge lost on zero	bool	\N	\N	\N
circ.charge_on_damaged	Charge item price when marked damaged	finance	Charge item price when marked damaged	bool	\N	\N	\N
circ.checkout_auto_renew_age	Checkout auto renew age	circ	When an item has been checked out for at least this amount of time, an attempt to check out the item to the patron that it is already checked out to will simply renew the circulation	interval	\N	\N	\N
circ.checkout_fills_related_hold	Checkout Fills Related Hold	circ	When a patron checks out an item and they have no holds that directly target the item, the system will attempt to find a hold for the patron that could be fulfilled by the checked out item and fulfills it	bool	\N	\N	\N
circ.checkout_fills_related_hold_exact_match_only	Checkout Fills Related Hold On Valid Copy Only	circ	When filling related holds on checkout only match on items that are valid for opportunistic capture for the hold. Without this set a Title or Volume hold could match when the item is not holdable. With this set only holdable items will match.	bool	\N	\N	\N
circ.claim_never_checked_out.mark_missing	Claim Never Checked Out: Mark copy as missing	lib	When a circ is marked as claims-never-checked-out, mark the copy as missing	bool	\N	\N	\N
circ.claim_return.copy_status	Claim Return Copy Status	lib	Claims returned copies are put into this status.  Default is to leave the copy in the Checked Out status	link	ccs	\N	\N
circ.damaged.void_ovedue	Mark item damaged voids overdues	lib	When an item is marked damaged, overdue fines on the most recent circulation are voided.	bool	\N	\N	\N
circ.damaged_item_processing_fee	Charge processing fee for damaged items	finance	Charge processing fee for damaged items	currency	\N	\N	\N
circ.do_not_tally_claims_returned	Do not include outstanding Claims Returned circulations in lump sum tallies in Patron Display.	circ	In the Patron Display interface, the number of total active circulations for a given patron is presented in the Summary sidebar and underneath the Items Out navigation button.  This setting will prevent Claims Returned circulations from counting toward these tallies.	bool	\N	\N	\N
circ.grace.extend	Auto-Extend Grace Periods	circ	When enabled grace periods will auto-extend. By default this will be only when they are a full day or more and end on a closed date, though other options can alter this.	bool	\N	\N	\N
circ.grace.extend.all	Auto-Extending Grace Periods extend for all closed dates	circ	If enabled and Grace Periods auto-extending is turned on grace periods will extend past all closed dates they intersect, within hard-coded limits. This basically becomes "grace periods can only be consumed by closed dates".	bool	\N	\N	\N
circ.grace.extend.into_closed	Auto-Extending Grace Periods include trailing closed dates	circ	If enabled and Grace Periods auto-extending is turned on grace periods will include closed dates that directly follow the last day of the grace period, to allow a backdate into the closed dates to assume "returned after hours on the last day of the grace period, and thus still within it" automatically.	bool	\N	\N	\N
circ.hold_boundary.hard	Hard boundary	holds	Holds: Hard boundary	integer	\N	\N	\N
circ.hold_boundary.soft	Soft boundary	holds	Holds: Soft boundary	integer	\N	\N	\N
circ.hold_expire_alert_interval	Expire Alert Interval	holds	Amount of time before a hold expires at which point the patron should be alerted. Examples: "5 days", "1 hour"	interval	\N	\N	\N
circ.hold_expire_interval	Expire Interval	holds	Amount of time after a hold is placed before the hold expires.  Example "100 days"	interval	\N	\N	\N
circ.hold_shelf_status_delay	Hold Shelf Status Delay	circ	The purpose is to provide an interval of time after an item goes into the on-holds-shelf status before it appears to patrons that it is actually on the holds shelf.  This gives staff time to process the item before it shows as ready-for-pickup. Examples: "5 days", "1 hour"	interval	\N	\N	\N
circ.hold_stalling.soft	Soft stalling interval	holds	How long to wait before allowing remote items to be opportunistically captured for a hold.  Example "5 days"	interval	\N	\N	\N
circ.hold_stalling_hard	Hard stalling interval	holds	Holds: Hard stalling interval	interval	\N	\N	\N
circ.holds.age_protect.active_date	Use Active Date for Age Protection	holds	When calculating age protection rules use the active date instead of the creation date.	bool	\N	\N	\N
circ.holds.behind_desk_pickup_supported	Behind Desk Pickup Supported	holds	If a branch supports both a public holds shelf and behind-the-desk pickups, set this value to true.  This gives the patron the option to enable behind-the-desk pickups for their holds	bool	\N	\N	\N
circ.holds.canceled.display_age	Canceled holds display age	holds	Show all canceled holds that were canceled within this amount of time	interval	\N	\N	\N
circ.holds.canceled.display_count	Canceled holds display count	holds	How many canceled holds to show in patron holds interfaces	integer	\N	\N	\N
circ.holds.clear_shelf.copy_status	Clear shelf copy status	holds	Any copies that have not been put into reshelving, in-transit, or on-holds-shelf (for a new hold) during the clear shelf process will be put into this status.  This is basically a purgatory status for copies waiting to be pulled from the shelf and processed by hand	link	ccs	\N	\N
circ.holds.default_estimated_wait_interval	Default Estimated Wait	holds	When predicting the amount of time a patron will be waiting for a hold to be fulfilled, this is the default estimated length of time to assume an item will be checked out. Examples: "3 weeks", "7 days"	interval	\N	\N	\N
circ.holds.default_shelf_expire_interval	Default hold shelf expire interval	holds	The amount of time an item will be held on the shelf before the hold expires. For example: "2 weeks" or "5 days"	interval	\N	\N	\N
circ.holds.expired_patron_block	Block hold request if hold recipient privileges have expired	circ	Block hold request if hold recipient privileges have expired	bool	\N	\N	\N
circ.holds.hold_has_copy_at.alert	Has Local Copy Alert	holds	If there is an available copy at the requesting library that could fulfill a hold during hold placement time, alert the patron	bool	\N	\N	\N
circ.holds.hold_has_copy_at.block	Has Local Copy Block	holds	If there is an available copy at the requesting library that could fulfill a hold during hold placement time, do not allow the hold to be placed	bool	\N	\N	\N
circ.holds.max_org_unit_target_loops	Maximum library target attempts	holds	When this value is set and greater than 0, the system will only attempt to find a copy at each possible branch the configured number of times	integer	\N	\N	\N
circ.holds.min_estimated_wait_interval	Minimum Estimated Wait	holds	When predicting the amount of time a patron will be waiting for a hold to be fulfilled, this is the minimum estimated length of time to assume an item will be checked out. Examples: "2 weeks", "5 days"	interval	\N	\N	\N
circ.holds.org_unit_target_weight	Org Unit Target Weight	holds	Org Units can be organized into hold target groups based on a weight.  Potential copies from org units with the same weight are chosen at random.	integer	\N	\N	\N
circ.holds.recall_fine_rules	An array of fine amount, fine interval, and maximum fine.	recall	Recalls: An array of fine amount, fine interval, and maximum fine. For example, to specify a new fine rule of $5.00 per day, with a maximum fine of $50.00, use: [5.00,"1 day",50.00]	array	\N	\N	\N
circ.holds.recall_return_interval	Truncated loan period.	recall	Recalls: When a recall is triggered, this defines the adjusted loan period for the item. For example, "4 days" or "1 week".	interval	\N	\N	\N
circ.holds.recall_threshold	Circulation duration that triggers a recall.	recall	Recalls: A hold placed on an item with a circulation duration longer than this will trigger a recall. For example, "14 days" or "3 weeks".	interval	\N	\N	\N
circ.holds.target_holds_by_org_unit_weight	Use weight-based hold targeting	holds	Use library weight based hold targeting	bool	\N	\N	\N
circ.holds.target_skip_me	Skip For Hold Targeting	holds	When true, don't target any copies at this org unit for holds	bool	\N	\N	\N
circ.holds.uncancel.reset_request_time	Reset request time on un-cancel	holds	When a hold is uncanceled, reset the request time to push it to the end of the queue	bool	\N	\N	\N
circ.holds_fifo	FIFO	holds	Force holds to a more strict First-In, First-Out capture	bool	\N	\N	\N
circ.item_checkout_history.max	Maximum previous checkouts displayed	gui	This is the maximum number of previous circulations the staff client will display when investigating item details	integer	\N	\N	\N
circ.lost.generate_overdue_on_checkin	Lost Checkin Generates New Overdues	circ	Enabling this setting causes retroactive creation of not-yet-existing overdue fines on lost item checkin, up to the point of checkin time (or max fines is reached).  This is different than "restore overdue on lost", because it only creates new overdue fines.  Use both settings together to get the full complement of overdue fines for a lost item	bool	\N	\N	\N
circ.lost_immediately_available	Lost items usable on checkin	circ	Lost items are usable on checkin instead of going 'home' first	bool	\N	\N	\N
circ.lost_materials_processing_fee	Lost Materials Processing Fee	finance	Lost Materials Processing Fee	currency	\N	\N	\N
circ.max_accept_return_of_lost	Void lost max interval	circ	Items that have been lost this long will not result in voided billings when returned.  E.g. '6 months'	interval	\N	\N	\N
circ.max_fine.cap_at_price	Cap Max Fine at Item Price	circ	This prevents the system from charging more than the item price in overdue fines	bool	\N	\N	\N
circ.max_patron_claim_return_count	Max Patron Claims Returned Count	circ	When this count is exceeded, a staff override is required to mark the item as claims returned	integer	\N	\N	\N
circ.missing_pieces.copy_status	Item Status for Missing Pieces	circ	This is the Item Status to use for items that have been marked or scanned as having Missing Pieces.  In the absence of this setting, the Damaged status is used.	link	ccs	\N	\N
circ.obscure_dob	Obscure the Date of Birth field	sec	When true, the Date of Birth column in patron lists will default to Not Visible, and in the Patron Summary sidebar the value will display as <Hidden> unless the field label is clicked.	bool	\N	\N	\N
circ.offline.skip_checkin_if_newer_status_changed_time	Skip offline checkin if newer item Status Changed Time.	offline	Skip offline checkin transaction (raise exception when processing) if item Status Changed Time is newer than the recorded transaction time.  WARNING: The Reshelving to Available status rollover will trigger this.	bool	\N	\N	\N
circ.offline.skip_checkout_if_newer_status_changed_time	Skip offline checkout if newer item Status Changed Time.	offline	Skip offline checkout transaction (raise exception when processing) if item Status Changed Time is newer than the recorded transaction time.  WARNING: The Reshelving to Available status rollover will trigger this.	bool	\N	\N	\N
circ.offline.skip_renew_if_newer_status_changed_time	Skip offline renewal if newer item Status Changed Time.	offline	Skip offline renewal transaction (raise exception when processing) if item Status Changed Time is newer than the recorded transaction time.  WARNING: The Reshelving to Available status rollover will trigger this.	bool	\N	\N	\N
circ.offline.username_allowed	Offline: Patron Usernames Allowed	sec	During offline circulations, allow patrons to identify themselves with usernames in addition to barcode.  For this setting to work, a barcode format must also be defined	bool	\N	\N	\N
circ.password_reset_request_per_user_limit	Maximum concurrently active self-serve password reset requests per user	sec	When a user has more than this number of concurrently active self-serve password reset requests for their account, prevent the user from creating any new self-serve password reset requests until the number of active requests for the user drops back below this number.	string	\N	\N	\N
circ.password_reset_request_requires_matching_email	Require matching email address for password reset requests	circ	Require matching email address for password reset requests	bool	\N	\N	\N
circ.password_reset_request_throttle	Maximum concurrently active self-serve password reset requests	sec	Prevent the creation of new self-serve password reset requests until the number of active requests drops back below this number.	string	\N	\N	\N
circ.password_reset_request_time_to_live	Self-serve password reset request time-to-live	sec	Length of time (in seconds) a self-serve password reset request should remain active.	string	\N	\N	\N
circ.patron_edit.clone.copy_address	Patron Registration: Cloned patrons get address copy	circ	In the Patron editor, copy addresses from the cloned user instead of linking directly to the address	bool	\N	\N	\N
circ.patron_invalid_address_apply_penalty	Invalid patron address penalty	circ	When set, if a patron address is set to invalid, a penalty is applied.	bool	\N	\N	\N
circ.pre_cat_copy_circ_lib	Pre-cat Item Circ Lib	lib	Override the default circ lib of "here" with a pre-configured circ lib for pre-cat items.  The value should be the "shortname" (aka policy name) of the org unit	string	\N	\N	\N
circ.reshelving_complete.interval	Change reshelving status interval	lib	Amount of time to wait before changing an item from "reshelving" status to "available".  Examples: "1 day", "6 hours"	interval	\N	\N	\N
circ.restore_overdue_on_lost_return	Restore overdues on lost item return	circ	Restore overdue fines on lost item return	bool	\N	\N	\N
circ.selfcheck.alert.popup	Pop-up alert for errors	self	If true, checkout/renewal errors will cause a pop-up window in addition to the on-screen message	bool	\N	\N	\N
circ.selfcheck.alert.sound	Audio Alerts	self	Use audio alerts for selfcheck events	bool	\N	\N	\N
circ.selfcheck.auto_override_checkout_events	Selfcheck override events list	self	List of checkout/renewal events that the selfcheck interface should automatically override instead instead of alerting and stopping the transaction	array	\N	\N	\N
circ.selfcheck.block_checkout_on_copy_status	Block copy checkout status	self	List of copy status IDs that will block checkout even if the generic COPY_NOT_AVAILABLE event is overridden	array	\N	\N	\N
circ.selfcheck.patron_login_timeout	Patron Login Timeout (in seconds)	self	Number of seconds of inactivity before the patron is logged out of the selfcheck interface	integer	\N	\N	\N
circ.selfcheck.patron_password_required	Require Patron Password	self	Patron must log in with barcode and password at selfcheck station	bool	\N	\N	\N
circ.selfcheck.require_patron_password	Require patron password	self	If true, patrons will be required to enter their password in addition to their username/barcode to log into the selfcheck interface	bool	\N	\N	\N
circ.selfcheck.workstation_required	Workstation Required	self	All selfcheck stations must use a workstation	bool	\N	\N	\N
circ.staff_client.actor_on_checkout	Load patron from Checkout	circ	When scanning barcodes into Checkout auto-detect if a new patron barcode is scanned and auto-load the new patron.	bool	\N	\N	\N
circ.staff_client.do_not_auto_attempt_print	Disable Automatic Print Attempt Type List	prog	Disable automatic print attempts from staff client interfaces for the receipt types in this list.  Possible values: "Checkout", "Bill Pay", "Hold Slip", "Transit Slip", and "Hold/Transit Slip".  This is different from the Auto-Print checkbox in the pertinent interfaces in that it disables automatic print attempts altogether, rather than encouraging silent printing by suppressing the print dialog.  The Auto-Print checkbox in these interfaces have no effect on the behavior for this setting.  In the case of the Hold, Transit, and Hold/Transit slips, this also suppresses the alert dialogs that precede the print dialog (the ones that offer Print and Do Not Print as options).	array	\N	\N	\N
circ.staff_client.receipt.alert_text	Content of alert_text include	receipt_template	Text/HTML/Macros to be inserted into receipt templates in place of %INCLUDE(alert_text)%	string	\N	\N	\N
circ.staff_client.receipt.event_text	Content of event_text include	receipt_template	Text/HTML/Macros to be inserted into receipt templates in place of %INCLUDE(event_text)%	string	\N	\N	\N
circ.staff_client.receipt.footer_text	Content of footer_text include	receipt_template	Text/HTML/Macros to be inserted into receipt templates in place of %INCLUDE(footer_text)%	string	\N	\N	\N
circ.staff_client.receipt.header_text	Content of header_text include	receipt_template	Text/HTML/Macros to be inserted into receipt templates in place of %INCLUDE(header_text)%	string	\N	\N	\N
circ.staff_client.receipt.notice_text	Content of notice_text include	receipt_template	Text/HTML/Macros to be inserted into receipt templates in place of %INCLUDE(notice_text)%	string	\N	\N	\N
circ.transit.min_checkin_interval	Minimum Transit Checkin Interval	circ	In-Transit items checked in this close to the transit start time will be prevented from checking in	interval	\N	\N	\N
circ.transit.suppress_hold	Suppress Hold Transits Group	circ	If set to a non-empty value, Hold Transits will be suppressed between this OU and others with the same value. If set to an empty value, transits will not be suppressed.	string	\N	\N	\N
circ.transit.suppress_non_hold	Suppress Non-Hold Transits Group	circ	If set to a non-empty value, Non-Hold Transits will be suppressed between this OU and others with the same value. If set to an empty value, transits will not be suppressed.	string	\N	\N	\N
circ.user_merge.deactivate_cards	Patron Merge Deactivate Card	circ	Mark barcode(s) of subordinate user(s) in a patron merge as inactive	bool	\N	\N	\N
circ.user_merge.delete_addresses	Patron Merge Address Delete	circ	Delete address(es) of subordinate user(s) in a patron merge	bool	\N	\N	\N
circ.user_merge.delete_cards	Patron Merge Barcode Delete	circ	Delete barcode(s) of subordinate user(s) in a patron merge	bool	\N	\N	\N
circ.void_lost_on_checkin	Void lost item billing when returned	circ	Void lost item billing when returned	bool	\N	\N	\N
circ.void_lost_proc_fee_on_checkin	Void processing fee on lost item return	circ	Void processing fee when lost item returned	bool	\N	\N	\N
circ.void_overdue_on_lost	Void overdue fines when items are marked lost	finance	Void overdue fines when items are marked lost	bool	\N	\N	\N
credit.payments.allow	Allow Credit Card Payments	finance	If enabled, patrons will be able to pay fines accrued at this location via credit card	bool	\N	\N	\N
format.date	Format Dates with this pattern.	gui	Format Dates with this pattern (examples: "yyyy-MM-dd" for "2010-04-26", "MMM d, yyyy" for "Apr 26, 2010")	string	\N	\N	\N
format.time	Format Times with this pattern.	gui	Format Times with this pattern (examples: "h:m:s.SSS a z" for "2:07:20.666 PM Eastern Daylight Time", "HH:mm" for "14:07")	string	\N	\N	\N
global.default_locale	Global Default Locale	glob	Global Default Locale	string	\N	\N	\N
global.juvenile_age_threshold	Juvenile Age Threshold	lib	The age at which a user is no long considered a juvenile.  For example, "18 years".	interval	\N	\N	\N
global.password_regex	Password format	glob	Regular expression defining the password format	string	\N	\N	\N
gui.disable_local_save_columns	Disable the ability to save list column configurations locally.	gui	Disable the ability to save list column configurations locally.  If set, columns may still be manipulated, however, the changes do not persist.  Also, existing local configurations are ignored if this setting is true.	bool	\N	\N	\N
lib.courier_code	Courier Code	lib	Courier Code for the library.  Available in transit slip templates as the %courier_code% macro.	string	\N	\N	\N
notice.telephony.callfile_lines	Telephony: Arbitrary line(s) to include in each notice callfile	lib	\n        This overrides lines from opensrf.xml.\n        Line(s) must be valid for your target server and platform\n        (e.g. Asterisk 1.4).\n        	string	\N	\N	\N
opac.allow_pending_address	Allow pending addresses	opac	If enabled, patrons can create and edit existing addresses.  Addresses are kept in a pending state until staff approves the changes	bool	\N	\N	\N
opac.barcode_regex	Patron barcode format	glob	Regular expression defining the patron barcode format	string	\N	\N	\N
opac.fully_compressed_serial_holdings	Use fully compressed serial holdings	opac	Show fully compressed serial holdings for all libraries at and below the current context unit	bool	\N	\N	\N
opac.lock_usernames	Lock Usernames	glob	If enabled username changing via the OPAC will be disabled	bool	\N	\N	\N
opac.org_unit_hiding.depth	Org Unit Hiding Depth	opac	This will hide certain org units in the public OPAC if the Original Location (url param "ol") for the OPAC inherits this setting.  This setting specifies an org unit depth, that together with the OPAC Original Location determines which section of the Org Hierarchy should be visible in the OPAC.  For example, a stock Evergreen installation will have a 3-tier hierarchy (Consortium/System/Branch), where System has a depth of 1 and Branch has a depth of 2.  If this setting contains a depth of 1 in such an installation, then every library in the System in which the Original Location belongs will be visible, and everything else will be hidden.  A depth of 0 will effectively make every org visible.  The embedded OPAC in the staff client ignores this setting.	integer	\N	\N	\N
opac.payment_history_age_limit	Payment History Age Limit	opac	The OPAC should not display payments by patrons that are older than any interval defined here.	interval	\N	\N	\N
opac.unlimit_usernames	Allow multiple username changes	glob	If enabled (and Lock Usernames is not set) patrons will be allowed to change their username when it does not look like a barcode. Otherwise username changing in the OPAC will only be allowed when the patron's username looks like a barcode.	bool	\N	\N	\N
opac.username_regex	Patron username format	glob	Regular expression defining the patron username format, used for patron registration and self-service username changing only	string	\N	\N	\N
org.bounced_emails	Sending email address for patron notices	prog	Sending email address for patron notices	string	\N	\N	\N
org.patron_opt_boundary	Patron Opt-In Boundary	sec	This determines at which depth above which patrons must be opted in, and below which patrons will be assumed to be opted in.	integer	\N	\N	\N
org.patron_opt_default	Patron Opt-In Default	sec	This is the default depth at which a patron is opted in; it is calculated as an org unit relative to the current workstation.	integer	\N	\N	\N
patron.password.use_phone	Patron: password from phone #	sec	By default, use the last 4 alphanumeric characters of the patrons phone number as the default password when creating new users.  The exact characters used may be configured via the "GUI: Regex for day_phone field on patron registration" setting.	bool	\N	\N	\N
print.custom_js_file	Printing: Custom Javascript File	circ	Full URL path to a Javascript File to be loaded when printing. Should implement a print_custom function for DOM manipulation. Can change the value of the do_print variable to false to cancel printing.	string	\N	\N	\N
serial.prev_issuance_copy_location	Previous Issuance Copy Location	serial	When a serial issuance is received, copies (units) of the previous issuance will be automatically moved into the configured shelving location	link	acpl	\N	\N
ui.admin.patron_log.max_entries	Work Log: Maximum Patrons Logged	gui	Maximum entries for "Most Recently Affected Patrons..." section of the Work Log interface.	interval	\N	\N	\N
ui.admin.work_log.max_entries	Work Log: Maximum Actions Logged	gui	Maximum entries for "Most Recent Staff Actions" section of the Work Log interface.	interval	\N	\N	\N
ui.cat.volume_copy_editor.horizontal	Horizontal layout for Volume/Copy Creator/Editor.	gui	The main entry point for this interface is in Holdings Maintenance, Actions for Selected Rows, Edit Item Attributes / Call Numbers / Replace Barcodes.  This setting changes the top and bottom panes for that interface into left and right panes.	bool	\N	\N	\N
ui.circ.billing.uncheck_bills_and_unfocus_payment_box	Uncheck bills by default in the patron billing interface	gui	Uncheck bills by default in the patron billing interface, and focus on the Uncheck All button instead of the Payment Received field.	bool	\N	\N	\N
ui.circ.in_house_use.entry_cap	Record In-House Use: Maximum # of uses allowed per entry.	gui	The # of uses entry in the Record In-House Use interface may not exceed the value of this setting.	integer	\N	\N	\N
ui.circ.in_house_use.entry_warn	Record In-House Use: # of uses threshold for Are You Sure? dialog.	gui	In the Record In-House Use interface, a submission attempt will warn if the # of uses field exceeds the value of this setting.	integer	\N	\N	\N
ui.circ.patron_summary.horizontal	Patron circulation summary is horizontal	gui	Patron circulation summary is horizontal	bool	\N	\N	\N
ui.circ.show_billing_tab_on_bills	Show billing tab first when bills are present	gui	If enabled and a patron has outstanding bills and the alert page is not required, show the billing tab by default, instead of the checkout tab, when a patron is loaded	bool	\N	\N	\N
ui.circ.suppress_checkin_popups	Suppress popup-dialogs during check-in.	circ	Suppress popup-dialogs during check-in.	bool	\N	\N	\N
ui.general.button_bar	Button bar	gui	Set to "circ" or "cat" for stock circulator or cataloger toolbar, respectively.	string	\N	\N	\N
ui.general.hotkeyset	Default Hotkeyset	gui	Default Hotkeyset for clients (filename without the .keyset).  Examples: Default, Minimal, and None	string	\N	\N	\N
ui.general.idle_timeout	Idle timeout	gui	If you want staff client windows to be minimized after a certain amount of system idle time, set this to the number of seconds of idle time that you want to allow before minimizing (requires staff client restart).	integer	\N	\N	\N
ui.patron.default_country	Default Country for New Addresses in Patron Editor	gui	This is the default Country for new addresses in the patron editor.	string	\N	\N	\N
ui.patron.default_ident_type	Default Ident Type for Patron Registration	gui	This is the default Ident Type for new users in the patron editor.	link	cit	\N	\N
ui.patron.default_inet_access_level	Default level of patrons' internet access	sec	Default level of patrons' internet access	integer	\N	\N	\N
ui.patron.edit.au.active.show	Show active field on patron registration	gui	The active field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.active.suggest	Suggest active field on patron registration	gui	The active field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.alert_message.show	Show alert_message field on patron registration	gui	The alert_message field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.alert_message.suggest	Suggest alert_message field on patron registration	gui	The alert_message field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.alias.show	Show alias field on patron registration	gui	The alias field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.alias.suggest	Suggest alias field on patron registration	gui	The alias field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.barred.show	Show barred field on patron registration	gui	The barred field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.barred.suggest	Suggest barred field on patron registration	gui	The barred field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.claims_never_checked_out_count.show	Show claims_never_checked_out_count field on patron registration	gui	The claims_never_checked_out_count field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.claims_never_checked_out_count.suggest	Suggest claims_never_checked_out_count field on patron registration	gui	The claims_never_checked_out_count field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.claims_returned_count.show	Show claims_returned_count field on patron registration	gui	The claims_returned_count field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.claims_returned_count.suggest	Suggest claims_returned_count field on patron registration	gui	The claims_returned_count field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.day_phone.example	Example for day_phone field on patron registration	gui	The Example for validation on the day_phone field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.day_phone.regex	Regex for day_phone field on patron registration	gui	The Regular Expression for validation on the day_phone field in patron registration. Note: The first capture group will be used for the "last 4 digits of phone number" feature, if enabled. Ex: "[2-9]\\d{2}-\\d{3}-(\\d{4})( x\\d+)?" will ignore the extension on a NANP number.	string	\N	\N	\N
ui.patron.edit.au.day_phone.require	Require day_phone field on patron registration	gui	The day_phone field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.day_phone.show	Show day_phone field on patron registration	gui	The day_phone field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.day_phone.suggest	Suggest day_phone field on patron registration	gui	The day_phone field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.dob.calendar	Show calendar widget for dob field on patron registration	gui	If set the calendar widget will appear when editing the dob field on the patron registration form.	bool	\N	\N	\N
ui.patron.edit.au.dob.require	Require dob field on patron registration	gui	The dob field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.dob.show	Show dob field on patron registration	gui	The dob field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.dob.suggest	Suggest dob field on patron registration	gui	The dob field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.email.example	Example for email field on patron registration	gui	The Example for validation on the email field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.email.regex	Regex for email field on patron registration	gui	The Regular Expression for validation on the email field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.email.require	Require email field on patron registration	gui	The email field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.email.show	Show email field on patron registration	gui	The email field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.email.suggest	Suggest email field on patron registration	gui	The email field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.evening_phone.example	Example for evening_phone field on patron registration	gui	The Example for validation on the evening_phone field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.evening_phone.regex	Regex for evening_phone field on patron registration	gui	The Regular Expression for validation on the evening_phone field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.evening_phone.require	Require evening_phone field on patron registration	gui	The evening_phone field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.evening_phone.show	Show evening_phone field on patron registration	gui	The evening_phone field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.evening_phone.suggest	Suggest evening_phone field on patron registration	gui	The evening_phone field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.ident_value.show	Show ident_value field on patron registration	gui	The ident_value field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.ident_value.suggest	Suggest ident_value field on patron registration	gui	The ident_value field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.ident_value2.show	Show ident_value2 field on patron registration	gui	The ident_value2 field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.ident_value2.suggest	Suggest ident_value2 field on patron registration	gui	The ident_value2 field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.juvenile.show	Show juvenile field on patron registration	gui	The juvenile field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.juvenile.suggest	Suggest juvenile field on patron registration	gui	The juvenile field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.master_account.show	Show master_account field on patron registration	gui	The master_account field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.master_account.suggest	Suggest master_account field on patron registration	gui	The master_account field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.other_phone.example	Example for other_phone field on patron registration	gui	The Example for validation on the other_phone field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.other_phone.regex	Regex for other_phone field on patron registration	gui	The Regular Expression for validation on the other_phone field in patron registration.	string	\N	\N	\N
ui.patron.edit.au.other_phone.require	Require other_phone field on patron registration	gui	The other_phone field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.other_phone.show	Show other_phone field on patron registration	gui	The other_phone field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.other_phone.suggest	Suggest other_phone field on patron registration	gui	The other_phone field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.prefix.require	Require prefix field on patron registration	gui	The prefix field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.au.prefix.show	Show prefix field on patron registration	gui	The prefix field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.prefix.suggest	Suggest prefix field on patron registration	gui	The prefix field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.second_given_name.show	Show second_given_name field on patron registration	gui	The second_given_name field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.second_given_name.suggest	Suggest second_given_name field on patron registration	gui	The second_given_name field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.suffix.show	Show suffix field on patron registration	gui	The suffix field will be shown on the patron registration screen. Showing a field makes it appear with required fields even when not required. If the field is required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.au.suffix.suggest	Suggest suffix field on patron registration	gui	The suffix field will be suggested on the patron registration screen. Suggesting a field makes it appear when suggested fields are shown. If the field is shown or required this setting is ignored.	bool	\N	\N	\N
ui.patron.edit.aua.county.require	Require county field on patron registration	gui	The county field will be required on the patron registration screen.	bool	\N	\N	\N
ui.patron.edit.aua.post_code.example	Example for post_code field on patron registration	gui	The Example for validation on the post_code field in patron registration.	string	\N	\N	\N
ui.patron.edit.aua.post_code.regex	Regex for post_code field on patron registration	gui	The Regular Expression for validation on the post_code field in patron registration.	string	\N	\N	\N
ui.patron.edit.default_suggested	Default showing suggested patron registration fields	gui	Instead of All fields, show just suggested fields in patron registration by default.	bool	\N	\N	\N
ui.patron.edit.phone.example	Example for phone fields on patron registration	gui	The Example for validation on phone fields in patron registration. Applies to all phone fields without their own setting.	string	\N	\N	\N
ui.patron.edit.phone.regex	Regex for phone fields on patron registration	gui	The Regular Expression for validation on phone fields in patron registration. Applies to all phone fields without their own setting. NOTE: See description of the day_phone regex for important information about capture groups with it.	string	\N	\N	\N
ui.patron.registration.require_address	Require at least one address for Patron Registration	gui	Enforces a requirement for having at least one address for a patron during registration.	bool	\N	\N	\N
ui.patron_search.result_cap	Cap results in Patron Search at this number.	gui	So for example, if you search for John Doe, normally you would get at most 50 results.  This setting allows you to raise or lower that limit.	integer	\N	\N	\N
ui.staff.require_initials	Require staff initials for entry/edit of item/patron/penalty notes/messages.	gui	Appends staff initials and edit date into note content.	bool	\N	\N	\N
ui.unified_volume_copy_editor	Unified Volume/Item Creator/Editor	gui	If true combines the Volume/Copy Creator and Item Attribute Editor in some instances.	bool	\N	\N	\N
url.remote_column_settings	URL for remote directory containing list column settings.	gui	URL for remote directory containing list column settings.  The format and naming convention for the files found in this directory match those in the local settings directory for a given workstation.  An administrator could create the desired settings locally and then copy all the tree_columns_for_* files to the remote directory.	string	\N	\N	\N
opac.staff_saved_search.size	OPAC: Number of staff client saved searches to display on left side of results and record details pages	opac	If unset, the OPAC (only when wrapped in the staff client!) will default to showing you your ten most recent searches on the left side of the results and record details pages.  If you actually don't want to see this feature at all, set this value to zero at the top of your organizational tree.	integer	\N	\N	\N
circ.holds.target_when_closed	Target copies for a hold even if copy's circ lib is closed	circ	If this setting is true at a given org unit or one of its ancestors, the hold targeter will target copies from this org unit even if the org unit is closed (according to the actor.org_unit.closed_date table).	bool	\N	\N	\N
circ.holds.target_when_closed_if_at_pickup_lib	Target copies for a hold even if copy's circ lib is closed IF the circ lib is the hold's pickup lib	circ	If this setting is true at a given org unit or one of its ancestors, the hold targeter will target copies from this org unit even if the org unit is closed (according to the actor.org_unit.closed_date table) IF AND ONLY IF the copy's circ lib is the same as the hold's pickup lib.	bool	\N	\N	\N
opac.staff.jump_to_details_on_single_hit	Jump to details on 1 hit (staff client)	opac	When a search yields only 1 result, jump directly to the record details page.  This setting only affects the OPAC within the staff client	bool	\N	\N	\N
opac.patron.jump_to_details_on_single_hit	Jump to details on 1 hit (public)	opac	When a search yields only 1 result, jump directly to the record details page.  This setting only affects the public OPAC	bool	\N	\N	\N
opac.search.tag_circulated_items	Tag Circulated Items in Results	opac	When a user is both logged in and has opted in to circulation history tracking, turning on this setting will cause previous (or currently) circulated items to be highlighted in search results	bool	\N	\N	\N
sms.enable	Enable features that send SMS text messages.	sms	Current features that use SMS include hold-ready-for-pickup notifications and a "Send Text" action for call numbers in the OPAC. If this setting is not enabled, the SMS options will not be offered to the user.  Unless you are carefully silo-ing patrons and their use of the OPAC, the context org for this setting should be the top org in the org hierarchy, otherwise patrons can trample their user settings when jumping between orgs.	bool	\N	\N	\N
sms.disable_authentication_requirement.callnumbers	Disable auth requirement for texting call numbers.	sms	Disable authentication requirement for sending call number information via SMS from the OPAC.	bool	\N	\N	\N
serial.default_display_grouping	Default display grouping for serials distributions presented in the OPAC.	serial	Default display grouping for serials distributions presented in the OPAC. This can be "enum" or "chron".	string	\N	\N	\N
vandelay.default_match_set	Default Record Match Set	vandelay	Default Record Match Set	string	\N	\N	\N
circ.patron_edit.duplicate_patron_check_depth	Specify search depth for the duplicate patron check in the patron editor	circ	When using the patron registration page, the duplicate patron check will use the configured depth to scope the search for duplicate patrons.	integer	\N	\N	\N
credit.processor.authorizenet.enabled	Enable AuthorizeNet payments	credit	Enable AuthorizeNet payments	bool	\N	389	390
credit.processor.authorizenet.login	AuthorizeNet login	credit	AuthorizeNet login	string	\N	389	390
credit.processor.authorizenet.password	AuthorizeNet password	credit	AuthorizeNet password	string	\N	389	390
credit.processor.authorizenet.server	AuthorizeNet server	credit	Required if using a developer/test account with AuthorizeNet	string	\N	389	390
credit.processor.authorizenet.testmode	AuthorizeNet test mode	credit	AuthorizeNet test mode	bool	\N	389	390
credit.processor.default	Name default credit processor	credit	This might be "AuthorizeNet", "PayPal", etc.	string	\N	389	390
credit.processor.payflowpro.enabled	Enable PayflowPro payments	credit	This is NOT the same thing as the settings labeled with just "PayPal."	bool	\N	389	390
credit.processor.payflowpro.login	PayflowPro login/merchant ID	credit	Often the same thing as the PayPal manager login	string	\N	389	390
credit.processor.payflowpro.partner	PayflowPro partner	credit	Often "PayPal" or "VeriSign", sometimes others	string	\N	389	390
credit.processor.payflowpro.password	PayflowPro password	credit	PayflowPro password	string	\N	389	390
credit.processor.payflowpro.testmode	PayflowPro test mode	credit	Do not really process transactions, but stay in test mode - uses pilot-payflowpro.paypal.com instead of the usual host	bool	\N	389	390
credit.processor.payflowpro.vendor	PayflowPro vendor	credit	Often the same thing as the login	string	\N	389	390
credit.processor.paypal.enabled	Enable PayPal payments	credit	Enable PayPal payments	bool	\N	389	390
credit.processor.paypal.login	PayPal login	credit	PayPal login	string	\N	389	390
credit.processor.paypal.password	PayPal password	credit	PayPal password	string	\N	389	390
credit.processor.paypal.signature	PayPal signature	credit	PayPal signature	string	\N	389	390
credit.processor.paypal.testmode	PayPal test mode	credit	PayPal test mode	bool	\N	389	390
circ.fines.charge_when_closed	Charge fines on overdue circulations when closed	circ	Normally, fines are not charged when a library is closed.  When set to True, fines will be charged during scheduled closings and normal weekly closed days.	bool	\N	\N	\N
circ.patron.usr_activity_retrieve.max	Max user activity entries to retrieve (staff client)	gui	Sets the maxinum number of recent user activity entries to retrieve for display in the staff client.  0 means show none, -1 means show all.  Default is 1.	integer	\N	\N	\N
ui.hide_copy_editor_fields	GUI: Hide these fields within the Item Attribute Editor	gui	This setting may be best maintained with the dedicated configuration interface within the Item Attribute Editor.  However, here it shows up as comma separated list of field identifiers to hide.	array	\N	\N	539
opac.patron.auto_overide_hold_events	Auto-Override Permitted Hold Blocks (Patrons)	opac	When a patron places a hold that fails and the patron has the correct permission to override the hold, automatically override the hold without presenting a message to the patron and requiring that the patron make a decision to override	bool	\N	\N	\N
opac.patron.temporary_list_warn	Warn patrons when adding to a temporary book list	opac	Present a warning dialog to the patron when a patron adds a book to a temporary book bag.	bool	\N	\N	\N
circ.staff.max_visible_event_age	Maximum visible age of User Trigger Events in Staff Interfaces	circ	If this is unset, staff can view User Trigger Events regardless of age. When this is set to an interval, it represents the age of the oldest possible User Trigger Event that can be viewed.	interval	\N	\N	\N
acq.fund.allow_rollover_without_money	Allow funds to be rolled over without bringing the money along	acq	Allow funds to be rolled over without bringing the money along.  This makes money left in the old fund disappear, modeling its return to some outside entity.	bool	\N	\N	\N
circ.lost.xact_open_on_zero	Leave transaction open when lost balance equals zero	finance	Leave transaction open when lost balance equals zero.  This leaves the lost copy on the patron record when it is paid	bool	\N	\N	\N
circ.patron_expires_soon_warning	Warn when patron account is about to expire	circ	Warn when patron account is about to expire. If set, the staff client displays a warning this many days before the expiry of a patron account. Value is in number of days, for example: 3 for 3 days.	integer	\N	\N	\N
circ.fines.truncate_to_max_fine	Truncate fines to max fine amount	circ	\N	bool	\N	\N	\N
url_verify.url_verification_delay	Number of seconds to wait between URL test attempts.	url_verify	Throttling mechanism for batch URL verification runs.  Each running process will wait this number of seconds after a URL test before performing the next.	integer	\N	\N	544
url_verify.url_verification_max_redirects	Maximum redirect lookups	url_verify	For URLs returning 3XX redirects, this is the maximum number of redirects we will follow before giving up.	integer	\N	\N	544
url_verify.url_verification_max_wait	Maximum wait time (in seconds) for a URL to lookup	url_verify	If we exceed the wait time, the URL is marked as a "timeout" and the system moves on to the next URL	integer	\N	\N	544
url_verify.verification_batch_size	Number of URLs to test in parallel	url_verify	URLs are tested in batches.  This number defines the size of each batch and it directly relates to the number of back-end processes performing URL verification.	integer	\N	\N	544
acq.upload.default.create_po	Upload Create PO	acq	Create a purchase order by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.activate_po	Upload Activate PO	acq	Activate the purchase order by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.provider	Upload Default Provider	acq	Default provider to use during ACQ file upload	link	acqpro	\N	\N
acq.upload.default.vandelay.match_set	Upload Default Match Set	acq	Default match set to use during ACQ file upload	link	vms	\N	\N
acq.upload.default.vandelay.merge_profile	Upload Default Merge Profile	acq	Default merge profile to use during ACQ file upload	link	vmp	\N	\N
acq.upload.default.vandelay.import_non_matching	Upload Import Non Matching by Default	acq	Import non-matching records by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.vandelay.merge_on_exact	Upload Merge on Exact Match by Default	acq	Merge records on exact match by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.vandelay.merge_on_best	Upload Merge on Best Match by Default	acq	Merge records on best match by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.vandelay.merge_on_single	Upload Merge on Single Match by Default	acq	Merge records on single match by default during ACQ file upload	bool	\N	\N	\N
acq.upload.default.vandelay.quality_ratio	Upload Default Min. Quality Ratio	acq	Default minimum quality ratio used during ACQ file upload	integer	\N	\N	\N
acq.upload.default.vandelay.low_quality_fall_thru_profile	Upload Default Insufficient Quality Fall-Thru Profile	acq	Default low-quality fall through profile used during ACQ file upload	link	vmp	\N	\N
acq.upload.default.vandelay.load_item_for_imported	Upload Load Items for Imported Records by Default	acq	Load items for imported records by default during ACQ file upload	bool	\N	\N	\N
circ.hold_capture_order	Best-hold selection sort order	holds	Defines the sort order of holds when selecting a hold to fill using a given copy at capture time	link	cbho	\N	543
circ.hold_go_home_interval	Max foreign-circulation time	holds	Time a copy can spend circulating away from its circ lib before returning there to fill a hold (if one exists there)	interval	\N	\N	543
acq.fund.rollover_distrib_forms	Rollover Distribution Formulae Funds	acq	During fiscal rollover, update distribution formalae to use new funds	bool	\N	\N	\N
\.


--
-- Data for Name: org_unit_setting_type_log; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY org_unit_setting_type_log (id, date_applied, org, original_value, new_value, field_name) FROM stdin;
1	2015-06-22 09:56:07.231968-07	1	\N	"1 day"	circ.booking_reservation.default_elbow_room
2	2015-06-22 09:56:07.231968-07	1	\N	0	cat.spine.line.margin
3	2015-06-22 09:56:07.231968-07	1	\N	9	cat.spine.line.height
4	2015-06-22 09:56:07.231968-07	1	\N	8	cat.spine.line.width
5	2015-06-22 09:56:07.231968-07	1	\N	"monospace"	cat.label.font.family
6	2015-06-22 09:56:07.231968-07	1	\N	10	cat.label.font.size
7	2015-06-22 09:56:07.231968-07	1	\N	"normal"	cat.label.font.weight
8	2015-06-22 09:56:07.231968-07	1	\N	true	circ.grace.extend
9	2015-06-22 09:56:07.390418-07	1	\N	"6 months"	circ.hold_go_home_interval
\.


--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('org_unit_setting_type_log_id_seq', 9, true);


--
-- Data for Name: record_attr_definition; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY record_attr_definition (name, label, description, filter, sorter, tag, sf_list, joiner, xpath, format, start_pos, string_len, fixed_field, phys_char_sf) FROM stdin;
alph	Alph	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Alph	\N
audience	Audn	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Audn	\N
bib_level	BLvl	\N	t	f	\N	\N	\N	\N	\N	\N	\N	BLvl	\N
biog	Biog	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Biog	\N
conf	Conf	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Conf	\N
control_type	Ctrl	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Ctrl	\N
ctry	Ctry	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Ctry	\N
date1	Date1	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Date1	\N
pubdate	Pub Date	\N	f	t	\N	\N	\N	\N	\N	\N	\N	Date1	\N
date2	Date2	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Date2	\N
cat_form	Desc	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Desc	\N
pub_status	DtSt	\N	t	f	\N	\N	\N	\N	\N	\N	\N	DtSt	\N
enc_level	ELvl	\N	t	f	\N	\N	\N	\N	\N	\N	\N	ELvl	\N
fest	Fest	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Fest	\N
item_form	Form	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Form	\N
gpub	GPub	\N	t	f	\N	\N	\N	\N	\N	\N	\N	GPub	\N
ills	Ills	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Ills	\N
indx	Indx	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Indx	\N
item_lang	Lang	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Lang	\N
language	Language (2.0 compat version)	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Lang	\N
lit_form	LitF	\N	t	f	\N	\N	\N	\N	\N	\N	\N	LitF	\N
mrec	MRec	\N	t	f	\N	\N	\N	\N	\N	\N	\N	MRec	\N
ff_sl	S/L	\N	t	f	\N	\N	\N	\N	\N	\N	\N	S/L	\N
type_mat	TMat	\N	t	f	\N	\N	\N	\N	\N	\N	\N	TMat	\N
item_type	Type	\N	t	f	\N	\N	\N	\N	\N	\N	\N	Type	\N
vr_format	Videorecording format	\N	t	f	\N	\N	\N	\N	\N	\N	\N	\N	72
titlesort	Title	\N	f	t	tnf	\N	\N	\N	\N	\N	\N	\N	\N
authorsort	Author	\N	f	t	1%	abcdefgklmnopqrstvxyz	\N	\N	\N	\N	\N	\N	\N
\.


--
-- Data for Name: record_attr_index_norm_map; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY record_attr_index_norm_map (id, attr, norm, params, pos) FROM stdin;
\.


--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('record_attr_index_norm_map_id_seq', 1, false);


--
-- Data for Name: remote_account; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY remote_account (id, label, host, username, password, account, path, owner, last_activity) FROM stdin;
\.


--
-- Name: remote_account_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('remote_account_id_seq', 1, false);


--
-- Data for Name: rule_age_hold_protect; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY rule_age_hold_protect (id, name, age, prox) FROM stdin;
1	3month	3 mons	0
2	6month	6 mons	2
\.


--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('rule_age_hold_protect_id_seq', 100, true);


--
-- Data for Name: rule_circ_duration; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY rule_circ_duration (id, name, extended, normal, shrt, max_renewals) FROM stdin;
1	7_days_0_renew	7 days	7 days	7 days	0
2	28_days_2_renew	28 days	28 days	28 days	2
3	3_months_0_renew	3 mons	3 mons	3 mons	0
4	3_days_1_renew	3 days	3 days	3 days	1
5	2_months_2_renew	2 mons	2 mons	2 mons	2
6	35_days_1_renew	35 days	35 days	35 days	1
7	7_days_2_renew	7 days	7 days	7 days	2
8	1_hour_2_renew	01:00:00	01:00:00	01:00:00	2
9	28_days_0_renew	28 days	28 days	28 days	0
10	14_days_2_renew	14 days	14 days	14 days	2
11	default	21 days	14 days	7 days	2
\.


--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('rule_circ_duration_id_seq', 100, true);


--
-- Data for Name: rule_max_fine; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY rule_max_fine (id, name, amount, is_percent) FROM stdin;
1	default	5.00	f
2	overdue_min	5.00	f
3	overdue_mid	10.00	f
4	overdue_max	100.00	f
5	overdue_equip_min	25.00	f
6	overdue_equip_mid	25.00	f
7	overdue_equip_max	100.00	f
\.


--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('rule_max_fine_id_seq', 100, true);


--
-- Data for Name: rule_recurring_fine; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY rule_recurring_fine (id, name, high, normal, low, recurrence_interval, grace_period) FROM stdin;
1	default	0.50	0.10	0.05	1 day	1 day
2	10_cent_per_day	0.50	0.10	0.10	1 day	1 day
3	50_cent_per_day	0.50	0.50	0.50	1 day	1 day
\.


--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('rule_recurring_fine_id_seq', 100, true);


--
-- Data for Name: settings_group; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY settings_group (name, label) FROM stdin;
acq	Acquisitions
sys	System
gui	GUI
lib	Library
sec	Security
cat	Cataloging
holds	Holds
circ	Circulation
self	Self Check
opac	OPAC
prog	Program
glob	Global
finance	Finances
credit	Credit Card Processing
serial	Serials
recall	Recalls
booking	Booking
offline	Offline
receipt_template	Receipt Template
sms	SMS Text Messages
vandelay	Vandelay
url_verify	URL Verify
\.


--
-- Data for Name: sms_carrier; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY sms_carrier (id, region, name, email_gateway, active) FROM stdin;
1	Local	Test Carrier	opensrf+$number@localhost	f
2	Canada & USA	Rogers Wireless	$number@pcs.rogers.com	t
3	Canada & USA	Rogers Wireless (Alternate)	1$number@mms.rogers.com	t
4	Canada & USA	Telus Mobility	$number@msg.telus.com	t
5	Canada	Koodo Mobile	$number@msg.telus.com	t
6	Canada	Fido	$number@fido.ca	t
7	Canada	Bell Mobility & Solo Mobile	$number@txt.bell.ca	t
8	Canada	Bell Mobility & Solo Mobile (Alternate)	$number@txt.bellmobility.ca	t
9	Canada	Aliant	$number@sms.wirefree.informe.ca	t
10	Canada	PC Telecom	$number@mobiletxt.ca	t
11	Canada	SaskTel	$number@sms.sasktel.com	t
12	Canada	MTS Mobility	$number@text.mtsmobility.com	t
13	Canada	Virgin Mobile	$number@vmobile.ca	t
14	International	Iridium	$number@msg.iridium.com	t
15	International	Globalstar	$number@msg.globalstarusa.com	t
16	International	Bulletin.net	$number@bulletinmessenger.net	t
17	International	Panacea Mobile	$number@api.panaceamobile.com	t
18	USA	C Beyond	$number@cbeyond.sprintpcs.com	t
19	Alaska, USA	General Communications, Inc.	$number@mobile.gci.net	t
20	California, USA	Golden State Cellular	$number@gscsms.com	t
21	Cincinnati, Ohio, USA	Cincinnati Bell	$number@gocbw.com	t
22	Hawaii, USA	Hawaiian Telcom Wireless	$number@hawaii.sprintpcs.com	t
23	Midwest, USA	i wireless (T-Mobile)	$number.iws@iwspcs.net	t
24	USA	i-wireless (Sprint PCS)	$number@iwirelesshometext.com	t
25	USA	MetroPCS	$number@mymetropcs.com	t
26	USA	Kajeet	$number@mobile.kajeet.net	t
27	USA	Element Mobile	$number@SMS.elementmobile.net	t
28	USA	Esendex	$number@echoemail.net	t
29	USA	Boost Mobile	$number@myboostmobile.com	t
30	USA	BellSouth	$number@bellsouth.com	t
31	USA	Bluegrass Cellular	$number@sms.bluecell.com	t
32	USA	AT&T Enterprise Paging	$number@page.att.net	t
33	USA	AT&T Mobility/Wireless	$number@txt.att.net	t
34	USA	AT&T Global Smart Messaging Suite	$number@sms.smartmessagingsuite.com	t
35	USA	Alltel (Allied Wireless)	$number@sms.alltelwireless.com	t
36	USA	Alaska Communications	$number@msg.acsalaska.com	t
37	USA	Ameritech	$number@paging.acswireless.com	t
38	USA	Cingular (GoPhone prepaid)	$number@cingulartext.com	t
39	USA	Cingular (Postpaid)	$number@cingular.com	t
40	USA	Cellular One (Dobson) / O2 / Orange	$number@mobile.celloneusa.com	t
41	USA	Cellular South	$number@csouth1.com	t
42	USA	Cellcom	$number@cellcom.quiktxt.com	t
43	USA	Chariton Valley Wireless	$number@sms.cvalley.net	t
44	USA	Cricket	$number@sms.mycricket.com	t
45	USA	Cleartalk Wireless	$number@sms.cleartalk.us	t
46	USA	Edge Wireless	$number@sms.edgewireless.com	t
47	USA	Syringa Wireless	$number@rinasms.com	t
48	USA	T-Mobile	$number@tmomail.net	t
49	USA	Straight Talk / PagePlus Cellular	$number@vtext.com	t
50	USA	South Central Communications	$number@rinasms.com	t
51	USA	Simple Mobile	$number@smtext.com	t
52	USA	Sprint (PCS)	$number@messaging.sprintpcs.com	t
53	USA	Nextel	$number@messaging.nextel.com	t
54	USA	Pioneer Cellular	$number@zsend.com	t
55	USA	Qwest Wireless	$number@qwestmp.com	t
56	USA	US Cellular	$number@email.uscc.net	t
57	USA	Unicel	$number@utext.com	t
58	USA	Teleflip	$number@teleflip.com	t
59	USA	Virgin Mobile	$number@vmobl.com	t
60	USA	Verizon Wireless	$number@vtext.com	t
61	USA	USA Mobility	$number@usamobility.net	t
62	USA	Viaero	$number@viaerosms.com	t
63	USA	TracFone	$number@mmst5.tracfone.com	t
64	USA	Centennial Wireless	$number@cwemail.com	t
65	South Korea and USA	Helio	$number@myhelio.com	t
\.


--
-- Name: sms_carrier_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('sms_carrier_id_seq', 1000, true);


--
-- Data for Name: standing; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY standing (id, value) FROM stdin;
1	Good
2	Barred
\.


--
-- Name: standing_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('standing_id_seq', 100, true);


--
-- Data for Name: standing_penalty; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY standing_penalty (id, name, label, block_list, staff_alert, org_depth) FROM stdin;
1	PATRON_EXCEEDS_FINES	Patron exceeds fine threshold	CIRC|FULFILL|HOLD|CAPTURE|RENEW	t	\N
2	PATRON_EXCEEDS_OVERDUE_COUNT	Patron exceeds max overdue item threshold	CIRC|FULFILL|HOLD|CAPTURE|RENEW	t	\N
3	PATRON_EXCEEDS_CHECKOUT_COUNT	Patron exceeds max checked out item threshold	CIRC|FULFILL	t	\N
4	PATRON_EXCEEDS_COLLECTIONS_WARNING	Patron exceeds pre-collections warning fine threshold	CIRC|FULFILL|HOLD|CAPTURE|RENEW	t	\N
20	ALERT_NOTE	Alerting Note, no blocks	\N	t	\N
21	SILENT_NOTE	Note, no blocks	\N	f	\N
22	STAFF_C	Alerting block on Circ	CIRC	t	\N
23	STAFF_CH	Alerting block on Circ and Hold	CIRC|HOLD	t	\N
24	STAFF_CR	Alerting block on Circ and Renew	CIRC|RENEW	t	\N
25	STAFF_CHR	Alerting block on Circ, Hold and Renew	CIRC|HOLD|RENEW	t	\N
26	STAFF_HR	Alerting block on Hold and Renew	HOLD|RENEW	t	\N
27	STAFF_H	Alerting block on Hold	HOLD	t	\N
28	STAFF_R	Alerting block on Renew	RENEW	t	\N
29	INVALID_PATRON_ADDRESS	Patron has an invalid address	\N	f	\N
30	PATRON_IN_COLLECTIONS	Patron has been referred to a collections agency	\N	f	\N
31	INVALID_PATRON_EMAIL_ADDRESS	Patron had an invalid email address	\N	t	0
32	INVALID_PATRON_DAY_PHONE	Patron had an invalid daytime phone number	\N	t	0
33	INVALID_PATRON_EVENING_PHONE	Patron had an invalid evening phone number	\N	t	0
34	INVALID_PATRON_OTHER_PHONE	Patron had an invalid other phone number	\N	t	0
\.


--
-- Name: standing_penalty_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('standing_penalty_id_seq', 100, true);


--
-- Data for Name: ts_config_list; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY ts_config_list (id, name) FROM stdin;
simple	Non-Stemmed Simple
danish_nostop	Danish Stemmed
dutch_nostop	Dutch Stemmed
english_nostop	English Stemmed
finnish_nostop	Finnish Stemmed
french_nostop	French Stemmed
german_nostop	German Stemmed
hungarian_nostop	Hungarian Stemmed
italian_nostop	Italian Stemmed
norwegian_nostop	Norwegian Stemmed
portuguese_nostop	Portuguese Stemmed
romanian_nostop	Romanian Stemmed
russian_nostop	Russian Stemmed
spanish_nostop	Spanish Stemmed
swedish_nostop	Swedish Stemmed
turkish_nostop	Turkish Stemmed
\.


--
-- Data for Name: upgrade_log; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY upgrade_log (version, install_date, applied_to) FROM stdin;
0825	2015-06-22 09:56:04.864447-07	\N
2.4.3	2015-06-22 09:56:04.864447-07	\N
\.


--
-- Data for Name: usr_activity_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY usr_activity_type (id, ewho, ewhat, ehow, label, egroup, enabled, transient) FROM stdin;
1	\N	login	opensrf	Login via opensrf	authen	t	f
2	\N	login	srfsh	Login via srfsh	authen	t	f
3	\N	login	gateway-v1	Login via gateway-v1	authen	t	f
4	\N	login	translator-v1	Login via translator-v1	authen	t	f
5	\N	login	xmlrpc	Login via xmlrpc	authen	t	f
6	\N	login	remoteauth	Login via remoteauth	authen	t	f
7	\N	login	sip2	SIP2 Proxy Login	authen	t	f
8	\N	login	apache	Login via Apache module	authen	t	f
9	\N	verify	opensrf	Verification via opensrf	authz	t	f
10	\N	verify	srfsh	Verification via srfsh	authz	t	f
11	\N	verify	gateway-v1	Verification via gateway-v1	authz	t	f
12	\N	verify	translator-v1	Verification via translator-v1	authz	t	f
13	\N	verify	xmlrpc	Verification via xmlrpc	authz	t	f
14	\N	verify	remoteauth	Verification via remoteauth	authz	t	f
15	\N	verify	sip2	SIP2 User Verification	authz	t	f
16	opac	login	gateway-v1	OPAC Login (jspac)	authen	t	f
17	opac	login	apache	OPAC Login (tpac)	authen	t	f
18	staffclient	login	gateway-v1	Staff Client Login	authen	t	f
19	selfcheck	login	translator-v1	Self-Check Proxy Login	authen	t	f
20	ums	login	xmlrpc	Unique Mgt Login	authen	t	f
21	authproxy	login	apache	Apache Auth Proxy Login	authen	t	f
22	libraryelf	login	xmlrpc	LibraryElf Login	authz	t	f
23	selfcheck	verify	translator-v1	Self-Check User Verification	authz	t	f
24	ezproxy	verify	remoteauth	EZProxy Verification	authz	t	f
\.


--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('usr_activity_type_id_seq', 1000, true);


--
-- Data for Name: usr_setting_type; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY usr_setting_type (name, opac_visible, label, description, grp, datatype, fm_class) FROM stdin;
opac.default_font	t	OPAC Font Size	OPAC Font Size	\N	string	\N
opac.default_search_depth	t	OPAC Search Depth	OPAC Search Depth	\N	integer	\N
opac.default_search_location	t	OPAC Search Location	OPAC Search Location	\N	integer	\N
opac.hits_per_page	t	Hits per Page	Hits per Page	\N	string	\N
opac.hold_notify	t	Hold Notification Format	Hold Notification Format	\N	string	\N
staff_client.catalog.record_view.default	t	Default Record View	Default Record View	\N	string	\N
staff_client.copy_editor.templates	t	Copy Editor Template	Copy Editor Template	\N	object	\N
circ.holds_behind_desk	f	Hold is behind Circ Desk	Hold is behind Circ Desk	\N	bool	\N
opac.default_pickup_location	t	Default Hold Pickup Location	Default location for holds pickup	\N	integer	\N
history.circ.retention_age	t	Historical Circulation Retention Age	Historical Circulation Retention Age	\N	interval	\N
history.circ.retention_start	f	Historical Circulation Retention Start Date	Historical Circulation Retention Start Date	\N	date	\N
history.hold.retention_age	t	Historical Hold Retention Age	Historical Hold Retention Age	\N	interval	\N
history.hold.retention_start	t	Historical Hold Retention Start Date	Historical Hold Retention Start Date	\N	interval	\N
history.hold.retention_count	t	Historical Hold Retention Count	Historical Hold Retention Count	\N	integer	\N
opac.default_sort	t	OPAC Default Search Sort	OPAC Default Search Sort	\N	string	\N
opac.default_sms_carrier	t	Default SMS/Text Carrier	Default SMS/Text Carrier	sms	link	csc
opac.default_sms_notify	t	Default SMS/Text Number	Default SMS/Text Number	sms	string	\N
opac.default_phone	t	Default Phone Number	Default Phone Number	opac	string	\N
ui.grid_columns.circ.hold_pull_list	f	Hold Pull List	Hold Pull List Saved Column Settings	gui	string	\N
ui.grid_columns.actor.user.event_log	f	User Event Log	User Event Log Saved Column Settings	gui	string	\N
opac.temporary_list_no_warn	t	Opt out of warning when adding a book to a temporary book list	Opt out of warning when adding a book to a temporary book list	opac	bool	\N
opac.default_list	f	Default list to use when adding to a bookbag	Default list to use when adding to a bookbag	opac	integer	\N
ui.grid_columns.url_verify.select_urls	f	Link Checker's URL Selection interface's saved columns	Link Checker's URL Selection interface's saved columns	gui	string	\N
ui.grid_columns.url_verify.review_attempt	f	Link Checker's Review Attempt interface's saved columns	Link Checker's Review Attempt interface's saved columns	gui	string	\N
\.


--
-- Data for Name: weight_assoc; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY weight_assoc (id, active, org_unit, circ_weights, hold_weights) FROM stdin;
1	t	1	1	1
\.


--
-- Name: weight_assoc_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('weight_assoc_id_seq', 1, true);


--
-- Data for Name: xml_transform; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY xml_transform (name, namespace_uri, prefix, xslt) FROM stdin;
marcxml	http://www.loc.gov/MARC21/slim	marc	---
mods	http://www.loc.gov/mods/	mods	<?xml version="1.0" encoding="UTF-8"?>\n<xsl:stylesheet version="1.0" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:marc="http://www.loc.gov/MARC21/slim" xmlns="http://www.loc.gov/mods/" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" exclude-result-prefixes="marc">\n\t<xsl:output method="xml" indent="yes"/>\n\t<!-- This stylesheet is for MODS Version 2-->\n\t\n<!--\ttrail 1/04 fixes \n\t\t1 place code/text can't be in same "place" element\n\t\t2 form doesn't have "uncontrolled" subelement\n\t\t3 related items have notes before identifiers\n\t\t4. Title: partnumber/partnames movedoutside title element\n\t\t5. roles: both $e and $4 on X00 allowed, not choice: first of $e, $4.\n\t\t6.  041 tag: datafield, not controlfield\n\t\t7. removed marc:datafield[@tag=775] from related item type=related\n\t\t8. related origininfo/place/code, publisher, edition added for 775f, 76x-78x $b $d\n\t\t9. related language added for 775$e\n\t\t10.  subject authority ind2\tfix\n\t-->\n\t<xsl:template match="/">\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="marc:collection">\n\t\t\t\t<modsCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/ http://www.loc.gov/standards/mods/mods.xsd">\n\t\t\t\t\t<xsl:for-each select="marc:collection/marc:record">\n\t\t\t\t\t\t<mods>\n\t\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t\t</mods>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</modsCollection>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<mods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/ http://www.loc.gov/standards/mods/mods.xsd">\n\t\t\t\t\t<xsl:for-each select="marc:record">\n\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</mods>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="marcRecord">\n\t\t\t<xsl:variable name="leader" select="marc:leader"/>\n\t\t\t<xsl:variable name="leader6" select="substring($leader,7,1)"/>\n\t\t\t<xsl:variable name="leader7" select="substring($leader,8,1)"/>\n\t\t\t<xsl:variable name="controlField008" select="marc:controlfield[@tag=008]"/>\n\n\t\t\t<xsl:variable name="typeOf008">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$leader6='a'">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">BK</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">SE</xsl:when>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='t'">BK</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='p'">MM</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='m'">CF</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">MP</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='g' or $leader6='k' or $leader6='o' or $leader6='r'">VM</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d' or $leader6='i' or $leader6='j'">MU</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:variable>\n\n\n\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=245]">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<xsl:variable name="title">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">afghk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abfghk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="@ind2&gt;0">\n\t\t\t\t\t\t\t<nonSort>\n\t\t\t\t\t\t\t\t<xsl:value-of select="substring($title,1,@ind2)"/>\n\t\t\t\t\t\t\t</nonSort>\n\t\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t\t<xsl:value-of select="substring($title,@ind2+1)"/>\n\t\t\t\t\t\t\t</title>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t\t<xsl:value-of select="$title"/>\n\t\t\t\t\t\t\t</title>\n\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t\t\t\t<subTitle>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">afghk</xsl:with-param>\n\t\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</subTitle>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=210]">\n\t\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=242]">\n\t\t\t\t<titleInfo type="translated">\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abh</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=246]">\n\t\t\t\t<titleInfo type="alternative">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='i']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abfh</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=130]|marc:datafield[@tag=240]|marc:datafield[@tag=730][@ind2!=2]">\n\t\t\t\t<titleInfo type="uniform">\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t\t\t\t\t<xsl:if test="(contains('adfkmor',@code) and (not(../marc:subfield[@code='n' or @code='p']) or (following-sibling::marc:subfield[@code='n' or @code='p'])))">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2!=2]">\n\t\t\t\t<titleInfo type="alternative">\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">ah</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=100]">\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<text>creator</text>\n\t\t\t\t\t</role>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=110]">\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<text>creator</text>\n\t\t\t\t\t</role>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=111]">\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<text>creator</text>\n\t\t\t\t\t</role>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t<code>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</code>\n\t\t\t\t\t\t</role>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=700][not(marc:subfield[@code='t'])]">\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=710][not(marc:subfield[@code='t'])]">\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=711][not(marc:subfield[@code='t'])]">\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t<code>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</code>\n\t\t\t\t\t\t</role>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=720][not(marc:subfield[@code='t'])]">\n\t\t\t\t<name>\n\t\t\t\t\t<xsl:if test="@ind1=1">\n\t\t\t\t\t\t<xsl:attribute name="type">personal</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t</xsl:for-each>\n\n\t\t\t<typeOfResource>\n\t\t\t\t<xsl:if test="$leader7='c'">\n\t\t\t\t\t<xsl:attribute name="collection">yes</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="$leader6='d' or $leader6='f' or $leader6='p' or $leader6='t'">\n\t\t\t\t\t<xsl:attribute name="manuscript">yes</xsl:attribute>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$leader6='a' or $leader6='t'">text</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">cartographic</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d'">notated music</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='i' or $leader6='j'">sound recording</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='k'">still image</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='g'">moving image</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='r'">three dimensional object</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='m'">software, multimedia</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6='p'">mixed material</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</typeOfResource>\n\n\t\t\t<xsl:if test="substring($controlField008,26,1)='d'">\n\t\t\t\t<genre authority="marc">globe</genre>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t\t<genre authority="marc">remote sensing image</genre>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='MP'">\n\t\t\t\t<xsl:variable name="controlField008-25" select="substring($controlField008,26,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-25='a' or $controlField008-25='b' or $controlField008-25='c' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t\t\t<genre authority="marc">map</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-25='e' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t\t\t<genre authority="marc">atlas</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='SE'">\n\t\t\t\t<xsl:variable name="controlField008-21" select="substring($controlField008,22,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-21='d'">\n\t\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-21='l'">\n\t\t\t\t\t\t<genre authority="marc">loose-leaf</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-21='m'">\n\t\t\t\t\t\t<genre authority="marc">series</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-21='n'">\n\t\t\t\t\t\t<genre authority="marc">newspaper</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-21='p'">\n\t\t\t\t\t\t<genre authority="marc">periodical</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-21='w'">\n\t\t\t\t\t\t<genre authority="marc">web site</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='SE'">\n\t\t\t\t<xsl:variable name="controlField008-24" select="substring($controlField008,25,4)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'a')">\n\t\t\t\t\t\t<genre authority="marc">abstract or summary</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'b')">\n\t\t\t\t\t\t<genre authority="marc">bibliography</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'c')">\n\t\t\t\t\t\t<genre authority="marc">catalog</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'d')">\n\t\t\t\t\t\t<genre authority="marc">dictionary</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'e')">\n\t\t\t\t\t\t<genre authority="marc">encyclopedia</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'f')">\n\t\t\t\t\t\t<genre authority="marc">handbook</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'g')">\n\t\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'i')">\n\t\t\t\t\t\t<genre authority="marc">index</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'k')">\n\t\t\t\t\t\t<genre authority="marc">discography</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'l')">\n\t\t\t\t\t\t<genre authority="marc">legislation</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'m')">\n\t\t\t\t\t\t<genre authority="marc">theses</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'n')">\n\t\t\t\t\t\t<genre authority="marc">survey of literature</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'o')">\n\t\t\t\t\t\t<genre authority="marc">review</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'p')">\n\t\t\t\t\t\t<genre authority="marc">programmed text</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'q')">\n\t\t\t\t\t\t<genre authority="marc">filmography</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'r')">\n\t\t\t\t\t\t<genre authority="marc">directory</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'s')">\n\t\t\t\t\t\t<genre authority="marc">statistics</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'t')">\n\t\t\t\t\t\t<genre authority="marc">technical report</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'v')">\n\t\t\t\t\t\t<genre authority="marc">legal case and case notes</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'w')">\n\t\t\t\t\t\t<genre authority="marc">law report or digest</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="contains($controlField008-24,'z')">\n\t\t\t\t\t\t<genre authority="marc">treaty</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-29='1'">\n\t\t\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='CF'">\n\t\t\t\t<xsl:variable name="controlField008-26" select="substring($controlField008,27,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-26='a'">\n\t\t\t\t\t\t<genre authority="marc">numeric data</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-26='e'">\n\t\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-26='f'">\n\t\t\t\t\t\t<genre authority="marc">font</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-26='g'">\n\t\t\t\t\t\t<genre authority="marc">game</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='BK'">\n\t\t\t\t<xsl:if test="substring($controlField008,25,1)='j'">\n\t\t\t\t\t<genre authority="marc">patent</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="substring($controlField008,31,1)='1'">\n\t\t\t\t\t<genre authority="marc">festschrift</genre>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:variable name="controlField008-34" select="substring($controlField008,35,1)"/>\n\t\t\t\t<xsl:if test="$controlField008-34='a' or $controlField008-34='b' or $controlField008-34='c' or $controlField008-34='d'">\n\t\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-33='e'">\n\t\t\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t\t<genre authority="marc">comic strip</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='h'">\n\t\t\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t\t<genre authority="marc">letter</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t\t<genre authority="marc">novel</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='j'">\n\t\t\t\t\t\t<genre authority="marc">short story</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='MU'">\n\t\t\t\t<xsl:variable name="controlField008-30-31" select="substring($controlField008,31,2)"/>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'b')">\n\t\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'c')">\n\t\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'d')">\n\t\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'e')">\n\t\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'f')">\n\t\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'o')">\n\t\t\t\t\t<genre authority="marc">folktale</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'h')">\n\t\t\t\t\t<genre authority="marc">history</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'k')">\n\t\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'m')">\n\t\t\t\t\t<genre authority="marc">memoir</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'p')">\n\t\t\t\t\t<genre authority="marc">poetry</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'r')">\n\t\t\t\t\t<genre authority="marc">rehersal</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'g')">\n\t\t\t\t\t<genre authority="marc">reporting</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'s')">\n\t\t\t\t\t<genre authority="marc">sound</genre>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="contains($controlField008-30-31,'l')">\n\t\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$typeOf008='VM'">\n\t\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-33='a'">\n\t\t\t\t\t\t<genre authority="marc">art original</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='b'">\n\t\t\t\t\t\t<genre authority="marc">kit</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t\t<genre authority="marc">art reproduction</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t\t<genre authority="marc">diorama</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t\t<genre authority="marc">filmstrip</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='g'">\n\t\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t\t<genre authority="marc">picture</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='k'">\n\t\t\t\t\t\t<genre authority="marc">graphic</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t\t<genre authority="marc">technical drawing</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='m'">\n\t\t\t\t\t\t<genre authority="marc">motion picture</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='n'">\n\t\t\t\t\t\t<genre authority="marc">chart</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='o'">\n\t\t\t\t\t\t<genre authority="marc">flash card</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='p'">\n\t\t\t\t\t\t<genre authority="marc">microscope slide</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='q' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t\t\t<genre authority="marc">model</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='r'">\n\t\t\t\t\t\t<genre authority="marc">realia</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t\t<genre authority="marc">slide</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='t'">\n\t\t\t\t\t\t<genre authority="marc">transparency</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='v'">\n\t\t\t\t\t\t<genre authority="marc">videorecording</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-33='w'">\n\t\t\t\t\t\t<genre authority="marc">toy</genre>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=655]">\n\t\t\t\t<genre authority="marc">\n\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abvxyz</xsl:with-param>\n\t\t\t\t\t\t<xsl:with-param name="delimeter">-</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</genre>\n\t\t\t</xsl:for-each>\n\n\t\t\t<originInfo>\n\t\t\t\t<xsl:variable name="MARCpublicationCode" select="normalize-space(substring($controlField008,16,3))"/>\n\t\t\t\t<!-- 1/04 fix -->\t\t\t\t\n\t\t\t\t\t<xsl:if test="translate($MARCpublicationCode,'|','')">\n\t\t\t\t\t<place>\n\t\t\t\t\t\t<code authority="marc">\n\t\t\t\t\t\t\t<xsl:value-of select="$MARCpublicationCode"/>\n\t\t\t\t\t\t</code>\n\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:if>\n\n\t\t\t\t\t<xsl:for-each select="marc:datafield[@tag=044]/marc:subfield[@code='c']">\n\t\t\t\t\t<place>\n\t\t\t\t\t\t<code authority="iso3166">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</code>\n\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\n\t\t\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='a']">\n\t\t\t\t\t<place>\n\t\t\t\t\t\t<text>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</text>\n\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='b' or @code='c' or @code='g']">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="@code='b'">\n\t\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</publisher>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@code='c'">\n\t\t\t\t\t\t\t<dateIssued>\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@code='g'">\n\t\t\t\t\t\t\t<dateCreated>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</dateCreated>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:variable name="dataField260c">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="marc:datafield[@tag=260]/marc:subfield[@code='c']"/>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:variable>\n\n\t\t\t\t<xsl:variable name="controlField008-7-10" select="normalize-space(substring($controlField008, 8, 4))"/>\n\t\t\t\t<xsl:variable name="controlField008-11-14" select="normalize-space(substring($controlField008, 12, 4))"/>\n\t\t\t\t<xsl:variable name="controlField008-6" select="normalize-space(substring($controlField008, 7, 1))"/>\n\n\t\t\t\t<xsl:if test="$controlField008-6='e' or $controlField008-6='p' or $controlField008-6='r' or $controlField008-6='t' or $controlField008-6='s'">\n\t\t\t\t\t<xsl:if test="$controlField008-7-10 and ($controlField008-7-10 != $dataField260c)">\n\t\t\t\t\t\t<dateIssued encoding="marc">\n\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t\t<dateIssued encoding="marc" point="start">\n\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t\t<dateIssued encoding="marc" point="end">\n\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=0 or @ind1=1]/marc:subfield[@code='a']">\n\t\t\t\t\t<dateCaptured encoding="iso8601">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</dateCaptured>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][1]">\n\t\t\t\t\t<dateCaptured encoding="iso8601" point="start">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</dateCaptured>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][2]">\n\t\t\t\t\t<dateCaptured encoding="iso8601" point="end">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</dateCaptured>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=250]/marc:subfield[@code='a']">\n\t\t\t\t\t<edition>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</edition>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:leader">\n\t\t\t\t\t<issuance>\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">monographic</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">continuing</xsl:when>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</issuance>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=310]|marc:datafield[@tag=321]">\n\t\t\t\t\t<frequency>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</frequency>\n\t\t\t\t</xsl:for-each>\n\t\t\t</originInfo>\n\n\t\t\t<!-- 1/04 fix -->\n\t\t\t<xsl:for-each select="marc:datafield[@tag=041]">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='d' or @code='e']">\n\t\t\t\t\t<language>\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="../marc:subfield[@code='2']">\n\t\t\t\t\t\t\t\t<xsl:attribute name="authority">rfc3066</xsl:attribute>\n\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t\t<xsl:attribute name="authority">iso639-2b</xsl:attribute>\n\t\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</language>\n\t\t\t\t</xsl:for-each>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:variable name="controlField008-35-37" select="normalize-space(translate(substring($controlField008,36,3),'|#',''))"/>\n\t\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t\t<language authority="iso639-2b">\n\t\t\t\t\t<xsl:value-of select="substring($controlField008,36,3)"/>\n\t\t\t\t</language>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:variable name="physicalDescription">\n\t\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='a' or substring(.,12,1)='b']">\n\t\t\t\t\t<digitalOrigin>reformatted digital</digitalOrigin>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:variable name="controlField008-23" select="substring($controlField008,24,1)"/>\n\t\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\n\t\t\t\t<xsl:variable name="check008-23">\n\t\t\t\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='MU' or $typeOf008='SE' or $typeOf008='MM'">\n\t\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:variable>\n\n\t\t\t\t<xsl:variable name="check008-29">\n\t\t\t\t\t<xsl:if test="$typeOf008='MP' or $typeOf008='VM'">\n\t\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:variable>\n\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='f') or ($check008-29 and $controlField008-29='f')">\n\t\t\t\t\t\t<form authority="marcform">braille</form>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="($controlField008-23=' ' and ($leader6='c' or $leader6='d')) or (($typeOf008='BK' or $typeOf008='SE') and ($controlField008-23=' ' or $controlField008='r'))">\n\t\t\t\t\t\t<form authority="marcform">print</form>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$leader6 = 'm' or ($check008-23 and $controlField008-23='s') or ($check008-29 and $controlField008-29='s')">\n\t\t\t\t\t\t<form authority="marcform">electronic</form>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='b') or ($check008-29 and $controlField008-29='b')">\n\t\t\t\t\t\t<form authority="marcform">microfiche</form>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='a') or ($check008-29 and $controlField008-29='a')">\n\t\t\t\t\t\t<form authority="marcform">microfilm</form>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\n\t\t\t\t<xsl:for-each select="marc:controlfield[@tag=007][substring(text(),1,1)='c']">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="substring(text(),14,1)='a'">\n\t\t\t\t\t\t\t<reformattingQuality>access</reformattingQuality>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:when test="substring(text(),14,1)='p'">\n\t\t\t\t\t\t\t<reformattingQuality>preservation</reformattingQuality>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:when test="substring(text(),14,1)='r'">\n\t\t\t\t\t\t\t<reformattingQuality>replacement</reformattingQuality>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=856]/marc:subfield[@code='q'][string-length(.)&gt;1]">\n\t\t\t\t\t<internetMediaType>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</internetMediaType>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=256]/marc:subfield[@code='a']">\n\t\t\t\t\t<form><xsl:value-of select="."/></form>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=300]">\n\t\t\t\t\t<extent>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abce</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</extent>\n\t\t\t\t</xsl:for-each>\n\t\t\t</xsl:variable>\n\n\t\t\t<xsl:if test="string-length(normalize-space($physicalDescription))">\n\t\t\t\t<physicalDescription>\n\t\t\t\t\t<xsl:copy-of select="$physicalDescription"/>\n\t\t\t\t</physicalDescription>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=520]">\n\t\t\t\t<abstract>\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</abstract>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=505]">\n\t\t\t\t<tableOfContents>\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">agrt</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</tableOfContents>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=521]">\n\t\t\t\t<targetAudience>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</targetAudience>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='CF' or $typeOf008='MU' or $typeOf008='VM'">\n\t\t\t\t<xsl:variable name="controlField008-22" select="substring($controlField008,23,1)"/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="$controlField008-22='d'">\n\t\t\t\t\t\t<targetAudience>adolescent</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-22='e'">\n\t\t\t\t\t\t<targetAudience>adult</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-22='g'">\n\t\t\t\t\t\t<targetAudience>general</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-22='b' or $controlField008-22='c' or $controlField008-22='j'">\n\t\t\t\t\t\t<targetAudience>juvenile</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-22='a'">\n\t\t\t\t\t\t<targetAudience>preschool</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="$controlField008-22='f'">\n\t\t\t\t\t\t<targetAudience>specialized</targetAudience>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:if>\n\n\t\t\t<!-- Not in mapping but in conversion -->\n\t\t\t<xsl:for-each select="marc:datafield[@tag=245]/marc:subfield[@code='c']">\n\t\t\t\t<note type="statement of responsibility">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</note>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=500]">\n\t\t\t\t<note>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t</note>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=511]">\n\t\t\t\t<note type="performers">\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</note>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=518]">\n\t\t\t\t<note type="venue">\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</note>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=501 or @tag=502 or @tag=504 or @tag=506 or @tag=507 or @tag=508 or @tag=510 or @tag=513 or @tag=514 or @tag=515 or @tag=516 or @tag=522 or @tag=524 or @tag=525 or @tag=526 or @tag=530 or @tag=533 or @tag=534 or @tag=535 or @tag=536 or @tag=538 or @tag=540 or @tag=541 or @tag=544 or @tag=545 or @tag=546 or @tag=547 or @tag=550 or @tag=552 or @tag=555 or @tag=556 or @tag=561 or @tag=562 or @tag=565 or @tag=567 or @tag=580 or @tag=581 or @tag=583 or @tag=584 or @tag=585 or @tag=586]">\n\t\t\t\t<note>\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t\t</note>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=034][marc:subfield[@code='d' or @code='e' or @code='f' or @code='g']]">\n\t\t\t\t<subject>\n\t\t\t\t\t<cartographics>\n\t\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">defg</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</coordinates>\n\t\t\t\t\t</cartographics>\n\t\t\t\t</subject>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=255]">\n\t\t\t\t<subject>\n\t\t\t\t\t<cartographics>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</coordinates>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t\t<scale>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</scale>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<projection>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</projection>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</cartographics>\n\t\t\t\t</subject>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:apply-templates select="marc:datafield[653 &gt;= @tag and @tag &gt;= 600]"/>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=752]">\n\t\t\t\t<subject>\n\t\t\t\t\t<hierarchicalGeographic>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t\t<country>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</country>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<state>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</state>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t\t<county>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</county>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t\t\t<city>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</city>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</hierarchicalGeographic>\n\t\t\t\t</subject>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=050]">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t\t<xsl:value-of select="preceding-sibling::marc:subfield[@code='a'][1]"/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</classification>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a'][not(following-sibling::marc:subfield[@code='b'])]">\n\t\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</classification>\n\t\t\t\t</xsl:for-each>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=082]">\n\t\t\t\t<classification authority="ddc">\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='2']">\n\t\t\t\t\t\t<xsl:attribute name="edition">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=080]">\n\t\t\t\t<classification authority="udc">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abx</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=060]">\n\t\t\t\t<classification authority="nlm">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=0]">\n\t\t\t\t<classification authority="sudocs">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=1]">\n\t\t\t\t<classification authority="candoc">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=086]">\n\t\t\t\t<classification>\n\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=084]">\n\t\t\t\t<classification>\n\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=440]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=490][@ind1=0]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\t\t\t\t\t\t\t\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t\t<relatedItem type="original">\n\t\t\t\t\t<xsl:call-template name="relatedTitle"/>\n\t\t\t\t\t<xsl:call-template name="relatedName"/>\n\t\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='z']">\n\t\t\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</identifier>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:call-template name="relatedNote"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=700][marc:subfield[@code='t']]">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="personal">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">abcq</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t\t<text>\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t</role>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=710][marc:subfield[@code='t']]">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="relatedPart"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="corporate">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:variable name="tempNamePart">\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:if test="normalize-space($tempNamePart)">\n\t\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t\t<xsl:value-of select="$tempNamePart"/>\n\t\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t\t<text>\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t</role>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=711][marc:subfield[@code='t']]">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="relatedPart"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="conference">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=730][@ind2=2]">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2=2]">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=760]|marc:datafield[@tag=762]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\t\t\t<!-- 1/04  fix removed 775 -->\n\t\t\t<xsl:for-each select="marc:datafield[@tag=765]|marc:datafield[@tag=767]|marc:datafield[@tag=777]|marc:datafield[@tag=787]">\n\t\t\t\t<relatedItem type="related">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=775]">\n\t\t\t\t<relatedItem type="otherVersion">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\t\t\t\t\t\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=770]|marc:datafield[@tag=774]">\n\t\t\t\t<relatedItem type="constituent">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=772]|marc:datafield[@tag=773]">\n\t\t\t\t<relatedItem type="host">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=776]">\n\t\t\t\t<relatedItem type="otherFormat">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=780]">\n\t\t\t\t<relatedItem type="preceding">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=785]">\n\t\t\t\t<relatedItem type="succeeding">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=786]">\n\t\t\t\t<relatedItem type="original">\n\t\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=800]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="personal">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">abcq</xsl:with-param>\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t\t<text>\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t</role>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=810]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="relatedPart"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="corporate">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t\t\t\t\t<role>\n\t\t\t\t\t\t\t\t<text>\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t</role>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=811]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="relatedPart"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<name type="conference">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</name>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=830]">\n\t\t\t\t<relatedItem type="series">\n\t\t\t\t\t<titleInfo>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t\t</titleInfo>\n\t\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=856][@ind2=2]/marc:subfield[@code='q']">\n\t\t\t\t<relatedItem>\n\t\t\t\t\t<internetMediaType>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</internetMediaType>\n\t\t\t\t</relatedItem>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=020]">\n\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=0]">\n\t\t\t\t<identifier type="isrc">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=2]">\n\t\t\t\t<identifier type="ismn">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=022]">\n\t\t\t\t<identifier type="issn">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=010]">\n\t\t\t\t<identifier type="lccn">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="normalize-space(marc:subfield[@code='a'])"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=028]">\n\t\t\t\t<identifier>\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=0">issue number</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=1">matrix number</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=2">music plate</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=3">music publisher</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=4">videorecording identifier</xsl:when>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=4]">\n\t\t\t\t<identifier type="sici">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=037]">\n\t\t\t\t<identifier type="stock number">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=856][marc:subfield[@code='u']]">\n\t\t\t\t<identifier>\n\t\t\t\t\t<xsl:call-template name="displayLabel"/>\n\t\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:doi') or starts-with(marc:subfield[@code='u'],'doi:')">doi</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>uri</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=1]">\n\t\t\t\t<identifier type="upc">\n\t\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=852]">\n\t\t\t\t<location>\n\t\t\t\t\t<xsl:call-template name="displayLabel"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abj</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</location>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t\t<accessCondition type="restrictionOnAccess">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcd35</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</accessCondition>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=540]">\n\t\t\t\t<accessCondition type="useAndReproduction">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcde35</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</accessCondition>\n\t\t\t</xsl:for-each>\n\n\t\t\t<recordInfo>\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=040]">\n\t\t\t\t\t<recordContentSource>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t</recordContentSource>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:controlfield[@tag=008]">\n\t\t\t\t\t<recordCreationDate encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="substring(.,1,6)"/>\n\t\t\t\t\t</recordCreationDate>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:controlfield[@tag=005]">\n\t\t\t\t\t<recordChangeDate encoding="iso8601">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</recordChangeDate>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:controlfield[@tag=001]">\n\t\t\t\t\t<recordIdentifier>\n\t\t\t\t\t\t<xsl:if test="../marc:controlfield[@tag=003]">\n\t\t\t\t\t\t\t<xsl:attribute name="source">\n\t\t\t\t\t\t\t\t<xsl:value-of select="../marc:controlfield[@tag=003]"/>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</recordIdentifier>\n\t\t\t\t</xsl:for-each>\n\n\t\t\t\t<xsl:for-each select="marc:datafield[@tag=040]/marc:subfield[@code='b']">\n\t\t\t\t\t<languageOfCataloging>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</languageOfCataloging>\n\t\t\t\t</xsl:for-each>\n\t\t\t</recordInfo>\n\t</xsl:template>\n\n\t<xsl:template name="displayForm">\n\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t<displayForm>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</displayForm>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="affiliation">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<affiliation>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</affiliation>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="uri">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<xsl:attribute name="xlink:href">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="role">\n\t<!-- 1/04 fix -->\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<role>\n\t\t\t\t<text>\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</text>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t<role>\n\t\t\t\t<code>\n\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</code>\n\t\t\t</role>\n\t\t</xsl:for-each>\t\t\t\n\t</xsl:template>\n\n\t<xsl:template name="part">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fghkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fghkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:value-of select="$partNumber"/>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:value-of select="$partName"/>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedPart">\n\t\t<xsl:for-each select="marc:subfield[@code='n'][preceding-sibling::marc:subfield[@code='t']]">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</partNumber>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='p']">\n\t\t\t<partName>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</partName>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedName">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<name>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</namePart>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedForm">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<form>\n\t\t\t\t\t<!--1/04 fix -->\n\t\t\t<!--\t\t<unControlled>-->\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t<!--\t\t\t\t</unControlled>-->\n\t\t\t\t</form>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedExtent">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</extent>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedNote">\n\t\t<xsl:for-each select="marc:subfield[@code='n']">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifierISSN">\n\t\t<xsl:for-each select="marc:subfield[@code='x']">\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifierLocal">\n\t\t<xsl:for-each select="marc:subfield[@code='w']">\n\t\t\t<identifier type="local">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifier">\n\t\t<xsl:for-each select="marc:subfield[@code='o']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedItem76X-78X">\n\t\t<xsl:call-template name="relatedTitle76X-78X"/>\n\t\t<xsl:call-template name="relatedName"/>\n\t\t<!-- 1/04 fix -->\n\t\t<xsl:call-template name="relatedOriginInfo"/>\n\t\t<xsl:call-template name="relatedLanguage"/>\n\t\t<xsl:call-template name="relatedExtent"/>\n\t\t<xsl:call-template name="relatedNote"/>\n\t\t<xsl:call-template name="relatedIdentifier"/>\n\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t<xsl:call-template name="relatedIdentifierLocal"/>\n\t\t\n\t</xsl:template>\n\n\t<xsl:template name="subjectGeographicZ">\n\t\t<geographic>\n\t\t\t<xsl:value-of select="."/>\n\t\t</geographic>\n\t</xsl:template>\n\n\t<xsl:template name="subjectTemporalY">\n\t\t<temporal>\n\t\t\t<xsl:value-of select="."/>\n\t\t</temporal>\n\t</xsl:template>\n\n\t<xsl:template name="subjectTopic">\n\t\t<topic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</topic>\n\t</xsl:template>\n\n\t<xsl:template name="nameABCDN">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:if test="marc:subfield[@code='c'] or marc:subfield[@code='d'] or marc:subfield[@code='n']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">cdn</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="nameABCDQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcq</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t\t<xsl:call-template name="nameDate"/>\n\t</xsl:template>\n\n\t<xsl:template name="nameACDEQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t<xsl:with-param name="codes">acdeq</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t</xsl:template>\n\n\t<xsl:template name="constituentOrRelatedType">\n\t\t<xsl:attribute name="type">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@ind2=2">constituent</xsl:when>\n\t\t\t\t<xsl:otherwise>related</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\n\t<xsl:template name="relatedTitle">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedTitle76X-78X">\n\t\t<titleInfo>\n\t\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</title>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='g']">\n\t\t\t\t<partNumber>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</partNumber>\n\t\t\t</xsl:for-each>\n\t\t</titleInfo>\n\t</xsl:template>\n\n\t<xsl:template name="nameDate">\n\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t<namePart type="date">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="subjectAuthority">\n\t\t<xsl:attribute name="authority">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@ind2=0">lcsh</xsl:when>\n\t\t\t\t<xsl:when test="@ind2=1">lcshac</xsl:when>\n\t\t\t\t<xsl:when test="@ind2=2">mesh</xsl:when>\n\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t<xsl:when test="@ind2=3">nal</xsl:when>\n\t\t\t\t<xsl:when test="@ind2=5">csh</xsl:when>\n\t\t\t\t<xsl:when test="@ind2=6">rvm</xsl:when>\n\t\t\t\t<xsl:when test="@ind2=7">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\n\t<xsl:template name="subjectAnyOrder">\n\t\t<xsl:for-each select="marc:subfield[@code='v' or @code='x' or @code='y' or @code='z']">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@code='v'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='x'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='y'">\n\t\t\t\t\t<xsl:call-template name="subjectTemporalY"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='z'">\n\t\t\t\t\t<xsl:call-template name="subjectGeographicZ"/>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="specialSubfieldSelect">\n\t\t<xsl:param name="anyCodes"/>\n\t\t<xsl:param name="axis"/>\n\t\t<xsl:param name="beforeCodes"/>\n\t\t<xsl:param name="afterCodes"/>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($anyCodes, @code) or (contains($beforeCodes,@code) and following-sibling::marc:subfield[@code=$axis]) or (contains($afterCodes,@code) and preceding-sibling::marc:subfield[@code=$axis])">\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=600]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="personal">\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abcq</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=610]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:if test="marc:subfield[@code='c' or @code='d' or @code='n' or @code='p']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">cdnp</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=611]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="conference">\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcdeqnp</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<code>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</code>\n\t\t\t\t\t</role>\n\t\t\t\t</xsl:for-each>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=630]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">adfhklor</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\t\t\t\t\t\n\t\t\t\t</title>\n\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=650]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<topic>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abcd</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</topic>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\n\t<xsl:template match="marc:datafield[@tag=651]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<geographic>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</geographic>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=653]">\n\t\t<subject>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<topic>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</topic>\n\t\t\t</xsl:for-each>\n\t\t</subject>\n\t</xsl:template>\n\t<!-- 1/04 fix -->\n\t<xsl:template name="relatedOriginInfo">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='d'] or marc:subfield[@code='f']">\n\t\t\t<originInfo>\n\t\t\t\t<xsl:if test="@tag=775">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='f']">\t\t\t\n\t\t\t\t\t\t<place>\n\t\t\t\t\t\t\t<code>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</code>\n\t\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t<publisher>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</publisher>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<edition>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</edition>\n\t\t\t\t</xsl:for-each>\n\t\t\t</originInfo>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedLanguage">\n\t\t<xsl:if test="@tag=775 and marc:subfield[@code='e']">\n\t\t\t<language authority="iso639-2b">\t\t\t\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='e']"/>\n\t\t\t</language>\n\t\t</xsl:if>\t\t\t\t\n\t</xsl:template>\n\n\t<xsl:template name="displayLabel">\n\t\t<xsl:if test="marc:subfield[@code='3']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='3']"/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="isInvalid">\n\t\t<xsl:if test="marc:subfield[@code='z']">\n\t\t\t<xsl:attribute name="invalid">yes</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="script">\n\t\t<xsl:param name="scriptCode"/>\n\t\t<xsl:attribute name="script">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$scriptCode='(3'">Arabic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(B'">Latin</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='$1'">Chinese, Japanese, Korean</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(N'">Cyrillic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(2'">Hebrew</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(S'">Greek</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\t<xsl:template name="datafield">\n\t\t<xsl:param name="tag"/>\n\t\t<xsl:param name="ind1"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="ind2"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="subfields"/>\n\t\t<xsl:element name="marc:datafield">\n\t\t\t<xsl:attribute name="tag">\n\t\t\t\t<xsl:value-of select="$tag"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind1">\n\t\t\t\t<xsl:value-of select="$ind1"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind2">\n\t\t\t\t<xsl:value-of select="$ind2"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:copy-of select="$subfields"/>\n\t\t</xsl:element>\n\t</xsl:template>\n\n\t<xsl:template name="subfieldSelect">\n\t\t<xsl:param name="codes"/>\n\t\t<xsl:param name="delimeter"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($codes, @code)">\n\t\t\t\t\t<xsl:value-of select="text()"/><xsl:value-of select="$delimeter"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-string-length($delimeter))"/>\n\t</xsl:template>\n\n\t<xsl:template name="buildSpaces">\n\t\t<xsl:param name="spaces"/>\n\t\t<xsl:param name="char"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:if test="$spaces>0">\n\t\t\t<xsl:value-of select="$char"/>\n\t\t\t<xsl:call-template name="buildSpaces">\n\t\t\t\t<xsl:with-param name="spaces" select="$spaces - 1"/>\n\t\t\t\t<xsl:with-param name="char" select="$char"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuation">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:param name="punctuation"><xsl:text>.:,;/ </xsl:text></xsl:param>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains($punctuation, substring($chopString,$length,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,1,$length - 1)"/>\n\t\t\t\t\t<xsl:with-param name="punctuation" select="$punctuation"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuationFront">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains('.:,;/[ ', substring($chopString,1,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,2,$length - 1)"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n</xsl:stylesheet>\n
mods3	http://www.loc.gov/mods/v3	mods3	<?xml version="1.0" encoding="UTF-8"?>\n<xsl:stylesheet version="1.0" xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:marc="http://www.loc.gov/MARC21/slim" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" exclude-result-prefixes="xlink marc">\n\t<xsl:include href="MARC21slimUtils.xsl"/>\n\t<xsl:output method="xml" indent="yes" encoding="UTF-8"/>\n\n<!--\nRevision 1.9 subfield $y was added to field 242 2004/09/02 10:57 jrad\n\nRevision 1.8 Subject chopPunctuation expanded and attribute fixes 2004/08/12 jrad\n\nRevision 1.7 2004/03/25 08:29 jrad\n\nRevision 1.6 various validation fixes 2004/02/20 ntra\n\nRevision 1.5  2003/10/02 16:18:58  ntra\nMODS2 to MODS3 updates, language unstacking and \nde-duping, chopPunctuation expanded\n\nRevision 1.3  2003/04/03 00:07:19  ntra\nRevision 1.3 Additional Changes not related to MODS Version 2.0 by ntra\n\nRevision 1.2  2003/03/24 19:37:42  ckeith\nAdded Log Comment\n\n-->\n\t<xsl:template match="/">\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="marc:collection">\n\t\t\t\t<modsCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-0.xsd">\n\t\t\t\t\t<xsl:for-each select="marc:collection/marc:record">\n\t\t\t\t\t\t<mods version="3.0">\n\t\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t\t</mods>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</modsCollection>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<mods version="3.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-0.xsd">\n\t\t\t\t\t<xsl:for-each select="marc:record">\n\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</mods>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="marcRecord">\n\t\t<xsl:variable name="leader" select="marc:leader"/>\n\t\t<xsl:variable name="leader6" select="substring($leader,7,1)"/>\n\t\t<xsl:variable name="leader7" select="substring($leader,8,1)"/>\n\t\t<xsl:variable name="controlField008" select="marc:controlfield[@tag=008]"/>\n\t\t<xsl:variable name="typeOf008">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a'">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">BK</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">SE</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='t'">BK</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">MM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">CF</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">MP</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g' or $leader6='k' or $leader6='o' or $leader6='r'">VM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d' or $leader6='i' or $leader6='j'">MU</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=245]">\n\t\t\t<titleInfo>\n\t\t\t\t<xsl:variable name="title">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">afghk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abfgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:variable>\n\n\t\t\t\t<xsl:variable name="titleChop">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="$title"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@ind2&gt;0">\n\t\t\t\t\t\t<nonSort>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,1,@ind2)"/>\n\t\t\t\t\t\t</nonSort>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,@ind2+1)"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="$titleChop"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t\t\t<subTitle>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">afghk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</subTitle>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=210]">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=242]">\n\t\t\t<titleInfo type="translated">\n\t\t\t<!--09/01/04 Added subfield $y-->\n\t\t\t<xsl:for-each select="marc:subfield[@code='y']">\n\t\t\t\t\t<xsl:attribute name="lang">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t<title>\n\t\t\t\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\n\t\t\t\t</title>\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=246]">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='i']">\n\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, $b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">af</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=130]|marc:datafield[@tag=240]|marc:datafield[@tag=730][@ind2!=2]">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t\t\t\t<xsl:if test="(contains('adfklmor',@code) and (not(../marc:subfield[@code='n' or @code='p']) or (following-sibling::marc:subfield[@code='n' or @code='p'])))">\n\t\t\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:variable>\n\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2!=2]">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">ah</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=100]">\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=110]">\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=111]">\n\t\t\t<name type="conference">\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=700][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=710][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=711][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="conference">\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=720][not(marc:subfield[@code='t'])]">\n\t\t\t<name>\n\t\t\t\t<xsl:if test="@ind1=1">\n\t\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t\t<xsl:text>personal</xsl:text>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\n\t\t<typeOfResource>\n\t\t\t<xsl:if test="$leader7='c'">\n\t\t\t\t<xsl:attribute name="collection">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$leader6='d' or $leader6='f' or $leader6='p' or $leader6='t'">\n\t\t\t\t<xsl:attribute name="manuscript">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a' or $leader6='t'">text</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">cartographic</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d'">notated music</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='i'">sound recording-nonmusical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='j'">sound recording-musical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='k'">still image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g'">moving image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='r'">three dimensional object</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">software, multimedia</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">mixed material</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</typeOfResource>\n\n\t\t<xsl:if test="substring($controlField008,26,1)='d'">\n\t\t\t<genre authority="marc">globe</genre>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t<genre authority="marc">remote sensing image</genre>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='MP'">\n\t\t\t<xsl:variable name="controlField008-25" select="substring($controlField008,26,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-25='a' or $controlField008-25='b' or $controlField008-25='c' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t\t<genre authority="marc">map</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-25='e' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t\t<genre authority="marc">atlas</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-21" select="substring($controlField008,22,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-21='d'">\n\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='l'">\n\t\t\t\t\t<genre authority="marc">loose-leaf</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='m'">\n\t\t\t\t\t<genre authority="marc">series</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='n'">\n\t\t\t\t\t<genre authority="marc">newspaper</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='p'">\n\t\t\t\t\t<genre authority="marc">periodical</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='w'">\n\t\t\t\t\t<genre authority="marc">web site</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-24" select="substring($controlField008,25,4)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'a')">\n\t\t\t\t\t<genre authority="marc">abstract or summary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'b')">\n\t\t\t\t\t<genre authority="marc">bibliography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'c')">\n\t\t\t\t\t<genre authority="marc">catalog</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'d')">\n\t\t\t\t\t<genre authority="marc">dictionary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'e')">\n\t\t\t\t\t<genre authority="marc">encyclopedia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'f')">\n\t\t\t\t\t<genre authority="marc">handbook</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'g')">\n\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'i')">\n\t\t\t\t\t<genre authority="marc">index</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'k')">\n\t\t\t\t\t<genre authority="marc">discography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'l')">\n\t\t\t\t\t<genre authority="marc">legislation</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'m')">\n\t\t\t\t\t<genre authority="marc">theses</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'n')">\n\t\t\t\t\t<genre authority="marc">survey of literature</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'o')">\n\t\t\t\t\t<genre authority="marc">review</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'p')">\n\t\t\t\t\t<genre authority="marc">programmed text</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'q')">\n\t\t\t\t\t<genre authority="marc">filmography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'r')">\n\t\t\t\t\t<genre authority="marc">directory</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'s')">\n\t\t\t\t\t<genre authority="marc">statistics</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'t')">\n\t\t\t\t\t<genre authority="marc">technical report</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'v')">\n\t\t\t\t\t<genre authority="marc">legal case and case notes</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'w')">\n\t\t\t\t\t<genre authority="marc">law report or digest</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'z')">\n\t\t\t\t\t<genre authority="marc">treaty</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-29='1'">\n\t\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='CF'">\n\t\t\t<xsl:variable name="controlField008-26" select="substring($controlField008,27,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-26='a'">\n\t\t\t\t\t<genre authority="marc">numeric data</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='e'">\n\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='f'">\n\t\t\t\t\t<genre authority="marc">font</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='g'">\n\t\t\t\t\t<genre authority="marc">game</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='BK'">\n\t\t\t<xsl:if test="substring($controlField008,25,1)='j'">\n\t\t\t\t<genre authority="marc">patent</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="substring($controlField008,31,1)='1'">\n\t\t\t\t<genre authority="marc">festschrift</genre>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:variable name="controlField008-34" select="substring($controlField008,35,1)"/>\n\t\t\t<xsl:if test="$controlField008-34='a' or $controlField008-34='b' or $controlField008-34='c' or $controlField008-34='d'">\n\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='e'">\n\t\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marc">comic strip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='h'">\n\t\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marc">letter</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marc">novel</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='j'">\n\t\t\t\t\t<genre authority="marc">short story</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='MU'">\n\t\t\t<xsl:variable name="controlField008-30-31" select="substring($controlField008,31,2)"/>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'b')">\n\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'c')">\n\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'d')">\n\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'e')">\n\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'f')">\n\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'o')">\n\t\t\t\t<genre authority="marc">folktale</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'h')">\n\t\t\t\t<genre authority="marc">history</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'k')">\n\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'m')">\n\t\t\t\t<genre authority="marc">memoir</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'p')">\n\t\t\t\t<genre authority="marc">poetry</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'r')">\n\t\t\t\t<genre authority="marc">rehearsal</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'g')">\n\t\t\t\t<genre authority="marc">reporting</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'s')">\n\t\t\t\t<genre authority="marc">sound</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'l')">\n\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\n\t\t<xsl:if test="$typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='a'">\n\t\t\t\t\t<genre authority="marc">art original</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='b'">\n\t\t\t\t\t<genre authority="marc">kit</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marc">art reproduction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marc">diorama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marc">filmstrip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='g'">\n\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marc">picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='k'">\n\t\t\t\t\t<genre authority="marc">graphic</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marc">technical drawing</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='m'">\n\t\t\t\t\t<genre authority="marc">motion picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='n'">\n\t\t\t\t\t<genre authority="marc">chart</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='o'">\n\t\t\t\t\t<genre authority="marc">flash card</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='p'">\n\t\t\t\t\t<genre authority="marc">microscope slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='q' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t\t<genre authority="marc">model</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='r'">\n\t\t\t\t\t<genre authority="marc">realia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marc">slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='t'">\n\t\t\t\t\t<genre authority="marc">transparency</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='v'">\n\t\t\t\t\t<genre authority="marc">videorecording</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='w'">\n\t\t\t\t\t<genre authority="marc">toy</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=655]">\n\t\t\t<genre authority="marc">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abvxyz</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="delimeter">-</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</genre>\n\t\t</xsl:for-each>\n\n\t\t<originInfo>\n\t\t\t<xsl:variable name="MARCpublicationCode" select="normalize-space(substring($controlField008,16,3))"/>\n\n\t\t\t<xsl:if test="translate($MARCpublicationCode,'|','')">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">marccountry</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="$MARCpublicationCode"/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=044]/marc:subfield[@code='c']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">iso3166</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='a']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">text</xsl:attribute>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='m']">\n\t\t\t\t<dateValid point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='n']">\n\t\t\t\t<dateValid point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='j']">\n\t\t\t\t<dateModified>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateModified>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='b' or @code='c' or @code='g']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@code='b'">\n\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</publisher>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='c'">\n\t\t\t\t\t\t<dateIssued>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='g'">\n\t\t\t\t\t\t<dateCreated>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</dateCreated>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:variable name="dataField260c">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="marc:datafield[@tag=260]/marc:subfield[@code='c']"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:variable>\n\n\t\t\t<xsl:variable name="controlField008-7-10" select="normalize-space(substring($controlField008, 8, 4))"/>\n\t\t\t<xsl:variable name="controlField008-11-14" select="normalize-space(substring($controlField008, 12, 4))"/>\n\t\t\t<xsl:variable name="controlField008-6" select="normalize-space(substring($controlField008, 7, 1))"/>\n\n\t\t\t<xsl:if test="$controlField008-6='e' or $controlField008-6='p' or $controlField008-6='r' or $controlField008-6='t' or $controlField008-6='s'">\n\t\t\t\t<xsl:if test="$controlField008-7-10 and ($controlField008-7-10 != $dataField260c)">\n\t\t\t\t\t<dateIssued encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="$controlField008-6='t'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<copyrightDate encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</copyrightDate>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=0 or @ind1=1]/marc:subfield[@code='a']">\n\t\t\t\t<dateCaptured encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][1]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][2]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=250]/marc:subfield[@code='a']">\n\t\t\t\t<edition>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</edition>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:leader">\n\t\t\t\t<issuance>\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">monographic</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">continuing</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</issuance>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=310]|marc:datafield[@tag=321]">\n\t\t\t\t<frequency>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</frequency>\n\t\t\t</xsl:for-each>\n\t\t</originInfo>\n\t\t<xsl:variable name="controlField008-35-37" select="normalize-space(translate(substring($controlField008,36,3),'|#',''))"/>\n\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t<language>\n\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t<xsl:value-of select="substring($controlField008,36,3)"/>\n\t\t\t\t</languageTerm>\n\t\t\t</language>\n\t\t</xsl:if>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=041]">\n\n\t\t\t<!--\t\t\t<xsl:variable name="langCodes">\t\t\t\n\t\t\t\t<xsl:copy-of select="marc:subfield[@code='a'or @code='d' or @code='e' or @code='2']"/>\n\t\t\t</xsl:variable>\n\t\t\t-->\n\t\t\t<xsl:variable name="langCodes" select="marc:subfield[@code='a'or @code='d' or @code='e' or @code='2']"/>\n\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="marc:subfield[@code='2']='rfc3066'">\n\t\t\t\t\t<!-- not stacked but could be repeated -->\n\t\t\t\t\t<xsl:call-template name="rfcLanguages">\n\t\t\t\t\t\t<xsl:with-param name="nodeNum">\n\t\t\t\t\t\t\t<xsl:value-of select="1"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t<xsl:text></xsl:text>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t<xsl:with-param name="controlField008-35-37">\n\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<!-- iso -->\n\t\t\t\t\t<xsl:variable name="allLanguages">\n\t\t\t\t\t\t<xsl:copy-of select="$langCodes"/>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:variable name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"/>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,4,string-length($allLanguages)-3)"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:for-each>\n\n\t\t<xsl:variable name="physicalDescription">\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='a' or substring(.,12,1)='b']">\n\t\t\t\t<digitalOrigin>reformatted digital</digitalOrigin>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:variable name="controlField008-23" select="substring($controlField008,24,1)"/>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\n\t\t\t<xsl:variable name="check008-23">\n\t\t\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='MU' or $typeOf008='SE' or $typeOf008='MM'">\n\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\n\t\t\t<xsl:variable name="check008-29">\n\t\t\t\t<xsl:if test="$typeOf008='MP' or $typeOf008='VM'">\n\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='f') or ($check008-29 and $controlField008-29='f')">\n\t\t\t\t\t<form authority="marcform">braille</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($controlField008-23=' ' and ($leader6='c' or $leader6='d')) or (($typeOf008='BK' or $typeOf008='SE') and ($controlField008-23=' ' or $controlField008='r'))">\n\t\t\t\t\t<form authority="marcform">print</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$leader6 = 'm' or ($check008-23 and $controlField008-23='s') or ($check008-29 and $controlField008-29='s')">\n\t\t\t\t\t<form authority="marcform">electronic</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='b') or ($check008-29 and $controlField008-29='b')">\n\t\t\t\t\t<form authority="marcform">microfiche</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='a') or ($check008-29 and $controlField008-29='a')">\n\t\t\t\t\t<form authority="marcform">microfilm</form>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<!-- 1/04 fix -->\n\t\t\t<xsl:if test="marc:datafield[@tag=130]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=130]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if test="marc:datafield[@tag=240]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=240]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=242]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=242]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=245]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=245]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=246]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=246]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=730]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=730]/marc:subfield[@code='h']"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=256]/marc:subfield[@code='a']">\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</form>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=007][substring(text(),1,1)='c']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='a'">\n\t\t\t\t\t\t<reformattingQuality>access</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='p'">\n\t\t\t\t\t\t<reformattingQuality>preservation</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='r'">\n\t\t\t\t\t\t<reformattingQuality>replacement</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=856]/marc:subfield[@code='q'][string-length(.)&gt;1]">\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</internetMediaType>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=300]">\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abce</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</extent>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\n\t\t<xsl:if test="string-length(normalize-space($physicalDescription))">\n\t\t\t<physicalDescription>\n\t\t\t\t<xsl:copy-of select="$physicalDescription"/>\n\t\t\t</physicalDescription>\n\t\t</xsl:if>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=520]">\n\t\t\t<abstract>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</abstract>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=505]">\n\t\t\t<tableOfContents>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">agrt</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</tableOfContents>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=521]">\n\t\t\t<targetAudience>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</targetAudience>\n\t\t</xsl:for-each>\n\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='CF' or $typeOf008='MU' or $typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-22" select="substring($controlField008,23,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<!-- 01/04 fix -->\n\t\t\t\t<xsl:when test="$controlField008-22='d'">\n\t\t\t\t\t<targetAudience authority="marctarget">adolescent</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='e'">\n\t\t\t\t\t<targetAudience authority="marctarget">adult</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='g'">\n\t\t\t\t\t<targetAudience authority="marctarget">general</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='b' or $controlField008-22='c' or $controlField008-22='j'">\n\t\t\t\t\t<targetAudience authority="marctarget">juvenile</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='a'">\n\t\t\t\t\t<targetAudience authority="marctarget">preschool</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='f'">\n\t\t\t\t\t<targetAudience authority="marctarget">specialized</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=245]/marc:subfield[@code='c']">\n\t\t\t<note type="statement of responsibility">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=500]">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=511]">\n\t\t\t<note type="performers">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=518]">\n\t\t\t<note type="venue">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=501 or @tag=502 or @tag=504 or @tag=506 or @tag=507 or @tag=508 or  @tag=513 or @tag=514 or @tag=515 or @tag=516 or @tag=522 or @tag=524 or @tag=525 or @tag=526 or @tag=530 or @tag=533 or @tag=534 or @tag=535 or @tag=536 or @tag=538 or @tag=540 or @tag=541 or @tag=544 or @tag=545 or @tag=546 or @tag=547 or @tag=550 or @tag=552 or @tag=555 or @tag=556 or @tag=561 or @tag=562 or @tag=565 or @tag=567 or @tag=580 or @tag=581 or @tag=583 or @tag=584 or @tag=585 or @tag=586]">\n\t\t\t<note>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=034][marc:subfield[@code='d' or @code='e' or @code='f' or @code='g']]">\n\t\t\t<subject>\n\t\t\t\t<cartographics>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">defg</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</coordinates>\n\t\t\t\t</cartographics>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=043]">\n\t\t\t<subject>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='c']">\n\t\t\t\t\t<geographicCode>\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:if test="@code='a'">\n\t\t\t\t\t\t\t\t<xsl:text>marcgac</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='b'">\n\t\t\t\t\t\t\t\t<xsl:value-of select="following-sibling::marc:subfield[@code=2]"/>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='c'">\n\t\t\t\t\t\t\t\t<xsl:text>iso3166</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="self::marc:subfield"/>\n\t\t\t\t\t</geographicCode>\n\t\t\t\t</xsl:for-each>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=255]">\n\t\t\t<subject>\n\t\t\t\t<cartographics>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</coordinates>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<scale>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</scale>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<projection>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</projection>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</cartographics>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:apply-templates select="marc:datafield[653 &gt;= @tag and @tag &gt;= 600]"/>\n\n\t\t<xsl:apply-templates select="marc:datafield[@tag=656]"/>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=752]">\n\t\t\t<subject>\n\t\t\t\t<hierarchicalGeographic>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<country>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</country>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<state>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</state>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t<county>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</county>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t\t<city>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</city>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</hierarchicalGeographic>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=045][marc:subfield[@code='b']]">\n\t\t\t<subject>\n\n\t\t\t\t<xsl:choose>\n\n\t\t\t\t\t<xsl:when test="@ind1=2">\n\n\t\t\t\t\t\t<temporal encoding="iso8601" point="start">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][1]"/>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t<temporal encoding="iso8601" point="end">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\n\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][2]"/>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=050]">\n\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:value-of select="preceding-sibling::marc:subfield[@code='a'][1]"/>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a'][not(following-sibling::marc:subfield[@code='b'])]">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=082]">\n\t\t\t<classification authority="ddc">\n\t\t\t\t<xsl:if test="marc:subfield[@code='2']">\n\t\t\t\t\t<xsl:attribute name="edition">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=080]">\n\t\t\t<classification authority="udc">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abx</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=060]">\n\t\t\t<classification authority="nlm">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=0]">\n\t\t\t<classification authority="sudocs">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=1]">\n\t\t\t<classification authority="candoc">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=086]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=084]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=440]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=490][@ind1=0]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=510]">\n\t\t\t<relatedItem type="isReferencedBy">\n\t\t\t\t<note>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcx3</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</note>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedTitle"/>\n\t\t\t\t<xsl:call-template name="relatedName"/>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t\t\t<originInfo>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</publisher>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<edition>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</edition>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</originInfo>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='z']">\n\t\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</identifier>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:call-template name="relatedNote"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=700][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=710][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:variable name="tempNamePart">\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:if test="normalize-space($tempNamePart)">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="$tempNamePart"/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=711][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=730][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=760]|marc:datafield[@tag=762]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=765]|marc:datafield[@tag=767]|marc:datafield[@tag=777]|marc:datafield[@tag=787]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=775]">\n\t\t\t<relatedItem type="otherVersion">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=770]|marc:datafield[@tag=774]">\n\t\t\t<relatedItem type="constituent">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=772]|marc:datafield[@tag=773]">\n\t\t\t<relatedItem type="host">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=776]">\n\t\t\t<relatedItem type="otherFormat">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=780]">\n\t\t\t<relatedItem type="preceding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=785]">\n\t\t\t<relatedItem type="succeeding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=786]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=800]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=810]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=811]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=830]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=856][@ind2=2]/marc:subfield[@code='q']">\n\t\t\t<relatedItem>\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</internetMediaType>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=020]">\n\t\t\t<identifier type="isbn">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=0]">\n\t\t\t<identifier type="isrc">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=2]">\n\t\t\t<identifier type="ismn">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=022]">\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=010]">\n\t\t\t<identifier type="lccn">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="normalize-space(marc:subfield[@code='a'])"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=028]">\n\t\t\t<identifier>\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="@ind1=0">issue number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1=1">matrix number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1=2">music plate</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1=3">music publisher</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1=4">videorecording identifier</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="@ind1=0">ba</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>ab</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1='4']">\n\t\t\t<identifier type="sici">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=037]">\n\t\t\t<identifier type="stock number">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=856][marc:subfield[@code='u']]">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:doi') or starts-with(marc:subfield[@code='u'],'doi')">doi</xsl:when>\n\t\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov')">hdl</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>uri</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov') ">\n\t\t\t\t\t\t<xsl:value-of select="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"/>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</identifier>\n\t\t\t<xsl:if test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl')">\n\t\t\t\t<identifier type="hdl">\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3' or @code='z']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3z</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=1]">\n\t\t\t<identifier type="upc">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<!-- 1/04 fix added $y -->\n\t\t<xsl:for-each select="marc:datafield[@tag=856][marc:subfield[@code='u']]">\n\t\t\t<location>\n\t\t\t\t<url>\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t</url>\n\t\t\t</location>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=852]">\n\t\t\t<location>\n\t\t\t\t<physicalLocation>\n\t\t\t\t\t<xsl:call-template name="displayLabel"/>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abje</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</physicalLocation>\n\t\t\t</location>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t<accessCondition type="restrictionOnAccess">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcd35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=540]">\n\t\t\t<accessCondition type="useAndReproduction">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcde35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\n\t\t<recordInfo>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]">\n\t\t\t\t<recordContentSource authority="marcorg">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</recordContentSource>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=008]">\n\t\t\t\t<recordCreationDate encoding="marc">\n\t\t\t\t\t<xsl:value-of select="substring(.,1,6)"/>\n\t\t\t\t</recordCreationDate>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=005]">\n\t\t\t\t<recordChangeDate encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</recordChangeDate>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=001]">\n\t\t\t\t<recordIdentifier>\n\t\t\t\t\t<xsl:if test="../marc:controlfield[@tag=003]">\n\t\t\t\t\t\t<xsl:attribute name="source">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:controlfield[@tag=003]"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</recordIdentifier>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]/marc:subfield[@code='b']">\n\t\t\t\t<languageOfCataloging>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</languageOfCataloging>\n\t\t\t</xsl:for-each>\n\t\t</recordInfo>\n\t</xsl:template>\n\n\t<xsl:template name="displayForm">\n\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t<displayForm>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</displayForm>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="affiliation">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<affiliation>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</affiliation>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="uri">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<xsl:attribute name="xlink:href">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="role">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<role>\n\t\t\t\t<roleTerm type="text">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t<role>\n\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="part">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fghkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fghkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partNumber"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partName"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedPart">\n\t\t<xsl:if test="@tag=773">\n\t\t\t<xsl:for-each select="marc:subfield[@code='g']">\n\t\t\t\t<part>\n\t\t\t\t\t<text>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</text>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='q']">\n\t\t\t\t<part>\n\t\t\t\t\t<xsl:call-template name="parsePart"/>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedPartNumName">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">pst</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fghkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:value-of select="$partNumber"/>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:value-of select="$partName"/>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedName">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<name>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</namePart>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedForm">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</form>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedExtent">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</extent>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedNote">\n\t\t<xsl:for-each select="marc:subfield[@code='n']">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedSubject">\n\t\t<xsl:for-each select="marc:subfield[@code='j']">\n\t\t\t<subject>\n\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</temporal>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifierISSN">\n\t\t<xsl:for-each select="marc:subfield[@code='x']">\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifierLocal">\n\t\t<xsl:for-each select="marc:subfield[@code='w']">\n\t\t\t<identifier type="local">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedIdentifier">\n\t\t<xsl:for-each select="marc:subfield[@code='o']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedItem76X-78X">\n\t\t<xsl:call-template name="displayLabel"/>\n\t\t<xsl:call-template name="relatedTitle76X-78X"/>\n\t\t<xsl:call-template name="relatedName"/>\n\t\t<xsl:call-template name="relatedOriginInfo"/>\n\t\t<xsl:call-template name="relatedLanguage"/>\n\t\t<xsl:call-template name="relatedExtent"/>\n\t\t<xsl:call-template name="relatedNote"/>\n\t\t<xsl:call-template name="relatedSubject"/>\n\t\t<xsl:call-template name="relatedIdentifier"/>\n\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t<xsl:call-template name="relatedIdentifierLocal"/>\n\t\t<xsl:call-template name="relatedPart"/>\n\t</xsl:template>\n\n\t<xsl:template name="subjectGeographicZ">\n\t\t<geographic>\n\n\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</geographic>\n\t</xsl:template>\n\n\t<xsl:template name="subjectTemporalY">\n\t\t<temporal>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</temporal>\n\t</xsl:template>\n\n\t<xsl:template name="subjectTopic">\n\t\t<topic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</topic>\n\t</xsl:template>\n\n\t<xsl:template name="nameABCDN">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:if test="marc:subfield[@code='c'] or marc:subfield[@code='d'] or marc:subfield[@code='n']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">cdn</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="nameABCDQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:with-param>\n\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t<xsl:call-template name="nameDate"/>\n\t</xsl:template>\n\n\t<xsl:template name="nameACDEQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t<xsl:with-param name="codes">acdeq</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t</xsl:template>\n\n\t<xsl:template name="constituentOrRelatedType">\n\t\t<xsl:if test="@ind2=2">\n\t\t\t<xsl:attribute name="type">constituent</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedTitle">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedTitle76X-78X">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='p']">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='s']">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="relatedOriginInfo">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='d'] or marc:subfield[@code='f']">\n\t\t\t<originInfo>\n\t\t\t\t<xsl:if test="@tag=775">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='f']">\n\t\t\t\t\t\t<place>\n\t\t\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:attribute name="authority">marcgac</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</placeTerm>\n\t\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t<publisher>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</publisher>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<edition>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</edition>\n\t\t\t\t</xsl:for-each>\n\t\t\t</originInfo>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="relatedLanguage">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t<xsl:with-param name="langString">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="nameDate">\n\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t<namePart type="date">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="subjectAuthority">\n\n\t\t<xsl:if test="@ind2!=4">\n\t\t\t<xsl:if test="@ind2!=' '">\n\t\t\t\t<xsl:if test="@ind2!=8">\n\t\t\t\t\t<xsl:if test="@ind2!=9">\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:choose>\n\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=0">lcsh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=1">lcshac</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=2">mesh</xsl:when>\n\t\t\t\t\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=3">nal</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=5">csh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=6">rvm</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=7">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="subjectAnyOrder">\n\t\t<xsl:for-each select="marc:subfield[@code='v' or @code='x' or @code='y' or @code='z']">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@code='v'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='x'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='y'">\n\t\t\t\t\t<xsl:call-template name="subjectTemporalY"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='z'">\n\t\t\t\t\t<xsl:call-template name="subjectGeographicZ"/>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\n\t<xsl:template name="specialSubfieldSelect">\n\t\t<xsl:param name="anyCodes"/>\n\t\t<xsl:param name="axis"/>\n\t\t<xsl:param name="beforeCodes"/>\n\t\t<xsl:param name="afterCodes"/>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($anyCodes, @code)      or (contains($beforeCodes,@code) and following-sibling::marc:subfield[@code=$axis])      or (contains($afterCodes,@code) and preceding-sibling::marc:subfield[@code=$axis])">\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=600]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=610]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:if test="marc:subfield[@code='c' or @code='d' or @code='n' or @code='p']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">cdnp</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=611]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="conference">\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcdeqnp</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</roleTerm>\n\t\t\t\t\t</role>\n\t\t\t\t</xsl:for-each>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=630]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfhklor</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=650]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<topic>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abcd</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</topic>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=651]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\n\t\t\t\t<geographic>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</geographic>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=653]">\n\t\t<subject>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<topic>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</topic>\n\t\t\t</xsl:for-each>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template match="marc:datafield[@tag=656]">\n\t\t<subject>\n\t\t\t<xsl:if test="marc:subfield[@code=2]">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code=2]"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<occupation>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</occupation>\n\t\t</subject>\n\t</xsl:template>\n\n\t<xsl:template name="termsOfAddress">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t<namePart type="termsOfAddress">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">bc</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="displayLabel">\n\t\t<xsl:if test="marc:subfield[@code='i']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='i']"/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t\t<xsl:if test="marc:subfield[@code='3']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='3']"/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="isInvalid">\n\t\t<xsl:if test="marc:subfield[@code='z']">\n\t\t\t<xsl:attribute name="invalid">yes</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="subtitle">\n\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t<subTitle>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b']"/>\n\n\t\t\t\t\t\t<!--<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">b</xsl:with-param>\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</xsl:call-template>-->\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</subTitle>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="script">\n\t\t<xsl:param name="scriptCode"/>\n\t\t<xsl:attribute name="script">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$scriptCode='(3'">Arabic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(B'">Latin</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='$1'">Chinese, Japanese, Korean</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(N'">Cyrillic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(2'">Hebrew</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(S'">Greek</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\n\t<xsl:template name="parsePart">\n\t\t<!-- assumes 773$q= 1:2:3<4\n\t\t     with up to 3 levels and one optional start page\n\t\t-->\n\t\t<xsl:variable name="level1">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains(text(),':')">\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t\t<xsl:value-of select="substring-before(text(),':')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="not(contains(text(),':'))">\n\t\t\t\t\t<!-- 1 or 1<3 -->\n\t\t\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t\t\t<!-- 1<3 -->\n\t\t\t\t\t\t<xsl:value-of select="substring-before(text(),'&lt;')"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="not(contains(text(),'&lt;'))">\n\t\t\t\t\t\t<!-- 1 -->\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after(text(),$level1),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after(text(),$level1),2)"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after(text(),$level1)"/>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici2,':')">\n\t\t\t\t\t<!--  2:3<4  -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,':')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($sici2,'&lt;')">\n\t\t\t\t\t<!-- 1: 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,'&lt;')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici2"/>\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after($sici2,$level2),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after($sici2,$level2),2)"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after($sici2,$level2)"/>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici3,'&lt;')">\n\t\t\t\t\t<!-- 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici3,'&lt;')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici3"/>\n\t\t\t\t\t<!-- 3 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="page">\n\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t<xsl:value-of select="substring-after(text(),'&lt;')"/>\n\t\t\t</xsl:if>\n\t\t</xsl:variable>\n\t\t<xsl:if test="$level1">\n\t\t\t<detail level="1">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level1"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level2">\n\t\t\t<detail level="2">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level2"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level3">\n\t\t\t<detail level="3">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level3"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$page">\n\t\t\t<extent unit="page">\n\t\t\t\t<start>\n\t\t\t\t\t<xsl:value-of select="$page"/>\n\t\t\t\t</start>\n\t\t\t</extent>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="getLanguage">\n\t\t<xsl:param name="langString"/>\n\t\t<xsl:param name="controlField008-35-37"/>\n\t\t<xsl:variable name="length" select="string-length($langString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="$controlField008-35-37=substring($langString,1,3)">\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"/>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<language>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="substring($langString,1,3)"/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"/>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="isoLanguage">\n\t\t<xsl:param name="currentLanguage"/>\n\t\t<xsl:param name="usedLanguages"/>\n\t\t<xsl:param name="remainingLanguages"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="string-length($currentLanguage)=0"/>\n\t\t\t<xsl:when test="not(contains($usedLanguages, $currentLanguage))">\n\t\t\t\t<language>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,4,string-length($remainingLanguages))"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,4,string-length($remainingLanguages))"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopBrackets">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="string">\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="$chopString"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="substring($string, 1,1)='['">\n\t\t\t<xsl:value-of select="substring($string,2, string-length($string)-2)"/>\n\t\t</xsl:if>\n\t\t<xsl:if test="substring($string, 1,1)!='['">\n\t\t\t<xsl:value-of select="$string"/>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="rfcLanguages">\n\t\t<xsl:param name="nodeNum"/>\n\t\t<xsl:param name="usedLanguages"/>\n\t\t<xsl:param name="controlField008-35-37"/>\n\t\t<!-- ??? xalan -->\n\n\t\t<xsl:variable name="currentLanguage" select="marc:subfield[position()=$nodeNum]/text()"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="not($currentLanguage)"/>\n\t\t\t<xsl:when test="$currentLanguage!=$controlField008-35-37 and $currentLanguage!='rfc3066'">\n\t\t\t\t<xsl:if test="not(contains($usedLanguages,$currentLanguage))">\n\t\t\t\t\t<language>\n\t\t\t\t\t\t<languageTerm authority="rfc3066" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"/>\n\t\t\t\t\t\t</languageTerm>\n\t\t\t\t\t</language>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="rfcLanguages">\n\t\t\t\t\t<!-- ??? xalan -->\n\t\t\t\t\t<xsl:with-param name="nodeNum">\n\t\t\t\t\t\t<xsl:value-of select="$nodeNum+1"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,'|',$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:call-template name="rfcLanguages">\n\t\t\t\t\t<xsl:with-param name="nodeNum">\n\t\t\t\t\t\t<xsl:value-of select="$nodeNum+1"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="datafield">\n\t\t<xsl:param name="tag"/>\n\t\t<xsl:param name="ind1"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="ind2"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="subfields"/>\n\t\t<xsl:element name="marc:datafield">\n\t\t\t<xsl:attribute name="tag">\n\t\t\t\t<xsl:value-of select="$tag"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind1">\n\t\t\t\t<xsl:value-of select="$ind1"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind2">\n\t\t\t\t<xsl:value-of select="$ind2"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:copy-of select="$subfields"/>\n\t\t</xsl:element>\n\t</xsl:template>\n\n\t<xsl:template name="subfieldSelect">\n\t\t<xsl:param name="codes"/>\n\t\t<xsl:param name="delimeter"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($codes, @code)">\n\t\t\t\t\t<xsl:value-of select="text()"/><xsl:value-of select="$delimeter"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-string-length($delimeter))"/>\n\t</xsl:template>\n\n\t<xsl:template name="buildSpaces">\n\t\t<xsl:param name="spaces"/>\n\t\t<xsl:param name="char"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:if test="$spaces>0">\n\t\t\t<xsl:value-of select="$char"/>\n\t\t\t<xsl:call-template name="buildSpaces">\n\t\t\t\t<xsl:with-param name="spaces" select="$spaces - 1"/>\n\t\t\t\t<xsl:with-param name="char" select="$char"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuation">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:param name="punctuation"><xsl:text>.:,;/ </xsl:text></xsl:param>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains($punctuation, substring($chopString,$length,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,1,$length - 1)"/>\n\t\t\t\t\t<xsl:with-param name="punctuation" select="$punctuation"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuationFront">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains('.:,;/[ ', substring($chopString,1,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,2,$length - 1)"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n</xsl:stylesheet>
mods32	http://www.loc.gov/mods/v3	mods32	<?xml version="1.0" encoding="UTF-8"?>\n<xsl:stylesheet xmlns="http://www.loc.gov/mods/v3" xmlns:marc="http://www.loc.gov/MARC21/slim" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" exclude-result-prefixes="xlink marc" version="1.0">\n\t<xsl:output encoding="UTF-8" indent="yes" method="xml"/>\n<!--\nRevision 1.14 - Fixed template isValid and fields 010, 020, 022, 024, 028, and 037 to output additional identifier elements \n  with corresponding @type and @invalid eq 'yes' when subfields z or y (in the case of 022) exist in the MARCXML ::: 2007/01/04 17:35:20 cred\n\nRevision 1.13 - Changed order of output under cartographics to reflect schema  2006/11/28 tmee\n\t\nRevision 1.12 - Updated to reflect MODS 3.2 Mapping  2006/10/11 tmee\n\t\t\nRevision 1.11 - The attribute objectPart moved from <languageTerm> to <language>\n      2006/04/08  jrad\n\nRevision 1.10 MODS 3.1 revisions to language and classification elements  \n\t\t\t\t(plus ability to find marc:collection embedded in wrapper elements such as SRU zs: wrappers)\n\t\t\t\t2006/02/06  ggar\n\nRevision 1.9 subfield $y was added to field 242 2004/09/02 10:57 jrad\n\nRevision 1.8 Subject chopPunctuation expanded and attribute fixes 2004/08/12 jrad\n\nRevision 1.7 2004/03/25 08:29 jrad\n\nRevision 1.6 various validation fixes 2004/02/20 ntra\n\nRevision 1.5  2003/10/02 16:18:58  ntra\nMODS2 to MODS3 updates, language unstacking and \nde-duping, chopPunctuation expanded\n\nRevision 1.3  2003/04/03 00:07:19  ntra\nRevision 1.3 Additional Changes not related to MODS Version 2.0 by ntra\n\nRevision 1.2  2003/03/24 19:37:42  ckeith\nAdded Log Comment\n\n-->\n\t<xsl:template match="/">\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="//marc:collection">\n\t\t\t\t<modsCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-2.xsd">\n\t\t\t\t\t<xsl:for-each select="//marc:collection/marc:record">\n\t\t\t\t\t\t<mods version="3.2">\n\t\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t\t</mods>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</modsCollection>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<mods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="3.2" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-2.xsd">\n\t\t\t\t\t<xsl:for-each select="//marc:record">\n\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</mods>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="marcRecord">\n\t\t<xsl:variable name="leader" select="marc:leader"/>\n\t\t<xsl:variable name="leader6" select="substring($leader,7,1)"/>\n\t\t<xsl:variable name="leader7" select="substring($leader,8,1)"/>\n\t\t<xsl:variable name="controlField008" select="marc:controlfield[@tag='008']"/>\n\t\t<xsl:variable name="typeOf008">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a'">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">BK</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">SE</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='t'">BK</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">MM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">CF</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">MP</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g' or $leader6='k' or $leader6='o' or $leader6='r'">VM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d' or $leader6='i' or $leader6='j'">MU</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:for-each select="marc:datafield[@tag='245']">\n\t\t\t<titleInfo>\n\t\t\t\t<xsl:variable name="title">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abfgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:variable name="titleChop">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="$title"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@ind2>0">\n\t\t\t\t\t\t<nonSort>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,1,@ind2)"/>\n\t\t\t\t\t\t</nonSort>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,@ind2+1)"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="$titleChop"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t\t\t<subTitle>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</subTitle>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t</titleInfo>\n\t\t\t<!-- A form of title that ignores non-filing characters; useful\n\t\t\t\t for not converting "L'Oreal" into "L' Oreal" at index time -->\n\t\t\t<titleNonfiling>\n\t\t\t\t<xsl:variable name="title">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abfgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:value-of select="$title"/>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t\t\t<subTitle>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</subTitle>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t</titleNonfiling>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='210']">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='242']">\n\t\t\t<titleInfo type="translated">\n\t\t\t\t<!--09/01/04 Added subfield $y-->\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='y']">\n\t\t\t\t\t<xsl:attribute name="lang">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='246']">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='i']">\n\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, $b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">af</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='130']|marc:datafield[@tag='240']|marc:datafield[@tag='730'][@ind2!='2']">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t\t\t\t<xsl:if test="(contains('adfklmor',@code) and (not(../marc:subfield[@code='n' or @code='p']) or (following-sibling::marc:subfield[@code='n' or @code='p'])))">\n\t\t\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='740'][@ind2!='2']">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">ah</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='100']">\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='110']">\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='111']">\n\t\t\t<name type="conference">\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='700'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='710'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='711'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="conference">\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='720'][not(marc:subfield[@code='t'])]">\n\t\t\t<name>\n\t\t\t\t<xsl:if test="@ind1=1">\n\t\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t\t<xsl:text>personal</xsl:text>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<typeOfResource>\n\t\t\t<xsl:if test="$leader7='c'">\n\t\t\t\t<xsl:attribute name="collection">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$leader6='d' or $leader6='f' or $leader6='p' or $leader6='t'">\n\t\t\t\t<xsl:attribute name="manuscript">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a' or $leader6='t'">text</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">cartographic</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d'">notated music</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='i'">sound recording-nonmusical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='j'">sound recording-musical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='k'">still image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g'">moving image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='r'">three dimensional object</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">software, multimedia</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">mixed material</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</typeOfResource>\n\t\t<xsl:if test="substring($controlField008,26,1)='d'">\n\t\t\t<genre authority="marc">globe</genre>\n\t\t</xsl:if>\n\t\t<xsl:if test="marc:controlfield[@tag='007'][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t<genre authority="marc">remote sensing image</genre>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='MP'">\n\t\t\t<xsl:variable name="controlField008-25" select="substring($controlField008,26,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-25='a' or $controlField008-25='b' or $controlField008-25='c' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t\t<genre authority="marc">map</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-25='e' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t\t<genre authority="marc">atlas</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-21" select="substring($controlField008,22,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-21='d'">\n\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='l'">\n\t\t\t\t\t<genre authority="marc">loose-leaf</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='m'">\n\t\t\t\t\t<genre authority="marc">series</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='n'">\n\t\t\t\t\t<genre authority="marc">newspaper</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='p'">\n\t\t\t\t\t<genre authority="marc">periodical</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='w'">\n\t\t\t\t\t<genre authority="marc">web site</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-24" select="substring($controlField008,25,4)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'a')">\n\t\t\t\t\t<genre authority="marc">abstract or summary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'b')">\n\t\t\t\t\t<genre authority="marc">bibliography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'c')">\n\t\t\t\t\t<genre authority="marc">catalog</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'d')">\n\t\t\t\t\t<genre authority="marc">dictionary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'e')">\n\t\t\t\t\t<genre authority="marc">encyclopedia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'f')">\n\t\t\t\t\t<genre authority="marc">handbook</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'g')">\n\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'i')">\n\t\t\t\t\t<genre authority="marc">index</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'k')">\n\t\t\t\t\t<genre authority="marc">discography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'l')">\n\t\t\t\t\t<genre authority="marc">legislation</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'m')">\n\t\t\t\t\t<genre authority="marc">theses</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'n')">\n\t\t\t\t\t<genre authority="marc">survey of literature</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'o')">\n\t\t\t\t\t<genre authority="marc">review</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'p')">\n\t\t\t\t\t<genre authority="marc">programmed text</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'q')">\n\t\t\t\t\t<genre authority="marc">filmography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'r')">\n\t\t\t\t\t<genre authority="marc">directory</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'s')">\n\t\t\t\t\t<genre authority="marc">statistics</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'t')">\n\t\t\t\t\t<genre authority="marc">technical report</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'v')">\n\t\t\t\t\t<genre authority="marc">legal case and case notes</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'w')">\n\t\t\t\t\t<genre authority="marc">law report or digest</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'z')">\n\t\t\t\t\t<genre authority="marc">treaty</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-29='1'">\n\t\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='CF'">\n\t\t\t<xsl:variable name="controlField008-26" select="substring($controlField008,27,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-26='a'">\n\t\t\t\t\t<genre authority="marc">numeric data</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='e'">\n\t\t\t\t\t<genre authority="marc">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='f'">\n\t\t\t\t\t<genre authority="marc">font</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='g'">\n\t\t\t\t\t<genre authority="marc">game</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='BK'">\n\t\t\t<xsl:if test="substring($controlField008,25,1)='j'">\n\t\t\t\t<genre authority="marc">patent</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="substring($controlField008,31,1)='1'">\n\t\t\t\t<genre authority="marc">festschrift</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-34" select="substring($controlField008,35,1)"></xsl:variable>\n\t\t\t<xsl:if test="$controlField008-34='a' or $controlField008-34='b' or $controlField008-34='c' or $controlField008-34='d'">\n\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='e'">\n\t\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marc">comic strip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='h'">\n\t\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marc">letter</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marc">novel</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='j'">\n\t\t\t\t\t<genre authority="marc">short story</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='MU'">\n\t\t\t<xsl:variable name="controlField008-30-31" select="substring($controlField008,31,2)"></xsl:variable>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'b')">\n\t\t\t\t<genre authority="marc">biography</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'c')">\n\t\t\t\t<genre authority="marc">conference publication</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'d')">\n\t\t\t\t<genre authority="marc">drama</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'e')">\n\t\t\t\t<genre authority="marc">essay</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'f')">\n\t\t\t\t<genre authority="marc">fiction</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'o')">\n\t\t\t\t<genre authority="marc">folktale</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'h')">\n\t\t\t\t<genre authority="marc">history</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'k')">\n\t\t\t\t<genre authority="marc">humor, satire</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'m')">\n\t\t\t\t<genre authority="marc">memoir</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'p')">\n\t\t\t\t<genre authority="marc">poetry</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'r')">\n\t\t\t\t<genre authority="marc">rehearsal</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'g')">\n\t\t\t\t<genre authority="marc">reporting</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'s')">\n\t\t\t\t<genre authority="marc">sound</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'l')">\n\t\t\t\t<genre authority="marc">speech</genre>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='a'">\n\t\t\t\t\t<genre authority="marc">art original</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='b'">\n\t\t\t\t\t<genre authority="marc">kit</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marc">art reproduction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marc">diorama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marc">filmstrip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='g'">\n\t\t\t\t\t<genre authority="marc">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marc">picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='k'">\n\t\t\t\t\t<genre authority="marc">graphic</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marc">technical drawing</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='m'">\n\t\t\t\t\t<genre authority="marc">motion picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='n'">\n\t\t\t\t\t<genre authority="marc">chart</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='o'">\n\t\t\t\t\t<genre authority="marc">flash card</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='p'">\n\t\t\t\t\t<genre authority="marc">microscope slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='q' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t\t<genre authority="marc">model</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='r'">\n\t\t\t\t\t<genre authority="marc">realia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marc">slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='t'">\n\t\t\t\t\t<genre authority="marc">transparency</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='v'">\n\t\t\t\t\t<genre authority="marc">videorecording</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='w'">\n\t\t\t\t\t<genre authority="marc">toy</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=655]">\n\t\t\t<genre authority="marc">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abvxyz</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="delimeter">-</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</genre>\n\t\t</xsl:for-each>\n\t\t<originInfo>\n\t\t\t<xsl:variable name="MARCpublicationCode" select="normalize-space(substring($controlField008,16,3))"></xsl:variable>\n\t\t\t<xsl:if test="translate($MARCpublicationCode,'|','')">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">marccountry</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="$MARCpublicationCode"/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=044]/marc:subfield[@code='c']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">iso3166</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='a']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">text</xsl:attribute>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='m']">\n\t\t\t\t<dateValid point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='n']">\n\t\t\t\t<dateValid point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='j']">\n\t\t\t\t<dateModified>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateModified>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='b' or @code='c' or @code='g']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@code='b'">\n\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</publisher>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='c'">\n\t\t\t\t\t\t<dateIssued>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='g'">\n\t\t\t\t\t\t<dateCreated>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</dateCreated>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:variable name="dataField260c">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="marc:datafield[@tag=260]/marc:subfield[@code='c']"></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:variable name="controlField008-7-10" select="normalize-space(substring($controlField008, 8, 4))"></xsl:variable>\n\t\t\t<xsl:variable name="controlField008-11-14" select="normalize-space(substring($controlField008, 12, 4))"></xsl:variable>\n\t\t\t<xsl:variable name="controlField008-6" select="normalize-space(substring($controlField008, 7, 1))"></xsl:variable>\n\t\t\t<xsl:if test="$controlField008-6='e' or $controlField008-6='p' or $controlField008-6='r' or $controlField008-6='t' or $controlField008-6='s'">\n\t\t\t\t<xsl:if test="$controlField008-7-10 and ($controlField008-7-10 != $dataField260c)">\n\t\t\t\t\t<dateIssued encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='t'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<copyrightDate encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</copyrightDate>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=0 or @ind1=1]/marc:subfield[@code='a']">\n\t\t\t\t<dateCaptured encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][1]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][2]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=250]/marc:subfield[@code='a']">\n\t\t\t\t<edition>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</edition>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:leader">\n\t\t\t\t<issuance>\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">monographic</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">continuing</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</issuance>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=310]|marc:datafield[@tag=321]">\n\t\t\t\t<frequency>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</frequency>\n\t\t\t</xsl:for-each>\n\t\t</originInfo>\n\t\t<xsl:variable name="controlField008-35-37" select="normalize-space(translate(substring($controlField008,36,3),'|#',''))"></xsl:variable>\n\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t<language>\n\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t<xsl:value-of select="substring($controlField008,36,3)"/>\n\t\t\t\t</languageTerm>\n\t\t\t</language>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=041]">\n\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='d' or @code='e' or @code='f' or @code='g' or @code='h']">\n\t\t\t\t<xsl:variable name="langCodes" select="."/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="../marc:subfield[@code='2']='rfc3066'">\n\t\t\t\t\t\t<!-- not stacked but could be repeated -->\n\t\t\t\t\t\t<xsl:call-template name="rfcLanguages">\n\t\t\t\t\t\t\t<xsl:with-param name="nodeNum">\n\t\t\t\t\t\t\t\t<xsl:value-of select="1"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t\t<xsl:text></xsl:text>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="controlField008-35-37">\n\t\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"></xsl:value-of>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<!-- iso -->\n\t\t\t\t\t\t<xsl:variable name="allLanguages">\n\t\t\t\t\t\t\t<xsl:copy-of select="$langCodes"></xsl:copy-of>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:variable name="currentLanguage">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"></xsl:value-of>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"></xsl:value-of>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,4,string-length($allLanguages)-3)"></xsl:value-of>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"></xsl:value-of>\n\t\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t</xsl:for-each>\n\t\t<xsl:variable name="physicalDescription">\n\t\t\t<!--3.2 change tmee 007/11 -->\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='a']">\n\t\t\t\t<digitalOrigin>reformatted digital</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='b']">\n\t\t\t\t<digitalOrigin>digitized microfilm</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='d']">\n\t\t\t\t<digitalOrigin>digitized other analog</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-23" select="substring($controlField008,24,1)"></xsl:variable>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"></xsl:variable>\n\t\t\t<xsl:variable name="check008-23">\n\t\t\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='MU' or $typeOf008='SE' or $typeOf008='MM'">\n\t\t\t\t\t<xsl:value-of select="true()"></xsl:value-of>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:variable name="check008-29">\n\t\t\t\t<xsl:if test="$typeOf008='MP' or $typeOf008='VM'">\n\t\t\t\t\t<xsl:value-of select="true()"></xsl:value-of>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='f') or ($check008-29 and $controlField008-29='f')">\n\t\t\t\t\t<form authority="marcform">braille</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($controlField008-23=' ' and ($leader6='c' or $leader6='d')) or (($typeOf008='BK' or $typeOf008='SE') and ($controlField008-23=' ' or $controlField008='r'))">\n\t\t\t\t\t<form authority="marcform">print</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$leader6 = 'm' or ($check008-23 and $controlField008-23='s') or ($check008-29 and $controlField008-29='s')">\n\t\t\t\t\t<form authority="marcform">electronic</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='b') or ($check008-29 and $controlField008-29='b')">\n\t\t\t\t\t<form authority="marcform">microfiche</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="($check008-23 and $controlField008-23='a') or ($check008-29 and $controlField008-29='a')">\n\t\t\t\t\t<form authority="marcform">microfilm</form>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<!-- 1/04 fix -->\n\t\t\t<xsl:if test="marc:datafield[@tag=130]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=130]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=240]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=240]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=242]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=242]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=245]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=245]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=246]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=246]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=730]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=730]/marc:subfield[@code='h']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=256]/marc:subfield[@code='a']">\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</form>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=007][substring(text(),1,1)='c']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='a'">\n\t\t\t\t\t\t<reformattingQuality>access</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='p'">\n\t\t\t\t\t\t<reformattingQuality>preservation</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='r'">\n\t\t\t\t\t\t<reformattingQuality>replacement</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t\t<!--3.2 change tmee 007/01 -->\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">chip cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">computer optical disc cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">magnetic disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='m']">\n\t\t\t\t<form authority="smd">magneto-optical disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">optical disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">tape cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">tape cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='h']">\n\t\t\t\t<form authority="smd">tape reel</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">celestial globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">earth moon globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">planetary or lunar globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">terrestrial globe</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='o'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">kit</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">atlas</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">diagram</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">map</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">model</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='k']">\n\t\t\t\t<form authority="smd">profile</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote-sensing image</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">section</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='y']">\n\t\t\t\t<form authority="smd">view</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">aperture card</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">microfiche</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">microfiche cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">microfilm cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">microfilm cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">microfilm reel</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">microopaque</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">film cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">film cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">film reel</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='n']">\n\t\t\t\t<form authority="smd">chart</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">collage</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">drawing</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">flash card</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">painting</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">photomechanical print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">photonegative</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='h']">\n\t\t\t\t<form authority="smd">photoprint</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='i']">\n\t\t\t\t<form authority="smd">picture</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='l']">\n\t\t\t\t<form authority="smd">technical drawing</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='q'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">notated music</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">filmslip</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">filmstrip cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">filmstrip roll</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">other filmstrip type</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">slide</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='t']">\n\t\t\t\t<form authority="smd">transparency</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='r'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote-sensing image</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">cylinder</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">roll</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">sound cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">sound cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">sound disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='t']">\n\t\t\t\t<form authority="smd">sound-tape reel</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='i']">\n\t\t\t\t<form authority="smd">sound-track film</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='w']">\n\t\t\t\t<form authority="smd">wire recording</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">braille</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">combination</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">moon</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">tactile, with no writing system</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">braille</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">large print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">regular print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">text in looseleaf binder</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">videocartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">videocassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">videodisc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">videoreel</form>\n\t\t\t</xsl:if>\n\t\t\t\n\t\t\t<xsl:for-each select="marc:datafield[@tag=856]/marc:subfield[@code='q'][string-length(.)>1]">\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</internetMediaType>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=300]">\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abce</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</extent>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($physicalDescription))">\n\t\t\t<physicalDescription>\n\t\t\t\t<xsl:copy-of select="$physicalDescription"></xsl:copy-of>\n\t\t\t</physicalDescription>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=520]">\n\t\t\t<abstract>\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</abstract>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=505]">\n\t\t\t<tableOfContents>\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">agrt</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</tableOfContents>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=521]">\n\t\t\t<targetAudience>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</targetAudience>\n\t\t</xsl:for-each>\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='CF' or $typeOf008='MU' or $typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-22" select="substring($controlField008,23,1)"></xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<!-- 01/04 fix -->\n\t\t\t\t<xsl:when test="$controlField008-22='d'">\n\t\t\t\t\t<targetAudience authority="marctarget">adolescent</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='e'">\n\t\t\t\t\t<targetAudience authority="marctarget">adult</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='g'">\n\t\t\t\t\t<targetAudience authority="marctarget">general</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='b' or $controlField008-22='c' or $controlField008-22='j'">\n\t\t\t\t\t<targetAudience authority="marctarget">juvenile</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='a'">\n\t\t\t\t\t<targetAudience authority="marctarget">preschool</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='f'">\n\t\t\t\t\t<targetAudience authority="marctarget">specialized</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=245]/marc:subfield[@code='c']">\n\t\t\t<note type="statement of responsibility">\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=500]">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<!--3.2 change tmee additional note fields-->\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t<note type="restrictions">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=510]">\n\t\t\t<note  type="citation/reference">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=511]">\n\t\t\t<note type="performers">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=518]">\n\t\t\t<note type="venue">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=530]">\n\t\t\t<note  type="additional physical form">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=533]">\n\t\t\t<note  type="reproduction">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t<note  type="original version">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=538]">\n\t\t\t<note  type="system details">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=583]">\n\t\t\t<note type="action">\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t\n\n\t\t\n\t\t\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=501 or @tag=502 or @tag=504 or @tag=507 or @tag=508 or  @tag=513 or @tag=514 or @tag=515 or @tag=516 or @tag=522 or @tag=524 or @tag=525 or @tag=526 or @tag=535 or @tag=536 or @tag=540 or @tag=541 or @tag=544 or @tag=545 or @tag=546 or @tag=547 or @tag=550 or @tag=552 or @tag=555 or @tag=556 or @tag=561 or @tag=562 or @tag=565 or @tag=567 or @tag=580 or @tag=581 or @tag=584 or @tag=585 or @tag=586]">\n\t\t\t<note>\n\t\t\t\t<xsl:call-template name="uri"></xsl:call-template>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=034][marc:subfield[@code='d' or @code='e' or @code='f' or @code='g']]">\n\t\t\t<subject>\n\t\t\t\t<cartographics>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">defg</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</coordinates>\n\t\t\t\t</cartographics>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=043]">\n\t\t\t<subject>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='c']">\n\t\t\t\t\t<geographicCode>\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:if test="@code='a'">\n\t\t\t\t\t\t\t\t<xsl:text>marcgac</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='b'">\n\t\t\t\t\t\t\t\t<xsl:value-of select="following-sibling::marc:subfield[@code=2]"></xsl:value-of>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='c'">\n\t\t\t\t\t\t\t\t<xsl:text>iso3166</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="self::marc:subfield"></xsl:value-of>\n\t\t\t\t\t</geographicCode>\n\t\t\t\t</xsl:for-each>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<!-- tmee 2006/11/27 -->\n\t\t<xsl:for-each select="marc:datafield[@tag=255]">\n\t\t\t<subject>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='c']">\n\t\t\t\t<cartographics>\n\t\t\t\t\t<xsl:if test="@code='a'">\n\t\t\t\t\t\t<scale>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</scale>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="@code='b'">\n\t\t\t\t\t\t<projection>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</projection>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="@code='c'">\n\t\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</coordinates>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</cartographics>\n\t\t\t\t</xsl:for-each>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t\t\t\n\t\t<xsl:apply-templates select="marc:datafield[653 >= @tag and @tag >= 600]"></xsl:apply-templates>\n\t\t<xsl:apply-templates select="marc:datafield[@tag=656]"></xsl:apply-templates>\n\t\t<xsl:for-each select="marc:datafield[@tag=752]">\n\t\t\t<subject>\n\t\t\t\t<hierarchicalGeographic>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<country>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</country>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<state>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</state>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t<county>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</county>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t\t<city>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</city>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</hierarchicalGeographic>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=045][marc:subfield[@code='b']]">\n\t\t\t<subject>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@ind1=2">\n\t\t\t\t\t\t<temporal encoding="iso8601" point="start">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][1]"></xsl:value-of>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t<temporal encoding="iso8601" point="end">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][2]"></xsl:value-of>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=050]">\n\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:if test="../marc:subfield[@code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:subfield[@code='3']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="preceding-sibling::marc:subfield[@code='a'][1]"></xsl:value-of>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t<xsl:value-of select="text()"></xsl:value-of>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a'][not(following-sibling::marc:subfield[@code='b'])]">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:if test="../marc:subfield[@code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:subfield[@code='3']"></xsl:value-of>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="text()"></xsl:value-of>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=082]">\n\t\t\t<classification authority="ddc">\n\t\t\t\t<xsl:if test="marc:subfield[@code='2']">\n\t\t\t\t\t<xsl:attribute name="edition">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"></xsl:value-of>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=080]">\n\t\t\t<classification authority="udc">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abx</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=060]">\n\t\t\t<classification authority="nlm">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=0]">\n\t\t\t<classification authority="sudocs">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=1]">\n\t\t\t<classification authority="candoc">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"></xsl:value-of>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=084]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"></xsl:value-of>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=440]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=490][@ind1=0]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=510]">\n\t\t\t<relatedItem type="isReferencedBy">\n\t\t\t\t<note>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcx3</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</note>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedTitle"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="relatedName"></xsl:call-template>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t\t\t<originInfo>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t\t</publisher>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<edition>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t\t</edition>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</originInfo>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='z']">\n\t\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</identifier>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:call-template name="relatedNote"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=700][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"></xsl:call-template>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"></xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="nameDate"></xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=710][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"></xsl:call-template>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:variable name="tempNamePart">\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:if test="normalize-space($tempNamePart)">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="$tempNamePart"></xsl:value-of>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=711][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"></xsl:call-template>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=730][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"></xsl:call-template>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"></xsl:call-template>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=760]|marc:datafield[@tag=762]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=765]|marc:datafield[@tag=767]|marc:datafield[@tag=777]|marc:datafield[@tag=787]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=775]">\n\t\t\t<relatedItem type="otherVersion">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=770]|marc:datafield[@tag=774]">\n\t\t\t<relatedItem type="constituent">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=772]|marc:datafield[@tag=773]">\n\t\t\t<relatedItem type="host">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=776]">\n\t\t\t<relatedItem type="otherFormat">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=780]">\n\t\t\t<relatedItem type="preceding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=785]">\n\t\t\t<relatedItem type="succeeding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=786]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=800]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"></xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="nameDate"></xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=810]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"></xsl:call-template>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=811]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='830']">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='856'][@ind2='2']/marc:subfield[@code='q']">\n\t\t\t<relatedItem>\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</internetMediaType>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='020']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">isbn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='0']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">isrc</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="isrc">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='2']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">ismn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="ismn">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='4']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">sici</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<identifier type="sici">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='022']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">issn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='010']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">lccn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<identifier type="lccn">\n\t\t\t\t<xsl:value-of select="normalize-space(marc:subfield[@code='a'])"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='028']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="@ind1='0'">issue number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='1'">matrix number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='2'">music plate</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='3'">music publisher</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='4'">videorecording identifier</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<!--<xsl:call-template name="isInvalid"/>--> <!-- no $z in 028 -->\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="@ind1='0'">ba</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>ab</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='037']">\n\t\t\t<identifier type="stock number">\n\t\t\t\t<!--<xsl:call-template name="isInvalid"/>--> <!-- no $z in 037 -->\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='856'][marc:subfield[@code='u']]">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:doi') or starts-with(marc:subfield[@code='u'],'doi')">doi</xsl:when>\n\t\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov')">hdl</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>uri</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov') ">\n\t\t\t\t\t\t<xsl:value-of select="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"></xsl:value-of>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"></xsl:value-of>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</identifier>\n\t\t\t<xsl:if test="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl')">\n\t\t\t\t<identifier type="hdl">\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3' or @code='z']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3z</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"></xsl:value-of>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=1]">\n\t\t\t<identifier type="upc">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<!-- 1/04 fix added $y -->\n\t\t<xsl:for-each select="marc:datafield[@tag=856][marc:subfield[@code='u']]">\n\t\t\t<location>\n\t\t\t\t<url>\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='z' ]">\n\t\t\t\t\t\t<xsl:attribute name="note">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">z</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"></xsl:value-of>\n\n\t\t\t\t</url>\n\t\t\t</location>\n\t\t</xsl:for-each>\n\t\t\t\n\t\t\t<!-- 3.2 change tmee 856z  -->\n\n\t\t\n\t\t<xsl:for-each select="marc:datafield[@tag=852]">\n\t\t\t<location>\n\t\t\t\t<physicalLocation>\n\t\t\t\t\t<xsl:call-template name="displayLabel"></xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abje</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</physicalLocation>\n\t\t\t</location>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t<accessCondition type="restrictionOnAccess">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcd35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=540]">\n\t\t\t<accessCondition type="useAndReproduction">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcde35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\t\t<recordInfo>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]">\n\t\t\t\t<recordContentSource authority="marcorg">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t\t</recordContentSource>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=008]">\n\t\t\t\t<recordCreationDate encoding="marc">\n\t\t\t\t\t<xsl:value-of select="substring(.,1,6)"></xsl:value-of>\n\t\t\t\t</recordCreationDate>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=005]">\n\t\t\t\t<recordChangeDate encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</recordChangeDate>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=001]">\n\t\t\t\t<recordIdentifier>\n\t\t\t\t\t<xsl:if test="../marc:controlfield[@tag=003]">\n\t\t\t\t\t\t<xsl:attribute name="source">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:controlfield[@tag=003]"></xsl:value-of>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</recordIdentifier>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]/marc:subfield[@code='b']">\n\t\t\t\t<languageOfCataloging>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</languageOfCataloging>\n\t\t\t</xsl:for-each>\n\t\t</recordInfo>\n\t</xsl:template>\n\t<xsl:template name="displayForm">\n\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t<displayForm>\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</displayForm>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="affiliation">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<affiliation>\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</affiliation>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="uri">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<xsl:attribute name="xlink:href">\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</xsl:attribute>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="role">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<role>\n\t\t\t\t<roleTerm type="text">\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t<role>\n\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="part">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partNumber"></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partName"></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedPart">\n\t\t<xsl:if test="@tag=773">\n\t\t\t<xsl:for-each select="marc:subfield[@code='g']">\n\t\t\t\t<part>\n\t\t\t\t\t<text>\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</text>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='q']">\n\t\t\t\t<part>\n\t\t\t\t\t<xsl:call-template name="parsePart"></xsl:call-template>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedPartNumName">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">pst</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:value-of select="$partNumber"></xsl:value-of>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:value-of select="$partName"></xsl:value-of>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedName">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<name>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</namePart>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedForm">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</form>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedExtent">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</extent>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedNote">\n\t\t<xsl:for-each select="marc:subfield[@code='n']">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedSubject">\n\t\t<xsl:for-each select="marc:subfield[@code='j']">\n\t\t\t<subject>\n\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</temporal>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifierISSN">\n\t\t<xsl:for-each select="marc:subfield[@code='x']">\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifierLocal">\n\t\t<xsl:for-each select="marc:subfield[@code='w']">\n\t\t\t<identifier type="local">\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifier">\n\t\t<xsl:for-each select="marc:subfield[@code='o']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedItem76X-78X">\n\t\t<xsl:call-template name="displayLabel"></xsl:call-template>\n\t\t<xsl:call-template name="relatedTitle76X-78X"></xsl:call-template>\n\t\t<xsl:call-template name="relatedName"></xsl:call-template>\n\t\t<xsl:call-template name="relatedOriginInfo"></xsl:call-template>\n\t\t<xsl:call-template name="relatedLanguage"></xsl:call-template>\n\t\t<xsl:call-template name="relatedExtent"></xsl:call-template>\n\t\t<xsl:call-template name="relatedNote"></xsl:call-template>\n\t\t<xsl:call-template name="relatedSubject"></xsl:call-template>\n\t\t<xsl:call-template name="relatedIdentifier"></xsl:call-template>\n\t\t<xsl:call-template name="relatedIdentifierISSN"></xsl:call-template>\n\t\t<xsl:call-template name="relatedIdentifierLocal"></xsl:call-template>\n\t\t<xsl:call-template name="relatedPart"></xsl:call-template>\n\t</xsl:template>\n\t<xsl:template name="subjectGeographicZ">\n\t\t<geographic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</geographic>\n\t</xsl:template>\n\t<xsl:template name="subjectTemporalY">\n\t\t<temporal>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</temporal>\n\t</xsl:template>\n\t<xsl:template name="subjectTopic">\n\t\t<topic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</topic>\n\t</xsl:template>\t\n\t<!-- 3.2 change tmee 6xx $v genre -->\n\t<xsl:template name="subjectGenre">\n\t\t<genre>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</genre>\n\t</xsl:template>\n\t\n\t<xsl:template name="nameABCDN">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:if test="marc:subfield[@code='c'] or marc:subfield[@code='d'] or marc:subfield[@code='n']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">cdn</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="nameABCDQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:with-param>\n\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t\t<xsl:call-template name="termsOfAddress"></xsl:call-template>\n\t\t<xsl:call-template name="nameDate"></xsl:call-template>\n\t</xsl:template>\n\t<xsl:template name="nameACDEQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t<xsl:with-param name="codes">acdeq</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t</xsl:template>\n\t<xsl:template name="constituentOrRelatedType">\n\t\t<xsl:if test="@ind2=2">\n\t\t\t<xsl:attribute name="type">constituent</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedTitle">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedTitle76X-78X">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='p']">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='s']">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"></xsl:call-template>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedOriginInfo">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='d'] or marc:subfield[@code='f']">\n\t\t\t<originInfo>\n\t\t\t\t<xsl:if test="@tag=775">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='f']">\n\t\t\t\t\t\t<place>\n\t\t\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:attribute name="authority">marcgac</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t\t</placeTerm>\n\t\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t<publisher>\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</publisher>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<edition>\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</edition>\n\t\t\t\t</xsl:for-each>\n\t\t\t</originInfo>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedLanguage">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t<xsl:with-param name="langString">\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="nameDate">\n\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t<namePart type="date">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="subjectAuthority">\n\t\t<xsl:if test="@ind2!=4">\n\t\t\t<xsl:if test="@ind2!=' '">\n\t\t\t\t<xsl:if test="@ind2!=8">\n\t\t\t\t\t<xsl:if test="@ind2!=9">\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=0">lcsh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=1">lcshac</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=2">mesh</xsl:when>\n\t\t\t\t\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=3">nal</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=5">csh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=6">rvm</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=7">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"></xsl:value-of>\n\t\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="subjectAnyOrder">\n\t\t<xsl:for-each select="marc:subfield[@code='v' or @code='x' or @code='y' or @code='z']">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@code='v'">\n\t\t\t\t\t<xsl:call-template name="subjectGenre"></xsl:call-template>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='x'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"></xsl:call-template>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='y'">\n\t\t\t\t\t<xsl:call-template name="subjectTemporalY"></xsl:call-template>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='z'">\n\t\t\t\t\t<xsl:call-template name="subjectGeographicZ"></xsl:call-template>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="specialSubfieldSelect">\n\t\t<xsl:param name="anyCodes"></xsl:param>\n\t\t<xsl:param name="axis"></xsl:param>\n\t\t<xsl:param name="beforeCodes"></xsl:param>\n\t\t<xsl:param name="afterCodes"></xsl:param>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($anyCodes, @code)      or (contains($beforeCodes,@code) and following-sibling::marc:subfield[@code=$axis])      or (contains($afterCodes,@code) and preceding-sibling::marc:subfield[@code=$axis])">\n\t\t\t\t\t<xsl:value-of select="text()"></xsl:value-of>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"></xsl:value-of>\n\t</xsl:template>\n\t\n\t<!-- 3.2 change tmee 6xx $v genre -->\n\t<xsl:template match="marc:datafield[@tag=600]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="termsOfAddress"></xsl:call-template>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="nameDate"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="affiliation"></xsl:call-template>\n\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=610]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:if test="marc:subfield[@code='c' or @code='d' or @code='n' or @code='p']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">cdnp</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="role"></xsl:call-template>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=611]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<name type="conference">\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcdeqnp</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t\t\t</roleTerm>\n\t\t\t\t\t</role>\n\t\t\t\t</xsl:for-each>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=630]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfhklor</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t<xsl:call-template name="part"></xsl:call-template>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=650]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<topic>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abcd</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</topic>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=651]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"></xsl:call-template>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<geographic>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."></xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</geographic>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:call-template name="subjectAnyOrder"></xsl:call-template>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=653]">\n\t\t<subject>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<topic>\n\t\t\t\t\t<xsl:value-of select="."></xsl:value-of>\n\t\t\t\t</topic>\n\t\t\t</xsl:for-each>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=656]">\n\t\t<subject>\n\t\t\t<xsl:if test="marc:subfield[@code=2]">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code=2]"></xsl:value-of>\n\t\t\t\t</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<occupation>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</occupation>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template name="termsOfAddress">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t<namePart type="termsOfAddress">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">bc</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="displayLabel">\n\t\t<xsl:if test="marc:subfield[@code='i']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='i']"></xsl:value-of>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t\t<xsl:if test="marc:subfield[@code='3']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='3']"></xsl:value-of>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="isInvalid">\n\t\t<xsl:param name="type"/>\n\t\t<xsl:if test="marc:subfield[@code='z'] or marc:subfield[@code='y']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:value-of select="$type"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:attribute name="invalid">\n\t\t\t\t\t<xsl:text>yes</xsl:text>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:if test="marc:subfield[@code='z']">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='z']"/>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="marc:subfield[@code='y']">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='y']"/>\n\t\t\t\t</xsl:if>\n\t\t\t</identifier>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="subtitle">\n\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t<subTitle>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b']"/>\n\t\t\t\t\t\t<!--<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">b</xsl:with-param>\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</xsl:call-template>-->\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</subTitle>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="script">\n\t\t<xsl:param name="scriptCode"></xsl:param>\n\t\t<xsl:attribute name="script">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$scriptCode='(3'">Arabic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(B'">Latin</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='$1'">Chinese, Japanese, Korean</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(N'">Cyrillic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(2'">Hebrew</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(S'">Greek</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\t<xsl:template name="parsePart">\n\t\t<!-- assumes 773$q= 1:2:3<4\n\t\t     with up to 3 levels and one optional start page\n\t\t-->\n\t\t<xsl:variable name="level1">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains(text(),':')">\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t\t<xsl:value-of select="substring-before(text(),':')"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="not(contains(text(),':'))">\n\t\t\t\t\t<!-- 1 or 1<3 -->\n\t\t\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t\t\t<!-- 1<3 -->\n\t\t\t\t\t\t<xsl:value-of select="substring-before(text(),'&lt;')"></xsl:value-of>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="not(contains(text(),'&lt;'))">\n\t\t\t\t\t\t<!-- 1 -->\n\t\t\t\t\t\t<xsl:value-of select="text()"></xsl:value-of>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after(text(),$level1),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after(text(),$level1),2)"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after(text(),$level1)"></xsl:value-of>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici2,':')">\n\t\t\t\t\t<!--  2:3<4  -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,':')"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($sici2,'&lt;')">\n\t\t\t\t\t<!-- 1: 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,'&lt;')"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici2"></xsl:value-of>\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after($sici2,$level2),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after($sici2,$level2),2)"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after($sici2,$level2)"></xsl:value-of>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici3,'&lt;')">\n\t\t\t\t\t<!-- 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici3,'&lt;')"></xsl:value-of>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici3"></xsl:value-of>\n\t\t\t\t\t<!-- 3 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="page">\n\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t<xsl:value-of select="substring-after(text(),'&lt;')"></xsl:value-of>\n\t\t\t</xsl:if>\n\t\t</xsl:variable>\n\t\t<xsl:if test="$level1">\n\t\t\t<detail level="1">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level1"></xsl:value-of>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level2">\n\t\t\t<detail level="2">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level2"></xsl:value-of>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level3">\n\t\t\t<detail level="3">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level3"></xsl:value-of>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$page">\n\t\t\t<extent unit="page">\n\t\t\t\t<start>\n\t\t\t\t\t<xsl:value-of select="$page"></xsl:value-of>\n\t\t\t\t</start>\n\t\t\t</extent>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="getLanguage">\n\t\t<xsl:param name="langString"></xsl:param>\n\t\t<xsl:param name="controlField008-35-37"></xsl:param>\n\t\t<xsl:variable name="length" select="string-length($langString)"></xsl:variable>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"></xsl:when>\n\t\t\t<xsl:when test="$controlField008-35-37=substring($langString,1,3)">\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"></xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<language>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="substring($langString,1,3)"></xsl:value-of>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"></xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"></xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="isoLanguage">\n\t\t<xsl:param name="currentLanguage"></xsl:param>\n\t\t<xsl:param name="usedLanguages"></xsl:param>\n\t\t<xsl:param name="remainingLanguages"></xsl:param>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="string-length($currentLanguage)=0"></xsl:when>\n\t\t\t<xsl:when test="not(contains($usedLanguages, $currentLanguage))">\n\t\t\t\t<language>\n\t\t\t\t\t<xsl:if test="@code!='a'">\n\t\t\t\t\t\t<xsl:attribute name="objectPart">\n\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='b'">summary or subtitle</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='d'">sung or spoken text</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='e'">libretto</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='f'">table of contents</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='g'">accompanying material</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='h'">translation</xsl:when>\n\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"></xsl:value-of>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,4,string-length($remainingLanguages))"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,4,string-length($remainingLanguages))"></xsl:value-of>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="chopBrackets">\n\t\t<xsl:param name="chopString"></xsl:param>\n\t\t<xsl:variable name="string">\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="$chopString"></xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="substring($string, 1,1)='['">\n\t\t\t<xsl:value-of select="substring($string,2, string-length($string)-2)"></xsl:value-of>\n\t\t</xsl:if>\n\t\t<xsl:if test="substring($string, 1,1)!='['">\n\t\t\t<xsl:value-of select="$string"></xsl:value-of>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="rfcLanguages">\n\t\t<xsl:param name="nodeNum"></xsl:param>\n\t\t<xsl:param name="usedLanguages"></xsl:param>\n\t\t<xsl:param name="controlField008-35-37"></xsl:param>\n\t\t<xsl:variable name="currentLanguage" select="."></xsl:variable>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="not($currentLanguage)"></xsl:when>\n\t\t\t<xsl:when test="$currentLanguage!=$controlField008-35-37 and $currentLanguage!='rfc3066'">\n\t\t\t\t<xsl:if test="not(contains($usedLanguages,$currentLanguage))">\n\t\t\t\t\t<language>\n\t\t\t\t\t\t<xsl:if test="@code!='a'">\n\t\t\t\t\t\t\t<xsl:attribute name="objectPart">\n\t\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='b'">summary or subtitle</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='d'">sung or spoken text</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='e'">libretto</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='f'">table of contents</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='g'">accompanying material</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='h'">translation</xsl:when>\n\t\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<languageTerm authority="rfc3066" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"/>\n\t\t\t\t\t\t</languageTerm>\n\t\t\t\t\t</language>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="datafield">\n\t\t<xsl:param name="tag"/>\n\t\t<xsl:param name="ind1"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="ind2"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:param name="subfields"/>\n\t\t<xsl:element name="marc:datafield">\n\t\t\t<xsl:attribute name="tag">\n\t\t\t\t<xsl:value-of select="$tag"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind1">\n\t\t\t\t<xsl:value-of select="$ind1"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind2">\n\t\t\t\t<xsl:value-of select="$ind2"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:copy-of select="$subfields"/>\n\t\t</xsl:element>\n\t</xsl:template>\n\n\t<xsl:template name="subfieldSelect">\n\t\t<xsl:param name="codes"/>\n\t\t<xsl:param name="delimeter"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($codes, @code)">\n\t\t\t\t\t<xsl:value-of select="text()"/><xsl:value-of select="$delimeter"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-string-length($delimeter))"/>\n\t</xsl:template>\n\n\t<xsl:template name="buildSpaces">\n\t\t<xsl:param name="spaces"/>\n\t\t<xsl:param name="char"><xsl:text> </xsl:text></xsl:param>\n\t\t<xsl:if test="$spaces>0">\n\t\t\t<xsl:value-of select="$char"/>\n\t\t\t<xsl:call-template name="buildSpaces">\n\t\t\t\t<xsl:with-param name="spaces" select="$spaces - 1"/>\n\t\t\t\t<xsl:with-param name="char" select="$char"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuation">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:param name="punctuation"><xsl:text>.:,;/ </xsl:text></xsl:param>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains($punctuation, substring($chopString,$length,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,1,$length - 1)"/>\n\t\t\t\t\t<xsl:with-param name="punctuation" select="$punctuation"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuationFront">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains('.:,;/[ ', substring($chopString,1,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,2,$length - 1)"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise><xsl:value-of select="$chopString"/></xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n</xsl:stylesheet>
mods33	http://www.loc.gov/mods/v3	mods33	<xsl:stylesheet xmlns="http://www.loc.gov/mods/v3" xmlns:marc="http://www.loc.gov/MARC21/slim"\n\txmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n\texclude-result-prefixes="xlink marc" version="1.0">\n\t<xsl:output encoding="UTF-8" indent="yes" method="xml"/>\n\n\t<xsl:variable name="ascii">\n\t\t<xsl:text> !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~</xsl:text>\n\t</xsl:variable>\n\n\t<xsl:variable name="latin1">\n\t\t<xsl:text> ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ</xsl:text>\n\t</xsl:variable>\n\t<!-- Characters that usually don't need to be escaped -->\n\t<xsl:variable name="safe">\n\t\t<xsl:text>!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~</xsl:text>\n\t</xsl:variable>\n\n\t<xsl:variable name="hex">0123456789ABCDEF</xsl:variable>\n\n\n\t\n\t<!--MARC21slim2MODS3-3.xsl\nRevision 1.27 - Mapped 648 to <subject> 2009/03/13 tmee\nRevision 1.26 - Added subfield $s mapping for 130/240/730  2008/10/16 tmee\nRevision 1.25 - Mapped 040e to <descriptiveStandard> and Leader/18 to <descriptive standard>aacr2  2008/09/18 tmee\nRevision 1.24 - Mapped 852 subfields $h, $i, $j, $k, $l, $m, $t to <shelfLocation> and 852 subfield $u to <physicalLocation> with @xlink 2008/09/17 tmee\nRevision 1.23 - Commented out xlink/uri for subfield 0 for 130/240/730, 100/700, 110/710, 111/711 as these are currently unactionable  2008/09/17  tmee\nRevision 1.22 - Mapped 022 subfield $l to type "issn-l" subfield $m to output identifier element with corresponding @type and @invalid eq 'yes'2008/09/17  tmee\nRevision 1.21 - Mapped 856 ind2=1 or ind2=2 to <relatedItem><location><url>  2008/07/03  tmee\nRevision 1.20 - Added genre w/@auth="contents of 2" and type= "musical composition"  2008/07/01  tmee\nRevision 1.19 - Added genre offprint for 008/24+ BK code 2  2008/07/01  tmee\nRevision 1.18 - Added xlink/uri for subfield 0 for 130/240/730, 100/700, 110/710, 111/711  2008/06/26  tmee\nRevision 1.17 - Added mapping of 662 2008/05/14 tmee\t\nRevision 1.16 - Changed @authority from "marc" to "marcgt" for 007 and 008 codes mapped to a term in <genre> 2007/07/10  tmee\nRevision 1.15 - For field 630, moved call to part template outside title element  2007/07/10  tmee\nRevision 1.14 - Fixed template isValid and fields 010, 020, 022, 024, 028, and 037 to output additional identifier elements with corresponding @type and @invalid eq 'yes' when subfields z or y (in the case of 022) exist in the MARCXML ::: 2007/01/04 17:35:20 cred\nRevision 1.13 - Changed order of output under cartographics to reflect schema  2006/11/28  tmee\nRevision 1.12 - Updated to reflect MODS 3.2 Mapping  2006/10/11  tmee\nRevision 1.11 - The attribute objectPart moved from <languageTerm> to <language>  2006/04/08  jrad\nRevision 1.10 - MODS 3.1 revisions to language and classification elements  (plus ability to find marc:collection embedded in wrapper elements such as SRU zs: wrappers)  2006/02/06  ggar\nRevision 1.9 - Subfield $y was added to field 242 2004/09/02 10:57 jrad\nRevision 1.8 - Subject chopPunctuation expanded and attribute fixes 2004/08/12 jrad\nRevision 1.7 - 2004/03/25 08:29 jrad\nRevision 1.6 - Various validation fixes 2004/02/20 ntra\nRevision 1.5 - MODS2 to MODS3 updates, language unstacking and de-duping, chopPunctuation expanded  2003/10/02 16:18:58  ntra\nRevision 1.3 - Additional Changes not related to MODS Version 2.0 by ntra\nRevision 1.2 - Added Log Comment  2003/03/24 19:37:42  ckeith\n-->\n\t<xsl:template match="/">\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="//marc:collection">\n\t\t\t\t<modsCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\t\t\t\t\txsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-2.xsd">\n\t\t\t\t\t<xsl:for-each select="//marc:collection/marc:record">\n\t\t\t\t\t\t<mods version="3.3">\n\t\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t\t</mods>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</modsCollection>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<mods xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="3.3"\n\t\t\t\t\txsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-2.xsd">\n\t\t\t\t\t<xsl:for-each select="//marc:record">\n\t\t\t\t\t\t<xsl:call-template name="marcRecord"/>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</mods>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="marcRecord">\n\t\t<xsl:variable name="leader" select="marc:leader"/>\n\t\t<xsl:variable name="leader6" select="substring($leader,7,1)"/>\n\t\t<xsl:variable name="leader7" select="substring($leader,8,1)"/>\n\t\t<xsl:variable name="controlField008" select="marc:controlfield[@tag='008']"/>\n\t\t<xsl:variable name="typeOf008">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a'">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when\n\t\t\t\t\t\t\ttest="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'">BK</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'">SE</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='t'">BK</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">MM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">CF</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">MP</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g' or $leader6='k' or $leader6='o' or $leader6='r'">VM</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d' or $leader6='i' or $leader6='j'"\n\t\t\t\t>MU</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:for-each select="marc:datafield[@tag='245']">\n\t\t\t<titleInfo>\n\t\t\t\t<xsl:variable name="title">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">abfgk</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:variable name="titleChop">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="$title"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@ind2&gt;0">\n\t\t\t\t\t\t<nonSort>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,1,@ind2)"/>\n\t\t\t\t\t\t</nonSort>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="substring($titleChop,@ind2+1)"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<title>\n\t\t\t\t\t\t\t<xsl:value-of select="$titleChop"/>\n\t\t\t\t\t\t</title>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t\t\t<subTitle>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">b</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">afgk</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</subTitle>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='210']">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='242']">\n\t\t\t<titleInfo type="translated">\n\t\t\t\t<!--09/01/04 Added subfield $y-->\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='y']">\n\t\t\t\t\t<xsl:attribute name="lang">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='i']">\n\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">a</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='246']">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='i']">\n\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<!-- 1/04 removed $h, $b -->\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">af</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="subtitle"/>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each\n\t\t\tselect="marc:datafield[@tag='130']|marc:datafield[@tag='240']|marc:datafield[@tag='730'][@ind2!='2']">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t-->\n\n\t\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t\t\t\t<xsl:if\n\t\t\t\t\t\t\t\ttest="(contains('adfklmors',@code) and (not(../marc:subfield[@code='n' or @code='p']) or (following-sibling::marc:subfield[@code='n' or @code='p'])))">\n\t\t\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='740'][@ind2!='2']">\n\t\t\t<titleInfo type="alternative">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">ah</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='100']">\n\t\t\t<name type="personal">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='110']">\n\t\t\t<name type="corporate">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='111']">\n\t\t\t<name type="conference">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<role>\n\t\t\t\t\t<roleTerm authority="marcrelator" type="text">creator</roleTerm>\n\t\t\t\t</role>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='700'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="personal">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameABCDQ"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='710'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="corporate">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameABCDN"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='711'][not(marc:subfield[@code='t'])]">\n\t\t\t<name type="conference">\n\n\t\t\t\t<!-- deleted uri for subfield 0\n\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t-->\n\n\t\t\t\t<xsl:call-template name="nameACDEQ"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='720'][not(marc:subfield[@code='t'])]">\n\t\t\t<name>\n\t\t\t\t<xsl:if test="@ind1=1">\n\t\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t\t<xsl:text>personal</xsl:text>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t\t<typeOfResource>\n\t\t\t<xsl:if test="$leader7='c'">\n\t\t\t\t<xsl:attribute name="collection">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$leader6='d' or $leader6='f' or $leader6='p' or $leader6='t'">\n\t\t\t\t<xsl:attribute name="manuscript">yes</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$leader6='a' or $leader6='t'">text</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='e' or $leader6='f'">cartographic</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='c' or $leader6='d'">notated music</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='i'">sound recording-nonmusical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='j'">sound recording-musical</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='k'">still image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='g'">moving image</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='r'">three dimensional object</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='m'">software, multimedia</xsl:when>\n\t\t\t\t<xsl:when test="$leader6='p'">mixed material</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</typeOfResource>\n\t\t<xsl:if test="substring($controlField008,26,1)='d'">\n\t\t\t<genre authority="marcgt">globe</genre>\n\t\t</xsl:if>\n\t\t<xsl:if\n\t\t\ttest="marc:controlfield[@tag='007'][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t<genre authority="marcgt">remote-sensing image</genre>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='MP'">\n\t\t\t<xsl:variable name="controlField008-25" select="substring($controlField008,26,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="$controlField008-25='a' or $controlField008-25='b' or $controlField008-25='c' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t\t<genre authority="marcgt">map</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="$controlField008-25='e' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t\t<genre authority="marcgt">atlas</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-21" select="substring($controlField008,22,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-21='d'">\n\t\t\t\t\t<genre authority="marcgt">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='l'">\n\t\t\t\t\t<genre authority="marcgt">loose-leaf</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='m'">\n\t\t\t\t\t<genre authority="marcgt">series</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='n'">\n\t\t\t\t\t<genre authority="marcgt">newspaper</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='p'">\n\t\t\t\t\t<genre authority="marcgt">periodical</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-21='w'">\n\t\t\t\t\t<genre authority="marcgt">web site</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='SE'">\n\t\t\t<xsl:variable name="controlField008-24" select="substring($controlField008,25,4)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'a')">\n\t\t\t\t\t<genre authority="marcgt">abstract or summary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'b')">\n\t\t\t\t\t<genre authority="marcgt">bibliography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'c')">\n\t\t\t\t\t<genre authority="marcgt">catalog</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'d')">\n\t\t\t\t\t<genre authority="marcgt">dictionary</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'e')">\n\t\t\t\t\t<genre authority="marcgt">encyclopedia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'f')">\n\t\t\t\t\t<genre authority="marcgt">handbook</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'g')">\n\t\t\t\t\t<genre authority="marcgt">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'i')">\n\t\t\t\t\t<genre authority="marcgt">index</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'k')">\n\t\t\t\t\t<genre authority="marcgt">discography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'l')">\n\t\t\t\t\t<genre authority="marcgt">legislation</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'m')">\n\t\t\t\t\t<genre authority="marcgt">theses</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'n')">\n\t\t\t\t\t<genre authority="marcgt">survey of literature</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'o')">\n\t\t\t\t\t<genre authority="marcgt">review</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'p')">\n\t\t\t\t\t<genre authority="marcgt">programmed text</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'q')">\n\t\t\t\t\t<genre authority="marcgt">filmography</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'r')">\n\t\t\t\t\t<genre authority="marcgt">directory</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'s')">\n\t\t\t\t\t<genre authority="marcgt">statistics</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'t')">\n\t\t\t\t\t<genre authority="marcgt">technical report</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'v')">\n\t\t\t\t\t<genre authority="marcgt">legal case and case notes</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'w')">\n\t\t\t\t\t<genre authority="marcgt">law report or digest</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($controlField008-24,'z')">\n\t\t\t\t\t<genre authority="marcgt">treaty</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-29='1'">\n\t\t\t\t\t<genre authority="marcgt">conference publication</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='CF'">\n\t\t\t<xsl:variable name="controlField008-26" select="substring($controlField008,27,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-26='a'">\n\t\t\t\t\t<genre authority="marcgt">numeric data</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='e'">\n\t\t\t\t\t<genre authority="marcgt">database</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='f'">\n\t\t\t\t\t<genre authority="marcgt">font</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-26='g'">\n\t\t\t\t\t<genre authority="marcgt">game</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='BK'">\n\t\t\t<xsl:if test="substring($controlField008,25,1)='j'">\n\t\t\t\t<genre authority="marcgt">patent</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="substring($controlField008,25,1)='2'">\n\t\t\t\t<genre authority="marcgt">offprint</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="substring($controlField008,31,1)='1'">\n\t\t\t\t<genre authority="marcgt">festschrift</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-34" select="substring($controlField008,35,1)"/>\n\t\t\t<xsl:if\n\t\t\t\ttest="$controlField008-34='a' or $controlField008-34='b' or $controlField008-34='c' or $controlField008-34='d'">\n\t\t\t\t<genre authority="marcgt">biography</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='e'">\n\t\t\t\t\t<genre authority="marcgt">essay</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marcgt">drama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marcgt">comic strip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marcgt">fiction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='h'">\n\t\t\t\t\t<genre authority="marcgt">humor, satire</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marcgt">letter</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marcgt">novel</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='j'">\n\t\t\t\t\t<genre authority="marcgt">short story</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marcgt">speech</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='MU'">\n\t\t\t<xsl:variable name="controlField008-30-31" select="substring($controlField008,31,2)"/>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'b')">\n\t\t\t\t<genre authority="marcgt">biography</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'c')">\n\t\t\t\t<genre authority="marcgt">conference publication</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'d')">\n\t\t\t\t<genre authority="marcgt">drama</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'e')">\n\t\t\t\t<genre authority="marcgt">essay</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'f')">\n\t\t\t\t<genre authority="marcgt">fiction</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'o')">\n\t\t\t\t<genre authority="marcgt">folktale</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'h')">\n\t\t\t\t<genre authority="marcgt">history</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'k')">\n\t\t\t\t<genre authority="marcgt">humor, satire</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'m')">\n\t\t\t\t<genre authority="marcgt">memoir</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'p')">\n\t\t\t\t<genre authority="marcgt">poetry</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'r')">\n\t\t\t\t<genre authority="marcgt">rehearsal</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'g')">\n\t\t\t\t<genre authority="marcgt">reporting</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'s')">\n\t\t\t\t<genre authority="marcgt">sound</genre>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="contains($controlField008-30-31,'l')">\n\t\t\t\t<genre authority="marcgt">speech</genre>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t\t<xsl:if test="$typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-33" select="substring($controlField008,34,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$controlField008-33='a'">\n\t\t\t\t\t<genre authority="marcgt">art original</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='b'">\n\t\t\t\t\t<genre authority="marcgt">kit</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='c'">\n\t\t\t\t\t<genre authority="marcgt">art reproduction</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='d'">\n\t\t\t\t\t<genre authority="marcgt">diorama</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='f'">\n\t\t\t\t\t<genre authority="marcgt">filmstrip</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='g'">\n\t\t\t\t\t<genre authority="marcgt">legal article</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='i'">\n\t\t\t\t\t<genre authority="marcgt">picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='k'">\n\t\t\t\t\t<genre authority="marcgt">graphic</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='l'">\n\t\t\t\t\t<genre authority="marcgt">technical drawing</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='m'">\n\t\t\t\t\t<genre authority="marcgt">motion picture</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='n'">\n\t\t\t\t\t<genre authority="marcgt">chart</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='o'">\n\t\t\t\t\t<genre authority="marcgt">flash card</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='p'">\n\t\t\t\t\t<genre authority="marcgt">microscope slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="$controlField008-33='q' or marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t\t<genre authority="marcgt">model</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='r'">\n\t\t\t\t\t<genre authority="marcgt">realia</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='s'">\n\t\t\t\t\t<genre authority="marcgt">slide</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='t'">\n\t\t\t\t\t<genre authority="marcgt">transparency</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='v'">\n\t\t\t\t\t<genre authority="marcgt">videorecording</genre>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-33='w'">\n\t\t\t\t\t<genre authority="marcgt">toy</genre>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\n\t\t<!-- 1.20 047 genre tmee-->\n\n\t\t<xsl:for-each select="marc:datafield[@tag=047]">\n\t\t\t<genre authority="marcgt">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcdef</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="delimeter">-</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</genre>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=655]">\n\t\t\t<genre authority="marcgt">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abvxyz</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="delimeter">-</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</genre>\n\t\t</xsl:for-each>\n\t\t<originInfo>\n\t\t\t<xsl:variable name="MARCpublicationCode"\n\t\t\t\tselect="normalize-space(substring($controlField008,16,3))"/>\n\t\t\t<xsl:if test="translate($MARCpublicationCode,'|','')">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">marccountry</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="$MARCpublicationCode"/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=044]/marc:subfield[@code='c']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t<xsl:attribute name="authority">iso3166</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=260]/marc:subfield[@code='a']">\n\t\t\t\t<place>\n\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t<xsl:attribute name="type">text</xsl:attribute>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</placeTerm>\n\t\t\t\t</place>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='m']">\n\t\t\t\t<dateValid point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='n']">\n\t\t\t\t<dateValid point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateValid>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=046]/marc:subfield[@code='j']">\n\t\t\t\t<dateModified>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateModified>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each\n\t\t\t\tselect="marc:datafield[@tag=260]/marc:subfield[@code='b' or @code='c' or @code='g']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@code='b'">\n\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</publisher>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='c'">\n\t\t\t\t\t\t<dateIssued>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</dateIssued>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="@code='g'">\n\t\t\t\t\t\t<dateCreated>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</dateCreated>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:variable name="dataField260c">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString"\n\t\t\t\t\t\tselect="marc:datafield[@tag=260]/marc:subfield[@code='c']"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:variable name="controlField008-7-10"\n\t\t\t\tselect="normalize-space(substring($controlField008, 8, 4))"/>\n\t\t\t<xsl:variable name="controlField008-11-14"\n\t\t\t\tselect="normalize-space(substring($controlField008, 12, 4))"/>\n\t\t\t<xsl:variable name="controlField008-6"\n\t\t\t\tselect="normalize-space(substring($controlField008, 7, 1))"/>\n\t\t\t<xsl:if\n\t\t\t\ttest="$controlField008-6='e' or $controlField008-6='p' or $controlField008-6='r' or $controlField008-6='t' or $controlField008-6='s'">\n\t\t\t\t<xsl:if test="$controlField008-7-10 and ($controlField008-7-10 != $dataField260c)">\n\t\t\t\t\t<dateIssued encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="$controlField008-6='c' or $controlField008-6='d' or $controlField008-6='i' or $controlField008-6='k' or $controlField008-6='m' or $controlField008-6='q' or $controlField008-6='u'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-7-10">\n\t\t\t\t\t<dateIssued encoding="marc" point="start" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-7-10"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='q'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<dateIssued encoding="marc" point="end" qualifier="questionable">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</dateIssued>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$controlField008-6='t'">\n\t\t\t\t<xsl:if test="$controlField008-11-14">\n\t\t\t\t\t<copyrightDate encoding="marc">\n\t\t\t\t\t\t<xsl:value-of select="$controlField008-11-14"/>\n\t\t\t\t\t</copyrightDate>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each\n\t\t\t\tselect="marc:datafield[@tag=033][@ind1=0 or @ind1=1]/marc:subfield[@code='a']">\n\t\t\t\t<dateCaptured encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][1]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="start">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=033][@ind1=2]/marc:subfield[@code='a'][2]">\n\t\t\t\t<dateCaptured encoding="iso8601" point="end">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</dateCaptured>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=250]/marc:subfield[@code='a']">\n\t\t\t\t<edition>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</edition>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:leader">\n\t\t\t\t<issuance>\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when\n\t\t\t\t\t\t\ttest="$leader7='a' or $leader7='c' or $leader7='d' or $leader7='m'"\n\t\t\t\t\t\t\t>monographic</xsl:when>\n\t\t\t\t\t\t<xsl:when test="$leader7='b' or $leader7='i' or $leader7='s'"\n\t\t\t\t\t\t>continuing</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</issuance>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=310]|marc:datafield[@tag=321]">\n\t\t\t\t<frequency>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</frequency>\n\t\t\t</xsl:for-each>\n\t\t</originInfo>\n\t\t<xsl:variable name="controlField008-35-37"\n\t\t\tselect="normalize-space(translate(substring($controlField008,36,3),'|#',''))"/>\n\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t<language>\n\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t<xsl:value-of select="substring($controlField008,36,3)"/>\n\t\t\t\t</languageTerm>\n\t\t\t</language>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=041]">\n\t\t\t<xsl:for-each\n\t\t\t\tselect="marc:subfield[@code='a' or @code='b' or @code='d' or @code='e' or @code='f' or @code='g' or @code='h']">\n\t\t\t\t<xsl:variable name="langCodes" select="."/>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="../marc:subfield[@code='2']='rfc3066'">\n\t\t\t\t\t\t<!-- not stacked but could be repeated -->\n\t\t\t\t\t\t<xsl:call-template name="rfcLanguages">\n\t\t\t\t\t\t\t<xsl:with-param name="nodeNum">\n\t\t\t\t\t\t\t\t<xsl:value-of select="1"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t\t<xsl:text/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="controlField008-35-37">\n\t\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<!-- iso -->\n\t\t\t\t\t\t<xsl:variable name="allLanguages">\n\t\t\t\t\t\t\t<xsl:copy-of select="$langCodes"/>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:variable name="currentLanguage">\n\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"/>\n\t\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t\t\t<xsl:value-of select="substring($allLanguages,1,3)"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\t\t\tselect="substring($allLanguages,4,string-length($allLanguages)-3)"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t\t\t<xsl:if test="$controlField008-35-37">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="$controlField008-35-37"/>\n\t\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t</xsl:for-each>\n\t\t<xsl:variable name="physicalDescription">\n\t\t\t<!--3.2 change tmee 007/11 -->\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='a']">\n\t\t\t\t<digitalOrigin>reformatted digital</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='b']">\n\t\t\t\t<digitalOrigin>digitized microfilm</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="$typeOf008='CF' and marc:controlfield[@tag=007][substring(.,12,1)='d']">\n\t\t\t\t<digitalOrigin>digitized other analog</digitalOrigin>\n\t\t\t</xsl:if>\n\t\t\t<xsl:variable name="controlField008-23" select="substring($controlField008,24,1)"/>\n\t\t\t<xsl:variable name="controlField008-29" select="substring($controlField008,30,1)"/>\n\t\t\t<xsl:variable name="check008-23">\n\t\t\t\t<xsl:if\n\t\t\t\t\ttest="$typeOf008='BK' or $typeOf008='MU' or $typeOf008='SE' or $typeOf008='MM'">\n\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:variable name="check008-29">\n\t\t\t\t<xsl:if test="$typeOf008='MP' or $typeOf008='VM'">\n\t\t\t\t\t<xsl:value-of select="true()"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:variable>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="($check008-23 and $controlField008-23='f') or ($check008-29 and $controlField008-29='f')">\n\t\t\t\t\t<form authority="marcform">braille</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="($controlField008-23=' ' and ($leader6='c' or $leader6='d')) or (($typeOf008='BK' or $typeOf008='SE') and ($controlField008-23=' ' or $controlField008='r'))">\n\t\t\t\t\t<form authority="marcform">print</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="$leader6 = 'm' or ($check008-23 and $controlField008-23='s') or ($check008-29 and $controlField008-29='s')">\n\t\t\t\t\t<form authority="marcform">electronic</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="($check008-23 and $controlField008-23='b') or ($check008-29 and $controlField008-29='b')">\n\t\t\t\t\t<form authority="marcform">microfiche</form>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="($check008-23 and $controlField008-23='a') or ($check008-29 and $controlField008-29='a')">\n\t\t\t\t\t<form authority="marcform">microfilm</form>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t\t<!-- 1/04 fix -->\n\t\t\t<xsl:if test="marc:datafield[@tag=130]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=130]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=240]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=240]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=242]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=242]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=245]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=245]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=246]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=246]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:datafield[@tag=730]/marc:subfield[@code='h']">\n\t\t\t\t<form authority="gmd">\n\t\t\t\t\t<xsl:call-template name="chopBrackets">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="marc:datafield[@tag=730]/marc:subfield[@code='h']"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=256]/marc:subfield[@code='a']">\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</form>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=007][substring(text(),1,1)='c']">\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='a'">\n\t\t\t\t\t\t<reformattingQuality>access</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='p'">\n\t\t\t\t\t\t<reformattingQuality>preservation</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:when test="substring(text(),14,1)='r'">\n\t\t\t\t\t\t<reformattingQuality>replacement</reformattingQuality>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t</xsl:choose>\n\t\t\t</xsl:for-each>\n\t\t\t<!--3.2 change tmee 007/01 -->\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">chip cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">computer optical disc cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">magnetic disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='m']">\n\t\t\t\t<form authority="smd">magneto-optical disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">optical disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">tape cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">tape cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='c'][substring(text(),2,1)='h']">\n\t\t\t\t<form authority="smd">tape reel</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">celestial globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">earth moon globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">planetary or lunar globe</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='d'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">terrestrial globe</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='o'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">kit</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">atlas</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">diagram</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">map</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">model</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='k']">\n\t\t\t\t<form authority="smd">profile</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote-sensing image</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">section</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='a'][substring(text(),2,1)='y']">\n\t\t\t\t<form authority="smd">view</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">aperture card</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">microfiche</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">microfiche cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">microfilm cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">microfilm cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">microfilm reel</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='h'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">microopaque</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">film cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">film cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='m'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">film reel</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='n']">\n\t\t\t\t<form authority="smd">chart</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">collage</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">drawing</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">flash card</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">painting</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">photomechanical print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">photonegative</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='h']">\n\t\t\t\t<form authority="smd">photoprint</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='i']">\n\t\t\t\t<form authority="smd">picture</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='j']">\n\t\t\t\t<form authority="smd">print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='k'][substring(text(),2,1)='l']">\n\t\t\t\t<form authority="smd">technical drawing</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='q'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">notated music</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">filmslip</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">filmstrip cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='o']">\n\t\t\t\t<form authority="smd">filmstrip roll</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">other filmstrip type</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">slide</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='g'][substring(text(),2,1)='t']">\n\t\t\t\t<form authority="smd">transparency</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='r'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">remote-sensing image</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='e']">\n\t\t\t\t<form authority="smd">cylinder</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='q']">\n\t\t\t\t<form authority="smd">roll</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='g']">\n\t\t\t\t<form authority="smd">sound cartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='s']">\n\t\t\t\t<form authority="smd">sound cassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">sound disc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='t']">\n\t\t\t\t<form authority="smd">sound-tape reel</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='i']">\n\t\t\t\t<form authority="smd">sound-track film</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='s'][substring(text(),2,1)='w']">\n\t\t\t\t<form authority="smd">wire recording</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">braille</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">combination</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">moon</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='f'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">tactile, with no writing system</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">braille</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='b']">\n\t\t\t\t<form authority="smd">large print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='a']">\n\t\t\t\t<form authority="smd">regular print</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='t'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">text in looseleaf binder</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='c']">\n\t\t\t\t<form authority="smd">videocartridge</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='f']">\n\t\t\t\t<form authority="smd">videocassette</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='d']">\n\t\t\t\t<form authority="smd">videodisc</form>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if\n\t\t\t\ttest="marc:controlfield[@tag=007][substring(text(),1,1)='v'][substring(text(),2,1)='r']">\n\t\t\t\t<form authority="smd">videoreel</form>\n\t\t\t</xsl:if>\n\n\t\t\t<xsl:for-each\n\t\t\t\tselect="marc:datafield[@tag=856]/marc:subfield[@code='q'][string-length(.)&gt;1]">\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</internetMediaType>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=300]">\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abce</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</extent>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($physicalDescription))">\n\t\t\t<physicalDescription>\n\t\t\t\t<xsl:copy-of select="$physicalDescription"/>\n\t\t\t</physicalDescription>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=520]">\n\t\t\t<abstract>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</abstract>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=505]">\n\t\t\t<tableOfContents>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">agrt</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</tableOfContents>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=521]">\n\t\t\t<targetAudience>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</targetAudience>\n\t\t</xsl:for-each>\n\t\t<xsl:if test="$typeOf008='BK' or $typeOf008='CF' or $typeOf008='MU' or $typeOf008='VM'">\n\t\t\t<xsl:variable name="controlField008-22" select="substring($controlField008,23,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<!-- 01/04 fix -->\n\t\t\t\t<xsl:when test="$controlField008-22='d'">\n\t\t\t\t\t<targetAudience authority="marctarget">adolescent</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='e'">\n\t\t\t\t\t<targetAudience authority="marctarget">adult</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='g'">\n\t\t\t\t\t<targetAudience authority="marctarget">general</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when\n\t\t\t\t\ttest="$controlField008-22='b' or $controlField008-22='c' or $controlField008-22='j'">\n\t\t\t\t\t<targetAudience authority="marctarget">juvenile</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='a'">\n\t\t\t\t\t<targetAudience authority="marctarget">preschool</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="$controlField008-22='f'">\n\t\t\t\t\t<targetAudience authority="marctarget">specialized</targetAudience>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:if>\n\t\t<xsl:for-each select="marc:datafield[@tag=245]/marc:subfield[@code='c']">\n\t\t\t<note type="statement of responsibility">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=500]">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<!--3.2 change tmee additional note fields-->\n\n\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t<note type="restrictions">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=510]">\n\t\t\t<note type="citation/reference">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\n\t\t<xsl:for-each select="marc:datafield[@tag=511]">\n\t\t\t<note type="performers">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=518]">\n\t\t\t<note type="venue">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=530]">\n\t\t\t<note type="additional physical form">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=533]">\n\t\t\t<note type="reproduction">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t<note type="original version">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=538]">\n\t\t\t<note type="system details">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=583]">\n\t\t\t<note type="action">\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each\n\t\t\tselect="marc:datafield[@tag=501 or @tag=502 or @tag=504 or @tag=507 or @tag=508 or  @tag=513 or @tag=514 or @tag=515 or @tag=516 or @tag=522 or @tag=524 or @tag=525 or @tag=526 or @tag=535 or @tag=536 or @tag=540 or @tag=541 or @tag=544 or @tag=545 or @tag=546 or @tag=547 or @tag=550 or @tag=552 or @tag=555 or @tag=556 or @tag=561 or @tag=562 or @tag=565 or @tag=567 or @tag=580 or @tag=581 or @tag=584 or @tag=585 or @tag=586]">\n\t\t\t<note>\n\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t<xsl:variable name="str">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code!='6' or @code!='8']">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:variable>\n\t\t\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each\n\t\t\tselect="marc:datafield[@tag=034][marc:subfield[@code='d' or @code='e' or @code='f' or @code='g']]">\n\t\t\t<subject>\n\t\t\t\t<cartographics>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">defg</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</coordinates>\n\t\t\t\t</cartographics>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=043]">\n\t\t\t<subject>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='c']">\n\t\t\t\t\t<geographicCode>\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:if test="@code='a'">\n\t\t\t\t\t\t\t\t<xsl:text>marcgac</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='b'">\n\t\t\t\t\t\t\t\t<xsl:value-of select="following-sibling::marc:subfield[@code=2]"/>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t\t<xsl:if test="@code='c'">\n\t\t\t\t\t\t\t\t<xsl:text>iso3166</xsl:text>\n\t\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t<xsl:value-of select="self::marc:subfield"/>\n\t\t\t\t\t</geographicCode>\n\t\t\t\t</xsl:for-each>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<!-- tmee 2006/11/27 -->\n\t\t<xsl:for-each select="marc:datafield[@tag=255]">\n\t\t\t<subject>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a' or @code='b' or @code='c']">\n\t\t\t\t\t<cartographics>\n\t\t\t\t\t\t<xsl:if test="@code='a'">\n\t\t\t\t\t\t\t<scale>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</scale>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:if test="@code='b'">\n\t\t\t\t\t\t\t<projection>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</projection>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:if test="@code='c'">\n\t\t\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</coordinates>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t</cartographics>\n\t\t\t\t</xsl:for-each>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\n\t\t<xsl:apply-templates select="marc:datafield[653 &gt;= @tag and @tag &gt;= 600]"/>\n\t\t<xsl:apply-templates select="marc:datafield[@tag=656]"/>\n\t\t<xsl:for-each select="marc:datafield[@tag=752 or @tag=662]">\n\t\t\t<subject>\n\t\t\t\t<hierarchicalGeographic>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<country>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</country>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<state>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</state>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t<county>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</county>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t\t<city>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</city>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t\t\t\t<citySection>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</citySection>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='g']">\n\t\t\t\t\t\t<region>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</region>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t\t\t\t<extraterrestrialArea>\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</extraterrestrialArea>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</hierarchicalGeographic>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=045][marc:subfield[@code='b']]">\n\t\t\t<subject>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when test="@ind1=2">\n\t\t\t\t\t\t<temporal encoding="iso8601" point="start">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][1]"/>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t<temporal encoding="iso8601" point="end">\n\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b'][2]"/>\n\t\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</temporal>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</temporal>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=050]">\n\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:if test="../marc:subfield[@code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:subfield[@code='3']"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="preceding-sibling::marc:subfield[@code='a'][1]"/>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each\n\t\t\t\tselect="marc:subfield[@code='a'][not(following-sibling::marc:subfield[@code='b'])]">\n\t\t\t\t<classification authority="lcc">\n\t\t\t\t\t<xsl:if test="../marc:subfield[@code='3']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:subfield[@code='3']"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t</classification>\n\t\t\t</xsl:for-each>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=082]">\n\t\t\t<classification authority="ddc">\n\t\t\t\t<xsl:if test="marc:subfield[@code='2']">\n\t\t\t\t\t<xsl:attribute name="edition">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t</xsl:attribute>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=080]">\n\t\t\t<classification authority="udc">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abx</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=060]">\n\t\t\t<classification authority="nlm">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=0]">\n\t\t\t<classification authority="sudocs">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086][@ind1=1]">\n\t\t\t<classification authority="candoc">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=086]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=084]">\n\t\t\t<classification>\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</classification>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=440]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=490][@ind1=0]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">av</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=510]">\n\t\t\t<relatedItem type="isReferencedBy">\n\t\t\t\t<note>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcx3</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</note>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=534]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedTitle"/>\n\t\t\t\t<xsl:call-template name="relatedName"/>\n\t\t\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t\t\t<originInfo>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t\t\t\t\t<publisher>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</publisher>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t\t<edition>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</edition>\n\t\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t</originInfo>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='z']">\n\t\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</identifier>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:call-template name="relatedNote"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=700][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=710][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:variable name="tempNamePart">\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:if test="normalize-space($tempNamePart)">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="$tempNamePart"/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=711][marc:subfield[@code='t']]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=730][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=740][@ind2=2]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="constituentOrRelatedType"/>\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=760]|marc:datafield[@tag=762]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each\n\t\t\tselect="marc:datafield[@tag=765]|marc:datafield[@tag=767]|marc:datafield[@tag=777]|marc:datafield[@tag=787]">\n\t\t\t<relatedItem>\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=775]">\n\t\t\t<relatedItem type="otherVersion">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=770]|marc:datafield[@tag=774]">\n\t\t\t<relatedItem type="constituent">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=772]|marc:datafield[@tag=773]">\n\t\t\t<relatedItem type="host">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=776]">\n\t\t\t<relatedItem type="otherFormat">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=780]">\n\t\t\t<relatedItem type="preceding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=785]">\n\t\t\t<relatedItem type="succeeding">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=786]">\n\t\t\t<relatedItem type="original">\n\t\t\t\t<xsl:call-template name="relatedItem76X-78X"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=800]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="personal">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aq</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=810]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">dg</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="corporate">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t\t<namePart>\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</namePart>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">c</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">dgn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=811]">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">tfklsv</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="afterCodes">g</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<name type="conference">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="anyCodes">aqdc</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="axis">t</xsl:with-param>\n\t\t\t\t\t\t\t<xsl:with-param name="beforeCodes">gn</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t\t</name>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='830']">\n\t\t\t<relatedItem type="series">\n\t\t\t\t<titleInfo>\n\t\t\t\t\t<title>\n\t\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfgklmorsv</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</title>\n\t\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t\t</titleInfo>\n\t\t\t\t<xsl:call-template name="relatedForm"/>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='856'][@ind2='2']/marc:subfield[@code='q']">\n\t\t\t<relatedItem>\n\t\t\t\t<internetMediaType>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</internetMediaType>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='020']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">isbn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="isbn">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='0']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">isrc</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="isrc">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='2']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">ismn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<identifier type="ismn">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='024'][@ind1='4']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">sici</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<identifier type="sici">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='022']">\n\t\t\t<xsl:if test="marc:subfield[@code='a']">\n\t\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t\t<xsl:with-param name="type">issn</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t\t<identifier type="issn">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t\t<xsl:if test="marc:subfield[@code='l']">\n\t\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t\t<xsl:with-param name="type">issn-l</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t\t<identifier type="issn-l">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='l']"/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\n\n\n\t\t<xsl:for-each select="marc:datafield[@tag='010']">\n\t\t\t<xsl:call-template name="isInvalid">\n\t\t\t\t<xsl:with-param name="type">lccn</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t\t<identifier type="lccn">\n\t\t\t\t<xsl:value-of select="normalize-space(marc:subfield[@code='a'])"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='028']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when test="@ind1='0'">issue number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='1'">matrix number</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='2'">music plate</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='3'">music publisher</xsl:when>\n\t\t\t\t\t\t<xsl:when test="@ind1='4'">videorecording identifier</xsl:when>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<!--<xsl:call-template name="isInvalid"/>-->\n\t\t\t\t<!-- no $z in 028 -->\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="@ind1='0'">ba</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>ab</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='037']">\n\t\t\t<identifier type="stock number">\n\t\t\t\t<!--<xsl:call-template name="isInvalid"/>-->\n\t\t\t\t<!-- no $z in 037 -->\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">ab</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag='856'][marc:subfield[@code='u']]">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t<xsl:when\n\t\t\t\t\t\t\ttest="starts-with(marc:subfield[@code='u'],'urn:doi') or starts-with(marc:subfield[@code='u'],'doi')"\n\t\t\t\t\t\t\t>doi</xsl:when>\n\t\t\t\t\t\t<xsl:when\n\t\t\t\t\t\t\ttest="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov')"\n\t\t\t\t\t\t\t>hdl</xsl:when>\n\t\t\t\t\t\t<xsl:otherwise>uri</xsl:otherwise>\n\t\t\t\t\t</xsl:choose>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:choose>\n\t\t\t\t\t<xsl:when\n\t\t\t\t\t\ttest="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl') or starts-with(marc:subfield[@code='u'],'http://hdl.loc.gov') ">\n\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\tselect="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</xsl:when>\n\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t</xsl:choose>\n\t\t\t</identifier>\n\t\t\t<xsl:if\n\t\t\t\ttest="starts-with(marc:subfield[@code='u'],'urn:hdl') or starts-with(marc:subfield[@code='u'],'hdl')">\n\t\t\t\t<identifier type="hdl">\n\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3' or @code='z']">\n\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3z</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\tselect="concat('hdl:',substring-after(marc:subfield[@code='u'],'http://hdl.loc.gov/'))"\n\t\t\t\t\t/>\n\t\t\t\t</identifier>\n\t\t\t</xsl:if>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=024][@ind1=1]">\n\t\t\t<identifier type="upc">\n\t\t\t\t<xsl:call-template name="isInvalid"/>\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\n\t\t<!-- 1/04 fix added $y -->\n\n\t\t<!-- 1.21  tmee-->\n\t\t<xsl:for-each select="marc:datafield[@tag=856][@ind2=1][marc:subfield[@code='u']]">\n\t\t\t<relatedItem type="otherVersion">\n\t\t\t\t<location>\n\t\t\t\t\t<url>\n\t\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3']">\n\t\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:if test="marc:subfield[@code='z' ]">\n\t\t\t\t\t\t\t<xsl:attribute name="note">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">z</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t\t</url>\n\t\t\t\t</location>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=856][@ind2=2][marc:subfield[@code='u']]">\n\t\t\t<relatedItem>\n\t\t\t\t<location>\n\t\t\t\t\t<url>\n\t\t\t\t\t\t<xsl:if test="marc:subfield[@code='y' or @code='3']">\n\t\t\t\t\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">y3</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:if test="marc:subfield[@code='z' ]">\n\t\t\t\t\t\t\t<xsl:attribute name="note">\n\t\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t\t<xsl:with-param name="codes">z</xsl:with-param>\n\t\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='u']"/>\n\t\t\t\t\t</url>\n\t\t\t\t</location>\n\t\t\t</relatedItem>\n\t\t</xsl:for-each>\n\n\t\t<!-- 3.2 change tmee 856z  -->\n\n\t\t<!-- 1.24  tmee  -->\n\t\t<xsl:for-each select="marc:datafield[@tag=852]">\n\t\t\t<location>\n\t\t\t\t<xsl:if test="marc:subfield[@code='a' or @code='b' or @code='e']">\n\t\t\t\t\t<physicalLocation>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abe</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</physicalLocation>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:if test="marc:subfield[@code='u']">\n\t\t\t\t\t<physicalLocation>\n\t\t\t\t\t\t<xsl:call-template name="uri"/>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">u</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</physicalLocation>\n\t\t\t\t</xsl:if>\n\n\t\t\t\t<xsl:if\n\t\t\t\t\ttest="marc:subfield[@code='h' or @code='i' or @code='j' or @code='k' or @code='l' or @code='m' or @code='t']">\n\t\t\t\t\t<shelfLocation>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">hijklmt</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</shelfLocation>\n\t\t\t\t</xsl:if>\n\t\t\t</location>\n\t\t</xsl:for-each>\n\n\t\t<xsl:for-each select="marc:datafield[@tag=506]">\n\t\t\t<accessCondition type="restrictionOnAccess">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcd35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:datafield[@tag=540]">\n\t\t\t<accessCondition type="useAndReproduction">\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">abcde35</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</accessCondition>\n\t\t</xsl:for-each>\n\n\t\t<recordInfo>\n\t\t\t<!-- 1.25  tmee-->\n\n\n\t\t\t<xsl:for-each select="marc:leader[substring($leader,19,1)='a']">\n\t\t\t\t<descriptionStandard>aacr2</descriptionStandard>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]">\n\t\t\t\t<xsl:if test="marc:subfield[@code='e']">\n\t\t\t\t\t<descriptionStandard>\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='e']"/>\n\t\t\t\t\t</descriptionStandard>\n\t\t\t\t</xsl:if>\n\t\t\t\t<recordContentSource authority="marcorg">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t</recordContentSource>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=008]">\n\t\t\t\t<recordCreationDate encoding="marc">\n\t\t\t\t\t<xsl:value-of select="substring(.,1,6)"/>\n\t\t\t\t</recordCreationDate>\n\t\t\t</xsl:for-each>\n\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=005]">\n\t\t\t\t<recordChangeDate encoding="iso8601">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</recordChangeDate>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:controlfield[@tag=001]">\n\t\t\t\t<recordIdentifier>\n\t\t\t\t\t<xsl:if test="../marc:controlfield[@tag=003]">\n\t\t\t\t\t\t<xsl:attribute name="source">\n\t\t\t\t\t\t\t<xsl:value-of select="../marc:controlfield[@tag=003]"/>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</recordIdentifier>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:datafield[@tag=040]/marc:subfield[@code='b']">\n\t\t\t\t<languageOfCataloging>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</languageOfCataloging>\n\t\t\t</xsl:for-each>\n\t\t</recordInfo>\n\t</xsl:template>\n\t<xsl:template name="displayForm">\n\t\t<xsl:for-each select="marc:subfield[@code='c']">\n\t\t\t<displayForm>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</displayForm>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="affiliation">\n\t\t<xsl:for-each select="marc:subfield[@code='u']">\n\t\t\t<affiliation>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</affiliation>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="uri">\n\t\t<xsl:for-each select="marc:subfield[@code='u']|marc:subfield[@code='0']">\n\t\t\t<xsl:attribute name="xlink:href">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="role">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<role>\n\t\t\t\t<roleTerm type="text">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t<role>\n\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</roleTerm>\n\t\t\t</role>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="part">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">n</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partNumber"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="$partName"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedPart">\n\t\t<xsl:if test="@tag=773">\n\t\t\t<xsl:for-each select="marc:subfield[@code='g']">\n\t\t\t\t<part>\n\t\t\t\t\t<text>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</text>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:for-each select="marc:subfield[@code='q']">\n\t\t\t\t<part>\n\t\t\t\t\t<xsl:call-template name="parsePart"/>\n\t\t\t\t</part>\n\t\t\t</xsl:for-each>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedPartNumName">\n\t\t<xsl:variable name="partNumber">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">g</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">pst</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="partName">\n\t\t\t<xsl:call-template name="specialSubfieldSelect">\n\t\t\t\t<xsl:with-param name="axis">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="anyCodes">p</xsl:with-param>\n\t\t\t\t<xsl:with-param name="afterCodes">fgkdlmor</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="string-length(normalize-space($partNumber))">\n\t\t\t<partNumber>\n\t\t\t\t<xsl:value-of select="$partNumber"/>\n\t\t\t</partNumber>\n\t\t</xsl:if>\n\t\t<xsl:if test="string-length(normalize-space($partName))">\n\t\t\t<partName>\n\t\t\t\t<xsl:value-of select="$partName"/>\n\t\t\t</partName>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedName">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<name>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</namePart>\n\t\t\t</name>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedForm">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<form>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</form>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedExtent">\n\t\t<xsl:for-each select="marc:subfield[@code='h']">\n\t\t\t<physicalDescription>\n\t\t\t\t<extent>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</extent>\n\t\t\t</physicalDescription>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedNote">\n\t\t<xsl:for-each select="marc:subfield[@code='n']">\n\t\t\t<note>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</note>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedSubject">\n\t\t<xsl:for-each select="marc:subfield[@code='j']">\n\t\t\t<subject>\n\t\t\t\t<temporal encoding="iso8601">\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</temporal>\n\t\t\t</subject>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifierISSN">\n\t\t<xsl:for-each select="marc:subfield[@code='x']">\n\t\t\t<identifier type="issn">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifierLocal">\n\t\t<xsl:for-each select="marc:subfield[@code='w']">\n\t\t\t<identifier type="local">\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedIdentifier">\n\t\t<xsl:for-each select="marc:subfield[@code='o']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</identifier>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedItem76X-78X">\n\t\t<xsl:call-template name="displayLabel"/>\n\t\t<xsl:call-template name="relatedTitle76X-78X"/>\n\t\t<xsl:call-template name="relatedName"/>\n\t\t<xsl:call-template name="relatedOriginInfo"/>\n\t\t<xsl:call-template name="relatedLanguage"/>\n\t\t<xsl:call-template name="relatedExtent"/>\n\t\t<xsl:call-template name="relatedNote"/>\n\t\t<xsl:call-template name="relatedSubject"/>\n\t\t<xsl:call-template name="relatedIdentifier"/>\n\t\t<xsl:call-template name="relatedIdentifierISSN"/>\n\t\t<xsl:call-template name="relatedIdentifierLocal"/>\n\t\t<xsl:call-template name="relatedPart"/>\n\t</xsl:template>\n\t<xsl:template name="subjectGeographicZ">\n\t\t<geographic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</geographic>\n\t</xsl:template>\n\t<xsl:template name="subjectTemporalY">\n\t\t<temporal>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</temporal>\n\t</xsl:template>\n\t<xsl:template name="subjectTopic">\n\t\t<topic>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</topic>\n\t</xsl:template>\n\t<!-- 3.2 change tmee 6xx $v genre -->\n\t<xsl:template name="subjectGenre">\n\t\t<genre>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t</xsl:call-template>\n\t\t</genre>\n\t</xsl:template>\n\n\t<xsl:template name="nameABCDN">\n\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:value-of select="."/>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t\t<xsl:if\n\t\t\ttest="marc:subfield[@code='c'] or marc:subfield[@code='d'] or marc:subfield[@code='n']">\n\t\t\t<namePart>\n\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t<xsl:with-param name="codes">cdn</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="nameABCDQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</xsl:with-param>\n\t\t\t\t<xsl:with-param name="punctuation">\n\t\t\t\t\t<xsl:text>:,;/ </xsl:text>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t<xsl:call-template name="nameDate"/>\n\t</xsl:template>\n\t<xsl:template name="nameACDEQ">\n\t\t<namePart>\n\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t<xsl:with-param name="codes">acdeq</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</namePart>\n\t</xsl:template>\n\t<xsl:template name="constituentOrRelatedType">\n\t\t<xsl:if test="@ind2=2">\n\t\t\t<xsl:attribute name="type">constituent</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedTitle">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedTitle76X-78X">\n\t\t<xsl:for-each select="marc:subfield[@code='t']">\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='p']">\n\t\t\t<titleInfo type="abbreviated">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t\t<xsl:for-each select="marc:subfield[@code='s']">\n\t\t\t<titleInfo type="uniform">\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:if test="marc:datafield[@tag!=773]and marc:subfield[@code='g']">\n\t\t\t\t\t<xsl:call-template name="relatedPartNumName"/>\n\t\t\t\t</xsl:if>\n\t\t\t</titleInfo>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="relatedOriginInfo">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='d'] or marc:subfield[@code='f']">\n\t\t\t<originInfo>\n\t\t\t\t<xsl:if test="@tag=775">\n\t\t\t\t\t<xsl:for-each select="marc:subfield[@code='f']">\n\t\t\t\t\t\t<place>\n\t\t\t\t\t\t\t<placeTerm>\n\t\t\t\t\t\t\t\t<xsl:attribute name="type">code</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:attribute name="authority">marcgac</xsl:attribute>\n\t\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t\t</placeTerm>\n\t\t\t\t\t\t</place>\n\t\t\t\t\t</xsl:for-each>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t\t\t<publisher>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</publisher>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<edition>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</edition>\n\t\t\t\t</xsl:for-each>\n\t\t\t</originInfo>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="relatedLanguage">\n\t\t<xsl:for-each select="marc:subfield[@code='e']">\n\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t<xsl:with-param name="langString">\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</xsl:with-param>\n\t\t\t</xsl:call-template>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="nameDate">\n\t\t<xsl:for-each select="marc:subfield[@code='d']">\n\t\t\t<namePart type="date">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="subjectAuthority">\n\t\t<xsl:if test="@ind2!=4">\n\t\t\t<xsl:if test="@ind2!=' '">\n\t\t\t\t<xsl:if test="@ind2!=8">\n\t\t\t\t\t<xsl:if test="@ind2!=9">\n\t\t\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=0">lcsh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=1">lcshac</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=2">mesh</xsl:when>\n\t\t\t\t\t\t\t\t<!-- 1/04 fix -->\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=3">nal</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=5">csh</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=6">rvm</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@ind2=7">\n\t\t\t\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='2']"/>\n\t\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="subjectAnyOrder">\n\t\t<xsl:for-each select="marc:subfield[@code='v' or @code='x' or @code='y' or @code='z']">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="@code='v'">\n\t\t\t\t\t<xsl:call-template name="subjectGenre"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='x'">\n\t\t\t\t\t<xsl:call-template name="subjectTopic"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='y'">\n\t\t\t\t\t<xsl:call-template name="subjectTemporalY"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="@code='z'">\n\t\t\t\t\t<xsl:call-template name="subjectGeographicZ"/>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:for-each>\n\t</xsl:template>\n\t<xsl:template name="specialSubfieldSelect">\n\t\t<xsl:param name="anyCodes"/>\n\t\t<xsl:param name="axis"/>\n\t\t<xsl:param name="beforeCodes"/>\n\t\t<xsl:param name="afterCodes"/>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if\n\t\t\t\t\ttest="contains($anyCodes, @code)      or (contains($beforeCodes,@code) and following-sibling::marc:subfield[@code=$axis])      or (contains($afterCodes,@code) and preceding-sibling::marc:subfield[@code=$axis])">\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t<xsl:text> </xsl:text>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-1)"/>\n\t</xsl:template>\n\n\t<!-- 3.2 change tmee 6xx $v genre -->\n\t<xsl:template match="marc:datafield[@tag=600]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="personal">\n\t\t\t\t<xsl:call-template name="termsOfAddress"/>\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">aq</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:call-template name="nameDate"/>\n\t\t\t\t<xsl:call-template name="affiliation"/>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=610]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="corporate">\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='b']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:for-each>\n\t\t\t\t<xsl:if test="marc:subfield[@code='c' or @code='d' or @code='n' or @code='p']">\n\t\t\t\t\t<namePart>\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">cdnp</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</namePart>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:call-template name="role"/>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=611]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<name type="conference">\n\t\t\t\t<namePart>\n\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t<xsl:with-param name="codes">abcdeqnp</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</namePart>\n\t\t\t\t<xsl:for-each select="marc:subfield[@code='4']">\n\t\t\t\t\t<role>\n\t\t\t\t\t\t<roleTerm authority="marcrelator" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t\t\t</roleTerm>\n\t\t\t\t\t</role>\n\t\t\t\t</xsl:for-each>\n\t\t\t</name>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=630]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<titleInfo>\n\t\t\t\t<title>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t\t<xsl:with-param name="codes">adfhklor</xsl:with-param>\n\t\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</title>\n\t\t\t\t<xsl:call-template name="part"/>\n\t\t\t</titleInfo>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<!-- 1.27 648 tmee-->\n\t<xsl:template match="marc:datafield[@tag=648]">\n\t\t<subject>\n\t\t\t<xsl:if test="marc:subfield[@code=2]">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code=2]"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<xsl:call-template name="uri"/>\n\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<temporal>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abcd</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</temporal>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=650]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<topic>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">abcd</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</topic>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=651]">\n\t\t<subject>\n\t\t\t<xsl:call-template name="subjectAuthority"/>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<geographic>\n\t\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t\t<xsl:with-param name="chopString" select="."/>\n\t\t\t\t\t</xsl:call-template>\n\t\t\t\t</geographic>\n\t\t\t</xsl:for-each>\n\t\t\t<xsl:call-template name="subjectAnyOrder"/>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=653]">\n\t\t<subject>\n\t\t\t<xsl:for-each select="marc:subfield[@code='a']">\n\t\t\t\t<topic>\n\t\t\t\t\t<xsl:value-of select="."/>\n\t\t\t\t</topic>\n\t\t\t</xsl:for-each>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template match="marc:datafield[@tag=656]">\n\t\t<subject>\n\t\t\t<xsl:if test="marc:subfield[@code=2]">\n\t\t\t\t<xsl:attribute name="authority">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code=2]"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t</xsl:if>\n\t\t\t<occupation>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='a']"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</occupation>\n\t\t</subject>\n\t</xsl:template>\n\t<xsl:template name="termsOfAddress">\n\t\t<xsl:if test="marc:subfield[@code='b' or @code='c']">\n\t\t\t<namePart type="termsOfAddress">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">bc</xsl:with-param>\n\t\t\t\t\t\t</xsl:call-template>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</namePart>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="displayLabel">\n\t\t<xsl:if test="marc:subfield[@code='i']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='i']"/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t\t<xsl:if test="marc:subfield[@code='3']">\n\t\t\t<xsl:attribute name="displayLabel">\n\t\t\t\t<xsl:value-of select="marc:subfield[@code='3']"/>\n\t\t\t</xsl:attribute>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="isInvalid">\n\t\t<xsl:param name="type"/>\n\t\t<xsl:if\n\t\t\ttest="marc:subfield[@code='z'] or marc:subfield[@code='y']  or marc:subfield[@code='m']">\n\t\t\t<identifier>\n\t\t\t\t<xsl:attribute name="type">\n\t\t\t\t\t<xsl:value-of select="$type"/>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:attribute name="invalid">\n\t\t\t\t\t<xsl:text>yes</xsl:text>\n\t\t\t\t</xsl:attribute>\n\t\t\t\t<xsl:if test="marc:subfield[@code='z']">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='z']"/>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="marc:subfield[@code='y']">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='y']"/>\n\t\t\t\t</xsl:if>\n\t\t\t\t<xsl:if test="marc:subfield[@code='m']">\n\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='m']"/>\n\t\t\t\t</xsl:if>\n\t\t\t</identifier>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="subtitle">\n\t\t<xsl:if test="marc:subfield[@code='b']">\n\t\t\t<subTitle>\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString">\n\t\t\t\t\t\t<xsl:value-of select="marc:subfield[@code='b']"/>\n\t\t\t\t\t\t<!--<xsl:call-template name="subfieldSelect">\n\t\t\t\t\t\t\t<xsl:with-param name="codes">b</xsl:with-param>\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</xsl:call-template>-->\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</subTitle>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="script">\n\t\t<xsl:param name="scriptCode"/>\n\t\t<xsl:attribute name="script">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="$scriptCode='(3'">Arabic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(B'">Latin</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='$1'">Chinese, Japanese, Korean</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(N'">Cyrillic</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(2'">Hebrew</xsl:when>\n\t\t\t\t<xsl:when test="$scriptCode='(S'">Greek</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:attribute>\n\t</xsl:template>\n\t<xsl:template name="parsePart">\n\t\t<!-- assumes 773$q= 1:2:3<4\n\t\t     with up to 3 levels and one optional start page\n\t\t-->\n\t\t<xsl:variable name="level1">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains(text(),':')">\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t\t<xsl:value-of select="substring-before(text(),':')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="not(contains(text(),':'))">\n\t\t\t\t\t<!-- 1 or 1<3 -->\n\t\t\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t\t\t<!-- 1<3 -->\n\t\t\t\t\t\t<xsl:value-of select="substring-before(text(),'&lt;')"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<xsl:if test="not(contains(text(),'&lt;'))">\n\t\t\t\t\t\t<!-- 1 -->\n\t\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t</xsl:when>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after(text(),$level1),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after(text(),$level1),2)"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after(text(),$level1)"/>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level2">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici2,':')">\n\t\t\t\t\t<!--  2:3<4  -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,':')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:when test="contains($sici2,'&lt;')">\n\t\t\t\t\t<!-- 1: 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici2,'&lt;')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici2"/>\n\t\t\t\t\t<!-- 1:2 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="sici3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="starts-with(substring-after($sici2,$level2),':')">\n\t\t\t\t\t<xsl:value-of select="substring(substring-after($sici2,$level2),2)"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="substring-after($sici2,$level2)"/>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="level3">\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($sici3,'&lt;')">\n\t\t\t\t\t<!-- 2<4 -->\n\t\t\t\t\t<xsl:value-of select="substring-before($sici3,'&lt;')"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:value-of select="$sici3"/>\n\t\t\t\t\t<!-- 3 -->\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t</xsl:variable>\n\t\t<xsl:variable name="page">\n\t\t\t<xsl:if test="contains(text(),'&lt;')">\n\t\t\t\t<xsl:value-of select="substring-after(text(),'&lt;')"/>\n\t\t\t</xsl:if>\n\t\t</xsl:variable>\n\t\t<xsl:if test="$level1">\n\t\t\t<detail level="1">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level1"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level2">\n\t\t\t<detail level="2">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level2"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$level3">\n\t\t\t<detail level="3">\n\t\t\t\t<number>\n\t\t\t\t\t<xsl:value-of select="$level3"/>\n\t\t\t\t</number>\n\t\t\t</detail>\n\t\t</xsl:if>\n\t\t<xsl:if test="$page">\n\t\t\t<extent unit="page">\n\t\t\t\t<start>\n\t\t\t\t\t<xsl:value-of select="$page"/>\n\t\t\t\t</start>\n\t\t\t</extent>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="getLanguage">\n\t\t<xsl:param name="langString"/>\n\t\t<xsl:param name="controlField008-35-37"/>\n\t\t<xsl:variable name="length" select="string-length($langString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="$controlField008-35-37=substring($langString,1,3)">\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"/>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<language>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="substring($langString,1,3)"/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="getLanguage">\n\t\t\t\t\t<xsl:with-param name="langString" select="substring($langString,4,$length)"/>\n\t\t\t\t\t<xsl:with-param name="controlField008-35-37" select="$controlField008-35-37"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="isoLanguage">\n\t\t<xsl:param name="currentLanguage"/>\n\t\t<xsl:param name="usedLanguages"/>\n\t\t<xsl:param name="remainingLanguages"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="string-length($currentLanguage)=0"/>\n\t\t\t<xsl:when test="not(contains($usedLanguages, $currentLanguage))">\n\t\t\t\t<language>\n\t\t\t\t\t<xsl:if test="@code!='a'">\n\t\t\t\t\t\t<xsl:attribute name="objectPart">\n\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='b'">summary or subtitle</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='d'">sung or spoken text</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='e'">libretto</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='f'">table of contents</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='g'">accompanying material</xsl:when>\n\t\t\t\t\t\t\t\t<xsl:when test="@code='h'">translation</xsl:when>\n\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t</xsl:if>\n\t\t\t\t\t<languageTerm authority="iso639-2b" type="code">\n\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"/>\n\t\t\t\t\t</languageTerm>\n\t\t\t\t</language>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\tselect="substring($remainingLanguages,4,string-length($remainingLanguages))"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:call-template name="isoLanguage">\n\t\t\t\t\t<xsl:with-param name="currentLanguage">\n\t\t\t\t\t\t<xsl:value-of select="substring($remainingLanguages,1,3)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="usedLanguages">\n\t\t\t\t\t\t<xsl:value-of select="concat($usedLanguages,$currentLanguage)"/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t\t<xsl:with-param name="remainingLanguages">\n\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\tselect="substring($remainingLanguages,4,string-length($remainingLanguages))"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</xsl:with-param>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\t<xsl:template name="chopBrackets">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="string">\n\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t<xsl:with-param name="chopString" select="$chopString"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:variable>\n\t\t<xsl:if test="substring($string, 1,1)='['">\n\t\t\t<xsl:value-of select="substring($string,2, string-length($string)-2)"/>\n\t\t</xsl:if>\n\t\t<xsl:if test="substring($string, 1,1)!='['">\n\t\t\t<xsl:value-of select="$string"/>\n\t\t</xsl:if>\n\t</xsl:template>\n\t<xsl:template name="rfcLanguages">\n\t\t<xsl:param name="nodeNum"/>\n\t\t<xsl:param name="usedLanguages"/>\n\t\t<xsl:param name="controlField008-35-37"/>\n\t\t<xsl:variable name="currentLanguage" select="."/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="not($currentLanguage)"/>\n\t\t\t<xsl:when\n\t\t\t\ttest="$currentLanguage!=$controlField008-35-37 and $currentLanguage!='rfc3066'">\n\t\t\t\t<xsl:if test="not(contains($usedLanguages,$currentLanguage))">\n\t\t\t\t\t<language>\n\t\t\t\t\t\t<xsl:if test="@code!='a'">\n\t\t\t\t\t\t\t<xsl:attribute name="objectPart">\n\t\t\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='b'">summary or subtitle</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='d'">sung or spoken text</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='e'">libretto</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='f'">table of contents</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='g'">accompanying material</xsl:when>\n\t\t\t\t\t\t\t\t\t<xsl:when test="@code='h'">translation</xsl:when>\n\t\t\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t\t\t</xsl:attribute>\n\t\t\t\t\t\t</xsl:if>\n\t\t\t\t\t\t<languageTerm authority="rfc3066" type="code">\n\t\t\t\t\t\t\t<xsl:value-of select="$currentLanguage"/>\n\t\t\t\t\t\t</languageTerm>\n\t\t\t\t\t</language>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:when>\n\t\t\t<xsl:otherwise> </xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n    <xsl:template name="datafield">\n\t\t<xsl:param name="tag"/>\n\t\t<xsl:param name="ind1">\n\t\t\t<xsl:text> </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:param name="ind2">\n\t\t\t<xsl:text> </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:param name="subfields"/>\n\t\t<xsl:element name="marc:datafield">\n\t\t\t<xsl:attribute name="tag">\n\t\t\t\t<xsl:value-of select="$tag"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind1">\n\t\t\t\t<xsl:value-of select="$ind1"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:attribute name="ind2">\n\t\t\t\t<xsl:value-of select="$ind2"/>\n\t\t\t</xsl:attribute>\n\t\t\t<xsl:copy-of select="$subfields"/>\n\t\t</xsl:element>\n\t</xsl:template>\n\n\t<xsl:template name="subfieldSelect">\n\t\t<xsl:param name="codes">abcdefghijklmnopqrstuvwxyz</xsl:param>\n\t\t<xsl:param name="delimeter">\n\t\t\t<xsl:text> </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:variable name="str">\n\t\t\t<xsl:for-each select="marc:subfield">\n\t\t\t\t<xsl:if test="contains($codes, @code)">\n\t\t\t\t\t<xsl:value-of select="text()"/>\n\t\t\t\t\t<xsl:value-of select="$delimeter"/>\n\t\t\t\t</xsl:if>\n\t\t\t</xsl:for-each>\n\t\t</xsl:variable>\n\t\t<xsl:value-of select="substring($str,1,string-length($str)-string-length($delimeter))"/>\n\t</xsl:template>\n\n\t<xsl:template name="buildSpaces">\n\t\t<xsl:param name="spaces"/>\n\t\t<xsl:param name="char">\n\t\t\t<xsl:text> </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:if test="$spaces>0">\n\t\t\t<xsl:value-of select="$char"/>\n\t\t\t<xsl:call-template name="buildSpaces">\n\t\t\t\t<xsl:with-param name="spaces" select="$spaces - 1"/>\n\t\t\t\t<xsl:with-param name="char" select="$char"/>\n\t\t\t</xsl:call-template>\n\t\t</xsl:if>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuation">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:param name="punctuation">\n\t\t\t<xsl:text>.:,;/ </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains($punctuation, substring($chopString,$length,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,1,$length - 1)"/>\n\t\t\t\t\t<xsl:with-param name="punctuation" select="$punctuation"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:value-of select="$chopString"/>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuationFront">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains('.:,;/[ ', substring($chopString,1,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuationFront">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,2,$length - 1)"\n\t\t\t\t\t/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:value-of select="$chopString"/>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<xsl:template name="chopPunctuationBack">\n\t\t<xsl:param name="chopString"/>\n\t\t<xsl:param name="punctuation">\n\t\t\t<xsl:text>.:,;/] </xsl:text>\n\t\t</xsl:param>\n\t\t<xsl:variable name="length" select="string-length($chopString)"/>\n\t\t<xsl:choose>\n\t\t\t<xsl:when test="$length=0"/>\n\t\t\t<xsl:when test="contains($punctuation, substring($chopString,$length,1))">\n\t\t\t\t<xsl:call-template name="chopPunctuation">\n\t\t\t\t\t<xsl:with-param name="chopString" select="substring($chopString,1,$length - 1)"/>\n\t\t\t\t\t<xsl:with-param name="punctuation" select="$punctuation"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:when>\n\t\t\t<xsl:when test="not($chopString)"/>\n\t\t\t<xsl:otherwise>\n\t\t\t\t<xsl:value-of select="$chopString"/>\n\t\t\t</xsl:otherwise>\n\t\t</xsl:choose>\n\t</xsl:template>\n\n\t<!-- nate added 12/14/2007 for lccn.loc.gov: url encode ampersand, etc. -->\n\t<xsl:template name="url-encode">\n\n\t\t<xsl:param name="str"/>\n\n\t\t<xsl:if test="$str">\n\t\t\t<xsl:variable name="first-char" select="substring($str,1,1)"/>\n\t\t\t<xsl:choose>\n\t\t\t\t<xsl:when test="contains($safe,$first-char)">\n\t\t\t\t\t<xsl:value-of select="$first-char"/>\n\t\t\t\t</xsl:when>\n\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t<xsl:variable name="codepoint">\n\t\t\t\t\t\t<xsl:choose>\n\t\t\t\t\t\t\t<xsl:when test="contains($ascii,$first-char)">\n\t\t\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\t\t\tselect="string-length(substring-before($ascii,$first-char)) + 32"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t<xsl:when test="contains($latin1,$first-char)">\n\t\t\t\t\t\t\t\t<xsl:value-of\n\t\t\t\t\t\t\t\t\tselect="string-length(substring-before($latin1,$first-char)) + 160"/>\n\t\t\t\t\t\t\t\t<!-- was 160 -->\n\t\t\t\t\t\t\t</xsl:when>\n\t\t\t\t\t\t\t<xsl:otherwise>\n\t\t\t\t\t\t\t\t<xsl:message terminate="no">Warning: string contains a character\n\t\t\t\t\t\t\t\t\tthat is out of range! Substituting "?".</xsl:message>\n\t\t\t\t\t\t\t\t<xsl:text>63</xsl:text>\n\t\t\t\t\t\t\t</xsl:otherwise>\n\t\t\t\t\t\t</xsl:choose>\n\t\t\t\t\t</xsl:variable>\n\t\t\t\t\t<xsl:variable name="hex-digit1"\n\t\t\t\t\t\tselect="substring($hex,floor($codepoint div 16) + 1,1)"/>\n\t\t\t\t\t<xsl:variable name="hex-digit2" select="substring($hex,$codepoint mod 16 + 1,1)"/>\n\t\t\t\t\t<!-- <xsl:value-of select="concat('%',$hex-digit2)"/> -->\n\t\t\t\t\t<xsl:value-of select="concat('%',$hex-digit1,$hex-digit2)"/>\n\t\t\t\t</xsl:otherwise>\n\t\t\t</xsl:choose>\n\t\t\t<xsl:if test="string-length($str) &gt; 1">\n\t\t\t\t<xsl:call-template name="url-encode">\n\t\t\t\t\t<xsl:with-param name="str" select="substring($str,2)"/>\n\t\t\t\t</xsl:call-template>\n\t\t\t</xsl:if>\n\t\t</xsl:if>\n\t</xsl:template>\n</xsl:stylesheet>
marc21expand880	http://www.loc.gov/MARC21/slim	marc	<?xml version="1.0" encoding="UTF-8"?>\n<xsl:stylesheet\n    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" \n    xmlns:marc="http://www.loc.gov/MARC21/slim"\n    version="1.0">\n<!--\nCopyright (C) 2010  Equinox Software, Inc.\nGalen Charlton <gmc@esilibrary.cOM.\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nmarc21_expand_880.xsl - stylesheet used during indexing to\n                        map alternative graphical representations\n                        of MARC fields stored in 880 fields\n                        to the corresponding tag name and value.\n\nFor example, if a MARC record for a Chinese book has\n\n245.00 $6 880-01 $a Ba shi san nian duan pian xiao shuo xuan\n880.00 $6 245-01/$1 $a八十三年短篇小說選\n\nthis stylesheet will transform it to the equivalent of\n\n245.00 $6 880-01 $a Ba shi san nian duan pian xiao shuo xuan\n245.00 $6 245-01/$1 $a八十三年短篇小說選\n\n-->\n    <xsl:output encoding="UTF-8" indent="yes" method="xml"/>\n\n    <xsl:template match="@*|node()">\n        <xsl:copy>\n            <xsl:apply-templates select="@*|node()"/>\n        </xsl:copy>\n    </xsl:template>\n\n    <xsl:template match="//marc:datafield[@tag='880']">\n        <xsl:if test="./marc:subfield[@code='6'] and string-length(./marc:subfield[@code='6']) &gt;= 6">\n            <marc:datafield>\n                <xsl:attribute name="tag">\n                    <xsl:value-of select="substring(./marc:subfield[@code='6'], 1, 3)" />\n                </xsl:attribute>\n                <xsl:attribute name="ind1">\n                    <xsl:value-of select="@ind1" />\n                </xsl:attribute>\n                <xsl:attribute name="ind2">\n                    <xsl:value-of select="@ind2" />\n                </xsl:attribute>\n                <xsl:apply-templates />\n            </marc:datafield>\n        </xsl:if>\n    </xsl:template>\n    \n</xsl:stylesheet>
\.


--
-- Data for Name: z3950_attr; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY z3950_attr (id, source, name, label, code, format, truncation) FROM stdin;
1	loc	tcn	Title Control Number	12	1	1
2	loc	isbn	ISBN	7	6	1
3	loc	lccn	LCCN	9	6	1
4	loc	author	Author	1003	6	1
5	loc	title	Title	4	6	1
6	loc	issn	ISSN	8	1	1
7	loc	publisher	Publisher	1018	6	1
8	loc	pubdate	Publication Date	31	1	1
9	loc	item_type	Item Type	1001	1	1
10	oclc	tcn	Title Control Number	12	1	0
11	oclc	isbn	ISBN	7	6	0
12	oclc	lccn	LCCN	9	1	0
13	oclc	author	Author	1003	6	0
14	oclc	title	Title	4	6	0
15	oclc	issn	ISSN	8	1	0
16	oclc	publisher	Publisher	1018	6	0
17	oclc	pubdate	Publication Date	31	1	0
18	oclc	item_type	Item Type	1001	1	0
19	biblios	tcn	Title Control Number	12	1	1
20	biblios	isbn	ISBN	7	6	1
21	biblios	lccn	LCCN	9	1	1
22	biblios	author	Author	1003	6	1
23	biblios	title	Title	4	6	1
24	biblios	issn	ISSN	8	1	1
25	biblios	publisher	Publisher	1018	6	1
26	biblios	pubdate	Publication Date	31	1	1
27	biblios	item_type	Item Type	1001	1	1
\.


--
-- Name: z3950_attr_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('z3950_attr_id_seq', 100, true);


--
-- Data for Name: z3950_source; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY z3950_source (name, label, host, port, db, record_format, transmission_format, auth, use_perm) FROM stdin;
loc	Library of Congress	lx2.loc.gov	210	LCDB	FI	usmarc	f	\N
oclc	OCLC	zcat.oclc.org	210	OLUCWorldCat	FI	usmarc	t	\N
biblios	‡biblios.net	z3950.biblios.net	210	bibliographic	FI	usmarc	f	\N
\.


--
-- Data for Name: z3950_source_credentials; Type: TABLE DATA; Schema: config; Owner: postgres
--

COPY z3950_source_credentials (id, owner, source, username, password) FROM stdin;
\.


--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE SET; Schema: config; Owner: postgres
--

SELECT pg_catalog.setval('z3950_source_credentials_id_seq', 1, false);


SET search_path = container, pg_catalog;

--
-- Data for Name: biblio_record_entry_bucket; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY biblio_record_entry_bucket (id, owner, name, btype, description, pub, create_time) FROM stdin;
\.


--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('biblio_record_entry_bucket_id_seq', 1, false);


--
-- Data for Name: biblio_record_entry_bucket_item; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY biblio_record_entry_bucket_item (id, bucket, target_biblio_record_entry, pos, create_time) FROM stdin;
\.


--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('biblio_record_entry_bucket_item_id_seq', 1, false);


--
-- Data for Name: biblio_record_entry_bucket_item_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY biblio_record_entry_bucket_item_note (id, item, note) FROM stdin;
\.


--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('biblio_record_entry_bucket_item_note_id_seq', 1, false);


--
-- Data for Name: biblio_record_entry_bucket_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY biblio_record_entry_bucket_note (id, bucket, note) FROM stdin;
\.


--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('biblio_record_entry_bucket_note_id_seq', 1, false);


--
-- Data for Name: biblio_record_entry_bucket_type; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY biblio_record_entry_bucket_type (code, label) FROM stdin;
misc	Miscellaneous
staff_client	General Staff Client container
bookbag	Book Bag
reading_list	Reading List
template_merge	Template Merge Container
url_verify	URL Verification Queue
temp	Temporary bucket which gets deleted after use.
vandelay_queue	Vandelay Queue
\.


--
-- Data for Name: call_number_bucket; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY call_number_bucket (id, owner, name, btype, description, pub, create_time) FROM stdin;
\.


--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('call_number_bucket_id_seq', 1, false);


--
-- Data for Name: call_number_bucket_item; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY call_number_bucket_item (id, bucket, target_call_number, pos, create_time) FROM stdin;
\.


--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('call_number_bucket_item_id_seq', 1, false);


--
-- Data for Name: call_number_bucket_item_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY call_number_bucket_item_note (id, item, note) FROM stdin;
\.


--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('call_number_bucket_item_note_id_seq', 1, false);


--
-- Data for Name: call_number_bucket_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY call_number_bucket_note (id, bucket, note) FROM stdin;
\.


--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('call_number_bucket_note_id_seq', 1, false);


--
-- Data for Name: call_number_bucket_type; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY call_number_bucket_type (code, label) FROM stdin;
misc	Miscellaneous
\.


--
-- Data for Name: copy_bucket; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY copy_bucket (id, owner, name, btype, description, pub, create_time) FROM stdin;
\.


--
-- Name: copy_bucket_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('copy_bucket_id_seq', 1, false);


--
-- Data for Name: copy_bucket_item; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY copy_bucket_item (id, bucket, target_copy, pos, create_time) FROM stdin;
\.


--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('copy_bucket_item_id_seq', 1, false);


--
-- Data for Name: copy_bucket_item_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY copy_bucket_item_note (id, item, note) FROM stdin;
\.


--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('copy_bucket_item_note_id_seq', 1, false);


--
-- Data for Name: copy_bucket_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY copy_bucket_note (id, bucket, note) FROM stdin;
\.


--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('copy_bucket_note_id_seq', 1, false);


--
-- Data for Name: copy_bucket_type; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY copy_bucket_type (code, label) FROM stdin;
misc	Miscellaneous
staff_client	General Staff Client container
circ_history	Circulation History
\.


--
-- Data for Name: user_bucket; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY user_bucket (id, owner, name, btype, description, pub, create_time) FROM stdin;
\.


--
-- Name: user_bucket_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('user_bucket_id_seq', 1, false);


--
-- Data for Name: user_bucket_item; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY user_bucket_item (id, bucket, target_user, pos, create_time) FROM stdin;
\.


--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('user_bucket_item_id_seq', 1, false);


--
-- Data for Name: user_bucket_item_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY user_bucket_item_note (id, item, note) FROM stdin;
\.


--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('user_bucket_item_note_id_seq', 1, false);


--
-- Data for Name: user_bucket_note; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY user_bucket_note (id, bucket, note) FROM stdin;
\.


--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE SET; Schema: container; Owner: postgres
--

SELECT pg_catalog.setval('user_bucket_note_id_seq', 1, false);


--
-- Data for Name: user_bucket_type; Type: TABLE DATA; Schema: container; Owner: postgres
--

COPY user_bucket_type (code, label) FROM stdin;
misc	Miscellaneous
folks	Friends
folks:pub_book_bags.view	List Published Book Bags
folks:pub_book_bags.add	Add to Published Book Bags
folks:circ.view	View Circulations
folks:circ.renew	Renew Circulations
folks:circ.checkout	Checkout Items
folks:hold.view	View Holds
folks:hold.cancel	Cancel Holds
\.


SET search_path = extend_reporter, pg_catalog;

--
-- Data for Name: legacy_circ_count; Type: TABLE DATA; Schema: extend_reporter; Owner: postgres
--

COPY legacy_circ_count (id, circ_count) FROM stdin;
\.


SET search_path = metabib, pg_catalog;

--
-- Data for Name: author_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY author_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: author_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('author_field_entry_id_seq', 1, false);


--
-- Data for Name: browse_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY browse_entry (id, value, index_vector) FROM stdin;
\.


--
-- Data for Name: browse_entry_def_map; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY browse_entry_def_map (id, entry, def, source) FROM stdin;
\.


--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('browse_entry_def_map_id_seq', 1, false);


--
-- Name: browse_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('browse_entry_id_seq', 1, false);


--
-- Data for Name: combined_author_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_author_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: combined_identifier_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_identifier_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: combined_keyword_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_keyword_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: combined_series_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_series_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: combined_subject_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_subject_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: combined_title_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY combined_title_field_entry (record, metabib_field, index_vector) FROM stdin;
\.


--
-- Data for Name: facet_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY facet_entry (id, source, field, value) FROM stdin;
\.


--
-- Name: facet_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('facet_entry_id_seq', 1, false);


--
-- Name: full_rec_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('full_rec_id_seq', 1, false);


--
-- Data for Name: identifier_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY identifier_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('identifier_field_entry_id_seq', 1, false);


--
-- Data for Name: keyword_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY keyword_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('keyword_field_entry_id_seq', 1, false);


--
-- Data for Name: metarecord; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY metarecord (id, fingerprint, master_record, mods) FROM stdin;
\.


--
-- Name: metarecord_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('metarecord_id_seq', 1, false);


--
-- Data for Name: metarecord_source_map; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY metarecord_source_map (id, metarecord, source) FROM stdin;
\.


--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('metarecord_source_map_id_seq', 1, false);


--
-- Data for Name: real_full_rec; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY real_full_rec (id, record, tag, ind1, ind2, subfield, value, index_vector) FROM stdin;
\.


--
-- Data for Name: record_attr; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY record_attr (id, attrs) FROM stdin;
\.


--
-- Data for Name: series_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY series_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: series_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('series_field_entry_id_seq', 1, false);


--
-- Data for Name: subject_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY subject_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('subject_field_entry_id_seq', 1, false);


--
-- Data for Name: title_field_entry; Type: TABLE DATA; Schema: metabib; Owner: postgres
--

COPY title_field_entry (id, source, field, value, index_vector) FROM stdin;
\.


--
-- Name: title_field_entry_id_seq; Type: SEQUENCE SET; Schema: metabib; Owner: postgres
--

SELECT pg_catalog.setval('title_field_entry_id_seq', 1, false);


SET search_path = money, pg_catalog;

--
-- Data for Name: billable_xact; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY billable_xact (id, usr, xact_start, xact_finish, unrecovered) FROM stdin;
\.


--
-- Name: billable_xact_id_seq; Type: SEQUENCE SET; Schema: money; Owner: postgres
--

SELECT pg_catalog.setval('billable_xact_id_seq', 1, false);


--
-- Data for Name: billing; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY billing (id, xact, billing_ts, voided, voider, void_time, amount, billing_type, btype, note) FROM stdin;
\.


--
-- Name: billing_id_seq; Type: SEQUENCE SET; Schema: money; Owner: postgres
--

SELECT pg_catalog.setval('billing_id_seq', 1, false);


--
-- Data for Name: bnm_desk_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY bnm_desk_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr, cash_drawer) FROM stdin;
\.


--
-- Data for Name: bnm_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY bnm_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr) FROM stdin;
\.


--
-- Data for Name: cash_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY cash_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr, cash_drawer) FROM stdin;
\.


--
-- Data for Name: check_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY check_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr, cash_drawer, check_number) FROM stdin;
\.


--
-- Data for Name: collections_tracker; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY collections_tracker (id, usr, collector, location, enter_time) FROM stdin;
\.


--
-- Name: collections_tracker_id_seq; Type: SEQUENCE SET; Schema: money; Owner: postgres
--

SELECT pg_catalog.setval('collections_tracker_id_seq', 1, false);


--
-- Data for Name: credit_card_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY credit_card_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr, cash_drawer, cc_type, cc_number, cc_processor, cc_first_name, cc_last_name, cc_order_number, expire_month, expire_year, approval_code) FROM stdin;
\.


--
-- Data for Name: credit_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY credit_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr) FROM stdin;
\.


--
-- Data for Name: forgive_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY forgive_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr) FROM stdin;
\.


--
-- Data for Name: goods_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY goods_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr) FROM stdin;
\.


--
-- Data for Name: grocery; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY grocery (id, usr, xact_start, xact_finish, unrecovered, billing_location, note) FROM stdin;
\.


--
-- Data for Name: materialized_billable_xact_summary; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY materialized_billable_xact_summary (id, usr, xact_start, xact_finish, total_paid, last_payment_ts, last_payment_note, last_payment_type, total_owed, last_billing_ts, last_billing_note, last_billing_type, balance_owed, xact_type) FROM stdin;
\.


--
-- Data for Name: payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY payment (id, xact, payment_ts, voided, amount, note) FROM stdin;
\.


--
-- Name: payment_id_seq; Type: SEQUENCE SET; Schema: money; Owner: postgres
--

SELECT pg_catalog.setval('payment_id_seq', 1, false);


--
-- Data for Name: work_payment; Type: TABLE DATA; Schema: money; Owner: postgres
--

COPY work_payment (id, xact, payment_ts, voided, amount, note, amount_collected, accepting_usr) FROM stdin;
\.


SET search_path = offline, pg_catalog;

--
-- Data for Name: script; Type: TABLE DATA; Schema: offline; Owner: postgres
--

COPY script (id, session, requestor, create_time, workstation, logfile, time_delta, count) FROM stdin;
\.


--
-- Name: script_id_seq; Type: SEQUENCE SET; Schema: offline; Owner: postgres
--

SELECT pg_catalog.setval('script_id_seq', 1, false);


--
-- Data for Name: session; Type: TABLE DATA; Schema: offline; Owner: postgres
--

COPY session (key, org, description, creator, create_time, in_process, start_time, end_time, num_complete) FROM stdin;
\.


SET search_path = permission, pg_catalog;

--
-- Data for Name: grp_penalty_threshold; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY grp_penalty_threshold (id, grp, org_unit, penalty, threshold) FROM stdin;
1	1	1	1	10.00
2	1	1	2	10.00
3	1	1	3	10.00
\.


--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('grp_penalty_threshold_id_seq', 3, true);


--
-- Data for Name: grp_perm_map; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY grp_perm_map (id, grp, perm, depth, grantable) FROM stdin;
1	1	29	0	f
2	1	90	0	f
3	1	498	0	f
4	1	3	0	f
5	1	1	0	f
6	1	511	0	f
7	1	12	0	f
8	1	4	0	f
9	1	468	0	f
10	14	74	0	f
11	14	175	0	f
12	14	43	0	f
13	14	80	0	f
14	14	9	0	f
15	14	192	0	f
16	14	82	0	f
17	14	38	0	f
18	14	28	0	f
19	14	13	0	f
20	14	14	0	f
21	14	81	0	f
22	14	108	0	f
23	14	70	1	f
24	14	6	1	f
25	14	69	1	f
26	14	37	1	f
27	14	96	1	f
28	14	95	1	f
29	14	2	1	f
30	14	5	1	f
31	3	41	0	f
32	3	45	0	f
33	3	74	0	f
34	3	92	0	f
35	3	37	0	f
36	3	30	0	f
37	3	44	0	f
38	3	145	0	f
39	3	79	0	f
40	3	78	0	f
41	3	7	0	f
42	3	2	0	f
43	3	253	0	f
44	3	89	0	f
45	3	40	0	f
46	3	77	0	f
47	3	80	0	f
48	3	9	0	f
49	3	91	0	f
50	3	76	0	f
51	3	31	0	f
52	3	48	0	f
53	3	82	0	f
54	3	38	0	f
55	3	506	0	f
56	3	81	0	f
57	3	120	0	f
58	3	121	0	f
59	3	25	1	f
60	3	26	1	f
61	3	175	1	f
62	3	43	1	f
63	3	192	1	f
64	3	49	1	f
65	3	28	1	f
66	3	13	1	f
67	3	14	1	f
68	3	523	2	f
69	3	109	2	f
70	3	70	2	f
71	3	6	2	f
72	3	75	2	f
73	3	39	2	f
74	3	69	2	f
75	3	33	2	f
76	3	24	2	f
77	3	22	2	f
78	3	19	2	f
79	3	5	2	f
80	4	351	0	f
81	4	287	0	f
82	4	311	0	f
83	4	16	0	f
84	4	85	0	f
85	4	296	0	f
86	4	314	0	f
87	4	172	0	f
88	4	88	0	f
89	4	190	0	f
90	4	522	0	f
91	4	17	0	f
92	4	350	0	f
93	4	280	0	f
94	4	302	0	f
95	4	303	0	f
96	4	305	0	f
97	4	15	0	f
98	4	385	0	f
99	4	310	0	f
100	4	471	0	f
101	4	21	1	f
102	4	83	1	f
103	4	193	1	f
104	4	18	1	f
105	4	84	1	f
106	4	23	1	f
107	4	86	1	f
108	4	195	1	f
109	4	20	1	f
110	4	87	1	f
111	4	500	1	f
112	4	176	1	f
113	4	178	1	f
114	4	177	1	f
115	4	186	1	f
116	4	181	1	f
117	4	182	1	f
118	4	179	1	f
119	4	180	1	f
120	4	184	1	f
121	4	185	1	f
122	4	183	1	f
123	4	22	1	f
124	4	258	1	f
125	4	317	1	f
126	4	194	1	f
127	4	19	1	f
128	4	277	1	f
129	4	479	1	f
130	8	412	0	t
131	8	420	0	t
132	8	286	0	t
133	8	497	0	t
134	8	432	0	t
135	8	312	0	t
136	8	313	0	t
137	8	439	0	t
138	8	491	0	t
139	8	488	0	t
140	8	485	0	t
141	8	292	0	t
142	8	499	0	t
143	8	445	0	t
144	8	315	0	t
145	8	316	0	t
146	8	451	0	t
147	8	493	0	t
148	8	490	0	t
149	8	487	0	t
150	8	500	0	t
151	8	301	0	t
152	8	304	0	t
153	8	502	0	t
154	8	318	0	t
155	8	319	0	t
156	8	464	0	t
157	8	492	0	t
158	8	489	0	t
159	8	486	0	t
160	8	52	1	t
161	8	54	1	t
162	8	60	1	t
163	8	516	1	t
164	8	141	1	t
165	8	142	1	t
166	8	72	1	t
167	8	56	1	t
168	8	58	1	t
169	8	143	1	t
170	5	381	2	f
171	5	376	2	f
172	5	378	2	f
173	5	379	2	f
174	5	380	2	f
175	5	377	2	f
176	5	204	2	f
177	5	176	2	f
178	5	178	2	f
179	5	177	2	f
180	5	186	2	f
181	5	181	2	f
182	5	182	2	f
183	5	179	2	f
184	5	180	2	f
185	5	501	2	f
186	5	184	2	f
187	5	185	2	f
188	5	183	2	f
189	5	94	2	f
190	5	95	2	f
191	5	47	2	f
192	5	36	2	f
193	5	198	2	f
194	5	34	2	f
195	5	35	2	f
196	5	200	2	f
197	5	202	2	f
198	5	199	2	f
199	5	201	2	f
200	5	281	2	f
201	5	475	2	f
202	5	480	2	f
203	5	100	2	f
204	5	5	2	f
205	5	107	1	f
206	5	106	1	f
207	5	384	1	f
208	5	101	1	f
209	5	137	1	f
210	5	97	1	f
211	5	98	1	f
212	5	103	1	f
213	5	102	1	f
214	5	144	1	f
215	5	99	1	f
216	5	349	1	f
217	5	139	1	f
218	5	104	1	f
219	5	105	1	f
220	5	110	1	f
221	5	46	1	f
222	5	249	1	f
223	5	140	1	f
224	5	344	1	f
225	5	388	1	f
226	5	132	1	f
227	5	138	1	f
228	5	133	1	f
229	5	347	1	f
230	5	134	1	f
231	5	136	1	f
232	5	135	1	f
233	5	383	1	f
234	5	11	1	f
235	9	27	2	t
236	9	507	0	t
237	9	508	0	t
238	9	419	0	t
239	9	207	0	t
240	9	230	0	t
241	9	501	0	t
242	9	256	0	t
243	9	503	0	t
244	9	269	0	t
245	9	510	0	t
246	9	473	0	t
247	9	476	0	t
248	9	381	1	t
249	9	401	1	t
250	9	382	1	t
251	9	376	1	t
252	9	378	1	t
253	9	379	1	t
254	9	380	1	t
255	9	377	1	t
256	9	203	1	t
257	9	409	1	t
258	9	204	1	t
259	9	117	1	t
260	9	6	1	t
261	9	75	1	t
262	9	39	1	t
263	9	433	1	t
264	9	67	1	t
265	9	51	1	t
266	9	53	1	t
267	9	525	1	t
268	9	59	1	t
269	9	46	1	t
270	9	446	1	t
271	9	114	1	t
272	9	61	1	t
273	9	63	1	t
274	9	527	1	t
275	9	65	1	t
276	9	249	1	t
277	9	176	1	t
278	9	178	1	t
279	9	177	1	t
280	9	186	1	t
281	9	181	1	t
282	9	182	1	t
283	9	179	1	t
284	9	180	1	t
285	9	184	1	t
286	9	185	1	t
287	9	183	1	t
288	9	387	1	t
289	9	96	1	t
290	9	94	1	t
291	9	95	1	t
292	9	47	1	t
293	9	36	1	t
294	9	198	1	t
295	9	34	1	t
296	9	35	1	t
297	9	509	1	t
298	9	118	1	t
299	9	200	1	t
300	9	68	1	t
301	9	202	1	t
302	9	199	1	t
303	9	281	1	t
304	9	348	1	t
305	9	26	1	t
306	9	143	1	t
307	9	480	1	t
308	9	100	1	t
309	9	5	1	t
310	9	122	1	t
311	9	115	1	t
312	9	116	1	t
313	10	-1	2	t
314	12	-1	1	t
315	12	535	0	f
316	12	360	0	f
317	13	-1	0	t
318	6	351	0	f
319	6	287	0	f
320	6	311	0	f
321	6	436	0	f
322	6	16	0	f
323	6	168	0	f
324	6	188	0	f
325	6	296	0	f
326	6	314	0	f
327	6	172	0	f
328	6	20	0	f
329	6	87	0	f
330	6	159	0	f
331	6	190	0	f
332	6	17	0	f
333	6	455	0	f
334	6	167	0	f
335	6	166	0	f
336	6	170	0	f
337	6	176	0	f
338	6	178	0	f
339	6	177	0	f
340	6	186	0	f
341	6	181	0	f
342	6	182	0	f
343	6	179	0	f
344	6	180	0	f
345	6	184	0	f
346	6	185	0	f
347	6	183	0	f
348	6	191	0	f
349	6	50	0	f
350	6	305	0	f
351	6	22	0	f
352	6	154	0	f
353	6	150	0	f
354	6	158	0	f
355	6	317	0	f
356	6	15	0	f
357	6	504	0	f
358	6	385	0	f
359	6	19	0	f
360	6	309	0	f
361	6	472	0	f
362	6	153	0	f
363	6	149	0	f
364	6	157	0	f
365	6	477	0	f
366	6	192	0	f
367	6	171	0	f
368	6	162	0	f
369	6	189	0	f
370	6	143	0	f
371	6	469	0	f
372	6	470	0	f
373	6	471	0	f
374	7	512	0	t
375	7	346	0	t
376	7	345	0	t
377	7	391	0	t
378	7	392	0	t
379	7	393	0	t
380	7	394	0	t
381	7	395	0	t
382	7	196	0	t
383	7	396	0	t
384	7	397	0	t
385	7	404	0	t
386	7	173	0	t
387	7	165	0	t
388	7	164	0	t
389	7	414	0	t
390	7	415	0	t
391	7	416	0	t
392	7	417	0	t
393	7	169	0	t
394	7	426	0	t
395	7	282	0	t
396	7	151	0	t
397	7	147	0	t
398	7	155	0	t
399	7	437	0	t
400	7	438	0	t
401	7	160	0	t
402	7	516	0	t
403	7	291	0	t
404	7	152	0	t
405	7	148	0	t
406	7	156	0	t
407	7	449	0	t
408	7	450	0	t
409	7	161	0	t
410	7	141	0	t
411	7	142	0	t
412	7	300	0	t
413	7	462	0	t
414	7	463	0	t
415	7	504	0	t
416	11	400	1	f
417	11	481	1	f
418	11	482	1	f
419	11	495	1	f
420	11	483	1	f
421	11	423	1	f
422	11	388	1	f
423	11	484	1	f
424	15	70	2	f
425	15	39	2	f
426	15	69	2	f
427	15	33	2	f
428	15	175	2	f
429	15	9	2	f
430	15	38	2	f
431	15	28	2	f
432	15	13	2	f
433	15	14	2	f
434	15	74	0	f
435	15	37	0	f
436	15	30	0	f
437	15	2	0	f
438	15	253	0	f
439	15	192	0	f
440	13	519	0	t
\.


--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('grp_perm_map_id_seq', 440, true);


--
-- Data for Name: grp_tree; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY grp_tree (id, name, parent, usergroup, perm_interval, description, application_perm, hold_priority) FROM stdin;
1	Users	\N	f	3 years	\N	group_application.user	0
2	Patrons	1	t	3 years	\N	group_application.user.patron	0
3	Staff	1	f	3 years	\N	group_application.user.staff	0
4	Catalogers	3	t	3 years	\N	group_application.user.staff.cat	0
5	Circulators	3	t	3 years	\N	group_application.user.staff.circ	0
6	Acquisitions	3	t	3 years	\N	group_application.user.staff.acq	0
7	Acquisitions Administrator	3	t	3 years	\N	group_application.user.staff.acq_admin	0
8	Cataloging Administrator	3	t	3 years	\N	group_application.user.staff.cat_admin	0
9	Circulation Administrator	3	t	3 years	\N	group_application.user.staff.circ_admin	0
10	Local Administrator	3	t	3 years	Can do anything at the Branch level	group_application.user.staff.admin.local_admin	0
11	Serials	3	t	3 years	Serials (includes admin features)	group_application.user.staff.serials	0
12	System Administrator	3	t	3 years	Can do anything at the System level	group_application.user.staff.admin.system_admin	0
13	Global Administrator	3	t	3 years	Can do anything at the Consortium level	group_application.user.staff.admin.global_admin	0
14	Data Review	3	t	3 years	\N	group_application.user.staff.data_review	0
15	Volunteers	3	t	3 years	\N	group_application.user.staff.volunteers	0
\.


--
-- Name: grp_tree_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('grp_tree_id_seq', 15, true);


--
-- Data for Name: perm_list; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY perm_list (id, code, description) FROM stdin;
-1	EVERYTHING	EVERYTHING
1	OPAC_LOGIN	Allow a user to log in to the OPAC
2	STAFF_LOGIN	Allow a user to log in to the staff client
3	MR_HOLDS	Allow a user to create a metarecord holds
4	TITLE_HOLDS	Allow a user to place a hold at the title level
5	VOLUME_HOLDS	Allow a user to place a volume level hold
6	COPY_HOLDS	Allow a user to place a hold on a specific copy
7	REQUEST_HOLDS	Allow a user to create holds for another user (if true, we still check to make sure they have permission to make the type of hold they are requesting, for example, COPY_HOLDS)
8	REQUEST_HOLDS_OVERRIDE	* no longer applicable
9	VIEW_HOLD	Allow a user to view another user's holds
10	DELETE_HOLDS	* no longer applicable
11	UPDATE_HOLD	Allow a user to update another user's hold
12	RENEW_CIRC	Allow a user to renew items
13	VIEW_USER_FINES_SUMMARY	Allow a user to view bill details
14	VIEW_USER_TRANSACTIONS	Allow a user to see another user's grocery or circulation transactions in the Bills Interface; duplicate of VIEW_TRANSACTION
15	UPDATE_MARC	Allow a user to edit a MARC record
16	CREATE_MARC	Allow a user to create new MARC records
17	IMPORT_MARC	Allow a user to import a MARC record via the Z39.50 interface
18	CREATE_VOLUME	Allow a user to create a volume
19	UPDATE_VOLUME	Allow a user to edit volumes - needed for merging records. This is a duplicate of VOLUME_UPDATE; user must have both permissions at appropriate level to merge records.
20	DELETE_VOLUME	Allow a user to delete a volume
21	CREATE_COPY	Allow a user to create a new copy object
22	UPDATE_COPY	Allow a user to edit a copy
23	DELETE_COPY	Allow a user to delete a copy
24	RENEW_HOLD_OVERRIDE	Allow a user to continue to renew an item even if it is required for a hold
25	CREATE_USER	Allow a user to create another user
26	UPDATE_USER	Allow a user to edit a user's record
27	DELETE_USER	Allow a user to mark a user as deleted
28	VIEW_USER	Allow a user to view another user's Patron Record
29	COPY_CHECKIN	Allow a user to check in a copy
30	CREATE_TRANSIT	Allow a user to place an item in transit
31	VIEW_PERMISSION	Allow a user to view user permissions within the user permissions editor
32	CHECKIN_BYPASS_HOLD_FULFILL	* no longer applicable
33	CREATE_PAYMENT	Allow a user to record payments in the Billing Interface
34	SET_CIRC_LOST	Allow a user to mark an item as 'lost'
35	SET_CIRC_MISSING	Allow a user to mark an item as 'missing'
36	SET_CIRC_CLAIMS_RETURNED	Allow a user to mark an item as 'claims returned'
37	CREATE_TRANSACTION	Allow a user to create a new billable transaction
38	VIEW_TRANSACTION	Allow a user may view another user's transactions
39	CREATE_BILL	Allow a user to create a new bill on a transaction
40	VIEW_CONTAINER	Allow a user to view another user's containers (buckets)
41	CREATE_CONTAINER	Allow a user to create a new container for another user
42	UPDATE_ORG_UNIT	Allow a user to change the settings for an organization unit
43	VIEW_CIRCULATIONS	Allow a user to see what another user has checked out
44	DELETE_CONTAINER	Allow a user to delete another user's container
45	CREATE_CONTAINER_ITEM	Allow a user to create a container item for another user
46	CREATE_USER_GROUP_LINK	Allow a user to add other users to permission groups
47	REMOVE_USER_GROUP_LINK	Allow a user to remove other users from permission groups
48	VIEW_PERM_GROUPS	Allow a user to view other users' permission groups
49	VIEW_PERMIT_CHECKOUT	Allow a user to determine whether another user can check out an item
50	UPDATE_BATCH_COPY	Allow a user to edit copies in batch
51	CREATE_PATRON_STAT_CAT	User may create a new patron statistical category
52	CREATE_COPY_STAT_CAT	User may create a copy statistical category
53	CREATE_PATRON_STAT_CAT_ENTRY	User may create an entry in a patron statistical category
54	CREATE_COPY_STAT_CAT_ENTRY	User may create an entry in a copy statistical category
55	UPDATE_PATRON_STAT_CAT	User may update a patron statistical category
56	UPDATE_COPY_STAT_CAT	User may update a copy statistical category
57	UPDATE_PATRON_STAT_CAT_ENTRY	User may update an entry in a patron statistical category
58	UPDATE_COPY_STAT_CAT_ENTRY	User may update an entry in a copy statistical category
59	CREATE_PATRON_STAT_CAT_ENTRY_MAP	User may link another user to an entry in a statistical category
60	CREATE_COPY_STAT_CAT_ENTRY_MAP	User may link a copy to an entry in a statistical category
61	DELETE_PATRON_STAT_CAT	User may delete a patron statistical category
62	DELETE_COPY_STAT_CAT	User may delete a copy statistical category
63	DELETE_PATRON_STAT_CAT_ENTRY	User may delete an entry from a patron statistical category
64	DELETE_COPY_STAT_CAT_ENTRY	User may delete an entry from a copy statistical category
65	DELETE_PATRON_STAT_CAT_ENTRY_MAP	User may delete a patron statistical category entry map
66	DELETE_COPY_STAT_CAT_ENTRY_MAP	User may delete a copy statistical category entry map
67	CREATE_NON_CAT_TYPE	Allow a user to create a new non-cataloged item type
68	UPDATE_NON_CAT_TYPE	Allow a user to update a non-cataloged item type
69	CREATE_IN_HOUSE_USE	Allow a user to create a new in-house-use 
70	COPY_CHECKOUT	Allow a user to check out a copy
71	CREATE_COPY_LOCATION	Allow a user to create a new copy location
72	UPDATE_COPY_LOCATION	Allow a user to update a copy location
73	DELETE_COPY_LOCATION	Allow a user to delete a copy location
74	CREATE_COPY_TRANSIT	Allow a user to create a transit_copy object for transiting a copy
75	COPY_TRANSIT_RECEIVE	Allow a user to close out a transit on a copy
76	VIEW_HOLD_PERMIT	Allow a user to see if another user has permission to place a hold on a given copy
235	DELETE_ITEM_TYPE	DELETE_ITEM_TYPE
77	VIEW_COPY_CHECKOUT_HISTORY	Allow a user to view which users have checked out a given copy
78	REMOTE_Z3950_QUERY	Allow a user to perform Z39.50 queries against remote servers
79	REGISTER_WORKSTATION	Allow a user to register a new workstation
80	VIEW_COPY_NOTES	Allow a user to view all notes attached to a copy
81	VIEW_VOLUME_NOTES	Allow a user to view all notes attached to a volume
82	VIEW_TITLE_NOTES	Allow a user to view all notes attached to a title
83	CREATE_COPY_NOTE	Allow a user to create a new copy note
84	CREATE_VOLUME_NOTE	Allow a user to create a new volume note
85	CREATE_TITLE_NOTE	Allow a user to create a new title note
86	DELETE_COPY_NOTE	Allow a user to delete another user's copy notes
87	DELETE_VOLUME_NOTE	Allow a user to delete another user's volume note
88	DELETE_TITLE_NOTE	Allow a user to delete another user's title note
89	UPDATE_CONTAINER	Allow a user to update another user's container
90	CREATE_MY_CONTAINER	Allow a user to create a container for themselves
91	VIEW_HOLD_NOTIFICATION	Allow a user to view notifications attached to a hold
92	CREATE_HOLD_NOTIFICATION	Allow a user to create new hold notifications
93	UPDATE_ORG_SETTING	Allow a user to update an organization unit setting
94	OFFLINE_UPLOAD	Allow a user to upload an offline script
95	OFFLINE_VIEW	Allow a user to view uploaded offline script information
96	OFFLINE_EXECUTE	Allow a user to execute an offline script batch
97	CIRC_OVERRIDE_DUE_DATE	Allow a user to change the due date on an item to any date
98	CIRC_PERMIT_OVERRIDE	Allow a user to bypass the circulation permit call for check out
99	COPY_IS_REFERENCE.override	Allow a user to override the copy_is_reference event
100	VOID_BILLING	Allow a user to void a bill
101	CIRC_CLAIMS_RETURNED.override	Allow a user to check in or check out an item that has a status of 'claims returned'
102	COPY_BAD_STATUS.override	Allow a user to check out an item in a non-circulatable status
103	COPY_ALERT_MESSAGE.override	Allow a user to check in/out an item that has an alert message
104	COPY_STATUS_LOST.override	Allow a user to remove the lost status from a copy
105	COPY_STATUS_MISSING.override	Allow a user to change the missing status on a copy
106	ABORT_TRANSIT	Allow a user to abort a copy transit if the user is at the transit destination or source
107	ABORT_REMOTE_TRANSIT	Allow a user to abort a copy transit if the user is not at the transit source or dest
108	VIEW_ZIP_DATA	Allow a user to query the ZIP code data method
109	CANCEL_HOLDS	Allow a user to cancel holds
110	CREATE_DUPLICATE_HOLDS	Allow a user to create duplicate holds (two or more holds on the same title)
111	actor.org_unit.closed_date.delete	Allow a user to remove a closed date interval for a given location
112	actor.org_unit.closed_date.update	Allow a user to update a closed date interval for a given location
113	actor.org_unit.closed_date.create	Allow a user to create a new closed date for a location
114	DELETE_NON_CAT_TYPE	Allow a user to delete a non cataloged type
115	money.collections_tracker.create	Allow a user to put someone into collections
116	money.collections_tracker.delete	Allow a user to remove someone from collections
117	BAR_PATRON	Allow a user to bar a patron
118	UNBAR_PATRON	Allow a user to un-bar a patron
119	DELETE_WORKSTATION	Allow a user to remove an existing workstation so a new one can replace it
120	group_application.user	Allow a user to add/remove users to/from the "User" group
121	group_application.user.patron	Allow a user to add/remove users to/from the "Patron" group
122	group_application.user.staff	Allow a user to add/remove users to/from the "Staff" group
123	group_application.user.staff.circ	Allow a user to add/remove users to/from the "Circulator" group
124	group_application.user.staff.cat	Allow a user to add/remove users to/from the "Cataloger" group
125	group_application.user.staff.admin.global_admin	Allow a user to add/remove users to/from the "GlobalAdmin" group
126	group_application.user.staff.admin.local_admin	Allow a user to add/remove users to/from the "LocalAdmin" group
127	group_application.user.staff.admin.lib_manager	Allow a user to add/remove users to/from the "LibraryManager" group
128	group_application.user.staff.cat.cat1	Allow a user to add/remove users to/from the "Cat1" group
129	group_application.user.staff.supercat	Allow a user to add/remove users to/from the "Supercat" group
130	group_application.user.sip_client	Allow a user to add/remove users to/from the "SIP-Client" group
131	group_application.user.vendor	Allow a user to add/remove users to/from the "Vendor" group
132	ITEM_AGE_PROTECTED.override	Allow a user to place a hold on an age-protected item
133	MAX_RENEWALS_REACHED.override	Allow a user to renew an item past the maximum renewal count
134	PATRON_EXCEEDS_CHECKOUT_COUNT.override	Allow staff to override checkout count failure
135	PATRON_EXCEEDS_OVERDUE_COUNT.override	Allow staff to override overdue count failure
136	PATRON_EXCEEDS_FINES.override	Allow staff to override fine amount checkout failure
137	CIRC_EXCEEDS_COPY_RANGE.override	Allow staff to override circulation copy range failure
138	ITEM_ON_HOLDS_SHELF.override	Allow staff to override item on holds shelf failure
139	COPY_NOT_AVAILABLE.override	Allow staff to force checkout of Missing/Lost type items
140	HOLD_EXISTS.override	Allow a user to place multiple holds on a single title
141	RUN_REPORTS	Allow a user to run reports
142	SHARE_REPORT_FOLDER	Allow a user to share report his own folders
143	VIEW_REPORT_OUTPUT	Allow a user to view report output
144	COPY_CIRC_NOT_ALLOWED.override	Allow a user to checkout an item that is marked as non-circ
145	DELETE_CONTAINER_ITEM	Allow a user to delete an item out of another user's container
146	ASSIGN_WORK_ORG_UNIT	Allow a staff member to define where another staff member has their permissions
147	CREATE_FUNDING_SOURCE	Allow a user to create a new funding source
148	DELETE_FUNDING_SOURCE	Allow a user to delete a funding source
149	VIEW_FUNDING_SOURCE	Allow a user to view a funding source
150	UPDATE_FUNDING_SOURCE	Allow a user to update a funding source
151	CREATE_FUND	Allow a user to create a new fund
152	DELETE_FUND	Allow a user to delete a fund
153	VIEW_FUND	Allow a user to view a fund
154	UPDATE_FUND	Allow a user to update a fund
155	CREATE_FUND_ALLOCATION	Allow a user to create a new fund allocation
156	DELETE_FUND_ALLOCATION	Allow a user to delete a fund allocation
157	VIEW_FUND_ALLOCATION	Allow a user to view a fund allocation
158	UPDATE_FUND_ALLOCATION	Allow a user to update a fund allocation
159	GENERAL_ACQ	Lowest level permission required to access the ACQ interface
160	CREATE_PROVIDER	Allow a user to create a new provider
161	DELETE_PROVIDER	Allow a user to delate a provider
162	VIEW_PROVIDER	Allow a user to view a provider
163	UPDATE_PROVIDER	Allow a user to update a provider
164	ADMIN_FUNDING_SOURCE	Allow a user to create/view/update/delete a funding source
165	ADMIN_FUND	(Deprecated) Allow a user to create/view/update/delete a fund
166	MANAGE_FUNDING_SOURCE	Allow a user to view/credit/debit a funding source
167	MANAGE_FUND	Allow a user to view/credit/debit a fund
168	CREATE_PICKLIST	Allows a user to create a picklist
169	ADMIN_PROVIDER	Allow a user to create/view/update/delete a provider
170	MANAGE_PROVIDER	Allow a user to view and purchase from a provider
171	VIEW_PICKLIST	Allow a user to view another users picklist
172	DELETE_RECORD	Allow a staff member to directly remove a bibliographic record
173	ADMIN_CURRENCY_TYPE	Allow a user to create/view/update/delete a currency_type
174	MARK_BAD_DEBT	Allow a user to mark a transaction as bad (unrecoverable) debt
175	VIEW_BILLING_TYPE	Allow a user to view billing types
176	MARK_ITEM_AVAILABLE	Allow a user to mark an item status as 'available'
177	MARK_ITEM_CHECKED_OUT	Allow a user to mark an item status as 'checked out'
178	MARK_ITEM_BINDERY	Allow a user to mark an item status as 'bindery'
179	MARK_ITEM_LOST	Allow a user to mark an item status as 'lost'
180	MARK_ITEM_MISSING	Allow a user to mark an item status as 'missing'
181	MARK_ITEM_IN_PROCESS	Allow a user to mark an item status as 'in process'
182	MARK_ITEM_IN_TRANSIT	Allow a user to mark an item status as 'in transit'
183	MARK_ITEM_RESHELVING	Allow a user to mark an item status as 'reshelving'
184	MARK_ITEM_ON_HOLDS_SHELF	Allow a user to mark an item status as 'on holds shelf'
185	MARK_ITEM_ON_ORDER	Allow a user to mark an item status as 'on order'
186	MARK_ITEM_ILL	Allow a user to mark an item status as 'inter-library loan'
187	group_application.user.staff.acq	Allows a user to add/remove/edit users in the "ACQ" group
188	CREATE_PURCHASE_ORDER	Allows a user to create a purchase order
189	VIEW_PURCHASE_ORDER	Allows a user to view a purchase order
190	IMPORT_ACQ_LINEITEM_BIB_RECORD	Allows a user to import a bib record from the acq staging area (on-order record) into the ILS bib data set
191	RECEIVE_PURCHASE_ORDER	Allows a user to mark a purchase order, lineitem, or individual copy as received
192	VIEW_ORG_SETTINGS	Allows a user to view all org settings at the specified level
193	CREATE_MFHD_RECORD	Allows a user to create a new MFHD record
194	UPDATE_MFHD_RECORD	Allows a user to update an MFHD record
195	DELETE_MFHD_RECORD	Allows a user to delete an MFHD record
196	ADMIN_ACQ_FUND	Allow a user to create/view/update/delete a fund
197	group_application.user.staff.acq_admin	Allows a user to add/remove/edit users in the "Acquisitions Administrators" group
198	SET_CIRC_CLAIMS_RETURNED.override	Allows staff to override the max claims returned value for a patron
199	UPDATE_PATRON_CLAIM_RETURN_COUNT	Allows staff to manually change a patron's claims returned count
200	UPDATE_BILL_NOTE	Allows staff to edit the note for a bill on a transaction
201	UPDATE_PAYMENT_NOTE	Allows staff to edit the note for a payment on a transaction
202	UPDATE_PATRON_CLAIM_NEVER_CHECKED_OUT_COUNT	Allows staff to manually change a patron's claims never checkout out count
203	ADMIN_COPY_LOCATION_ORDER	Allow a user to create/view/update/delete a copy location order
204	ASSIGN_GROUP_PERM	ASSIGN_GROUP_PERM
205	CREATE_AUDIENCE	CREATE_AUDIENCE
206	CREATE_BIB_LEVEL	CREATE_BIB_LEVEL
207	CREATE_CIRC_DURATION	CREATE_CIRC_DURATION
208	CREATE_CIRC_MOD	CREATE_CIRC_MOD
209	CREATE_COPY_STATUS	CREATE_COPY_STATUS
210	CREATE_HOURS_OF_OPERATION	CREATE_HOURS_OF_OPERATION
211	CREATE_ITEM_FORM	CREATE_ITEM_FORM
212	CREATE_ITEM_TYPE	CREATE_ITEM_TYPE
213	CREATE_LANGUAGE	CREATE_LANGUAGE
214	CREATE_LASSO	CREATE_LASSO
215	CREATE_LASSO_MAP	CREATE_LASSO_MAP
216	CREATE_LIT_FORM	CREATE_LIT_FORM
217	CREATE_METABIB_FIELD	CREATE_METABIB_FIELD
218	CREATE_NET_ACCESS_LEVEL	CREATE_NET_ACCESS_LEVEL
219	CREATE_ORG_ADDRESS	CREATE_ORG_ADDRESS
220	CREATE_ORG_TYPE	CREATE_ORG_TYPE
221	CREATE_ORG_UNIT	CREATE_ORG_UNIT
222	CREATE_ORG_UNIT_CLOSING	CREATE_ORG_UNIT_CLOSING
223	CREATE_PERM	CREATE_PERM
224	CREATE_RELEVANCE_ADJUSTMENT	CREATE_RELEVANCE_ADJUSTMENT
225	CREATE_SURVEY	CREATE_SURVEY
226	CREATE_VR_FORMAT	CREATE_VR_FORMAT
227	CREATE_XML_TRANSFORM	CREATE_XML_TRANSFORM
228	DELETE_AUDIENCE	DELETE_AUDIENCE
229	DELETE_BIB_LEVEL	DELETE_BIB_LEVEL
230	DELETE_CIRC_DURATION	DELETE_CIRC_DURATION
231	DELETE_CIRC_MOD	DELETE_CIRC_MOD
232	DELETE_COPY_STATUS	DELETE_COPY_STATUS
233	DELETE_HOURS_OF_OPERATION	DELETE_HOURS_OF_OPERATION
234	DELETE_ITEM_FORM	DELETE_ITEM_FORM
236	DELETE_LANGUAGE	DELETE_LANGUAGE
237	DELETE_LASSO	DELETE_LASSO
238	DELETE_LASSO_MAP	DELETE_LASSO_MAP
239	DELETE_LIT_FORM	DELETE_LIT_FORM
240	DELETE_METABIB_FIELD	DELETE_METABIB_FIELD
241	DELETE_NET_ACCESS_LEVEL	DELETE_NET_ACCESS_LEVEL
242	DELETE_ORG_ADDRESS	DELETE_ORG_ADDRESS
243	DELETE_ORG_TYPE	DELETE_ORG_TYPE
244	DELETE_ORG_UNIT	DELETE_ORG_UNIT
245	DELETE_ORG_UNIT_CLOSING	DELETE_ORG_UNIT_CLOSING
246	DELETE_PERM	DELETE_PERM
247	DELETE_RELEVANCE_ADJUSTMENT	DELETE_RELEVANCE_ADJUSTMENT
248	DELETE_SURVEY	DELETE_SURVEY
249	DELETE_TRANSIT	DELETE_TRANSIT
250	DELETE_VR_FORMAT	DELETE_VR_FORMAT
251	DELETE_XML_TRANSFORM	DELETE_XML_TRANSFORM
252	REMOVE_GROUP_PERM	REMOVE_GROUP_PERM
253	TRANSIT_COPY	TRANSIT_COPY
254	UPDATE_AUDIENCE	UPDATE_AUDIENCE
255	UPDATE_BIB_LEVEL	UPDATE_BIB_LEVEL
256	UPDATE_CIRC_DURATION	UPDATE_CIRC_DURATION
257	UPDATE_CIRC_MOD	UPDATE_CIRC_MOD
258	UPDATE_COPY_NOTE	UPDATE_COPY_NOTE
259	UPDATE_COPY_STATUS	UPDATE_COPY_STATUS
260	UPDATE_GROUP_PERM	UPDATE_GROUP_PERM
261	UPDATE_HOURS_OF_OPERATION	UPDATE_HOURS_OF_OPERATION
262	UPDATE_ITEM_FORM	UPDATE_ITEM_FORM
263	UPDATE_ITEM_TYPE	UPDATE_ITEM_TYPE
264	UPDATE_LANGUAGE	UPDATE_LANGUAGE
265	UPDATE_LASSO	UPDATE_LASSO
266	UPDATE_LASSO_MAP	UPDATE_LASSO_MAP
267	UPDATE_LIT_FORM	UPDATE_LIT_FORM
268	UPDATE_METABIB_FIELD	UPDATE_METABIB_FIELD
269	UPDATE_NET_ACCESS_LEVEL	UPDATE_NET_ACCESS_LEVEL
270	UPDATE_ORG_ADDRESS	UPDATE_ORG_ADDRESS
271	UPDATE_ORG_TYPE	UPDATE_ORG_TYPE
272	UPDATE_ORG_UNIT_CLOSING	UPDATE_ORG_UNIT_CLOSING
273	UPDATE_PERM	UPDATE_PERM
274	UPDATE_RELEVANCE_ADJUSTMENT	UPDATE_RELEVANCE_ADJUSTMENT
275	UPDATE_SURVEY	UPDATE_SURVEY
276	UPDATE_TRANSIT	UPDATE_TRANSIT
277	UPDATE_VOLUME_NOTE	UPDATE_VOLUME_NOTE
278	UPDATE_VR_FORMAT	UPDATE_VR_FORMAT
279	UPDATE_XML_TRANSFORM	UPDATE_XML_TRANSFORM
280	MERGE_BIB_RECORDS	MERGE_BIB_RECORDS
281	UPDATE_PICKUP_LIB_FROM_HOLDS_SHELF	UPDATE_PICKUP_LIB_FROM_HOLDS_SHELF
282	CREATE_ACQ_FUNDING_SOURCE	CREATE_ACQ_FUNDING_SOURCE
283	CREATE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF	CREATE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF
284	CREATE_AUTHORITY_IMPORT_QUEUE	CREATE_AUTHORITY_IMPORT_QUEUE
285	CREATE_AUTHORITY_RECORD_NOTE	CREATE_AUTHORITY_RECORD_NOTE
286	CREATE_BIB_IMPORT_FIELD_DEF	CREATE_BIB_IMPORT_FIELD_DEF
287	CREATE_BIB_IMPORT_QUEUE	CREATE_BIB_IMPORT_QUEUE
288	CREATE_LOCALE	CREATE_LOCALE
289	CREATE_MARC_CODE	CREATE_MARC_CODE
290	CREATE_TRANSLATION	CREATE_TRANSLATION
291	DELETE_ACQ_FUNDING_SOURCE	DELETE_ACQ_FUNDING_SOURCE
292	DELETE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF	DELETE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF
293	DELETE_AUTHORITY_IMPORT_QUEUE	DELETE_AUTHORITY_IMPORT_QUEUE
294	DELETE_AUTHORITY_RECORD_NOTE	DELETE_AUTHORITY_RECORD_NOTE
295	DELETE_BIB_IMPORT_IMPORT_FIELD_DEF	DELETE_BIB_IMPORT_IMPORT_FIELD_DEF
296	DELETE_BIB_IMPORT_QUEUE	DELETE_BIB_IMPORT_QUEUE
297	DELETE_LOCALE	DELETE_LOCALE
298	DELETE_MARC_CODE	DELETE_MARC_CODE
299	DELETE_TRANSLATION	DELETE_TRANSLATION
300	UPDATE_ACQ_FUNDING_SOURCE	UPDATE_ACQ_FUNDING_SOURCE
301	UPDATE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF	UPDATE_AUTHORITY_IMPORT_IMPORT_FIELD_DEF
302	UPDATE_AUTHORITY_IMPORT_QUEUE	UPDATE_AUTHORITY_IMPORT_QUEUE
303	UPDATE_AUTHORITY_RECORD_NOTE	UPDATE_AUTHORITY_RECORD_NOTE
304	UPDATE_BIB_IMPORT_IMPORT_FIELD_DEF	UPDATE_BIB_IMPORT_IMPORT_FIELD_DEF
305	UPDATE_BIB_IMPORT_QUEUE	UPDATE_BIB_IMPORT_QUEUE
306	UPDATE_LOCALE	UPDATE_LOCALE
307	UPDATE_MARC_CODE	UPDATE_MARC_CODE
308	UPDATE_TRANSLATION	UPDATE_TRANSLATION
309	VIEW_ACQ_FUNDING_SOURCE	VIEW_ACQ_FUNDING_SOURCE
310	VIEW_AUTHORITY_RECORD_NOTES	VIEW_AUTHORITY_RECORD_NOTES
311	CREATE_IMPORT_ITEM	CREATE_IMPORT_ITEM
312	CREATE_IMPORT_ITEM_ATTR_DEF	CREATE_IMPORT_ITEM_ATTR_DEF
313	CREATE_IMPORT_TRASH_FIELD	CREATE_IMPORT_TRASH_FIELD
314	DELETE_IMPORT_ITEM	DELETE_IMPORT_ITEM
315	DELETE_IMPORT_ITEM_ATTR_DEF	DELETE_IMPORT_ITEM_ATTR_DEF
316	DELETE_IMPORT_TRASH_FIELD	DELETE_IMPORT_TRASH_FIELD
317	UPDATE_IMPORT_ITEM	UPDATE_IMPORT_ITEM
318	UPDATE_IMPORT_ITEM_ATTR_DEF	UPDATE_IMPORT_ITEM_ATTR_DEF
319	UPDATE_IMPORT_TRASH_FIELD	UPDATE_IMPORT_TRASH_FIELD
320	UPDATE_ORG_UNIT_SETTING_ALL	UPDATE_ORG_UNIT_SETTING_ALL
321	UPDATE_ORG_UNIT_SETTING.circ.lost_materials_processing_fee	UPDATE_ORG_UNIT_SETTING.circ.lost_materials_processing_fee
322	UPDATE_ORG_UNIT_SETTING.cat.default_item_price	UPDATE_ORG_UNIT_SETTING.cat.default_item_price
323	UPDATE_ORG_UNIT_SETTING.auth.opac_timeout	UPDATE_ORG_UNIT_SETTING.auth.opac_timeout
324	UPDATE_ORG_UNIT_SETTING.auth.staff_timeout	UPDATE_ORG_UNIT_SETTING.auth.staff_timeout
325	UPDATE_ORG_UNIT_SETTING.org.bounced_emails	UPDATE_ORG_UNIT_SETTING.org.bounced_emails
326	UPDATE_ORG_UNIT_SETTING.circ.hold_expire_alert_interval	UPDATE_ORG_UNIT_SETTING.circ.hold_expire_alert_interval
327	UPDATE_ORG_UNIT_SETTING.circ.hold_expire_interval	UPDATE_ORG_UNIT_SETTING.circ.hold_expire_interval
328	UPDATE_ORG_UNIT_SETTING.credit.payments.allow	UPDATE_ORG_UNIT_SETTING.credit.payments.allow
329	UPDATE_ORG_UNIT_SETTING.circ.void_overdue_on_lost	UPDATE_ORG_UNIT_SETTING.circ.void_overdue_on_lost
330	UPDATE_ORG_UNIT_SETTING.circ.hold_stalling.soft	UPDATE_ORG_UNIT_SETTING.circ.hold_stalling.soft
331	UPDATE_ORG_UNIT_SETTING.circ.hold_boundary.hard	UPDATE_ORG_UNIT_SETTING.circ.hold_boundary.hard
332	UPDATE_ORG_UNIT_SETTING.circ.hold_boundary.soft	UPDATE_ORG_UNIT_SETTING.circ.hold_boundary.soft
333	UPDATE_ORG_UNIT_SETTING.opac.barcode_regex	UPDATE_ORG_UNIT_SETTING.opac.barcode_regex
334	UPDATE_ORG_UNIT_SETTING.global.password_regex	UPDATE_ORG_UNIT_SETTING.global.password_regex
335	UPDATE_ORG_UNIT_SETTING.circ.item_checkout_history.max	UPDATE_ORG_UNIT_SETTING.circ.item_checkout_history.max
336	UPDATE_ORG_UNIT_SETTING.circ.reshelving_complete.interval	UPDATE_ORG_UNIT_SETTING.circ.reshelving_complete.interval
337	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.patron_login_timeout	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.patron_login_timeout
338	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.alert_on_checkout_event	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.alert_on_checkout_event
339	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.require_patron_password	UPDATE_ORG_UNIT_SETTING.circ.selfcheck.require_patron_password
340	UPDATE_ORG_UNIT_SETTING.global.juvenile_age_threshold	UPDATE_ORG_UNIT_SETTING.global.juvenile_age_threshold
341	UPDATE_ORG_UNIT_SETTING.cat.bib.keep_on_empty	UPDATE_ORG_UNIT_SETTING.cat.bib.keep_on_empty
342	UPDATE_ORG_UNIT_SETTING.cat.bib.alert_on_empty	UPDATE_ORG_UNIT_SETTING.cat.bib.alert_on_empty
343	UPDATE_ORG_UNIT_SETTING.patron.password.use_phone	UPDATE_ORG_UNIT_SETTING.patron.password.use_phone
344	HOLD_ITEM_CHECKED_OUT.override	Allows a user to place a hold on an item that they already have checked out
345	ADMIN_ACQ_CANCEL_CAUSE	Allow a user to create/update/delete reasons for order cancellations
346	ACQ_XFER_MANUAL_DFUND_AMOUNT	Allow a user to transfer different amounts of money out of one fund and into another
347	OVERRIDE_HOLD_HAS_LOCAL_COPY	Allow a user to override the circ.holds.hold_has_copy_at.block setting
348	UPDATE_PICKUP_LIB_FROM_TRANSIT	Allow a user to change the pickup and transit destination for a captured hold item already in transit
349	COPY_NEEDED_FOR_HOLD.override	Allow a user to force renewal of an item that could fulfill a hold request
350	MERGE_AUTH_RECORDS	Allow a user to merge authority records together
351	ALLOW_ALT_TCN	Allows staff to import a record using an alternate TCN to avoid conflicts
352	ADMIN_TRIGGER_EVENT_DEF	Allow a user to administer trigger event definitions
353	ADMIN_TRIGGER_CLEANUP	Allow a user to create, delete, and update trigger cleanup entries
354	CREATE_TRIGGER_CLEANUP	Allow a user to create trigger cleanup entries
355	DELETE_TRIGGER_CLEANUP	Allow a user to delete trigger cleanup entries
356	UPDATE_TRIGGER_CLEANUP	Allow a user to update trigger cleanup entries
357	CREATE_TRIGGER_EVENT_DEF	Allow a user to create trigger event definitions
358	DELETE_TRIGGER_EVENT_DEF	Allow a user to delete trigger event definitions
359	UPDATE_TRIGGER_EVENT_DEF	Allow a user to update trigger event definitions
360	VIEW_TRIGGER_EVENT_DEF	Allow a user to view trigger event definitions
361	ADMIN_TRIGGER_HOOK	Allow a user to create, update, and delete trigger hooks
362	CREATE_TRIGGER_HOOK	Allow a user to create trigger hooks
363	DELETE_TRIGGER_HOOK	Allow a user to delete trigger hooks
364	UPDATE_TRIGGER_HOOK	Allow a user to update trigger hooks
365	ADMIN_TRIGGER_REACTOR	Allow a user to create, update, and delete trigger reactors
366	CREATE_TRIGGER_REACTOR	Allow a user to create trigger reactors
367	DELETE_TRIGGER_REACTOR	Allow a user to delete trigger reactors
368	UPDATE_TRIGGER_REACTOR	Allow a user to update trigger reactors
369	ADMIN_TRIGGER_TEMPLATE_OUTPUT	Allow a user to delete trigger template output
370	DELETE_TRIGGER_TEMPLATE_OUTPUT	Allow a user to delete trigger template output
371	ADMIN_TRIGGER_VALIDATOR	Allow a user to create, update, and delete trigger validators
372	CREATE_TRIGGER_VALIDATOR	Allow a user to create trigger validators
373	DELETE_TRIGGER_VALIDATOR	Allow a user to delete trigger validators
374	UPDATE_TRIGGER_VALIDATOR	Allow a user to update trigger validators
376	ADMIN_BOOKING_RESOURCE	Enables the user to create/update/delete booking resources
377	ADMIN_BOOKING_RESOURCE_TYPE	Enables the user to create/update/delete booking resource types
378	ADMIN_BOOKING_RESOURCE_ATTR	Enables the user to create/update/delete booking resource attributes
379	ADMIN_BOOKING_RESOURCE_ATTR_MAP	Enables the user to create/update/delete booking resource attribute maps
380	ADMIN_BOOKING_RESOURCE_ATTR_VALUE	Enables the user to create/update/delete booking resource attribute values
381	ADMIN_BOOKING_RESERVATION	Enables the user to create/update/delete booking reservations
382	ADMIN_BOOKING_RESERVATION_ATTR_VALUE_MAP	Enables the user to create/update/delete booking reservation attribute value maps
383	RETRIEVE_RESERVATION_PULL_LIST	Allows a user to retrieve a booking reservation pull list
384	CAPTURE_RESERVATION	Allows a user to capture booking reservations
385	UPDATE_RECORD	UPDATE_RECORD
386	UPDATE_ORG_UNIT_SETTING.circ.block_renews_for_holds	UPDATE_ORG_UNIT_SETTING.circ.block_renews_for_holds
387	MERGE_USERS	Allows user records to be merged
388	ISSUANCE_HOLDS	Allow a user to place holds on serials issuances
389	VIEW_CREDIT_CARD_PROCESSING	View org unit settings related to credit card processing
390	ADMIN_CREDIT_CARD_PROCESSING	Update org unit settings related to credit card processing
391	ADMIN_ACQ_CLAIM	ADMIN_ACQ_CLAIM
392	ADMIN_ACQ_CLAIM_EVENT_TYPE	ADMIN_ACQ_CLAIM_EVENT_TYPE
393	ADMIN_ACQ_CLAIM_TYPE	ADMIN_ACQ_CLAIM_TYPE
394	ADMIN_ACQ_DISTRIB_FORMULA	ADMIN_ACQ_DISTRIB_FORMULA
395	ADMIN_ACQ_FISCAL_YEAR	ADMIN_ACQ_FISCAL_YEAR
396	ADMIN_ACQ_FUND_ALLOCATION_PERCENT	ADMIN_ACQ_FUND_ALLOCATION_PERCENT
397	ADMIN_ACQ_FUND_TAG	ADMIN_ACQ_FUND_TAG
398	ADMIN_ACQ_LINEITEM_ALERT_TEXT	ADMIN_ACQ_LINEITEM_ALERT_TEXT
399	ADMIN_AGE_PROTECT_RULE	ADMIN_AGE_PROTECT_RULE
400	ADMIN_ASSET_COPY_TEMPLATE	ADMIN_ASSET_COPY_TEMPLATE
401	ADMIN_BOOKING_RESERVATION_ATTR_MAP	ADMIN_BOOKING_RESERVATION_ATTR_MAP
402	ADMIN_CIRC_MATRIX_MATCHPOINT	ADMIN_CIRC_MATRIX_MATCHPOINT
403	ADMIN_CIRC_MOD	ADMIN_CIRC_MOD
404	ADMIN_CLAIM_POLICY	ADMIN_CLAIM_POLICY
405	ADMIN_CONFIG_REMOTE_ACCOUNT	ADMIN_CONFIG_REMOTE_ACCOUNT
406	ADMIN_FIELD_DOC	ADMIN_FIELD_DOC
407	ADMIN_GLOBAL_FLAG	ADMIN_GLOBAL_FLAG
408	ADMIN_GROUP_PENALTY_THRESHOLD	ADMIN_GROUP_PENALTY_THRESHOLD
409	ADMIN_HOLD_CANCEL_CAUSE	ADMIN_HOLD_CANCEL_CAUSE
410	ADMIN_HOLD_MATRIX_MATCHPOINT	ADMIN_HOLD_MATRIX_MATCHPOINT
411	ADMIN_IDENT_TYPE	ADMIN_IDENT_TYPE
412	ADMIN_IMPORT_ITEM_ATTR_DEF	ADMIN_IMPORT_ITEM_ATTR_DEF
413	ADMIN_INDEX_NORMALIZER	ADMIN_INDEX_NORMALIZER
414	ADMIN_INVOICE	ADMIN_INVOICE
415	ADMIN_INVOICE_METHOD	ADMIN_INVOICE_METHOD
416	ADMIN_INVOICE_PAYMENT_METHOD	ADMIN_INVOICE_PAYMENT_METHOD
417	ADMIN_LINEITEM_MARC_ATTR_DEF	ADMIN_LINEITEM_MARC_ATTR_DEF
418	ADMIN_MARC_CODE	ADMIN_MARC_CODE
419	ADMIN_MAX_FINE_RULE	ADMIN_MAX_FINE_RULE
420	ADMIN_MERGE_PROFILE	ADMIN_MERGE_PROFILE
421	ADMIN_ORG_UNIT_SETTING_TYPE	ADMIN_ORG_UNIT_SETTING_TYPE
422	ADMIN_RECURRING_FINE_RULE	ADMIN_RECURRING_FINE_RULE
423	ADMIN_SERIAL_SUBSCRIPTION	ADMIN_SERIAL_SUBSCRIPTION
424	ADMIN_STANDING_PENALTY	ADMIN_STANDING_PENALTY
425	ADMIN_SURVEY	ADMIN_SURVEY
426	ADMIN_USER_REQUEST_TYPE	ADMIN_USER_REQUEST_TYPE
427	ADMIN_USER_SETTING_GROUP	ADMIN_USER_SETTING_GROUP
428	ADMIN_USER_SETTING_TYPE	ADMIN_USER_SETTING_TYPE
429	ADMIN_Z3950_SOURCE	ADMIN_Z3950_SOURCE
430	CREATE_BIB_BTYPE	CREATE_BIB_BTYPE
431	CREATE_BIBLIO_FINGERPRINT	CREATE_BIBLIO_FINGERPRINT
432	CREATE_BIB_SOURCE	CREATE_BIB_SOURCE
433	CREATE_BILLING_TYPE	CREATE_BILLING_TYPE
434	CREATE_CN_BTYPE	CREATE_CN_BTYPE
435	CREATE_COPY_BTYPE	CREATE_COPY_BTYPE
436	CREATE_INVOICE	CREATE_INVOICE
437	CREATE_INVOICE_ITEM_TYPE	CREATE_INVOICE_ITEM_TYPE
438	CREATE_INVOICE_METHOD	CREATE_INVOICE_METHOD
439	CREATE_MERGE_PROFILE	CREATE_MERGE_PROFILE
440	CREATE_METABIB_CLASS	CREATE_METABIB_CLASS
441	CREATE_METABIB_SEARCH_ALIAS	CREATE_METABIB_SEARCH_ALIAS
442	CREATE_USER_BTYPE	CREATE_USER_BTYPE
443	DELETE_BIB_BTYPE	DELETE_BIB_BTYPE
444	DELETE_BIBLIO_FINGERPRINT	DELETE_BIBLIO_FINGERPRINT
445	DELETE_BIB_SOURCE	DELETE_BIB_SOURCE
446	DELETE_BILLING_TYPE	DELETE_BILLING_TYPE
447	DELETE_CN_BTYPE	DELETE_CN_BTYPE
448	DELETE_COPY_BTYPE	DELETE_COPY_BTYPE
449	DELETE_INVOICE_ITEM_TYPE	DELETE_INVOICE_ITEM_TYPE
450	DELETE_INVOICE_METHOD	DELETE_INVOICE_METHOD
451	DELETE_MERGE_PROFILE	DELETE_MERGE_PROFILE
452	DELETE_METABIB_CLASS	DELETE_METABIB_CLASS
453	DELETE_METABIB_SEARCH_ALIAS	DELETE_METABIB_SEARCH_ALIAS
454	DELETE_USER_BTYPE	DELETE_USER_BTYPE
455	MANAGE_CLAIM	MANAGE_CLAIM
456	UPDATE_BIB_BTYPE	UPDATE_BIB_BTYPE
457	UPDATE_BIBLIO_FINGERPRINT	UPDATE_BIBLIO_FINGERPRINT
458	UPDATE_BIB_SOURCE	UPDATE_BIB_SOURCE
459	UPDATE_BILLING_TYPE	UPDATE_BILLING_TYPE
460	UPDATE_CN_BTYPE	UPDATE_CN_BTYPE
461	UPDATE_COPY_BTYPE	UPDATE_COPY_BTYPE
462	UPDATE_INVOICE_ITEM_TYPE	UPDATE_INVOICE_ITEM_TYPE
463	UPDATE_INVOICE_METHOD	UPDATE_INVOICE_METHOD
464	UPDATE_MERGE_PROFILE	UPDATE_MERGE_PROFILE
465	UPDATE_METABIB_CLASS	UPDATE_METABIB_CLASS
466	UPDATE_METABIB_SEARCH_ALIAS	UPDATE_METABIB_SEARCH_ALIAS
467	UPDATE_USER_BTYPE	UPDATE_USER_BTYPE
468	user_request.create	user_request.create
469	user_request.delete	user_request.delete
470	user_request.update	user_request.update
471	user_request.view	user_request.view
472	VIEW_ACQ_FUND_ALLOCATION_PERCENT	VIEW_ACQ_FUND_ALLOCATION_PERCENT
473	VIEW_CIRC_MATRIX_MATCHPOINT	VIEW_CIRC_MATRIX_MATCHPOINT
474	VIEW_CLAIM	VIEW_CLAIM
475	VIEW_GROUP_PENALTY_THRESHOLD	VIEW_GROUP_PENALTY_THRESHOLD
476	VIEW_HOLD_MATRIX_MATCHPOINT	VIEW_HOLD_MATRIX_MATCHPOINT
477	VIEW_INVOICE	VIEW_INVOICE
478	VIEW_MERGE_PROFILE	VIEW_MERGE_PROFILE
479	VIEW_SERIAL_SUBSCRIPTION	VIEW_SERIAL_SUBSCRIPTION
480	VIEW_STANDING_PENALTY	VIEW_STANDING_PENALTY
481	ADMIN_SERIAL_CAPTION_PATTERN	ADMIN_SERIAL_CAPTION_PATTERN
482	ADMIN_SERIAL_DISTRIBUTION	ADMIN_SERIAL_DISTRIBUTION
483	ADMIN_SERIAL_STREAM	ADMIN_SERIAL_STREAM
484	RECEIVE_SERIAL	Receive serial items
485	CREATE_VOLUME_SUFFIX	Create suffix label definition.
486	UPDATE_VOLUME_SUFFIX	Update suffix label definition.
487	DELETE_VOLUME_SUFFIX	Delete suffix label definition.
488	CREATE_VOLUME_PREFIX	Create prefix label definition.
489	UPDATE_VOLUME_PREFIX	Update prefix label definition.
490	DELETE_VOLUME_PREFIX	Delete prefix label definition.
491	CREATE_MONOGRAPH_PART	Create monograph part definition.
492	UPDATE_MONOGRAPH_PART	Update monograph part definition.
493	DELETE_MONOGRAPH_PART	Delete monograph part definition.
494	ADMIN_CODED_VALUE	Create/Update/Delete SVF Record Attribute Coded Value Map
495	ADMIN_SERIAL_ITEM	Create/Retrieve/Update/Delete Serial Item
496	ADMIN_SVF	Create/Update/Delete SVF Record Attribute Defintion
497	CREATE_BIB_PTYPE	Create Bibliographic Record Peer Type
498	CREATE_PURCHASE_REQUEST	Create User Purchase Request
499	DELETE_BIB_PTYPE	Delete Bibliographic Record Peer Type
500	MAP_MONOGRAPH_PART	Create/Update/Delete Copy Monograph Part Map
501	MARK_ITEM_MISSING_PIECES	Allows the Mark Item Missing Pieces action.
502	UPDATE_BIB_PTYPE	Update Bibliographic Record Peer Type
503	UPDATE_HOLD_REQUEST_TIME	Allows editing of a hold's request time, and/or its Cut-in-line/Top-of-queue flag.
504	UPDATE_PICKLIST	Allows update/re-use of an acquisitions pick/selection list.
505	UPDATE_WORKSTATION	Allows update of a workstation during workstation registration override.
506	VIEW_USER_SETTING_TYPE	Allows viewing of configurable user setting types.
507	ABORT_TRANSIT_ON_LOST	Allows a user to abort a transit on a copy with status of LOST
508	ABORT_TRANSIT_ON_MISSING	Allows a user to abort a transit on a copy with status of MISSING
509	TRANSIT_CHECKIN_INTERVAL_BLOCK.override	Allows a user to override the TRANSIT_CHECKIN_INTERVAL_BLOCK event
510	UPDATE_PATRON_COLLECTIONS_EXEMPT	Allows a user to indicate that a patron is exempt from collections processing
511	PERSISTENT_LOGIN	Allows a user to authenticate and get a long-lived session (length configured in opensrf.xml)
512	ACQ_INVOICE_REOPEN	Allows a user to reopen an Acquisitions invoice
513	DEBUG_CLIENT	Allows a user to use debug functions in the staff client
514	UPDATE_PATRON_ACTIVE_CARD	Allows a user to manually adjust a patron's active cards
515	UPDATE_PATRON_PRIMARY_CARD	Allows a user to manually adjust a patron's primary card
516	CREATE_REPORT_TEMPLATE	Allows a user to create report templates
517	COPY_HOLDS_FORCE	Allow a user to place a force hold on a specific copy
518	COPY_HOLDS_RECALL	Allow a user to place a cataloging recall on a specific copy
519	ADMIN_SMS_CARRIER	Allows a user to add/create/delete SMS Carrier entries.
520	COPY_DELETE_WARNING.override	Allow a user to override warnings about deleting copies in problematic situations.
521	IMPORT_ACQ_LINEITEM_BIB_RECORD_UPLOAD	Allows a user to create new bibs directly from an ACQ MARC file upload
522	IMPORT_AUTHORITY_MARC	Allows a user to create new authority records
523	ADMIN_TOOLBAR	Allows a user to create, edit, and delete custom toolbars
524	PLACE_UNFILLABLE_HOLD	Allows a user to place a hold that cannot currently be filled.
525	CREATE_PATRON_STAT_CAT_ENTRY_DEFAULT	User may set a default entry in a patron statistical category
526	UPDATE_PATRON_STAT_CAT_ENTRY_DEFAULT	User may reset a default entry in a patron statistical category
527	DELETE_PATRON_STAT_CAT_ENTRY_DEFAULT	User may unset a default entry in a patron statistical category
528	ADMIN_ORG_UNIT_CUSTOM_TREE	User may update custom org unit trees
529	ADMIN_IMPORT_MATCH_SET	Allows a user to create/retrieve/update/delete vandelay match sets
530	VIEW_IMPORT_MATCH_SET	Allows a user to view vandelay match sets
531	ADMIN_ADDRESS_ALERT	Allows a user to create/retrieve/update/delete address alerts
532	VIEW_ADDRESS_ALERT	Allows a user to view address alerts
533	ADMIN_COPY_LOCATION_GROUP	Allows a user to create/retrieve/update/delete copy location groups
534	ADMIN_USER_ACTIVITY_TYPE	Allows a user to create/retrieve/update/delete user activity types
535	VIEW_TRIGGER_EVENT	Allows a user to view circ- and hold-related action/trigger events
536	IMPORT_OVERLAY_COPY	Allows a user to overlay copy data in MARC import
537	ADMIN_SEARCH_FILTER_GROUP	Allows staff to manage search filter groups and entries
538	VIEW_SEARCH_FILTER_GROUP	Allows staff to view search filter groups and entries
539	UPDATE_ORG_UNIT_SETTING.ui.hide_copy_editor_fields	Allows staff to edit displayed copy editor fields
540	ADMIN_TOOLBAR_FOR_ORG	Allows a user to create, edit, and delete custom toolbars for org units
541	ADMIN_TOOLBAR_FOR_WORKSTATION	Allows a user to create, edit, and delete custom toolbars for workstations
542	ADMIN_TOOLBAR_FOR_USER	Allows a user to create, edit, and delete custom toolbars for users
543	URL_VERIFY	Allows a user to process and verify ULSs
544	URL_VERIFY_UPDATE_SETTINGS	Allows a user to configure URL verification org unit settings
545	SAVED_FILTER_DIALOG_FILTERS	Allows users to save and load sets of filters for filter dialogs, available in certain staff interfaces
546	ADMIN_HOLD_CAPTURE_SORT	Allows a user to make changes to best-hold selection sort order
547	ACQ_ADD_LINEITEM_IDENTIFIER	When granted, newly added lineitem identifiers will propagate to linked bib records
548	ACQ_SET_LINEITEM_IDENTIFIER	Allows staff to change the lineitem identifier
\.


--
-- Name: perm_list_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('perm_list_id_seq', 1000, true);


--
-- Data for Name: usr_grp_map; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY usr_grp_map (id, usr, grp) FROM stdin;
\.


--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('usr_grp_map_id_seq', 1, false);


--
-- Data for Name: usr_object_perm_map; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY usr_object_perm_map (id, usr, perm, object_type, object_id, grantable) FROM stdin;
\.


--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('usr_object_perm_map_id_seq', 1, false);


--
-- Data for Name: usr_perm_map; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY usr_perm_map (id, usr, perm, depth, grantable) FROM stdin;
1	1	-1	0	f
\.


--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('usr_perm_map_id_seq', 1, true);


--
-- Data for Name: usr_work_ou_map; Type: TABLE DATA; Schema: permission; Owner: postgres
--

COPY usr_work_ou_map (id, usr, work_ou) FROM stdin;
1	1	1
\.


--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE SET; Schema: permission; Owner: postgres
--

SELECT pg_catalog.setval('usr_work_ou_map_id_seq', 1, true);


SET search_path = query, pg_catalog;

--
-- Data for Name: bind_variable; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY bind_variable (name, type, description, default_value, label) FROM stdin;
\.


--
-- Data for Name: case_branch; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY case_branch (id, parent_expr, seq_no, condition, result) FROM stdin;
\.


--
-- Name: case_branch_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('case_branch_id_seq', 1, false);


--
-- Data for Name: datatype; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY datatype (id, datatype_name, is_numeric, is_composite) FROM stdin;
1	SMALLINT	t	f
2	INTEGER	t	f
3	BIGINT	t	f
4	DECIMAL	t	f
5	NUMERIC	t	f
6	REAL	t	f
7	DOUBLE PRECISION	t	f
8	SERIAL	t	f
9	BIGSERIAL	t	f
10	MONEY	f	f
11	VARCHAR	f	f
12	CHAR	f	f
13	TEXT	f	f
14	"char"	f	f
15	NAME	f	f
16	BYTEA	f	f
17	TIMESTAMP WITHOUT TIME ZONE	f	f
18	TIMESTAMP WITH TIME ZONE	f	f
19	DATE	f	f
20	TIME WITHOUT TIME ZONE	f	f
21	TIME WITH TIME ZONE	f	f
22	INTERVAL	f	f
23	BOOLEAN	f	f
\.


--
-- Name: datatype_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('datatype_id_seq', 1000, true);


--
-- Data for Name: expression; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY expression (id, type, parenthesize, parent_expr, seq_no, literal, table_alias, column_name, left_operand, operator, right_operand, function_id, subquery, cast_type, negate, bind_variable) FROM stdin;
\.


--
-- Name: expression_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('expression_id_seq', 1, false);


--
-- Data for Name: from_relation; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY from_relation (id, type, table_name, class_name, subquery, function_call, table_alias, parent_relation, seq_no, join_type, on_clause) FROM stdin;
\.


--
-- Name: from_relation_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('from_relation_id_seq', 1, false);


--
-- Data for Name: function_param_def; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY function_param_def (id, function_id, seq_no, datatype) FROM stdin;
\.


--
-- Name: function_param_def_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('function_param_def_id_seq', 1, false);


--
-- Data for Name: function_sig; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY function_sig (id, function_name, return_type, is_aggregate) FROM stdin;
\.


--
-- Name: function_sig_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('function_sig_id_seq', 1, false);


--
-- Data for Name: order_by_item; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY order_by_item (id, stored_query, seq_no, expression) FROM stdin;
\.


--
-- Name: order_by_item_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('order_by_item_id_seq', 1, false);


--
-- Data for Name: query_sequence; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY query_sequence (id, parent_query, seq_no, child_query) FROM stdin;
\.


--
-- Name: query_sequence_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('query_sequence_id_seq', 1, false);


--
-- Data for Name: record_column; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY record_column (id, from_relation, seq_no, column_name, column_type) FROM stdin;
\.


--
-- Name: record_column_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('record_column_id_seq', 1, false);


--
-- Data for Name: select_item; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY select_item (id, stored_query, seq_no, expression, column_alias, grouped_by) FROM stdin;
\.


--
-- Name: select_item_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('select_item_id_seq', 1, false);


--
-- Data for Name: stored_query; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY stored_query (id, type, use_all, use_distinct, from_clause, where_clause, having_clause, limit_count, offset_count) FROM stdin;
\.


--
-- Name: stored_query_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('stored_query_id_seq', 1, false);


--
-- Data for Name: subfield; Type: TABLE DATA; Schema: query; Owner: postgres
--

COPY subfield (id, composite_type, seq_no, subfield_type) FROM stdin;
\.


--
-- Name: subfield_id_seq; Type: SEQUENCE SET; Schema: query; Owner: postgres
--

SELECT pg_catalog.setval('subfield_id_seq', 1, false);


SET search_path = reporter, pg_catalog;

--
-- Data for Name: materialized_simple_record; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY materialized_simple_record (id, fingerprint, quality, tcn_source, tcn_value, title, author, publisher, pubdate, isbn, issn) FROM stdin;
\.


--
-- Data for Name: output_folder; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY output_folder (id, parent, owner, create_time, name, shared, share_with) FROM stdin;
\.


--
-- Name: output_folder_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('output_folder_id_seq', 1, false);


--
-- Data for Name: report; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY report (id, owner, create_time, name, description, template, data, folder, recur, recurrence) FROM stdin;
\.


--
-- Data for Name: report_folder; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY report_folder (id, parent, owner, create_time, name, shared, share_with) FROM stdin;
\.


--
-- Name: report_folder_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('report_folder_id_seq', 1, false);


--
-- Name: report_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('report_id_seq', 1, false);


--
-- Data for Name: schedule; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY schedule (id, report, folder, runner, run_time, start_time, complete_time, email, excel_format, html_format, csv_format, chart_pie, chart_bar, chart_line, error_code, error_text) FROM stdin;
\.


--
-- Name: schedule_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('schedule_id_seq', 1, false);


--
-- Data for Name: template; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY template (id, owner, create_time, name, description, data, folder) FROM stdin;
\.


--
-- Data for Name: template_folder; Type: TABLE DATA; Schema: reporter; Owner: postgres
--

COPY template_folder (id, parent, owner, create_time, name, shared, share_with) FROM stdin;
\.


--
-- Name: template_folder_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('template_folder_id_seq', 1, false);


--
-- Name: template_id_seq; Type: SEQUENCE SET; Schema: reporter; Owner: postgres
--

SELECT pg_catalog.setval('template_id_seq', 1, false);


SET search_path = search, pg_catalog;

--
-- Data for Name: relevance_adjustment; Type: TABLE DATA; Schema: search; Owner: postgres
--

COPY relevance_adjustment (id, active, field, bump_type, multiplier) FROM stdin;
1	t	1	first_word	1.5
2	t	1	full_match	20
3	t	2	first_word	1.5
4	t	2	word_order	10
5	t	2	full_match	20
6	t	3	first_word	1.5
7	t	3	word_order	10
8	t	3	full_match	20
9	t	4	first_word	1.5
10	t	4	word_order	10
11	t	4	full_match	20
12	t	5	first_word	1.5
13	t	5	word_order	10
14	t	5	full_match	20
15	t	6	first_word	1.5
16	t	6	word_order	10
17	t	6	full_match	20
18	t	7	first_word	1.5
19	t	8	first_word	1.5
20	t	9	first_word	1.5
21	t	10	first_word	1.5
22	t	15	word_order	10
\.


--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE SET; Schema: search; Owner: postgres
--

SELECT pg_catalog.setval('relevance_adjustment_id_seq', 22, true);


SET search_path = serial, pg_catalog;

--
-- Data for Name: basic_summary; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY basic_summary (id, distribution, generated_coverage, textual_holdings, show_generated) FROM stdin;
\.


--
-- Name: basic_summary_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('basic_summary_id_seq', 1, false);


--
-- Data for Name: caption_and_pattern; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY caption_and_pattern (id, subscription, type, create_date, start_date, end_date, active, pattern_code, enum_1, enum_2, enum_3, enum_4, enum_5, enum_6, chron_1, chron_2, chron_3, chron_4, chron_5) FROM stdin;
\.


--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('caption_and_pattern_id_seq', 1, false);


--
-- Data for Name: distribution; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY distribution (id, record_entry, summary_method, subscription, holding_lib, label, display_grouping, receive_call_number, receive_unit_template, bind_call_number, bind_unit_template, unit_label_prefix, unit_label_suffix) FROM stdin;
\.


--
-- Name: distribution_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('distribution_id_seq', 1, false);


--
-- Data for Name: distribution_note; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY distribution_note (id, distribution, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: distribution_note_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('distribution_note_id_seq', 1, false);


--
-- Data for Name: index_summary; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY index_summary (id, distribution, generated_coverage, textual_holdings, show_generated) FROM stdin;
\.


--
-- Name: index_summary_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('index_summary_id_seq', 1, false);


--
-- Data for Name: issuance; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY issuance (id, creator, editor, create_date, edit_date, subscription, label, date_published, caption_and_pattern, holding_code, holding_type, holding_link_id) FROM stdin;
\.


--
-- Name: issuance_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('issuance_id_seq', 1, false);


--
-- Data for Name: item; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY item (id, creator, editor, create_date, edit_date, issuance, stream, unit, uri, date_expected, date_received, status, shadowed) FROM stdin;
\.


--
-- Name: item_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('item_id_seq', 1, false);


--
-- Data for Name: item_note; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY item_note (id, item, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: item_note_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('item_note_id_seq', 1, false);


--
-- Data for Name: materialized_holding_code; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY materialized_holding_code (id, issuance, subfield, value) FROM stdin;
\.


--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('materialized_holding_code_id_seq', 1, false);


--
-- Data for Name: record_entry; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY record_entry (id, record, owning_lib, creator, editor, source, create_date, edit_date, active, deleted, marc, last_xact_id) FROM stdin;
\.


--
-- Name: record_entry_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('record_entry_id_seq', 1, false);


--
-- Data for Name: routing_list_user; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY routing_list_user (id, stream, pos, reader, department, note) FROM stdin;
\.


--
-- Name: routing_list_user_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('routing_list_user_id_seq', 1, false);


--
-- Data for Name: stream; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY stream (id, distribution, routing_label) FROM stdin;
\.


--
-- Name: stream_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('stream_id_seq', 1, false);


--
-- Data for Name: subscription; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY subscription (id, owning_lib, start_date, end_date, record_entry, expected_date_offset) FROM stdin;
\.


--
-- Name: subscription_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('subscription_id_seq', 1, false);


--
-- Data for Name: subscription_note; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY subscription_note (id, subscription, creator, create_date, pub, title, value) FROM stdin;
\.


--
-- Name: subscription_note_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('subscription_note_id_seq', 1, false);


--
-- Data for Name: supplement_summary; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY supplement_summary (id, distribution, generated_coverage, textual_holdings, show_generated) FROM stdin;
\.


--
-- Name: supplement_summary_id_seq; Type: SEQUENCE SET; Schema: serial; Owner: postgres
--

SELECT pg_catalog.setval('supplement_summary_id_seq', 1, false);


--
-- Data for Name: unit; Type: TABLE DATA; Schema: serial; Owner: postgres
--

COPY unit (id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, active_date, mint_condition, cost, sort_key, detailed_contents, summary_contents) FROM stdin;
\.


SET search_path = staging, pg_catalog;

--
-- Data for Name: billing_address_stage; Type: TABLE DATA; Schema: staging; Owner: postgres
--

COPY billing_address_stage (row_id, row_date, usrname, street1, street2, city, state, country, post_code, complete) FROM stdin;
\.


--
-- Data for Name: card_stage; Type: TABLE DATA; Schema: staging; Owner: postgres
--

COPY card_stage (row_id, row_date, usrname, barcode, complete) FROM stdin;
\.


--
-- Name: card_stage_row_id_seq; Type: SEQUENCE SET; Schema: staging; Owner: postgres
--

SELECT pg_catalog.setval('card_stage_row_id_seq', 1, false);


--
-- Data for Name: mailing_address_stage; Type: TABLE DATA; Schema: staging; Owner: postgres
--

COPY mailing_address_stage (row_id, row_date, usrname, street1, street2, city, state, country, post_code, complete) FROM stdin;
\.


--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE SET; Schema: staging; Owner: postgres
--

SELECT pg_catalog.setval('mailing_address_stage_row_id_seq', 1, false);


--
-- Data for Name: statcat_stage; Type: TABLE DATA; Schema: staging; Owner: postgres
--

COPY statcat_stage (row_id, row_date, usrname, statcat, value, complete) FROM stdin;
\.


--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE SET; Schema: staging; Owner: postgres
--

SELECT pg_catalog.setval('statcat_stage_row_id_seq', 1, false);


--
-- Data for Name: user_stage; Type: TABLE DATA; Schema: staging; Owner: postgres
--

COPY user_stage (row_id, row_date, usrname, profile, email, passwd, ident_type, first_given_name, second_given_name, family_name, day_phone, evening_phone, home_ou, dob, complete) FROM stdin;
\.


--
-- Name: user_stage_row_id_seq; Type: SEQUENCE SET; Schema: staging; Owner: postgres
--

SELECT pg_catalog.setval('user_stage_row_id_seq', 1, false);


SET search_path = unapi, pg_catalog;

--
-- Data for Name: bre_output_layout; Type: TABLE DATA; Schema: unapi; Owner: postgres
--

COPY bre_output_layout (name, transform, mime_type, feed_top, holdings_element, title_element, description_element, creator_element, update_ts_element) FROM stdin;
holdings_xml	\N	application/xml	hxml	\N	\N	\N	\N	\N
marcxml	marcxml	application/marc+xml	collection	record	\N	\N	\N	\N
mods32	mods32	application/mods+xml	modsCollection	mods	\N	\N	\N	\N
\.


SET search_path = url_verify, pg_catalog;

--
-- Data for Name: session; Type: TABLE DATA; Schema: url_verify; Owner: postgres
--

COPY session (id, name, owning_lib, creator, container, create_time, search) FROM stdin;
\.


--
-- Name: session_id_seq; Type: SEQUENCE SET; Schema: url_verify; Owner: postgres
--

SELECT pg_catalog.setval('session_id_seq', 1, false);


--
-- Data for Name: url; Type: TABLE DATA; Schema: url_verify; Owner: postgres
--

COPY url (id, redirect_from, item, session, url_selector, tag, subfield, ord, full_url, scheme, username, password, host, domain, tld, port, path, page, query, fragment) FROM stdin;
\.


--
-- Name: url_id_seq; Type: SEQUENCE SET; Schema: url_verify; Owner: postgres
--

SELECT pg_catalog.setval('url_id_seq', 1, false);


--
-- Data for Name: url_selector; Type: TABLE DATA; Schema: url_verify; Owner: postgres
--

COPY url_selector (id, xpath, session) FROM stdin;
\.


--
-- Name: url_selector_id_seq; Type: SEQUENCE SET; Schema: url_verify; Owner: postgres
--

SELECT pg_catalog.setval('url_selector_id_seq', 1, false);


--
-- Data for Name: url_verification; Type: TABLE DATA; Schema: url_verify; Owner: postgres
--

COPY url_verification (id, url, attempt, req_time, res_time, res_code, res_text, redirect_to) FROM stdin;
\.


--
-- Name: url_verification_id_seq; Type: SEQUENCE SET; Schema: url_verify; Owner: postgres
--

SELECT pg_catalog.setval('url_verification_id_seq', 1, false);


--
-- Data for Name: verification_attempt; Type: TABLE DATA; Schema: url_verify; Owner: postgres
--

COPY verification_attempt (id, usr, session, start_time, finish_time) FROM stdin;
\.


--
-- Name: verification_attempt_id_seq; Type: SEQUENCE SET; Schema: url_verify; Owner: postgres
--

SELECT pg_catalog.setval('verification_attempt_id_seq', 1, false);


SET search_path = vandelay, pg_catalog;

--
-- Data for Name: authority_attr_definition; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY authority_attr_definition (id, code, description, xpath, remove) FROM stdin;
1	rec_identifier	Identifier	//*[@tag="001"]	
\.


--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('authority_attr_definition_id_seq', 100, true);


--
-- Data for Name: authority_match; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY authority_match (id, queued_record, eg_record, quality) FROM stdin;
\.


--
-- Name: authority_match_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('authority_match_id_seq', 1, false);


--
-- Data for Name: authority_queue; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY authority_queue (id, owner, name, complete, match_set, queue_type) FROM stdin;
\.


--
-- Data for Name: bib_attr_definition; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY bib_attr_definition (id, code, description, xpath, remove) FROM stdin;
1	title	Title of work	//*[@tag="245"]/*[contains("abcmnopr",@code)]	
2	author	Author of work	//*[@tag="100" or @tag="110" or @tag="113"]/*[contains("ad",@code)]	
3	language	Language of work	//*[@tag="240"]/*[@code="l"][1]	
4	pagination	Pagination	//*[@tag="300"]/*[@code="a"][1]	
5	isbn	ISBN	//*[@tag="020"]/*[@code="a"]	(?:-|\\s.+$)
6	issn	ISSN	//*[@tag="022"]/*[@code="a"]	(?:-|\\s.+$)
7	price	Price	//*[@tag="020" or @tag="022"]/*[@code="c"][1]	
8	rec_identifier	Accession Number	//*[@tag="001"]	
9	eg_tcn	TCN Value	//*[@tag="901"]/*[@code="a"]	
10	eg_tcn_source	TCN Source	//*[@tag="901"]/*[@code="b"]	
11	eg_identifier	Internal ID	//*[@tag="901"]/*[@code="c"]	
12	publisher	Publisher	//*[@tag="260"]/*[@code="b"][1]	
13	pubdate	Publication Date	//*[@tag="260"]/*[@code="c"][1]	\\D
14	edition	Edition	//*[@tag="250"]/*[@code="a"][1]	
15	item_barcode	Item Barcode	//*[@tag="852"]/*[@code="p"][1]	
\.


--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('bib_attr_definition_id_seq', 100, true);


--
-- Data for Name: bib_match; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY bib_match (id, queued_record, eg_record, quality, match_score) FROM stdin;
\.


--
-- Name: bib_match_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('bib_match_id_seq', 1, false);


--
-- Data for Name: bib_queue; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY bib_queue (id, owner, name, complete, match_set, queue_type, item_attr_def) FROM stdin;
\.


--
-- Data for Name: import_bib_trash_fields; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY import_bib_trash_fields (id, grp, field) FROM stdin;
\.


--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('import_bib_trash_fields_id_seq', 1, false);


--
-- Data for Name: import_bib_trash_group; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY import_bib_trash_group (id, owner, label, always_apply) FROM stdin;
\.


--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('import_bib_trash_group_id_seq', 1, false);


--
-- Data for Name: import_error; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY import_error (code, description) FROM stdin;
general.unknown	Import or Overlay failed
import.item.duplicate.barcode	Import failed due to barcode collision
import.item.invalid.circ_modifier	Import failed due to invalid circulation modifier
import.item.invalid.location	Import failed due to invalid copy location
import.duplicate.sysid	Import failed due to system id collision
import.duplicate.tcn	Import failed due to system id collision
overlay.missing.sysid	Overlay failed due to missing system id
import.auth.duplicate.acn	Import failed due to Accession Number collision
import.xml.malformed	Malformed record cause Import failure
overlay.xml.malformed	Malformed record cause Overlay failure
overlay.record.quality	New record had insufficient quality
import.item.invalid.status	Invalid value for "status"
import.item.invalid.price	Invalid value for "price"
import.item.invalid.deposit_amount	Invalid value for "deposit_amount"
import.item.invalid.owning_lib	Invalid value for "owning_lib"
import.item.invalid.circ_lib	Invalid value for "circ_lib"
import.item.invalid.copy_number	Invalid value for "copy_number"
import.item.invalid.circ_as_type	Invalid value for "circ_as_type"
import.record.perm_failure	Perm failure creating a record
\.


--
-- Data for Name: import_item; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY import_item (id, record, definition, import_error, error_detail, imported_as, import_time, owning_lib, circ_lib, call_number, copy_number, status, location, circulate, deposit, deposit_amount, ref, holdable, price, barcode, circ_modifier, circ_as_type, alert_message, pub_note, priv_note, opac_visible, internal_id) FROM stdin;
\.


--
-- Data for Name: import_item_attr_definition; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY import_item_attr_definition (id, owner, name, tag, keep, owning_lib, circ_lib, call_number, copy_number, status, location, circulate, deposit, deposit_amount, ref, holdable, price, barcode, circ_modifier, circ_as_type, alert_message, opac_visible, pub_note_title, pub_note, priv_note_title, priv_note, internal_id) FROM stdin;
1	1	Evergreen 852 export format	852	f	[@code = "b"][1]	[@code = "b"][2]	j	t	z	c	[@code = "x" and text() = "circulating"]	\N	\N	[@code = "x" and text() = "reference"]	[@code = "x" and text() = "holdable"]	y	p	g	\N	\N	[@code = "x" and text() = "visible"]	\N	\N	\N	\N	\N
2	1	Unicorn Import format -- 999	999	f	m	\N	a	\N	k	l	\N	\N	\N	\N	\N	p	i	t	\N	\N	\N	\N	\N	\N	\N	\N
\.


--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('import_item_attr_definition_id_seq', 2, true);


--
-- Name: import_item_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('import_item_id_seq', 1, false);


--
-- Data for Name: match_set; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY match_set (id, name, owner, mtype) FROM stdin;
\.


--
-- Name: match_set_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('match_set_id_seq', 1, false);


--
-- Data for Name: match_set_point; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY match_set_point (id, match_set, parent, bool_op, svf, tag, subfield, negate, quality) FROM stdin;
\.


--
-- Name: match_set_point_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('match_set_point_id_seq', 1, false);


--
-- Data for Name: match_set_quality; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY match_set_quality (id, match_set, svf, tag, subfield, value, quality) FROM stdin;
\.


--
-- Name: match_set_quality_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('match_set_quality_id_seq', 1, false);


--
-- Data for Name: merge_profile; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY merge_profile (id, owner, name, add_spec, replace_spec, strip_spec, preserve_spec, lwm_ratio) FROM stdin;
1	1	Match-Only Merge	\N	901c	\N	\N	\N
2	1	Full Overlay	\N	\N	\N	901c	\N
\.


--
-- Name: merge_profile_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('merge_profile_id_seq', 2, true);


--
-- Data for Name: queue; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queue (id, owner, name, complete, match_set) FROM stdin;
\.


--
-- Name: queue_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('queue_id_seq', 1, false);


--
-- Data for Name: queued_authority_record; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queued_authority_record (id, create_time, import_time, purpose, marc, quality, queue, imported_as, import_error, error_detail) FROM stdin;
\.


--
-- Data for Name: queued_authority_record_attr; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queued_authority_record_attr (id, record, field, attr_value) FROM stdin;
\.


--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('queued_authority_record_attr_id_seq', 1, false);


--
-- Data for Name: queued_bib_record; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queued_bib_record (id, create_time, import_time, purpose, marc, quality, queue, bib_source, imported_as, import_error, error_detail) FROM stdin;
\.


--
-- Data for Name: queued_bib_record_attr; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queued_bib_record_attr (id, record, field, attr_value) FROM stdin;
\.


--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('queued_bib_record_attr_id_seq', 1, false);


--
-- Data for Name: queued_record; Type: TABLE DATA; Schema: vandelay; Owner: postgres
--

COPY queued_record (id, create_time, import_time, purpose, marc, quality) FROM stdin;
\.


--
-- Name: queued_record_id_seq; Type: SEQUENCE SET; Schema: vandelay; Owner: postgres
--

SELECT pg_catalog.setval('queued_record_id_seq', 1, false);


SET search_path = acq, pg_catalog;

--
-- Name: acq_cancel_reason_one_per_org_unit; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT acq_cancel_reason_one_per_org_unit UNIQUE (org_unit, label);


--
-- Name: acq_fy_logical_key; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT acq_fy_logical_key UNIQUE (calendar, year);


--
-- Name: acq_fy_physical_key; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT acq_fy_physical_key UNIQUE (calendar, year_begin);


--
-- Name: acq_lineitem_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acq_lineitem_history
    ADD CONSTRAINT acq_lineitem_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_purchase_order_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acq_purchase_order_history
    ADD CONSTRAINT acq_purchase_order_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acqdf_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT acqdf_name_once_per_owner UNIQUE (name, owner);


--
-- Name: acqdfe_lib_once_per_formula; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT acqdfe_lib_once_per_formula UNIQUE (formula, "position");


--
-- Name: acqft_tag_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT acqft_tag_once_per_owner UNIQUE (name, owner);


--
-- Name: acqftm_fund_once_per_tag; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT acqftm_fund_once_per_tag UNIQUE (fund, tag);


--
-- Name: action_sequence; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT action_sequence UNIQUE (claim_policy, action_interval);


--
-- Name: alert_one_code_per_org; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT alert_one_code_per_org UNIQUE (code, owning_lib);


--
-- Name: cancel_reason_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT cancel_reason_pkey PRIMARY KEY (id);


--
-- Name: claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_pkey PRIMARY KEY (id);


--
-- Name: claim_event_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT claim_event_type_pkey PRIMARY KEY (id);


--
-- Name: claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_pkey PRIMARY KEY (id);


--
-- Name: claim_policy_action_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_pkey PRIMARY KEY (id);


--
-- Name: claim_policy_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT claim_policy_pkey PRIMARY KEY (id);


--
-- Name: claim_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: claim_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_pkey PRIMARY KEY (id);


--
-- Name: code_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT code_once_per_org_year UNIQUE (org, code, year);


--
-- Name: code_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT code_once_per_owner UNIQUE (code, owner);


--
-- Name: currency_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY currency_type
    ADD CONSTRAINT currency_type_pkey PRIMARY KEY (code);


--
-- Name: debit_attribution_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_application_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT distribution_formula_pkey PRIMARY KEY (id);


--
-- Name: edi_account_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY edi_account
    ADD CONSTRAINT edi_account_pkey PRIMARY KEY (id);


--
-- Name: edi_message_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_pkey PRIMARY KEY (id);


--
-- Name: event_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT event_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: exchange_rate_from_to_once; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_from_to_once UNIQUE (from_currency, to_currency);


--
-- Name: exchange_rate_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_pkey PRIMARY KEY (id);


--
-- Name: fiscal_calendar_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fiscal_calendar
    ADD CONSTRAINT fiscal_calendar_pkey PRIMARY KEY (id);


--
-- Name: fiscal_year_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT fiscal_year_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_percent_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_pkey PRIMARY KEY (id);


--
-- Name: fund_debit_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_pkey PRIMARY KEY (id);


--
-- Name: fund_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_pkey PRIMARY KEY (id);


--
-- Name: fund_tag_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_pkey PRIMARY KEY (id);


--
-- Name: fund_tag_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT fund_tag_pkey PRIMARY KEY (id);


--
-- Name: fund_transfer_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_pkey PRIMARY KEY (id);


--
-- Name: funding_source_code_key; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_code_key UNIQUE (code);


--
-- Name: funding_source_credit_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY funding_source_credit
    ADD CONSTRAINT funding_source_credit_pkey PRIMARY KEY (id);


--
-- Name: funding_source_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_name_once_per_owner UNIQUE (name, owner);


--
-- Name: funding_source_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_pkey PRIMARY KEY (id);


--
-- Name: inv_ident_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT inv_ident_once_per_provider UNIQUE (provider, inv_ident);


--
-- Name: invoice_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_pkey PRIMARY KEY (id);


--
-- Name: invoice_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_pkey PRIMARY KEY (id);


--
-- Name: invoice_item_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice_item_type
    ADD CONSTRAINT invoice_item_type_pkey PRIMARY KEY (code);


--
-- Name: invoice_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice_method
    ADD CONSTRAINT invoice_method_pkey PRIMARY KEY (code);


--
-- Name: invoice_payment_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice_payment_method
    ADD CONSTRAINT invoice_payment_method_pkey PRIMARY KEY (code);


--
-- Name: invoice_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_pkey PRIMARY KEY (id);


--
-- Name: lineitem_alert_text_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_attr_definition
    ADD CONSTRAINT lineitem_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_attr
    ADD CONSTRAINT lineitem_attr_pkey PRIMARY KEY (id);


--
-- Name: lineitem_detail_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_pkey PRIMARY KEY (id);


--
-- Name: lineitem_generated_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_generated_attr_definition
    ADD CONSTRAINT lineitem_generated_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_local_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_local_attr_definition
    ADD CONSTRAINT lineitem_local_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_marc_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_marc_attr_definition
    ADD CONSTRAINT lineitem_marc_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_pkey PRIMARY KEY (id);


--
-- Name: lineitem_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_pkey PRIMARY KEY (id);


--
-- Name: lineitem_provider_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_usr_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: logical_key; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT logical_key UNIQUE (funding_source, org, fund_code);


--
-- Name: name_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT name_once_per_org UNIQUE (org_unit, name);


--
-- Name: name_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT name_once_per_org_year UNIQUE (org, name, year);


--
-- Name: name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT name_once_per_owner UNIQUE (name, owner);


--
-- Name: name_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT name_once_per_provider UNIQUE (provider, name);


--
-- Name: picklist_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_pkey PRIMARY KEY (id);


--
-- Name: po_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_pkey PRIMARY KEY (id);


--
-- Name: po_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_pkey PRIMARY KEY (id);


--
-- Name: provider_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_address
    ADD CONSTRAINT provider_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_contact_address
    ADD CONSTRAINT provider_contact_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_contact
    ADD CONSTRAINT provider_contact_pkey PRIMARY KEY (id);


--
-- Name: provider_holding_subfield_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: provider_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_name_once_per_owner UNIQUE (name, owner);


--
-- Name: provider_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_pkey PRIMARY KEY (id);


--
-- Name: provider_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_pkey PRIMARY KEY (id);


--
-- Name: purchase_order_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_pkey PRIMARY KEY (id);


--
-- Name: serial_claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_pkey PRIMARY KEY (id);


--
-- Name: serial_claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_pkey PRIMARY KEY (id);


--
-- Name: user_request_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_pkey PRIMARY KEY (id);


--
-- Name: user_request_type_label_key; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_request_type
    ADD CONSTRAINT user_request_type_label_key UNIQUE (label);


--
-- Name: user_request_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_request_type
    ADD CONSTRAINT user_request_type_pkey PRIMARY KEY (id);


SET search_path = action, pg_catalog;

--
-- Name: aged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY aged_circulation
    ADD CONSTRAINT aged_circulation_pkey PRIMARY KEY (id);


--
-- Name: archive_actor_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY archive_actor_stat_cat
    ADD CONSTRAINT archive_actor_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: archive_asset_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY archive_asset_stat_cat
    ADD CONSTRAINT archive_asset_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: circulation_limit_group_map_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_pkey PRIMARY KEY (circ, limit_group);


--
-- Name: circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_pkey PRIMARY KEY (id);


--
-- Name: copy_once_per_hold; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT copy_once_per_hold UNIQUE (hold, target_copy);


--
-- Name: fieldset_col_once_per_set; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_once_per_set UNIQUE (fieldset, col);


--
-- Name: fieldset_col_val_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_pkey PRIMARY KEY (id);


--
-- Name: fieldset_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_pkey PRIMARY KEY (id);


--
-- Name: hold_copy_map_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT hold_copy_map_pkey PRIMARY KEY (id);


--
-- Name: hold_notification_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_pkey PRIMARY KEY (id);


--
-- Name: hold_request_cancel_cause_label_key; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_label_key UNIQUE (label);


--
-- Name: hold_request_cancel_cause_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_pkey PRIMARY KEY (id);


--
-- Name: hold_request_note_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_request_note
    ADD CONSTRAINT hold_request_note_pkey PRIMARY KEY (id);


--
-- Name: hold_request_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_pkey PRIMARY KEY (id);


--
-- Name: hold_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_pkey PRIMARY KEY (id);


--
-- Name: lib_name_unique; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT lib_name_unique UNIQUE (owning_lib, name);


--
-- Name: non_cat_in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_pkey PRIMARY KEY (id);


--
-- Name: reservation_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: survey_answer_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY survey_answer
    ADD CONSTRAINT survey_answer_pkey PRIMARY KEY (id);


--
-- Name: survey_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY survey
    ADD CONSTRAINT survey_pkey PRIMARY KEY (id);


--
-- Name: survey_question_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY survey_question
    ADD CONSTRAINT survey_question_pkey PRIMARY KEY (id);


--
-- Name: survey_response_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_pkey PRIMARY KEY (id);


--
-- Name: transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_pkey PRIMARY KEY (id);


--
-- Name: unfulfilled_hold_list_pkey; Type: CONSTRAINT; Schema: action; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unfulfilled_hold_list
    ADD CONSTRAINT unfulfilled_hold_list_pkey PRIMARY KEY (id);


SET search_path = action_trigger, pg_catalog;

--
-- Name: cleanup_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cleanup
    ADD CONSTRAINT cleanup_pkey PRIMARY KEY (module);


--
-- Name: collector_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY collector
    ADD CONSTRAINT collector_pkey PRIMARY KEY (module);


--
-- Name: env_event_label_once; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT env_event_label_once UNIQUE (event_def, label);


--
-- Name: environment_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_pkey PRIMARY KEY (id);


--
-- Name: ev_def_name_owner_once; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT ev_def_name_owner_once UNIQUE (owner, name);


--
-- Name: ev_def_owner_hook_val_react_clean_delay_once; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT ev_def_owner_hook_val_react_clean_delay_once UNIQUE (owner, hook, validator, reactor, delay, delay_field);


--
-- Name: event_definition_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_pkey PRIMARY KEY (id);


--
-- Name: event_output_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_output
    ADD CONSTRAINT event_output_pkey PRIMARY KEY (id);


--
-- Name: event_params_event_def_param_once; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_event_def_param_once UNIQUE (event_def, param);


--
-- Name: event_params_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_pkey PRIMARY KEY (id);


--
-- Name: event_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: hook_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hook
    ADD CONSTRAINT hook_pkey PRIMARY KEY (key);


--
-- Name: reactor_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY reactor
    ADD CONSTRAINT reactor_pkey PRIMARY KEY (module);


--
-- Name: validator_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY validator
    ADD CONSTRAINT validator_pkey PRIMARY KEY (module);


SET search_path = actor, pg_catalog;

--
-- Name: address_alert_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY address_alert
    ADD CONSTRAINT address_alert_pkey PRIMARY KEY (id);


--
-- Name: aouctn_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT aouctn_once_per_org UNIQUE (tree, org_unit);


--
-- Name: asfg_code_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT asfg_code_once_per_org UNIQUE (owner, code);


--
-- Name: asfg_label_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT asfg_label_once_per_org UNIQUE (owner, label);


--
-- Name: asfge_query_once_per_group; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT asfge_query_once_per_group UNIQUE (grp, query);


--
-- Name: card_barcode_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_barcode_key UNIQUE (barcode);


--
-- Name: card_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: hours_of_operation_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hours_of_operation
    ADD CONSTRAINT hours_of_operation_pkey PRIMARY KEY (id);


--
-- Name: name_once_per_user; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT name_once_per_user UNIQUE (owner, name);


--
-- Name: org_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_address
    ADD CONSTRAINT org_address_pkey PRIMARY KEY (id);


--
-- Name: org_lasso_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_pkey PRIMARY KEY (id);


--
-- Name: org_lasso_name_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_lasso
    ADD CONSTRAINT org_lasso_name_key UNIQUE (name);


--
-- Name: org_lasso_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_lasso
    ADD CONSTRAINT org_lasso_pkey PRIMARY KEY (id);


--
-- Name: org_unit_closed_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_closed
    ADD CONSTRAINT org_unit_closed_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_node_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_purpose_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_purpose_key UNIQUE (purpose);


--
-- Name: org_unit_name_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_name_key UNIQUE (name);


--
-- Name: org_unit_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity_adjustment_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_proximity
    ADD CONSTRAINT org_unit_proximity_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_pkey PRIMARY KEY (id);


--
-- Name: org_unit_shortname_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_shortname_key UNIQUE (shortname);


--
-- Name: org_unit_type_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_type
    ADD CONSTRAINT org_unit_type_pkey PRIMARY KEY (id);


--
-- Name: ou_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT ou_once_per_key UNIQUE (org_unit, name);


--
-- Name: sc_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: sc_once_per_usr; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT sc_once_per_usr UNIQUE (target_usr, stat_cat);


--
-- Name: sce_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: sced_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT sced_once_per_owner UNIQUE (stat_cat, owner);


--
-- Name: search_filter_group_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_pkey PRIMARY KEY (id);


--
-- Name: search_filter_group_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT search_filter_group_pkey PRIMARY KEY (id);


--
-- Name: search_query_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY search_query
    ADD CONSTRAINT search_query_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_default_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_usr_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT stat_cat_entry_usr_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: toolbar_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_pkey PRIMARY KEY (id);


--
-- Name: usr_activity_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_pkey PRIMARY KEY (id);


--
-- Name: usr_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_pkey PRIMARY KEY (id);


--
-- Name: usr_card_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_card_key UNIQUE (card);


--
-- Name: usr_note_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_pkey PRIMARY KEY (id);


--
-- Name: usr_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_once_per_key UNIQUE (usr, name);


--
-- Name: usr_opt_in_once_per_org_unit; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_opt_in_once_per_org_unit UNIQUE (usr, org_unit);


--
-- Name: usr_org_unit_opt_in_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_pkey PRIMARY KEY (id);


--
-- Name: usr_password_reset_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_password_reset
    ADD CONSTRAINT usr_password_reset_pkey PRIMARY KEY (id);


--
-- Name: usr_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_pkey PRIMARY KEY (id);


--
-- Name: usr_saved_search_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT usr_saved_search_pkey PRIMARY KEY (id);


--
-- Name: usr_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_pkey PRIMARY KEY (id);


--
-- Name: usr_standing_penalty_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: usr_usrname_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_usrname_key UNIQUE (usrname);


--
-- Name: workstation_name_key; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_name_key UNIQUE (name);


--
-- Name: workstation_pkey; Type: CONSTRAINT; Schema: actor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_pkey PRIMARY KEY (id);


SET search_path = asset, pg_catalog;

--
-- Name: acl_name_once_per_lib; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT acl_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: acplo_once_per_org; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT acplo_once_per_org UNIQUE (location, org);


--
-- Name: call_number_class_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_class
    ADD CONSTRAINT call_number_class_pkey PRIMARY KEY (id);


--
-- Name: call_number_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT call_number_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_pkey PRIMARY KEY (id);


--
-- Name: call_number_prefix_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_prefix
    ADD CONSTRAINT call_number_prefix_pkey PRIMARY KEY (id);


--
-- Name: call_number_suffix_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_suffix
    ADD CONSTRAINT call_number_suffix_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT copy_location_group_pkey PRIMARY KEY (id);


--
-- Name: copy_location_order_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_pkey PRIMARY KEY (id);


--
-- Name: copy_location_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT copy_location_pkey PRIMARY KEY (id);


--
-- Name: copy_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT copy_note_pkey PRIMARY KEY (id);


--
-- Name: copy_part_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_part_map
    ADD CONSTRAINT copy_part_map_pkey PRIMARY KEY (id);


--
-- Name: copy_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_pkey PRIMARY KEY (id);


--
-- Name: copy_template_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_pkey PRIMARY KEY (id);


--
-- Name: lgroup_once_per_group; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT lgroup_once_per_group UNIQUE (lgroup, location);


--
-- Name: lgroup_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT lgroup_once_per_owner UNIQUE (owner, name);


--
-- Name: opac_visible_copies_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY opac_visible_copies
    ADD CONSTRAINT opac_visible_copies_pkey PRIMARY KEY (id);


--
-- Name: sc_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: sce_once_per_copy; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT sce_once_per_copy UNIQUE (owning_copy, stat_cat);


--
-- Name: sce_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: scte_once_per_trans; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_transparency_map
    ADD CONSTRAINT scte_once_per_trans UNIQUE (owning_transparency, stat_cat);


--
-- Name: stat_cat_entry_copy_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT stat_cat_entry_copy_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_transparency_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_transparency_map
    ADD CONSTRAINT stat_cat_entry_transparency_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: uri_call_number_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_pkey PRIMARY KEY (id);


--
-- Name: uri_cn_once; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_cn_once UNIQUE (uri, call_number);


--
-- Name: uri_pkey; Type: CONSTRAINT; Schema: asset; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY uri
    ADD CONSTRAINT uri_pkey PRIMARY KEY (id);


SET search_path = auditor, pg_catalog;

--
-- Name: acq_invoice_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_entry_history
    ADD CONSTRAINT acq_invoice_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_history
    ADD CONSTRAINT acq_invoice_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_item_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_item_history
    ADD CONSTRAINT acq_invoice_item_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_org_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY actor_org_unit_history
    ADD CONSTRAINT actor_org_unit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_address_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY actor_usr_address_history
    ADD CONSTRAINT actor_usr_address_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY actor_usr_history
    ADD CONSTRAINT actor_usr_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_call_number_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY asset_call_number_history
    ADD CONSTRAINT asset_call_number_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_copy_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY asset_copy_history
    ADD CONSTRAINT asset_copy_history_pkey PRIMARY KEY (audit_id);


--
-- Name: biblio_record_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_history
    ADD CONSTRAINT biblio_record_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: serial_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY serial_unit_history
    ADD CONSTRAINT serial_unit_history_pkey PRIMARY KEY (audit_id);


SET search_path = authority, pg_catalog;

--
-- Name: bib_linking_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_pkey PRIMARY KEY (id);


--
-- Name: browse_axis_authority_field_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_pkey PRIMARY KEY (id);


--
-- Name: browse_axis_name_key; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_name_key UNIQUE (name);


--
-- Name: browse_axis_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_pkey PRIMARY KEY (code);


--
-- Name: control_set_authority_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_pkey PRIMARY KEY (id);


--
-- Name: control_set_bib_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_pkey PRIMARY KEY (id);


--
-- Name: control_set_name_key; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY control_set
    ADD CONSTRAINT control_set_name_key UNIQUE (name);


--
-- Name: control_set_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY control_set
    ADD CONSTRAINT control_set_pkey PRIMARY KEY (id);


--
-- Name: full_rec_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY full_rec
    ADD CONSTRAINT full_rec_pkey PRIMARY KEY (id);


--
-- Name: rec_descriptor_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rec_descriptor
    ADD CONSTRAINT rec_descriptor_pkey PRIMARY KEY (id);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_note_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


--
-- Name: simple_heading_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_pkey PRIMARY KEY (id);


--
-- Name: thesaurus_name_key; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_name_key UNIQUE (name);


--
-- Name: thesaurus_pkey; Type: CONSTRAINT; Schema: authority; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_pkey PRIMARY KEY (code);


SET search_path = biblio, pg_catalog;

--
-- Name: monograph_part_pkey; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT monograph_part_pkey PRIMARY KEY (id);


--
-- Name: peer_bib_copy_map_pkey; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_pkey PRIMARY KEY (id);


--
-- Name: peer_type_name_key; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY peer_type
    ADD CONSTRAINT peer_type_name_key UNIQUE (name);


--
-- Name: peer_type_pkey; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY peer_type
    ADD CONSTRAINT peer_type_pkey PRIMARY KEY (id);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_label_unique; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT record_label_unique UNIQUE (record, label);


--
-- Name: record_note_pkey; Type: CONSTRAINT; Schema: biblio; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


SET search_path = booking, pg_catalog;

--
-- Name: br_unique; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT br_unique UNIQUE (owner, barcode);


--
-- Name: bra_name_once_per_type; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT bra_name_once_per_type UNIQUE (resource_type, name);


--
-- Name: bram_one_value_per_attr; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT bram_one_value_per_attr UNIQUE (resource, resource_attr);


--
-- Name: brav_logical_key; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT brav_logical_key UNIQUE (owner, attr, valid_value);


--
-- Name: bravm_logical_key; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT bravm_logical_key UNIQUE (reservation, attr_value);


--
-- Name: brt_name_and_record_once_per_owner; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT brt_name_and_record_once_per_owner UNIQUE (owner, name, record);


--
-- Name: reservation_attr_value_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_pkey PRIMARY KEY (id);


--
-- Name: reservation_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_value_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_pkey PRIMARY KEY (id);


--
-- Name: resource_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_pkey PRIMARY KEY (id);


--
-- Name: resource_type_pkey; Type: CONSTRAINT; Schema: booking; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_pkey PRIMARY KEY (id);


SET search_path = config, pg_catalog;

--
-- Name: barcode_completion_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY barcode_completion
    ADD CONSTRAINT barcode_completion_pkey PRIMARY KEY (id);


--
-- Name: best_hold_order_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY best_hold_order
    ADD CONSTRAINT best_hold_order_name_key UNIQUE (name);


--
-- Name: best_hold_order_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY best_hold_order
    ADD CONSTRAINT best_hold_order_pkey PRIMARY KEY (id);


--
-- Name: bib_source_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_source
    ADD CONSTRAINT bib_source_pkey PRIMARY KEY (id);


--
-- Name: bib_source_source_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_source
    ADD CONSTRAINT bib_source_source_key UNIQUE (source);


--
-- Name: biblio_fingerprint_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_fingerprint
    ADD CONSTRAINT biblio_fingerprint_pkey PRIMARY KEY (id);


--
-- Name: billing_type_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT billing_type_once_per_lib UNIQUE (name, owner);


--
-- Name: billing_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT billing_type_pkey PRIMARY KEY (id);


--
-- Name: cfdfs_name_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT cfdfs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: circ_limit_group_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_group
    ADD CONSTRAINT circ_limit_group_name_key UNIQUE (name);


--
-- Name: circ_limit_group_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_group
    ADD CONSTRAINT circ_limit_group_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_circ_mod_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_copy_loc_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_group_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_name_key UNIQUE (name);


--
-- Name: circ_limit_set_once_per_matchpoint; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_limit_set_once_per_matchpoint UNIQUE (matchpoint, limit_set);


--
-- Name: circ_limit_set_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_limit_set_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_name_key UNIQUE (name);


--
-- Name: circ_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: circ_modifier_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_modifier
    ADD CONSTRAINT circ_modifier_name_key UNIQUE (name);


--
-- Name: circ_modifier_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_modifier
    ADD CONSTRAINT circ_modifier_pkey PRIMARY KEY (code);


--
-- Name: cl_once_per_set; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT cl_once_per_set UNIQUE (limit_set, copy_loc);


--
-- Name: clg_once_per_set; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT clg_once_per_set UNIQUE (limit_set, limit_group);


--
-- Name: cm_once_per_set; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT cm_once_per_set UNIQUE (limit_set, circ_mod);


--
-- Name: coded_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY coded_value_map
    ADD CONSTRAINT coded_value_map_pkey PRIMARY KEY (id);


--
-- Name: copy_status_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_status
    ADD CONSTRAINT copy_status_name_key UNIQUE (name);


--
-- Name: copy_status_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_status
    ADD CONSTRAINT copy_status_pkey PRIMARY KEY (id);


--
-- Name: czsc_source_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT czsc_source_once_per_lib UNIQUE (source, owner);


--
-- Name: db_patch_dependencies_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY db_patch_dependencies
    ADD CONSTRAINT db_patch_dependencies_pkey PRIMARY KEY (db_patch);


--
-- Name: filter_dialog_filter_set_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_pkey PRIMARY KEY (id);


--
-- Name: filter_dialog_interface_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_interface
    ADD CONSTRAINT filter_dialog_interface_pkey PRIMARY KEY (key);


--
-- Name: global_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY global_flag
    ADD CONSTRAINT global_flag_pkey PRIMARY KEY (name);


--
-- Name: hard_due_date_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hard_due_date
    ADD CONSTRAINT hard_due_date_name_key UNIQUE (name);


--
-- Name: hard_due_date_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hard_due_date
    ADD CONSTRAINT hard_due_date_pkey PRIMARY KEY (id);


--
-- Name: hard_due_date_values_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_name_key UNIQUE (name);


--
-- Name: hold_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: i18n_core_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY i18n_core
    ADD CONSTRAINT i18n_core_pkey PRIMARY KEY (id);


--
-- Name: i18n_locale_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY i18n_locale
    ADD CONSTRAINT i18n_locale_name_key UNIQUE (name);


--
-- Name: i18n_locale_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY i18n_locale
    ADD CONSTRAINT i18n_locale_pkey PRIMARY KEY (code);


--
-- Name: identification_type_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY identification_type
    ADD CONSTRAINT identification_type_name_key UNIQUE (name);


--
-- Name: identification_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY identification_type
    ADD CONSTRAINT identification_type_pkey PRIMARY KEY (id);


--
-- Name: idl_field_doc_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY idl_field_doc
    ADD CONSTRAINT idl_field_doc_pkey PRIMARY KEY (id);


--
-- Name: index_normalizer_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY index_normalizer
    ADD CONSTRAINT index_normalizer_name_key UNIQUE (name);


--
-- Name: index_normalizer_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY index_normalizer
    ADD CONSTRAINT index_normalizer_pkey PRIMARY KEY (id);


--
-- Name: internal_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY internal_flag
    ADD CONSTRAINT internal_flag_pkey PRIMARY KEY (name);


--
-- Name: marc21_ff_pos_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY marc21_ff_pos_map
    ADD CONSTRAINT marc21_ff_pos_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_subfield_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_type_map
    ADD CONSTRAINT marc21_physical_characteristic_type_map_pkey PRIMARY KEY (ptype_key);


--
-- Name: marc21_physical_characteristic_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_rec_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY marc21_rec_type_map
    ADD CONSTRAINT marc21_rec_type_map_pkey PRIMARY KEY (code);


--
-- Name: metabib_class_label_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_class
    ADD CONSTRAINT metabib_class_label_key UNIQUE (label);


--
-- Name: metabib_class_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_class
    ADD CONSTRAINT metabib_class_pkey PRIMARY KEY (name);


--
-- Name: metabib_class_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_search_alias_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_pkey PRIMARY KEY (alias);


--
-- Name: net_access_level_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY net_access_level
    ADD CONSTRAINT net_access_level_name_key UNIQUE (name);


--
-- Name: net_access_level_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY net_access_level
    ADD CONSTRAINT net_access_level_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_type
    ADD CONSTRAINT non_cataloged_type_pkey PRIMARY KEY (id);


--
-- Name: noncat_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_type
    ADD CONSTRAINT noncat_once_per_lib UNIQUE (owning_lib, name);


--
-- Name: org_unit_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_label_key UNIQUE (label);


--
-- Name: org_unit_setting_type_log_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_pkey PRIMARY KEY (name);


--
-- Name: record_attr_definition_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_pkey PRIMARY KEY (name);


--
-- Name: record_attr_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: remote_account_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY remote_account
    ADD CONSTRAINT remote_account_pkey PRIMARY KEY (id);


--
-- Name: rule_age_hold_protect_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_name_key UNIQUE (name);


--
-- Name: rule_age_hold_protect_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_pkey PRIMARY KEY (id);


--
-- Name: rule_circ_duration_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_name_key UNIQUE (name);


--
-- Name: rule_circ_duration_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_pkey PRIMARY KEY (id);


--
-- Name: rule_max_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_max_fine
    ADD CONSTRAINT rule_max_fine_name_key UNIQUE (name);


--
-- Name: rule_max_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_max_fine
    ADD CONSTRAINT rule_max_fine_pkey PRIMARY KEY (id);


--
-- Name: rule_recurring_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_name_key UNIQUE (name);


--
-- Name: rule_recurring_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_pkey PRIMARY KEY (id);


--
-- Name: settings_group_label_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY settings_group
    ADD CONSTRAINT settings_group_label_key UNIQUE (label);


--
-- Name: settings_group_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY settings_group
    ADD CONSTRAINT settings_group_pkey PRIMARY KEY (name);


--
-- Name: sms_carrier_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY sms_carrier
    ADD CONSTRAINT sms_carrier_pkey PRIMARY KEY (id);


--
-- Name: standing_penalty_name_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY standing_penalty
    ADD CONSTRAINT standing_penalty_name_key UNIQUE (name);


--
-- Name: standing_penalty_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY standing_penalty
    ADD CONSTRAINT standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: standing_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY standing
    ADD CONSTRAINT standing_pkey PRIMARY KEY (id);


--
-- Name: standing_value_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY standing
    ADD CONSTRAINT standing_value_key UNIQUE (value);


--
-- Name: ts_config_list_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ts_config_list
    ADD CONSTRAINT ts_config_list_pkey PRIMARY KEY (id);


--
-- Name: upgrade_log_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY upgrade_log
    ADD CONSTRAINT upgrade_log_pkey PRIMARY KEY (version);


--
-- Name: usr_activity_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_activity_type
    ADD CONSTRAINT usr_activity_type_pkey PRIMARY KEY (id);


--
-- Name: usr_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_label_key UNIQUE (label);


--
-- Name: usr_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_pkey PRIMARY KEY (name);


--
-- Name: weight_assoc_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_pkey PRIMARY KEY (id);


--
-- Name: xml_transform_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY xml_transform
    ADD CONSTRAINT xml_transform_pkey PRIMARY KEY (name);


--
-- Name: z3950_attr_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z3950_attr_pkey PRIMARY KEY (id);


--
-- Name: z3950_source_credentials_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_pkey PRIMARY KEY (id);


--
-- Name: z3950_source_label_key; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT z3950_source_label_key UNIQUE (label);


--
-- Name: z3950_source_pkey; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT z3950_source_pkey PRIMARY KEY (name);


--
-- Name: z_code_format_once_per_source; Type: CONSTRAINT; Schema: config; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z_code_format_once_per_source UNIQUE (code, format, source);


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_label_key UNIQUE (label);


--
-- Name: biblio_record_entry_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: breb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT breb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: call_number_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_label_key UNIQUE (label);


--
-- Name: call_number_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: cb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT cb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: cnb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT cnb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: copy_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_label_key UNIQUE (label);


--
-- Name: copy_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: ub_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT ub_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: user_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket_note
    ADD CONSTRAINT user_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket_type
    ADD CONSTRAINT user_bucket_type_label_key UNIQUE (label);


--
-- Name: user_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_bucket_type
    ADD CONSTRAINT user_bucket_type_pkey PRIMARY KEY (code);


SET search_path = extend_reporter, pg_catalog;

--
-- Name: legacy_circ_count_pkey; Type: CONSTRAINT; Schema: extend_reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY legacy_circ_count
    ADD CONSTRAINT legacy_circ_count_pkey PRIMARY KEY (id);


SET search_path = metabib, pg_catalog;

--
-- Name: author_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY author_field_entry
    ADD CONSTRAINT author_field_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_entry
    ADD CONSTRAINT browse_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_value_key; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY browse_entry
    ADD CONSTRAINT browse_entry_value_key UNIQUE (value);


--
-- Name: facet_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY facet_entry
    ADD CONSTRAINT facet_entry_pkey PRIMARY KEY (id);


--
-- Name: identifier_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT identifier_field_entry_pkey PRIMARY KEY (id);


--
-- Name: keyword_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY keyword_field_entry
    ADD CONSTRAINT keyword_field_entry_pkey PRIMARY KEY (id);


--
-- Name: metarecord_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metarecord
    ADD CONSTRAINT metarecord_pkey PRIMARY KEY (id);


--
-- Name: metarecord_source_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metarecord_source_map_pkey PRIMARY KEY (id);


--
-- Name: real_full_rec_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY real_full_rec
    ADD CONSTRAINT real_full_rec_pkey PRIMARY KEY (id);


--
-- Name: record_attr_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_attr
    ADD CONSTRAINT record_attr_pkey PRIMARY KEY (id);


--
-- Name: series_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY series_field_entry
    ADD CONSTRAINT series_field_entry_pkey PRIMARY KEY (id);


--
-- Name: subject_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subject_field_entry
    ADD CONSTRAINT subject_field_entry_pkey PRIMARY KEY (id);


--
-- Name: title_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY title_field_entry
    ADD CONSTRAINT title_field_entry_pkey PRIMARY KEY (id);


SET search_path = money, pg_catalog;

--
-- Name: billable_xact_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY billable_xact
    ADD CONSTRAINT billable_xact_pkey PRIMARY KEY (id);


--
-- Name: billing_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY billing
    ADD CONSTRAINT billing_pkey PRIMARY KEY (id);


--
-- Name: bnm_desk_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_pkey PRIMARY KEY (id);


--
-- Name: bnm_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bnm_payment
    ADD CONSTRAINT bnm_payment_pkey PRIMARY KEY (id);


--
-- Name: cash_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cash_payment
    ADD CONSTRAINT cash_payment_pkey PRIMARY KEY (id);


--
-- Name: check_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY check_payment
    ADD CONSTRAINT check_payment_pkey PRIMARY KEY (id);


--
-- Name: collections_tracker_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_pkey PRIMARY KEY (id);


--
-- Name: credit_card_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY credit_card_payment
    ADD CONSTRAINT credit_card_payment_pkey PRIMARY KEY (id);


--
-- Name: credit_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY credit_payment
    ADD CONSTRAINT credit_payment_pkey PRIMARY KEY (id);


--
-- Name: forgive_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY forgive_payment
    ADD CONSTRAINT forgive_payment_pkey PRIMARY KEY (id);


--
-- Name: goods_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY goods_payment
    ADD CONSTRAINT goods_payment_pkey PRIMARY KEY (id);


--
-- Name: grocery_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grocery
    ADD CONSTRAINT grocery_pkey PRIMARY KEY (id);


--
-- Name: materialized_billable_xact_summary_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialized_billable_xact_summary
    ADD CONSTRAINT materialized_billable_xact_summary_pkey PRIMARY KEY (id);


--
-- Name: payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY payment
    ADD CONSTRAINT payment_pkey PRIMARY KEY (id);


--
-- Name: work_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY work_payment
    ADD CONSTRAINT work_payment_pkey PRIMARY KEY (id);


SET search_path = offline, pg_catalog;

--
-- Name: script_pkey; Type: CONSTRAINT; Schema: offline; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY script
    ADD CONSTRAINT script_pkey PRIMARY KEY (id);


--
-- Name: session_pkey; Type: CONSTRAINT; Schema: offline; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_pkey PRIMARY KEY (key);


SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_pkey PRIMARY KEY (id);


--
-- Name: grp_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_pkey PRIMARY KEY (id);


--
-- Name: grp_tree_name_key; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_name_key UNIQUE (name);


--
-- Name: grp_tree_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_pkey PRIMARY KEY (id);


--
-- Name: penalty_grp_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT penalty_grp_once UNIQUE (grp, penalty, org_unit);


--
-- Name: perm_grp_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT perm_grp_once UNIQUE (grp, perm);


--
-- Name: perm_list_code_key; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY perm_list
    ADD CONSTRAINT perm_list_code_key UNIQUE (code);


--
-- Name: perm_list_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY perm_list
    ADD CONSTRAINT perm_list_pkey PRIMARY KEY (id);


--
-- Name: perm_usr_obj_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT perm_usr_obj_once UNIQUE (usr, perm, object_type, object_id);


--
-- Name: perm_usr_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT perm_usr_once UNIQUE (usr, perm);


--
-- Name: usr_grp_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_pkey PRIMARY KEY (id);


--
-- Name: usr_grp_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_once UNIQUE (usr, grp);


--
-- Name: usr_object_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_once; Type: CONSTRAINT; Schema: permission; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_once UNIQUE (usr, work_ou);


SET search_path = query, pg_catalog;

--
-- Name: bind_variable_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bind_variable
    ADD CONSTRAINT bind_variable_pkey PRIMARY KEY (name);


--
-- Name: case_branch_parent_seq; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_parent_seq UNIQUE (parent_expr, seq_no);


--
-- Name: case_branch_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_pkey PRIMARY KEY (id);


--
-- Name: column_sequence; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT column_sequence UNIQUE (from_relation, seq_no);


--
-- Name: datatype_datatype_name_key; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY datatype
    ADD CONSTRAINT datatype_datatype_name_key UNIQUE (datatype_name);


--
-- Name: datatype_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY datatype
    ADD CONSTRAINT datatype_pkey PRIMARY KEY (id);


--
-- Name: expression_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_pkey PRIMARY KEY (id);


--
-- Name: from_relation_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_pkey PRIMARY KEY (id);


--
-- Name: function_param_def_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_pkey PRIMARY KEY (id);


--
-- Name: function_sig_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY function_sig
    ADD CONSTRAINT function_sig_pkey PRIMARY KEY (id);


--
-- Name: order_by_item_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_pkey PRIMARY KEY (id);


--
-- Name: order_by_sequence; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_sequence UNIQUE (stored_query, seq_no);


--
-- Name: qfpd_function_param_seq; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT qfpd_function_param_seq UNIQUE (function_id, seq_no);


--
-- Name: qsf_datatype_seq_no; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT qsf_datatype_seq_no UNIQUE (composite_type, seq_no);


--
-- Name: query_query_seq; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_query_seq UNIQUE (parent_query, seq_no);


--
-- Name: query_sequence_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_pkey PRIMARY KEY (id);


--
-- Name: record_column_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_pkey PRIMARY KEY (id);


--
-- Name: select_item_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_pkey PRIMARY KEY (id);


--
-- Name: select_sequence; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_sequence UNIQUE (stored_query, seq_no);


--
-- Name: stored_query_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_pkey PRIMARY KEY (id);


--
-- Name: subfield_pkey; Type: CONSTRAINT; Schema: query; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_pkey PRIMARY KEY (id);


SET search_path = reporter, pg_catalog;

--
-- Name: materialized_simple_record_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialized_simple_record
    ADD CONSTRAINT materialized_simple_record_pkey PRIMARY KEY (id);


--
-- Name: output_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_pkey PRIMARY KEY (id);


--
-- Name: report_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_pkey PRIMARY KEY (id);


--
-- Name: report_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_pkey PRIMARY KEY (id);


--
-- Name: schedule_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_pkey PRIMARY KEY (id);


--
-- Name: template_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_pkey PRIMARY KEY (id);


--
-- Name: template_pkey; Type: CONSTRAINT; Schema: reporter; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_pkey PRIMARY KEY (id);


SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment_pkey; Type: CONSTRAINT; Schema: search; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_pkey PRIMARY KEY (id);


SET search_path = serial, pg_catalog;

--
-- Name: basic_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basic_summary
    ADD CONSTRAINT basic_summary_pkey PRIMARY KEY (id);


--
-- Name: caption_and_pattern_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_pkey PRIMARY KEY (id);


--
-- Name: distribution_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_pkey PRIMARY KEY (id);


--
-- Name: distribution_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_pkey PRIMARY KEY (id);


--
-- Name: index_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY index_summary
    ADD CONSTRAINT index_summary_pkey PRIMARY KEY (id);


--
-- Name: issuance_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_pkey PRIMARY KEY (id);


--
-- Name: item_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_pkey PRIMARY KEY (id);


--
-- Name: item_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_pkey PRIMARY KEY (id);


--
-- Name: materialized_holding_code_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_pkey PRIMARY KEY (id);


--
-- Name: one_pos_per_routing_list; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT one_pos_per_routing_list UNIQUE (stream, pos);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: routing_list_user_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_pkey PRIMARY KEY (id);


--
-- Name: stream_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stream
    ADD CONSTRAINT stream_pkey PRIMARY KEY (id);


--
-- Name: subscription_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_pkey PRIMARY KEY (id);


--
-- Name: subscription_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_pkey PRIMARY KEY (id);


--
-- Name: supplement_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY supplement_summary
    ADD CONSTRAINT supplement_summary_pkey PRIMARY KEY (id);


--
-- Name: unit_pkey; Type: CONSTRAINT; Schema: serial; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT unit_pkey PRIMARY KEY (id);


SET search_path = staging, pg_catalog;

--
-- Name: billing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY billing_address_stage
    ADD CONSTRAINT billing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: card_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY card_stage
    ADD CONSTRAINT card_stage_pkey PRIMARY KEY (row_id);


--
-- Name: mailing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY mailing_address_stage
    ADD CONSTRAINT mailing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: statcat_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY statcat_stage
    ADD CONSTRAINT statcat_stage_pkey PRIMARY KEY (row_id);


--
-- Name: user_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY user_stage
    ADD CONSTRAINT user_stage_pkey PRIMARY KEY (row_id);


SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout_pkey; Type: CONSTRAINT; Schema: unapi; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bre_output_layout
    ADD CONSTRAINT bre_output_layout_pkey PRIMARY KEY (name);


SET search_path = url_verify, pg_catalog;

--
-- Name: session_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_pkey PRIMARY KEY (id);


--
-- Name: tag_once_per_sess; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT tag_once_per_sess UNIQUE (xpath, session);


--
-- Name: url_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_pkey PRIMARY KEY (id);


--
-- Name: url_selector_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT url_selector_pkey PRIMARY KEY (id);


--
-- Name: url_verification_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_pkey PRIMARY KEY (id);


--
-- Name: uvs_name_once_per_lib; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT uvs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: verification_attempt_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_pkey PRIMARY KEY (id);


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_code_key UNIQUE (code);


--
-- Name: authority_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: authority_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_pkey PRIMARY KEY (id);


--
-- Name: authority_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY authority_queue
    ADD CONSTRAINT authority_queue_pkey PRIMARY KEY (id);


--
-- Name: bib_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_code_key UNIQUE (code);


--
-- Name: bib_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: bib_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_pkey PRIMARY KEY (id);


--
-- Name: bib_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT bib_queue_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_fields_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_group_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_pkey PRIMARY KEY (id);


--
-- Name: import_error_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_error
    ADD CONSTRAINT import_error_pkey PRIMARY KEY (code);


--
-- Name: import_item_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: import_item_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_pkey PRIMARY KEY (id);


--
-- Name: match_set_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT match_set_pkey PRIMARY KEY (id);


--
-- Name: match_set_point_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_pkey PRIMARY KEY (id);


--
-- Name: match_set_quality_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_pkey PRIMARY KEY (id);


--
-- Name: merge_profile_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT merge_profile_pkey PRIMARY KEY (id);


--
-- Name: name_once_per_owner_mtype; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT name_once_per_owner_mtype UNIQUE (name, owner, mtype);


--
-- Name: queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_pkey PRIMARY KEY (id);


--
-- Name: queued_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY queued_record
    ADD CONSTRAINT queued_record_pkey PRIMARY KEY (id);


--
-- Name: vand_authority_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY authority_queue
    ADD CONSTRAINT vand_authority_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: vand_bib_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT vand_bib_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: vand_import_bib_trash_fields_once_per; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT vand_import_bib_trash_fields_once_per UNIQUE (grp, field);


--
-- Name: vand_import_bib_trash_grp_owner_label; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT vand_import_bib_trash_grp_owner_label UNIQUE (owner, label);


--
-- Name: vand_import_item_attr_def_idx; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT vand_import_item_attr_def_idx UNIQUE (owner, name);


--
-- Name: vand_merge_prof_owner_name_idx; Type: CONSTRAINT; Schema: vandelay; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT vand_merge_prof_owner_name_idx UNIQUE (owner, name);


SET search_path = acq, pg_catalog;

--
-- Name: acq_attribution_credit_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_attribution_credit_idx ON debit_attribution USING btree (funding_source_credit);


--
-- Name: acq_attribution_debit_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_attribution_debit_idx ON debit_attribution USING btree (fund_debit);


--
-- Name: acq_lineitem_hist_id_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_lineitem_hist_id_idx ON acq_lineitem_history USING btree (id);


--
-- Name: acq_picklist_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_picklist_creator_idx ON picklist USING btree (creator);


--
-- Name: acq_picklist_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_picklist_editor_idx ON picklist USING btree (editor);


--
-- Name: acq_picklist_owner_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_picklist_owner_idx ON picklist USING btree (owner);


--
-- Name: acq_po_hist_id_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_po_hist_id_idx ON acq_purchase_order_history USING btree (id);


--
-- Name: acq_po_note_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_po_note_creator_idx ON po_note USING btree (creator);


--
-- Name: acq_po_note_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_po_note_editor_idx ON po_note USING btree (editor);


--
-- Name: acq_po_org_name_order_date_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_po_org_name_order_date_idx ON purchase_order USING btree (ordering_agency, name, order_date);


--
-- Name: acq_pro_note_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_pro_note_creator_idx ON provider_note USING btree (creator);


--
-- Name: acq_pro_note_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_pro_note_editor_idx ON provider_note USING btree (editor);


--
-- Name: acq_pro_note_pro_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acq_pro_note_pro_idx ON provider_note USING btree (provider);


--
-- Name: acqdfa_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acqdfa_creator_idx ON distribution_formula_application USING btree (creator);


--
-- Name: acqdfa_df_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acqdfa_df_idx ON distribution_formula_application USING btree (formula);


--
-- Name: acqdfa_li_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acqdfa_li_idx ON distribution_formula_application USING btree (lineitem);


--
-- Name: acqftr_usr_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX acqftr_usr_idx ON fund_transfer USING btree (transfer_user);


--
-- Name: claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX claim_event_claim_date_idx ON claim_event USING btree (claim, event_date);


--
-- Name: claim_lid_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX claim_lid_idx ON claim USING btree (lineitem_detail);


--
-- Name: edi_message_account_status_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX edi_message_account_status_idx ON edi_message USING btree (account, status);


--
-- Name: edi_message_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX edi_message_po_idx ON edi_message USING btree (purchase_order);


--
-- Name: fund_alloc_allocator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX fund_alloc_allocator_idx ON fund_allocation USING btree (allocator);


--
-- Name: ie_inv_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ie_inv_idx ON invoice_entry USING btree (invoice);


--
-- Name: ie_li_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ie_li_idx ON invoice_entry USING btree (lineitem);


--
-- Name: ie_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ie_po_idx ON invoice_entry USING btree (purchase_order);


--
-- Name: ii_inv_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ii_inv_idx ON invoice_item USING btree (invoice);


--
-- Name: ii_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ii_po_idx ON invoice_item USING btree (purchase_order);


--
-- Name: ii_poi_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX ii_poi_idx ON invoice_item USING btree (po_item);


--
-- Name: li_attr_definition_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_attr_definition_idx ON lineitem_attr USING btree (definition);


--
-- Name: li_attr_li_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_attr_li_idx ON lineitem_attr USING btree (lineitem);


--
-- Name: li_attr_value_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_attr_value_idx ON lineitem_attr USING btree (attr_value);


--
-- Name: li_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_creator_idx ON lineitem USING btree (creator);


--
-- Name: li_detail_li_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_detail_li_idx ON lineitem_detail USING btree (lineitem);


--
-- Name: li_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_editor_idx ON lineitem USING btree (editor);


--
-- Name: li_note_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_note_creator_idx ON lineitem_note USING btree (creator);


--
-- Name: li_note_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_note_editor_idx ON lineitem_note USING btree (editor);


--
-- Name: li_note_li_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_note_li_idx ON lineitem_note USING btree (lineitem);


--
-- Name: li_pl_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_pl_idx ON lineitem USING btree (picklist);


--
-- Name: li_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_po_idx ON lineitem USING btree (purchase_order);


--
-- Name: li_selector_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_selector_idx ON lineitem USING btree (selector);


--
-- Name: li_usr_attr_def_usr_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX li_usr_attr_def_usr_idx ON lineitem_usr_attr_definition USING btree (usr);


--
-- Name: po_creator_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_creator_idx ON purchase_order USING btree (creator);


--
-- Name: po_editor_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_editor_idx ON purchase_order USING btree (editor);


--
-- Name: po_note_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_note_po_idx ON po_note USING btree (purchase_order);


--
-- Name: po_owner_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_owner_idx ON purchase_order USING btree (owner);


--
-- Name: po_provider_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_provider_idx ON purchase_order USING btree (provider);


--
-- Name: po_state_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX po_state_idx ON purchase_order USING btree (state);


--
-- Name: poi_po_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX poi_po_idx ON po_item USING btree (purchase_order);


--
-- Name: serial_claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_claim_event_claim_date_idx ON serial_claim_event USING btree (claim, event_date);


--
-- Name: serial_claim_lid_idx; Type: INDEX; Schema: acq; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_claim_lid_idx ON serial_claim USING btree (item);


SET search_path = action, pg_catalog;

--
-- Name: acm_copy_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX acm_copy_idx ON hold_copy_map USING btree (target_copy);


--
-- Name: action_aged_circulation_target_copy_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_aged_circulation_target_copy_idx ON aged_circulation USING btree (target_copy);


--
-- Name: action_circulation_target_copy_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_circulation_target_copy_idx ON circulation USING btree (target_copy);


--
-- Name: action_fieldset_sched_time_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_fieldset_sched_time_idx ON fieldset USING btree (scheduled_time);


--
-- Name: action_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_in_house_use_staff_idx ON in_house_use USING btree (staff);


--
-- Name: action_non_cat_circ_patron_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_non_cat_circ_patron_idx ON non_cataloged_circulation USING btree (patron);


--
-- Name: action_non_cat_circ_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_non_cat_circ_staff_idx ON non_cataloged_circulation USING btree (staff);


--
-- Name: action_owner_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_owner_idx ON fieldset USING btree (owner);


--
-- Name: action_survey_response_usr_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX action_survey_response_usr_idx ON survey_response USING btree (usr);


--
-- Name: active_hold_transit_cp_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_hold_transit_cp_idx ON hold_transit_copy USING btree (target_copy);


--
-- Name: active_hold_transit_dest_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_hold_transit_dest_idx ON hold_transit_copy USING btree (dest);


--
-- Name: active_hold_transit_source_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_hold_transit_source_idx ON hold_transit_copy USING btree (source);


--
-- Name: active_reservation_transit_cp_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_reservation_transit_cp_idx ON reservation_transit_copy USING btree (target_copy);


--
-- Name: active_reservation_transit_dest_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_reservation_transit_dest_idx ON reservation_transit_copy USING btree (dest);


--
-- Name: active_reservation_transit_source_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_reservation_transit_source_idx ON reservation_transit_copy USING btree (source);


--
-- Name: active_transit_cp_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_transit_cp_idx ON transit_copy USING btree (target_copy);


--
-- Name: active_transit_dest_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_transit_dest_idx ON transit_copy USING btree (dest);


--
-- Name: active_transit_source_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX active_transit_source_idx ON transit_copy USING btree (source);


--
-- Name: aged_circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX aged_circ_circ_lib_idx ON aged_circulation USING btree (circ_lib);


--
-- Name: aged_circ_copy_circ_lib_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX aged_circ_copy_circ_lib_idx ON aged_circulation USING btree (copy_circ_lib);


--
-- Name: aged_circ_copy_location_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX aged_circ_copy_location_idx ON aged_circulation USING btree (copy_location);


--
-- Name: aged_circ_copy_owning_lib_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX aged_circ_copy_owning_lib_idx ON aged_circulation USING btree (copy_owning_lib);


--
-- Name: aged_circ_start_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX aged_circ_start_idx ON aged_circulation USING btree (xact_start);


--
-- Name: ahn_hold_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX ahn_hold_idx ON hold_notification USING btree (hold);


--
-- Name: ahn_notify_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX ahn_notify_staff_idx ON hold_notification USING btree (notify_staff);


--
-- Name: ahrn_hold_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX ahrn_hold_idx ON hold_request_note USING btree (hold);


--
-- Name: asv_once_per_owner_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX asv_once_per_owner_idx ON survey USING btree (owner, name);


--
-- Name: circ_all_usr_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_all_usr_idx ON circulation USING btree (usr);


--
-- Name: circ_checkin_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_checkin_staff_idx ON circulation USING btree (checkin_staff);


--
-- Name: circ_checkin_time; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_checkin_time ON circulation USING btree (checkin_time) WHERE (checkin_time IS NOT NULL);


--
-- Name: circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_circ_lib_idx ON circulation USING btree (circ_lib);


--
-- Name: circ_circ_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_circ_staff_idx ON circulation USING btree (circ_staff);


--
-- Name: circ_open_date_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_open_date_idx ON circulation USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: circ_open_xacts_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_open_xacts_idx ON circulation USING btree (usr) WHERE (xact_finish IS NULL);


--
-- Name: circ_outstanding_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_outstanding_idx ON circulation USING btree (usr) WHERE (checkin_time IS NULL);


--
-- Name: circ_parent_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX circ_parent_idx ON circulation USING btree (parent_circ) WHERE (parent_circ IS NOT NULL);


--
-- Name: hold_request_current_copy_before_cap_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_current_copy_before_cap_idx ON hold_request USING btree (current_copy) WHERE ((capture_time IS NULL) AND (cancel_time IS NULL));


--
-- Name: hold_request_current_copy_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_current_copy_idx ON hold_request USING btree (current_copy);


--
-- Name: hold_request_fulfillment_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_fulfillment_staff_idx ON hold_request USING btree (fulfillment_staff);


--
-- Name: hold_request_open_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_open_idx ON hold_request USING btree (id) WHERE ((cancel_time IS NULL) AND (fulfillment_time IS NULL));


--
-- Name: hold_request_pickup_lib_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_pickup_lib_idx ON hold_request USING btree (pickup_lib);


--
-- Name: hold_request_prev_check_time_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_prev_check_time_idx ON hold_request USING btree (prev_check_time);


--
-- Name: hold_request_requestor_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_requestor_idx ON hold_request USING btree (requestor);


--
-- Name: hold_request_target_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_target_idx ON hold_request USING btree (target);


--
-- Name: hold_request_usr_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_request_usr_idx ON hold_request USING btree (usr);


--
-- Name: hold_transit_copy_hold_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX hold_transit_copy_hold_idx ON hold_transit_copy USING btree (hold);


--
-- Name: non_cat_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX non_cat_in_house_use_staff_idx ON non_cat_in_house_use USING btree (staff);


--
-- Name: only_one_concurrent_checkout_per_copy; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX only_one_concurrent_checkout_per_copy ON circulation USING btree (target_copy) WHERE (checkin_time IS NULL);


--
-- Name: uhr_hold_idx; Type: INDEX; Schema: action; Owner: postgres; Tablespace: 
--

CREATE INDEX uhr_hold_idx ON unfulfilled_hold_list USING btree (hold);


SET search_path = action_trigger, pg_catalog;

--
-- Name: atev_def_state; Type: INDEX; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE INDEX atev_def_state ON event USING btree (event_def, state);


--
-- Name: atev_target_def_idx; Type: INDEX; Schema: action_trigger; Owner: postgres; Tablespace: 
--

CREATE INDEX atev_target_def_idx ON event USING btree (target, event_def);


SET search_path = actor, pg_catalog;

--
-- Name: actor_card_barcode_evergreen_lowercase_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_card_barcode_evergreen_lowercase_idx ON card USING btree (evergreen.lowercase(barcode));


--
-- Name: actor_card_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_card_usr_idx ON card USING btree (usr);


--
-- Name: actor_org_address_org_unit_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_address_org_unit_idx ON org_address USING btree (org_unit);


--
-- Name: actor_org_unit_billing_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_billing_address_idx ON org_unit USING btree (billing_address);


--
-- Name: actor_org_unit_holds_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_holds_address_idx ON org_unit USING btree (holds_address);


--
-- Name: actor_org_unit_ill_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_ill_address_idx ON org_unit USING btree (ill_address);


--
-- Name: actor_org_unit_mailing_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_mailing_address_idx ON org_unit USING btree (mailing_address);


--
-- Name: actor_org_unit_ou_type_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_ou_type_idx ON org_unit USING btree (ou_type);


--
-- Name: actor_org_unit_parent_ou_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_parent_ou_idx ON org_unit USING btree (parent_ou);


--
-- Name: actor_org_unit_setting_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_setting_usr_idx ON org_unit_setting USING btree (org_unit);


--
-- Name: actor_org_unit_type_parent_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_org_unit_type_parent_idx ON org_unit_type USING btree (parent);


--
-- Name: actor_stat_cat_entry_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_stat_cat_entry_usr_idx ON stat_cat_entry_usr_map USING btree (target_usr);


--
-- Name: actor_usr_addr_city_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_city_idx ON usr_address USING btree (evergreen.lowercase(city));


--
-- Name: actor_usr_addr_post_code_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_post_code_idx ON usr_address USING btree (evergreen.lowercase(post_code));


--
-- Name: actor_usr_addr_state_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_state_idx ON usr_address USING btree (evergreen.lowercase(state));


--
-- Name: actor_usr_addr_street1_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_street1_idx ON usr_address USING btree (evergreen.lowercase(street1));


--
-- Name: actor_usr_addr_street2_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_street2_idx ON usr_address USING btree (evergreen.lowercase(street2));


--
-- Name: actor_usr_addr_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_addr_usr_idx ON usr_address USING btree (usr);


--
-- Name: actor_usr_billing_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_billing_address_idx ON usr USING btree (billing_address);


--
-- Name: actor_usr_day_phone_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_day_phone_idx ON usr USING btree (evergreen.lowercase(day_phone));


--
-- Name: actor_usr_day_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_day_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(day_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_email_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_email_idx ON usr USING btree (evergreen.lowercase(email));


--
-- Name: actor_usr_evening_phone_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_evening_phone_idx ON usr USING btree (evergreen.lowercase(evening_phone));


--
-- Name: actor_usr_evening_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_evening_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(evening_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_family_name_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_family_name_idx ON usr USING btree (evergreen.lowercase(family_name));


--
-- Name: actor_usr_first_given_name_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_first_given_name_idx ON usr USING btree (evergreen.lowercase(first_given_name));


--
-- Name: actor_usr_home_ou_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_home_ou_idx ON usr USING btree (home_ou);


--
-- Name: actor_usr_ident_value2_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_ident_value2_idx ON usr USING btree (evergreen.lowercase(ident_value2));


--
-- Name: actor_usr_ident_value_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_ident_value_idx ON usr USING btree (evergreen.lowercase(ident_value));


--
-- Name: actor_usr_mailing_address_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_mailing_address_idx ON usr USING btree (mailing_address);


--
-- Name: actor_usr_note_creator_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_note_creator_idx ON usr_note USING btree (creator);


--
-- Name: actor_usr_note_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_note_usr_idx ON usr_note USING btree (usr);


--
-- Name: actor_usr_other_phone_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_other_phone_idx ON usr USING btree (evergreen.lowercase(other_phone));


--
-- Name: actor_usr_other_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_other_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(other_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_password_reset_has_been_reset_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_has_been_reset_idx ON usr_password_reset USING btree (has_been_reset);


--
-- Name: actor_usr_password_reset_request_time_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_request_time_idx ON usr_password_reset USING btree (request_time);


--
-- Name: actor_usr_password_reset_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_usr_idx ON usr_password_reset USING btree (usr);


--
-- Name: actor_usr_password_reset_uuid_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX actor_usr_password_reset_uuid_idx ON usr_password_reset USING btree (uuid);


--
-- Name: actor_usr_second_given_name_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_second_given_name_idx ON usr USING btree (evergreen.lowercase(second_given_name));


--
-- Name: actor_usr_setting_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_setting_usr_idx ON usr_setting USING btree (usr);


--
-- Name: actor_usr_standing_penalty_staff_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_standing_penalty_staff_idx ON usr_standing_penalty USING btree (staff);


--
-- Name: actor_usr_standing_penalty_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_standing_penalty_usr_idx ON usr_standing_penalty USING btree (usr);


--
-- Name: actor_usr_usrgroup_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_usrgroup_idx ON usr USING btree (usrgroup);


--
-- Name: actor_usr_usrname_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX actor_usr_usrname_idx ON usr USING btree (evergreen.lowercase(usrname));


--
-- Name: from_prox_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX from_prox_idx ON org_unit_proximity USING btree (from_org);


--
-- Name: label_once_per_org; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_org ON toolbar USING btree (org, label) WHERE (org IS NOT NULL);


--
-- Name: label_once_per_usr; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_usr ON toolbar USING btree (usr, label) WHERE (usr IS NOT NULL);


--
-- Name: label_once_per_ws; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_ws ON toolbar USING btree (ws, label) WHERE (ws IS NOT NULL);


--
-- Name: ou_lasso_lasso_ou_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX ou_lasso_lasso_ou_idx ON org_lasso_map USING btree (lasso, org_unit);


--
-- Name: ou_lasso_org_unit_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX ou_lasso_org_unit_idx ON org_lasso_map USING btree (org_unit);


--
-- Name: prox_adj_circ_lib_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_circ_lib_idx ON org_unit_proximity_adjustment USING btree (item_circ_lib);


--
-- Name: prox_adj_circ_mod_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_circ_mod_idx ON org_unit_proximity_adjustment USING btree (circ_mod);


--
-- Name: prox_adj_copy_location_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_copy_location_idx ON org_unit_proximity_adjustment USING btree (copy_location);


--
-- Name: prox_adj_once_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX prox_adj_once_idx ON org_unit_proximity_adjustment USING btree ((COALESCE(item_circ_lib, (-1))), (COALESCE(item_owning_lib, (-1))), (COALESCE(copy_location, (-1))), (COALESCE(hold_pickup_lib, (-1))), (COALESCE(hold_request_lib, (-1))), (COALESCE(circ_mod, ''::text)), pos);


--
-- Name: prox_adj_owning_lib_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_owning_lib_idx ON org_unit_proximity_adjustment USING btree (item_owning_lib);


--
-- Name: prox_adj_pickup_lib_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_pickup_lib_idx ON org_unit_proximity_adjustment USING btree (hold_pickup_lib);


--
-- Name: prox_adj_request_lib_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX prox_adj_request_lib_idx ON org_unit_proximity_adjustment USING btree (hold_request_lib);


--
-- Name: usr_activity_usr_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX usr_activity_usr_idx ON usr_activity USING btree (usr);


--
-- Name: usr_org_unit_opt_in_staff_idx; Type: INDEX; Schema: actor; Owner: postgres; Tablespace: 
--

CREATE INDEX usr_org_unit_opt_in_staff_idx ON usr_org_unit_opt_in USING btree (staff);


SET search_path = asset, pg_catalog;

--
-- Name: asset_call_number_creator_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_creator_idx ON call_number USING btree (creator);


--
-- Name: asset_call_number_dewey_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_dewey_idx ON call_number USING btree (public.call_number_dewey(label));


--
-- Name: asset_call_number_editor_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_editor_idx ON call_number USING btree (editor);


--
-- Name: asset_call_number_label_once_per_lib; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_label_once_per_lib ON call_number USING btree (record, owning_lib, label, prefix, suffix) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: asset_call_number_label_sortkey; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_label_sortkey ON call_number USING btree (evergreen.oils_text_as_bytea(label_sortkey));


--
-- Name: asset_call_number_label_sortkey_browse; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_label_sortkey_browse ON call_number USING btree (evergreen.oils_text_as_bytea(label_sortkey), evergreen.oils_text_as_bytea(label), id, owning_lib) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: asset_call_number_note_creator_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_note_creator_idx ON call_number_note USING btree (creator);


--
-- Name: asset_call_number_prefix_once_per_lib; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_prefix_once_per_lib ON call_number_prefix USING btree (label, owning_lib);


--
-- Name: asset_call_number_prefix_sortkey_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_prefix_sortkey_idx ON call_number_prefix USING btree (label_sortkey);


--
-- Name: asset_call_number_record_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_record_idx ON call_number USING btree (record);


--
-- Name: asset_call_number_suffix_once_per_lib; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_suffix_once_per_lib ON call_number_suffix USING btree (label, owning_lib);


--
-- Name: asset_call_number_suffix_sortkey_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_suffix_sortkey_idx ON call_number_suffix USING btree (label_sortkey);


--
-- Name: asset_call_number_upper_label_id_owning_lib_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_call_number_upper_label_id_owning_lib_idx ON call_number USING btree (evergreen.oils_text_as_bytea(label), id, owning_lib);


--
-- Name: asset_copy_note_creator_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_copy_note_creator_idx ON copy_note USING btree (creator);


--
-- Name: asset_copy_note_owning_copy_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_copy_note_owning_copy_idx ON copy_note USING btree (owning_copy);


--
-- Name: asset_uri_call_number_map_cn_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX asset_uri_call_number_map_cn_idx ON uri_call_number_map USING btree (call_number);


--
-- Name: copy_barcode_key; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX copy_barcode_key ON copy USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: copy_part_map_cp_part_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX copy_part_map_cp_part_idx ON copy_part_map USING btree (target_copy, part);


--
-- Name: cp_avail_cn_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_avail_cn_idx ON copy USING btree (call_number);


--
-- Name: cp_available_by_circ_lib_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_available_by_circ_lib_idx ON copy USING btree (circ_lib) WHERE (status = ANY (ARRAY[0, 7]));


--
-- Name: cp_cn_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_cn_idx ON copy USING btree (call_number);


--
-- Name: cp_create_date; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_create_date ON copy USING btree (create_date);


--
-- Name: cp_creator_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_creator_idx ON copy USING btree (creator);


--
-- Name: cp_editor_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX cp_editor_idx ON copy USING btree (editor);


--
-- Name: opac_visible_copies_copy_id_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX opac_visible_copies_copy_id_idx ON opac_visible_copies USING btree (copy_id);


--
-- Name: opac_visible_copies_idx1; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX opac_visible_copies_idx1 ON opac_visible_copies USING btree (record, circ_lib);


--
-- Name: opac_visible_copies_once_per_record_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX opac_visible_copies_once_per_record_idx ON opac_visible_copies USING btree (copy_id, record);


--
-- Name: scecm_owning_copy_idx; Type: INDEX; Schema: asset; Owner: postgres; Tablespace: 
--

CREATE INDEX scecm_owning_copy_idx ON stat_cat_entry_copy_map USING btree (owning_copy);


SET search_path = auditor, pg_catalog;

--
-- Name: aud_actor_usr_address_hist_id_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_actor_usr_address_hist_id_idx ON actor_usr_address_history USING btree (id);


--
-- Name: aud_actor_usr_hist_id_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_actor_usr_hist_id_idx ON actor_usr_history USING btree (id);


--
-- Name: aud_asset_cn_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_asset_cn_hist_creator_idx ON asset_call_number_history USING btree (creator);


--
-- Name: aud_asset_cn_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_asset_cn_hist_editor_idx ON asset_call_number_history USING btree (editor);


--
-- Name: aud_asset_cp_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_asset_cp_hist_creator_idx ON asset_copy_history USING btree (creator);


--
-- Name: aud_asset_cp_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_asset_cp_hist_editor_idx ON asset_copy_history USING btree (editor);


--
-- Name: aud_bib_rec_entry_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_bib_rec_entry_hist_creator_idx ON biblio_record_entry_history USING btree (creator);


--
-- Name: aud_bib_rec_entry_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_bib_rec_entry_hist_editor_idx ON biblio_record_entry_history USING btree (editor);


--
-- Name: aud_serial_unit_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_serial_unit_hist_creator_idx ON serial_unit_history USING btree (creator);


--
-- Name: aud_serial_unit_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: postgres; Tablespace: 
--

CREATE INDEX aud_serial_unit_hist_editor_idx ON serial_unit_history USING btree (editor);


SET search_path = authority, pg_catalog;

--
-- Name: authority_bl_bib_authority_once_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX authority_bl_bib_authority_once_idx ON bib_linking USING btree (authority, bib);


--
-- Name: authority_bl_bib_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_bl_bib_idx ON bib_linking USING btree (bib);


--
-- Name: authority_full_rec_index_vector_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_index_vector_idx ON full_rec USING gist (index_vector);


--
-- Name: authority_full_rec_record_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_record_idx ON full_rec USING btree (record);


--
-- Name: authority_full_rec_subfield_a_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_subfield_a_idx ON full_rec USING btree (value) WHERE (subfield = 'a'::text);


--
-- Name: authority_full_rec_tag_part_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_tag_part_idx ON full_rec USING btree ("substring"((tag)::text, 2));


--
-- Name: authority_full_rec_tag_subfield_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_tag_subfield_idx ON full_rec USING btree (tag, subfield);


--
-- Name: authority_full_rec_value_index; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_value_index ON full_rec USING btree (value);


--
-- Name: authority_full_rec_value_tpo_index; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_full_rec_value_tpo_index ON full_rec USING btree (value text_pattern_ops);


--
-- Name: authority_rec_descriptor_record_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_rec_descriptor_record_idx ON rec_descriptor USING btree (record);


--
-- Name: authority_record_deleted_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_deleted_idx ON record_entry USING btree (deleted) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: authority_record_entry_creator_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: authority_record_entry_editor_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: authority_record_note_creator_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_note_creator_idx ON record_note USING btree (creator);


--
-- Name: authority_record_note_editor_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_note_editor_idx ON record_note USING btree (editor);


--
-- Name: authority_record_note_record_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_record_note_record_idx ON record_note USING btree (record);


--
-- Name: authority_simple_heading_index_vector_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_simple_heading_index_vector_idx ON simple_heading USING gist (index_vector);


--
-- Name: authority_simple_heading_sort_value_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_simple_heading_sort_value_idx ON simple_heading USING btree (sort_value);


--
-- Name: authority_simple_heading_value_idx; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX authority_simple_heading_value_idx ON simple_heading USING btree (value);


--
-- Name: by_heading; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX by_heading ON record_entry USING btree (simple_normalize_heading(marc)) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: by_heading_and_thesaurus; Type: INDEX; Schema: authority; Owner: postgres; Tablespace: 
--

CREATE INDEX by_heading_and_thesaurus ON record_entry USING btree (normalize_heading(marc)) WHERE ((deleted IS FALSE) OR (deleted = false));


SET search_path = biblio, pg_catalog;

--
-- Name: biblio_record_entry_create_date_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_entry_create_date_idx ON record_entry USING btree (create_date);


--
-- Name: biblio_record_entry_creator_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: biblio_record_entry_edit_date_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_entry_edit_date_idx ON record_entry USING btree (edit_date);


--
-- Name: biblio_record_entry_editor_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: biblio_record_entry_fp_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_entry_fp_idx ON record_entry USING btree (fingerprint);


--
-- Name: biblio_record_note_creator_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_note_creator_idx ON record_note USING btree (creator);


--
-- Name: biblio_record_note_editor_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_note_editor_idx ON record_note USING btree (editor);


--
-- Name: biblio_record_note_record_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX biblio_record_note_record_idx ON record_note USING btree (record);


--
-- Name: biblio_record_unique_tcn; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX biblio_record_unique_tcn ON record_entry USING btree (tcn_value) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: peer_bib_copy_map_copy_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX peer_bib_copy_map_copy_idx ON peer_bib_copy_map USING btree (target_copy);


--
-- Name: peer_bib_copy_map_record_idx; Type: INDEX; Schema: biblio; Owner: postgres; Tablespace: 
--

CREATE INDEX peer_bib_copy_map_record_idx ON peer_bib_copy_map USING btree (peer_record);


SET search_path = config, pg_catalog;

--
-- Name: ccmm_once_per_paramset; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX ccmm_once_per_paramset ON circ_matrix_matchpoint USING btree (org_unit, grp, (COALESCE(circ_modifier, ''::text)), (COALESCE((copy_location)::text, ''::text)), (COALESCE(marc_type, ''::text)), (COALESCE(marc_form, ''::text)), (COALESCE(marc_bib_level, ''::text)), (COALESCE(marc_vr_format, ''::text)), (COALESCE((copy_circ_lib)::text, ''::text)), (COALESCE((copy_owning_lib)::text, ''::text)), (COALESCE((user_home_ou)::text, ''::text)), (COALESCE((ref_flag)::text, ''::text)), (COALESCE((juvenile_flag)::text, ''::text)), (COALESCE((is_renewal)::text, ''::text)), (COALESCE((usr_age_lower_bound)::text, ''::text)), (COALESCE((usr_age_upper_bound)::text, ''::text)), (COALESCE((item_age)::text, ''::text))) WHERE active;


--
-- Name: chmm_once_per_paramset; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX chmm_once_per_paramset ON hold_matrix_matchpoint USING btree ((COALESCE((user_home_ou)::text, ''::text)), (COALESCE((request_ou)::text, ''::text)), (COALESCE((pickup_ou)::text, ''::text)), (COALESCE((item_owning_ou)::text, ''::text)), (COALESCE((item_circ_ou)::text, ''::text)), (COALESCE((usr_grp)::text, ''::text)), (COALESCE((requestor_grp)::text, ''::text)), (COALESCE(circ_modifier, ''::text)), (COALESCE(marc_type, ''::text)), (COALESCE(marc_form, ''::text)), (COALESCE(marc_bib_level, ''::text)), (COALESCE(marc_vr_format, ''::text)), (COALESCE((juvenile_flag)::text, ''::text)), (COALESCE((ref_flag)::text, ''::text)), (COALESCE((item_age)::text, ''::text))) WHERE active;


--
-- Name: config_metabib_field_class_name_idx; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX config_metabib_field_class_name_idx ON metabib_field USING btree (field_class, name);


--
-- Name: cwa_one_active_per_ou; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX cwa_one_active_per_ou ON weight_assoc USING btree (org_unit) WHERE active;


--
-- Name: i18n_identity; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX i18n_identity ON i18n_core USING btree (fq_field, identity_value, translation);


--
-- Name: idl_field_doc_identity; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idl_field_doc_identity ON idl_field_doc USING btree (fm_class, field, owner);


--
-- Name: unique_wwh; Type: INDEX; Schema: config; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX unique_wwh ON usr_activity_type USING btree ((COALESCE(ewho, ''::text)), (COALESCE(ewhat, ''::text)), (COALESCE(ehow, ''::text)));


SET search_path = container, pg_catalog;

--
-- Name: copy_bucket_item_bucket_idx; Type: INDEX; Schema: container; Owner: postgres; Tablespace: 
--

CREATE INDEX copy_bucket_item_bucket_idx ON copy_bucket_item USING btree (bucket);


--
-- Name: user_bucket_item_target_user_idx; Type: INDEX; Schema: container; Owner: postgres; Tablespace: 
--

CREATE INDEX user_bucket_item_target_user_idx ON user_bucket_item USING btree (target_user);


SET search_path = metabib, pg_catalog;

--
-- Name: browse_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX browse_entry_def_map_def_idx ON browse_entry_def_map USING btree (def);


--
-- Name: browse_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX browse_entry_def_map_entry_idx ON browse_entry_def_map USING btree (entry);


--
-- Name: browse_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX browse_entry_def_map_source_idx ON browse_entry_def_map USING btree (source);


--
-- Name: metabib_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_index_vector_idx ON author_field_entry USING gist (index_vector);


--
-- Name: metabib_author_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_source_idx ON author_field_entry USING btree (source);


--
-- Name: metabib_author_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_value_idx ON author_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_browse_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_browse_entry_index_vector_idx ON browse_entry USING gin (index_vector);


--
-- Name: metabib_combined_author_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_author_field_entry_fakepk_idx ON combined_author_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_author_field_entry_index_vector_idx ON combined_author_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_author_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_author_field_source_idx ON combined_author_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_identifier_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_identifier_field_entry_fakepk_idx ON combined_identifier_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_identifier_field_entry_index_vector_idx ON combined_identifier_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_identifier_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_identifier_field_source_idx ON combined_identifier_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_keyword_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_keyword_field_entry_fakepk_idx ON combined_keyword_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_keyword_field_entry_index_vector_idx ON combined_keyword_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_keyword_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_keyword_field_source_idx ON combined_keyword_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_series_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_series_field_entry_fakepk_idx ON combined_series_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_series_field_entry_index_vector_idx ON combined_series_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_series_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_series_field_source_idx ON combined_series_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_subject_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_subject_field_entry_fakepk_idx ON combined_subject_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_subject_field_entry_index_vector_idx ON combined_subject_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_subject_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_subject_field_source_idx ON combined_subject_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_title_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_title_field_entry_fakepk_idx ON combined_title_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_title_field_entry_index_vector_idx ON combined_title_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_title_field_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_combined_title_field_source_idx ON combined_title_field_entry USING btree (metabib_field);


--
-- Name: metabib_facet_entry_field_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_facet_entry_field_idx ON facet_entry USING btree (field);


--
-- Name: metabib_facet_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_facet_entry_source_idx ON facet_entry USING btree (source);


--
-- Name: metabib_facet_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_facet_entry_value_idx ON facet_entry USING btree ("substring"(value, 1, 1024));


--
-- Name: metabib_full_rec_02x_tag_subfield_lower_substring; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_02x_tag_subfield_lower_substring ON real_full_rec USING btree (tag, subfield, lower("substring"(value, 1, 1024))) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_index_vector_idx ON real_full_rec USING gist (index_vector);


--
-- Name: metabib_full_rec_isxn_caseless_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_isxn_caseless_idx ON real_full_rec USING btree (lower(value)) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_record_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_record_idx ON real_full_rec USING btree (record);


--
-- Name: metabib_full_rec_tag_subfield_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_tag_subfield_idx ON real_full_rec USING btree (tag, subfield);


--
-- Name: metabib_full_rec_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_value_idx ON real_full_rec USING btree ("substring"(value, 1, 1024));


--
-- Name: metabib_full_rec_value_tpo_index; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_full_rec_value_tpo_index ON real_full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops);


--
-- Name: metabib_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_index_vector_idx ON identifier_field_entry USING gist (index_vector);


--
-- Name: metabib_identifier_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_source_idx ON identifier_field_entry USING btree (source);


--
-- Name: metabib_identifier_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_value_idx ON identifier_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_index_vector_idx ON keyword_field_entry USING gist (index_vector);


--
-- Name: metabib_keyword_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_source_idx ON keyword_field_entry USING btree (source);


--
-- Name: metabib_keyword_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_value_idx ON keyword_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_metarecord_fingerprint_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_metarecord_fingerprint_idx ON metarecord USING btree (fingerprint);


--
-- Name: metabib_metarecord_master_record_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_metarecord_master_record_idx ON metarecord USING btree (master_record);


--
-- Name: metabib_metarecord_source_map_metarecord_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_metarecord_source_map_metarecord_idx ON metarecord_source_map USING btree (metarecord);


--
-- Name: metabib_metarecord_source_map_source_record_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_metarecord_source_map_source_record_idx ON metarecord_source_map USING btree (source);


--
-- Name: metabib_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_index_vector_idx ON series_field_entry USING gist (index_vector);


--
-- Name: metabib_series_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_source_idx ON series_field_entry USING btree (source);


--
-- Name: metabib_series_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_value_idx ON series_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_index_vector_idx ON subject_field_entry USING gist (index_vector);


--
-- Name: metabib_subject_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_source_idx ON subject_field_entry USING btree (source);


--
-- Name: metabib_subject_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_value_idx ON subject_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_svf_attrs_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_svf_attrs_idx ON record_attr USING gist (attrs);


--
-- Name: metabib_svf_date1_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_svf_date1_idx ON record_attr USING btree (((attrs OPERATOR(public.->) 'date1'::text)));


--
-- Name: metabib_svf_dates_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_svf_dates_idx ON record_attr USING btree (((attrs OPERATOR(public.->) 'date1'::text)), ((attrs OPERATOR(public.->) 'date2'::text)));


--
-- Name: metabib_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_index_vector_idx ON title_field_entry USING gist (index_vector);


--
-- Name: metabib_title_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_source_idx ON title_field_entry USING btree (source);


--
-- Name: metabib_title_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: postgres; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_value_idx ON title_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


SET search_path = money, pg_catalog;

--
-- Name: circ_open_date_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX circ_open_date_idx ON grocery USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: m_b_time_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_b_time_idx ON billing USING btree (billing_ts);


--
-- Name: m_b_x_open_xacts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_b_x_open_xacts_idx ON billable_xact USING btree (usr);


--
-- Name: m_b_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_b_xact_idx ON billing USING btree (xact);


--
-- Name: m_c_t_collector_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_c_t_collector_idx ON collections_tracker USING btree (collector);


--
-- Name: m_c_t_usr_collector_location_once_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX m_c_t_usr_collector_location_once_idx ON collections_tracker USING btree (usr, collector, location);


--
-- Name: m_g_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_g_usr_idx ON grocery USING btree (usr);


--
-- Name: m_p_time_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_p_time_idx ON payment USING btree (payment_ts);


--
-- Name: m_p_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX m_p_xact_idx ON payment USING btree (xact);


--
-- Name: money_cash_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_cash_id_idx ON cash_payment USING btree (id);


--
-- Name: money_cash_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_cash_payment_accepting_usr_idx ON cash_payment USING btree (accepting_usr);


--
-- Name: money_cash_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_cash_payment_cash_drawer_idx ON cash_payment USING btree (cash_drawer);


--
-- Name: money_cash_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_cash_payment_ts_idx ON cash_payment USING btree (payment_ts);


--
-- Name: money_cash_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_cash_payment_xact_idx ON cash_payment USING btree (xact);


--
-- Name: money_check_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_check_id_idx ON check_payment USING btree (id);


--
-- Name: money_check_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_check_payment_accepting_usr_idx ON check_payment USING btree (accepting_usr);


--
-- Name: money_check_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_check_payment_cash_drawer_idx ON check_payment USING btree (cash_drawer);


--
-- Name: money_check_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_check_payment_ts_idx ON check_payment USING btree (payment_ts);


--
-- Name: money_check_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_check_payment_xact_idx ON check_payment USING btree (xact);


--
-- Name: money_credit_card_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_card_id_idx ON credit_card_payment USING btree (id);


--
-- Name: money_credit_card_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_card_payment_accepting_usr_idx ON credit_card_payment USING btree (accepting_usr);


--
-- Name: money_credit_card_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_card_payment_cash_drawer_idx ON credit_card_payment USING btree (cash_drawer);


--
-- Name: money_credit_card_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_card_payment_ts_idx ON credit_card_payment USING btree (payment_ts);


--
-- Name: money_credit_card_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_card_payment_xact_idx ON credit_card_payment USING btree (xact);


--
-- Name: money_credit_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_id_idx ON credit_payment USING btree (id);


--
-- Name: money_credit_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_payment_accepting_usr_idx ON credit_payment USING btree (accepting_usr);


--
-- Name: money_credit_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_payment_payment_ts_idx ON credit_payment USING btree (payment_ts);


--
-- Name: money_credit_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_credit_payment_xact_idx ON credit_payment USING btree (xact);


--
-- Name: money_forgive_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_forgive_id_idx ON forgive_payment USING btree (id);


--
-- Name: money_forgive_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_forgive_payment_accepting_usr_idx ON forgive_payment USING btree (accepting_usr);


--
-- Name: money_forgive_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_forgive_payment_payment_ts_idx ON forgive_payment USING btree (payment_ts);


--
-- Name: money_forgive_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_forgive_payment_xact_idx ON forgive_payment USING btree (xact);


--
-- Name: money_goods_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_goods_id_idx ON goods_payment USING btree (id);


--
-- Name: money_goods_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_goods_payment_accepting_usr_idx ON goods_payment USING btree (accepting_usr);


--
-- Name: money_goods_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_goods_payment_payment_ts_idx ON goods_payment USING btree (payment_ts);


--
-- Name: money_goods_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_goods_payment_xact_idx ON goods_payment USING btree (xact);


--
-- Name: money_mat_summary_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_mat_summary_usr_idx ON materialized_billable_xact_summary USING btree (usr);


--
-- Name: money_mat_summary_xact_start_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_mat_summary_xact_start_idx ON materialized_billable_xact_summary USING btree (xact_start);


--
-- Name: money_work_id_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_work_id_idx ON work_payment USING btree (id);


--
-- Name: money_work_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_work_payment_accepting_usr_idx ON work_payment USING btree (accepting_usr);


--
-- Name: money_work_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_work_payment_payment_ts_idx ON work_payment USING btree (payment_ts);


--
-- Name: money_work_payment_xact_idx; Type: INDEX; Schema: money; Owner: postgres; Tablespace: 
--

CREATE INDEX money_work_payment_xact_idx ON work_payment USING btree (xact);


SET search_path = offline, pg_catalog;

--
-- Name: offline_script_pkey; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_script_pkey ON script USING btree (id);


--
-- Name: offline_script_session; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_script_session ON script USING btree (session);


--
-- Name: offline_script_ws; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_script_ws ON script USING btree (workstation);


--
-- Name: offline_session_creation; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_session_creation ON session USING btree (create_time);


--
-- Name: offline_session_org; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_session_org ON session USING btree (org);


--
-- Name: offline_session_pkey; Type: INDEX; Schema: offline; Owner: postgres; Tablespace: 
--

CREATE INDEX offline_session_pkey ON session USING btree (key);


SET search_path = permission, pg_catalog;

--
-- Name: grp_tree_parent_idx; Type: INDEX; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE INDEX grp_tree_parent_idx ON grp_tree USING btree (parent);


--
-- Name: perm_list_code_idx; Type: INDEX; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE INDEX perm_list_code_idx ON perm_list USING btree (code);


--
-- Name: uopm_usr_idx; Type: INDEX; Schema: permission; Owner: postgres; Tablespace: 
--

CREATE INDEX uopm_usr_idx ON usr_object_perm_map USING btree (usr);


SET search_path = query, pg_catalog;

--
-- Name: from_parent_seq; Type: INDEX; Schema: query; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX from_parent_seq ON from_relation USING btree (parent_relation, seq_no) WHERE (parent_relation IS NOT NULL);


--
-- Name: query_expr_parent_seq; Type: INDEX; Schema: query; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX query_expr_parent_seq ON expression USING btree (parent_expr, seq_no) WHERE (parent_expr IS NOT NULL);


--
-- Name: query_function_sig_name_idx; Type: INDEX; Schema: query; Owner: postgres; Tablespace: 
--

CREATE INDEX query_function_sig_name_idx ON function_sig USING btree (function_name);


SET search_path = reporter, pg_catalog;

--
-- Name: rpt_output_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_output_fldr_owner_idx ON output_folder USING btree (owner);


--
-- Name: rpt_output_folder_once_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_output_folder_once_idx ON output_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_output_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_output_folder_once_parent_idx ON output_folder USING btree (name, parent);


--
-- Name: rpt_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_report_folder_once_idx ON report_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_report_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_report_folder_once_parent_idx ON report_folder USING btree (name, parent);


--
-- Name: rpt_rpt_fldr_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_rpt_fldr_idx ON report USING btree (folder);


--
-- Name: rpt_rpt_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_rpt_fldr_owner_idx ON report_folder USING btree (owner);


--
-- Name: rpt_rpt_owner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_rpt_owner_idx ON report USING btree (owner);


--
-- Name: rpt_sched_folder_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_sched_folder_idx ON schedule USING btree (folder);


--
-- Name: rpt_sched_runner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_sched_runner_idx ON schedule USING btree (runner);


--
-- Name: rpt_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_template_folder_once_idx ON template_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_template_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rpt_template_folder_once_parent_idx ON template_folder USING btree (name, parent);


--
-- Name: rpt_tmpl_fldr_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_tmpl_fldr_idx ON template USING btree (folder);


--
-- Name: rpt_tmpl_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_tmpl_fldr_owner_idx ON template_folder USING btree (owner);


--
-- Name: rpt_tmpl_owner_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE INDEX rpt_tmpl_owner_idx ON template USING btree (owner);


--
-- Name: rtp_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rtp_report_folder_once_idx ON report USING btree (name, folder);


--
-- Name: rtp_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rtp_template_folder_once_idx ON template USING btree (name, folder);


SET search_path = search, pg_catalog;

--
-- Name: bump_once_per_field_idx; Type: INDEX; Schema: search; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX bump_once_per_field_idx ON relevance_adjustment USING btree (field, bump_type);


SET search_path = serial, pg_catalog;

--
-- Name: assist_holdings_display; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX assist_holdings_display ON materialized_holding_code USING btree (issuance, subfield);


--
-- Name: label_once_per_dist; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_dist ON stream USING btree (distribution, routing_label) WHERE (routing_label IS NOT NULL);


--
-- Name: one_dist_per_sre_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX one_dist_per_sre_idx ON distribution USING btree (record_entry);


--
-- Name: serial_basic_summary_dist_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_basic_summary_dist_idx ON basic_summary USING btree (distribution);


--
-- Name: serial_caption_and_pattern_sub_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_caption_and_pattern_sub_idx ON caption_and_pattern USING btree (subscription);


--
-- Name: serial_distribution_holding_lib_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_distribution_holding_lib_idx ON distribution USING btree (holding_lib);


--
-- Name: serial_distribution_note_dist_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_distribution_note_dist_idx ON distribution_note USING btree (distribution);


--
-- Name: serial_distribution_sub_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_distribution_sub_idx ON distribution USING btree (subscription);


--
-- Name: serial_index_summary_dist_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_index_summary_dist_idx ON index_summary USING btree (distribution);


--
-- Name: serial_issuance_caption_and_pattern_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_issuance_caption_and_pattern_idx ON issuance USING btree (caption_and_pattern);


--
-- Name: serial_issuance_date_published_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_issuance_date_published_idx ON issuance USING btree (date_published);


--
-- Name: serial_issuance_sub_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_issuance_sub_idx ON issuance USING btree (subscription);


--
-- Name: serial_item_date_received_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_date_received_idx ON item USING btree (date_received);


--
-- Name: serial_item_issuance_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_issuance_idx ON item USING btree (issuance);


--
-- Name: serial_item_note_item_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_note_item_idx ON item_note USING btree (item);


--
-- Name: serial_item_status_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_status_idx ON item USING btree (status);


--
-- Name: serial_item_stream_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_stream_idx ON item USING btree (stream);


--
-- Name: serial_item_unit_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_unit_idx ON item USING btree (unit);


--
-- Name: serial_item_uri_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_item_uri_idx ON item USING btree (uri);


--
-- Name: serial_record_entry_creator_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: serial_record_entry_editor_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: serial_record_entry_owning_lib_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_record_entry_owning_lib_idx ON record_entry USING btree (owning_lib, deleted);


--
-- Name: serial_routing_list_user_reader_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_routing_list_user_reader_idx ON routing_list_user USING btree (reader);


--
-- Name: serial_routing_list_user_stream_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_routing_list_user_stream_idx ON routing_list_user USING btree (stream);


--
-- Name: serial_stream_dist_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_stream_dist_idx ON stream USING btree (distribution);


--
-- Name: serial_subscription_note_sub_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_subscription_note_sub_idx ON subscription_note USING btree (subscription);


--
-- Name: serial_subscription_owner_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_subscription_owner_idx ON subscription USING btree (owning_lib);


--
-- Name: serial_subscription_record_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_subscription_record_idx ON subscription USING btree (record_entry);


--
-- Name: serial_supplement_summary_dist_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX serial_supplement_summary_dist_idx ON supplement_summary USING btree (distribution);


--
-- Name: unit_avail_cn_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX unit_avail_cn_idx ON unit USING btree (call_number);


--
-- Name: unit_barcode_key; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX unit_barcode_key ON unit USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: unit_cn_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX unit_cn_idx ON unit USING btree (call_number);


--
-- Name: unit_creator_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX unit_creator_idx ON unit USING btree (creator);


--
-- Name: unit_editor_idx; Type: INDEX; Schema: serial; Owner: postgres; Tablespace: 
--

CREATE INDEX unit_editor_idx ON unit USING btree (editor);


SET search_path = vandelay, pg_catalog;

--
-- Name: queued_authority_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE INDEX queued_authority_record_attr_record_idx ON queued_authority_record_attr USING btree (record);


--
-- Name: queued_authority_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE INDEX queued_authority_record_queue_idx ON queued_authority_record USING btree (queue);


--
-- Name: queued_bib_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE INDEX queued_bib_record_attr_record_idx ON queued_bib_record_attr USING btree (record);


--
-- Name: queued_bib_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE INDEX queued_bib_record_queue_idx ON queued_bib_record USING btree (queue);


--
-- Name: vmsq_def_once_per_set; Type: INDEX; Schema: vandelay; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX vmsq_def_once_per_set ON match_set_quality USING btree (match_set, (COALESCE(tag, ''::text)), (COALESCE(subfield, ''::text)), (COALESCE(svf, ''::text)), value);


SET search_path = actor, pg_catalog;

--
-- Name: protect_user_delete; Type: RULE; Schema: actor; Owner: postgres
--

CREATE RULE protect_user_delete AS ON DELETE TO usr DO INSTEAD UPDATE usr SET deleted = true WHERE (old.id = usr.id);


SET search_path = asset, pg_catalog;

--
-- Name: protect_cn_delete; Type: RULE; Schema: asset; Owner: postgres
--

CREATE RULE protect_cn_delete AS ON DELETE TO call_number DO INSTEAD UPDATE call_number SET deleted = true WHERE (old.id = call_number.id);


--
-- Name: protect_copy_delete; Type: RULE; Schema: asset; Owner: postgres
--

CREATE RULE protect_copy_delete AS ON DELETE TO copy DO INSTEAD UPDATE copy SET deleted = true WHERE (old.id = copy.id);


SET search_path = authority, pg_catalog;

--
-- Name: protect_authority_rec_delete; Type: RULE; Schema: authority; Owner: postgres
--

CREATE RULE protect_authority_rec_delete AS ON DELETE TO record_entry DO INSTEAD (UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id); DELETE FROM full_rec WHERE (full_rec.record = old.id); );


SET search_path = biblio, pg_catalog;

--
-- Name: protect_bib_rec_delete; Type: RULE; Schema: biblio; Owner: postgres
--

CREATE RULE protect_bib_rec_delete AS ON DELETE TO record_entry DO INSTEAD UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id);


SET search_path = metabib, pg_catalog;

--
-- Name: metabib_full_rec_delete_rule; Type: RULE; Schema: metabib; Owner: postgres
--

CREATE RULE metabib_full_rec_delete_rule AS ON DELETE TO full_rec DO INSTEAD DELETE FROM real_full_rec WHERE (real_full_rec.id = old.id);


--
-- Name: metabib_full_rec_insert_rule; Type: RULE; Schema: metabib; Owner: postgres
--

CREATE RULE metabib_full_rec_insert_rule AS ON INSERT TO full_rec DO INSTEAD INSERT INTO real_full_rec (id, record, tag, ind1, ind2, subfield, value, index_vector) VALUES (COALESCE(new.id, nextval('full_rec_id_seq'::regclass)), new.record, new.tag, new.ind1, new.ind2, new.subfield, new.value, new.index_vector);


--
-- Name: metabib_full_rec_update_rule; Type: RULE; Schema: metabib; Owner: postgres
--

CREATE RULE metabib_full_rec_update_rule AS ON UPDATE TO full_rec DO INSTEAD UPDATE real_full_rec SET id = new.id, record = new.record, tag = new.tag, ind1 = new.ind1, ind2 = new.ind2, subfield = new.subfield, value = new.value, index_vector = new.index_vector WHERE (real_full_rec.id = old.id);


SET search_path = money, pg_catalog;

--
-- Name: money_payment_view_update; Type: RULE; Schema: money; Owner: postgres
--

CREATE RULE money_payment_view_update AS ON UPDATE TO payment_view DO INSTEAD UPDATE payment SET xact = new.xact, payment_ts = new.payment_ts, voided = new.voided, amount = new.amount, note = new.note WHERE (payment.id = new.id);


SET search_path = query, pg_catalog;

--
-- Name: query_expr_string_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_string_delete_rule AS ON DELETE TO expr_xstr DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_string_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_string_insert_rule AS ON INSERT TO expr_xstr DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xstr'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: query_expr_string_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_string_update_rule AS ON UPDATE TO expr_xstr DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal WHERE (expression.id = old.id);


--
-- Name: query_expr_xbet_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbet_delete_rule AS ON DELETE TO expr_xbet DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbet_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbet_insert_rule AS ON INSERT TO expr_xbet DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbet'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xbet_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbet_update_rule AS ON UPDATE TO expr_xbet DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xbind_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbind_delete_rule AS ON DELETE TO expr_xbind DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbind_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbind_insert_rule AS ON INSERT TO expr_xbind DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, bind_variable) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbind'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.bind_variable);


--
-- Name: query_expr_xbind_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbind_update_rule AS ON UPDATE TO expr_xbind DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, bind_variable = new.bind_variable WHERE (expression.id = old.id);


--
-- Name: query_expr_xbool_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbool_delete_rule AS ON DELETE TO expr_xbool DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbool_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbool_insert_rule AS ON INSERT TO expr_xbool DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbool'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal, COALESCE(new.negate, false));


--
-- Name: query_expr_xbool_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xbool_update_rule AS ON UPDATE TO expr_xbool DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcase_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcase_delete_rule AS ON DELETE TO expr_xcase DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcase_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcase_insert_rule AS ON INSERT TO expr_xcase DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcase'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xcase_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcase_update_rule AS ON UPDATE TO expr_xcase DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcast_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcast_delete_rule AS ON DELETE TO expr_xcast DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcast_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcast_insert_rule AS ON INSERT TO expr_xcast DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, cast_type, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcast'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.cast_type, COALESCE(new.negate, false));


--
-- Name: query_expr_xcast_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcast_update_rule AS ON UPDATE TO expr_xcast DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, cast_type = new.cast_type, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcol_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcol_delete_rule AS ON DELETE TO expr_xcol DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcol_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcol_insert_rule AS ON INSERT TO expr_xcol DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, table_alias, column_name, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcol'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.table_alias, new.column_name, COALESCE(new.negate, false));


--
-- Name: query_expr_xcol_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xcol_update_rule AS ON UPDATE TO expr_xcol DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, table_alias = new.table_alias, column_name = new.column_name, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xex_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xex_delete_rule AS ON DELETE TO expr_xex DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xex_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xex_insert_rule AS ON INSERT TO expr_xex DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xex'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xex_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xex_update_rule AS ON UPDATE TO expr_xex DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xfunc_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xfunc_delete_rule AS ON DELETE TO expr_xfunc DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xfunc_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xfunc_insert_rule AS ON INSERT TO expr_xfunc DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, column_name, function_id, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xfunc'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.column_name, new.function_id, COALESCE(new.negate, false));


--
-- Name: query_expr_xfunc_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xfunc_update_rule AS ON UPDATE TO expr_xfunc DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, column_name = new.column_name, function_id = new.function_id, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xin_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xin_delete_rule AS ON DELETE TO expr_xin DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xin_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xin_insert_rule AS ON INSERT TO expr_xin DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xin'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xin_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xin_update_rule AS ON UPDATE TO expr_xin DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xisnull_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xisnull_delete_rule AS ON DELETE TO expr_xisnull DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xisnull_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xisnull_insert_rule AS ON INSERT TO expr_xisnull DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xisnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xisnull_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xisnull_update_rule AS ON UPDATE TO expr_xisnull DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xnull_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnull_delete_rule AS ON DELETE TO expr_xnull DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xnull_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnull_insert_rule AS ON INSERT TO expr_xnull DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), COALESCE(new.negate, false));


--
-- Name: query_expr_xnull_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnull_update_rule AS ON UPDATE TO expr_xnull DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xnum_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnum_delete_rule AS ON DELETE TO expr_xnum DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xnum_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnum_insert_rule AS ON INSERT TO expr_xnum DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xnum'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: query_expr_xnum_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xnum_update_rule AS ON UPDATE TO expr_xnum DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal WHERE (expression.id = old.id);


--
-- Name: query_expr_xop_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xop_delete_rule AS ON DELETE TO expr_xop DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xop_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xop_insert_rule AS ON INSERT TO expr_xop DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, operator, right_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xop'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.operator, new.right_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xop_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xop_update_rule AS ON UPDATE TO expr_xop DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, operator = new.operator, right_operand = new.right_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xser_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xser_delete_rule AS ON DELETE TO expr_xser DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xser_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xser_insert_rule AS ON INSERT TO expr_xser DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, operator, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xser'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.operator, COALESCE(new.negate, false));


--
-- Name: query_expr_xser_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xser_update_rule AS ON UPDATE TO expr_xser DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, operator = new.operator, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xsubq_delete_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xsubq_delete_rule AS ON DELETE TO expr_xsubq DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xsubq_insert_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xsubq_insert_rule AS ON INSERT TO expr_xsubq DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xsubq'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xsubq_update_rule; Type: RULE; Schema: query; Owner: postgres
--

CREATE RULE query_expr_xsubq_update_rule AS ON UPDATE TO expr_xsubq DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


SET search_path = serial, pg_catalog;

--
-- Name: protect_mfhd_delete; Type: RULE; Schema: serial; Owner: postgres
--

CREATE RULE protect_mfhd_delete AS ON DELETE TO record_entry DO INSTEAD UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id);


--
-- Name: protect_serial_unit_delete; Type: RULE; Schema: serial; Owner: postgres
--

CREATE RULE protect_serial_unit_delete AS ON DELETE TO unit DO INSTEAD UPDATE unit SET deleted = true WHERE (old.id = unit.id);


SET search_path = acq, pg_catalog;

--
-- Name: acq_fund_alloc_percent_val_trig; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER acq_fund_alloc_percent_val_trig BEFORE INSERT OR UPDATE ON fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE fund_alloc_percent_val();


--
-- Name: acqfap_limit_100_trig; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER acqfap_limit_100_trig AFTER INSERT OR UPDATE ON fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE fap_limit_100();


--
-- Name: audit_acq_invoice_entry_update_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER audit_acq_invoice_entry_update_trigger AFTER DELETE OR UPDATE ON invoice_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_entry_func();


--
-- Name: audit_acq_invoice_item_update_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER audit_acq_invoice_item_update_trigger AFTER DELETE OR UPDATE ON invoice_item FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_item_func();


--
-- Name: audit_acq_invoice_update_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER audit_acq_invoice_update_trigger AFTER DELETE OR UPDATE ON invoice FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_func();


--
-- Name: audit_acq_lineitem_update_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER audit_acq_lineitem_update_trigger AFTER DELETE OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE audit_acq_lineitem_func();


--
-- Name: audit_acq_purchase_order_update_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER audit_acq_purchase_order_update_trigger AFTER DELETE OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE audit_acq_purchase_order_func();


--
-- Name: cleanup_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER cleanup_lineitem_trigger BEFORE DELETE OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE public.cleanup_acq_marc();


--
-- Name: ingest_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER ingest_lineitem_trigger AFTER INSERT OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE public.ingest_acq_marc();


--
-- Name: po_name_default_trg; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER po_name_default_trg BEFORE INSERT OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE purchase_order_name_default();


--
-- Name: po_org_name_date_unique_trg; Type: TRIGGER; Schema: acq; Owner: postgres
--

CREATE TRIGGER po_org_name_date_unique_trg BEFORE INSERT OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE po_org_name_date_unique();


SET search_path = action, pg_catalog;

--
-- Name: action_circulation_aging_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER action_circulation_aging_tgr BEFORE DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE age_circ_on_delete();


--
-- Name: action_circulation_stop_fines_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER action_circulation_stop_fines_tgr BEFORE UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE circulation_claims_returned();


--
-- Name: action_circulation_target_copy_trig; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER action_circulation_target_copy_trig AFTER INSERT OR UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE evergreen.fake_fkey_tgr('target_copy');


--
-- Name: action_survey_response_answer_date_fixup_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER action_survey_response_answer_date_fixup_tgr BEFORE INSERT ON survey_response FOR EACH ROW EXECUTE PROCEDURE survey_response_answer_date_fixup();


--
-- Name: age_parent_circ; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER age_parent_circ AFTER DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE age_parent_circ_on_delete();


--
-- Name: archive_stat_cats_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER archive_stat_cats_tgr AFTER INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE archive_stat_cats();


--
-- Name: fill_circ_copy_location_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER fill_circ_copy_location_tgr BEFORE INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE fill_circ_copy_location();


--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('circulation');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


--
-- Name: push_due_date_tgr; Type: TRIGGER; Schema: action; Owner: postgres
--

CREATE TRIGGER push_due_date_tgr BEFORE INSERT OR UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE push_circ_due_time();


SET search_path = actor, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: actor_crypt_pw_insert_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER actor_crypt_pw_insert_trigger BEFORE INSERT ON usr FOR EACH ROW EXECUTE PROCEDURE crypt_pw_insert();


--
-- Name: actor_crypt_pw_update_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER actor_crypt_pw_update_trigger BEFORE UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE crypt_pw_update();


--
-- Name: actor_org_unit_parent_protect_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER actor_org_unit_parent_protect_trigger BEFORE INSERT OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE org_unit_parent_protect();


--
-- Name: actor_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER actor_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON stat_cat FOR EACH ROW EXECUTE PROCEDURE stat_cat_check();


--
-- Name: au_update_trig; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER au_update_trig BEFORE INSERT OR UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE au_updated();


--
-- Name: audit_actor_org_unit_update_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER audit_actor_org_unit_update_trigger AFTER DELETE OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_org_unit_func();


--
-- Name: audit_actor_usr_address_update_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER audit_actor_usr_address_update_trigger AFTER DELETE OR UPDATE ON usr_address FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_address_func();


--
-- Name: audit_actor_usr_update_trigger; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER audit_actor_usr_update_trigger AFTER DELETE OR UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_func();


--
-- Name: log_ous_change; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER log_ous_change BEFORE INSERT OR UPDATE ON org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_change_log();


--
-- Name: log_ous_del; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER log_ous_del BEFORE DELETE ON org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_delete_log();


--
-- Name: proximity_update_tgr; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER proximity_update_tgr AFTER INSERT OR DELETE OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE org_unit_prox_update();


--
-- Name: remove_transient_usr_activity; Type: TRIGGER; Schema: actor; Owner: postgres
--

CREATE TRIGGER remove_transient_usr_activity BEFORE INSERT ON usr_activity FOR EACH ROW EXECUTE PROCEDURE usr_activity_transient_trg();


SET search_path = asset, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy_location FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: acp_created_trig; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER acp_created_trig BEFORE INSERT ON copy FOR EACH ROW EXECUTE PROCEDURE acp_created();


--
-- Name: acp_status_changed_trig; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER acp_status_changed_trig BEFORE UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE acp_status_changed();


--
-- Name: asset_label_sortkey_trigger; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER asset_label_sortkey_trigger BEFORE INSERT OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE label_normalizer();


--
-- Name: asset_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER asset_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON stat_cat FOR EACH ROW EXECUTE PROCEDURE stat_cat_check();


--
-- Name: audit_asset_call_number_update_trigger; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER audit_asset_call_number_update_trigger AFTER DELETE OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_call_number_func();


--
-- Name: audit_asset_copy_update_trigger; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER audit_asset_copy_update_trigger AFTER DELETE OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_copy_func();


--
-- Name: autogenerate_placeholder_barcode; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE autogenerate_placeholder_barcode();


--
-- Name: prefix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER prefix_normalize_tgr BEFORE INSERT OR UPDATE ON call_number_prefix FOR EACH ROW EXECUTE PROCEDURE normalize_affix_sortkey();


--
-- Name: suffix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: postgres
--

CREATE TRIGGER suffix_normalize_tgr BEFORE INSERT OR UPDATE ON call_number_suffix FOR EACH ROW EXECUTE PROCEDURE normalize_affix_sortkey();


SET search_path = authority, pg_catalog;

--
-- Name: a_marcxml_is_well_formed; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.check_marcxml_well_formed();


--
-- Name: aaa_auth_ingest_or_delete; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER aaa_auth_ingest_or_delete AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE indexing_ingest_or_delete();


--
-- Name: authority_full_rec_fti_trigger; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER authority_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: authority_simple_heading_fti_trigger; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER authority_simple_heading_fti_trigger BEFORE INSERT OR UPDATE ON simple_heading FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: map_thesaurus_to_control_set; Type: TRIGGER; Schema: authority; Owner: postgres
--

CREATE TRIGGER map_thesaurus_to_control_set BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE map_thesaurus_to_control_set();


SET search_path = biblio, pg_catalog;

--
-- Name: a_marcxml_is_well_formed; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE check_marcxml_well_formed();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR DELETE ON peer_bib_copy_map FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: aaa_indexing_ingest_or_delete; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER aaa_indexing_ingest_or_delete AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE indexing_ingest_or_delete();


--
-- Name: audit_biblio_record_entry_update_trigger; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER audit_biblio_record_entry_update_trigger AFTER DELETE OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_biblio_record_entry_func();


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: bbb_simple_rec_trigger; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER bbb_simple_rec_trigger AFTER INSERT OR DELETE OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: fingerprint_tgr; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER fingerprint_tgr BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE fingerprint_trigger('eng', 'BKS');


--
-- Name: norm_sort_label; Type: TRIGGER; Schema: biblio; Owner: postgres
--

CREATE TRIGGER norm_sort_label BEFORE INSERT OR UPDATE ON monograph_part FOR EACH ROW EXECUTE PROCEDURE normalize_biblio_monograph_part_sortkey();


SET search_path = booking, pg_catalog;

--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: booking; Owner: postgres
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: booking; Owner: postgres
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('reservation');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: booking; Owner: postgres
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


SET search_path = config, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: config; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy_status FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: limit_logs_oust; Type: TRIGGER; Schema: config; Owner: postgres
--

CREATE TRIGGER limit_logs_oust BEFORE INSERT OR UPDATE ON org_unit_setting_type_log FOR EACH ROW EXECUTE PROCEDURE evergreen.limit_oustl();


--
-- Name: no_overlapping_deps; Type: TRIGGER; Schema: config; Owner: postgres
--

CREATE TRIGGER no_overlapping_deps BEFORE INSERT OR UPDATE ON db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('deprecates');


--
-- Name: no_overlapping_sups; Type: TRIGGER; Schema: config; Owner: postgres
--

CREATE TRIGGER no_overlapping_sups BEFORE INSERT OR UPDATE ON db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('supersedes');


SET search_path = metabib, pg_catalog;

--
-- Name: facet_force_nfc_tgr; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER facet_force_nfc_tgr BEFORE INSERT OR UPDATE ON facet_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.facet_force_nfc();


--
-- Name: facet_normalize_tgr; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER facet_normalize_tgr BEFORE INSERT OR UPDATE ON facet_entry FOR EACH ROW EXECUTE PROCEDURE facet_normalize_trigger();


--
-- Name: metabib_author_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_author_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON author_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('author');


--
-- Name: metabib_browse_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_browse_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_full_rec_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON real_full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('default');


--
-- Name: metabib_identifier_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_identifier_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON identifier_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('identifier');


--
-- Name: metabib_keyword_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_keyword_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON keyword_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_series_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_series_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON series_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('series');


--
-- Name: metabib_subject_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_subject_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON subject_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('subject');


--
-- Name: metabib_title_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: postgres
--

CREATE TRIGGER metabib_title_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON title_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('title');


SET search_path = money, pg_catalog;

--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_add();


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('bnm_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('forgive_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('work_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('credit_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('goods_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('bnm_desk_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('cash_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('check_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('credit_card_payment');


--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_create('grocery');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_del();


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('bnm_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('forgive_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('work_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('credit_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('goods_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('bnm_desk_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('cash_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('check_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('credit_card_payment');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_delete();


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_update();


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('bnm_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('forgive_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('work_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('credit_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('goods_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('bnm_desk_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('cash_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('check_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: postgres
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('credit_card_payment');


SET search_path = permission, pg_catalog;

--
-- Name: maintain_perm_i18n_tgr; Type: TRIGGER; Schema: permission; Owner: postgres
--

CREATE TRIGGER maintain_perm_i18n_tgr AFTER UPDATE ON perm_list FOR EACH ROW EXECUTE PROCEDURE evergreen.oils_i18n_id_tracking('ppl');


SET search_path = serial, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: audit_serial_unit_update_trigger; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER audit_serial_unit_update_trigger AFTER DELETE OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_serial_unit_func();


--
-- Name: autogenerate_placeholder_barcode; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.autogenerate_placeholder_barcode();


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: materialize_holding_code; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER materialize_holding_code AFTER INSERT OR UPDATE ON issuance FOR EACH ROW EXECUTE PROCEDURE materialize_holding_code();


--
-- Name: sunit_created_trig; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER sunit_created_trig BEFORE INSERT ON unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_created();


--
-- Name: sunit_status_changed_trig; Type: TRIGGER; Schema: serial; Owner: postgres
--

CREATE TRIGGER sunit_status_changed_trig BEFORE UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_status_changed();


SET search_path = url_verify, pg_catalog;

--
-- Name: ingest_url_tgr; Type: TRIGGER; Schema: url_verify; Owner: postgres
--

CREATE TRIGGER ingest_url_tgr BEFORE INSERT ON url FOR EACH ROW EXECUTE PROCEDURE ingest_url();


SET search_path = vandelay, pg_catalog;

--
-- Name: cleanup_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER cleanup_authority_trigger BEFORE DELETE OR UPDATE ON queued_authority_record FOR EACH ROW EXECUTE PROCEDURE cleanup_authority_marc();


--
-- Name: cleanup_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER cleanup_bib_trigger BEFORE DELETE OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE cleanup_bib_marc();


--
-- Name: ingest_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER ingest_authority_trigger AFTER INSERT OR UPDATE ON queued_authority_record FOR EACH ROW EXECUTE PROCEDURE ingest_authority_marc();


--
-- Name: ingest_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER ingest_bib_trigger AFTER INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE ingest_bib_marc();


--
-- Name: ingest_item_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER ingest_item_trigger AFTER INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE ingest_bib_items();


--
-- Name: zz_match_bibs_trigger; Type: TRIGGER; Schema: vandelay; Owner: postgres
--

CREATE TRIGGER zz_match_bibs_trigger BEFORE INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE match_bib_record();


SET search_path = acq, pg_catalog;

--
-- Name: acq_provider_edi_default_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT acq_provider_edi_default_fkey FOREIGN KEY (edi_default) REFERENCES edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: cancel_reason_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT cancel_reason_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_type_fkey FOREIGN KEY (type) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT claim_event_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_lineitem_detail_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_lineitem_detail_fkey FOREIGN KEY (lineitem_detail) REFERENCES lineitem_detail(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action_action_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_action_fkey FOREIGN KEY (action) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES claim_policy(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT claim_policy_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_type_fkey FOREIGN KEY (type) REFERENCES claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_formula_fkey FOREIGN KEY (formula) REFERENCES distribution_formula(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code);


--
-- Name: distribution_formula_entry_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_formula_fkey FOREIGN KEY (formula) REFERENCES distribution_formula(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id);


--
-- Name: distribution_formula_entry_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id);


--
-- Name: distribution_formula_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT distribution_formula_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_account_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY edi_account
    ADD CONSTRAINT edi_account_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message_account_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_account_fkey FOREIGN KEY (account) REFERENCES edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate_from_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_from_currency_fkey FOREIGN KEY (from_currency) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate_to_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_to_currency_fkey FOREIGN KEY (to_currency) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fiscal_year_calendar_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT fiscal_year_calendar_fkey FOREIGN KEY (calendar) REFERENCES fiscal_calendar(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_origin_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_origin_currency_type_fkey FOREIGN KEY (origin_currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_xfer_destination_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_xfer_destination_fkey FOREIGN KEY (xfer_destination) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map_tag_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_tag_fkey FOREIGN KEY (tag) REFERENCES fund_tag(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT fund_tag_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_dest_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_dest_fund_fkey FOREIGN KEY (dest_fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_src_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_src_fund_fkey FOREIGN KEY (src_fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_transfer_user_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_transfer_user_fkey FOREIGN KEY (transfer_user) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_credit_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY funding_source_credit
    ADD CONSTRAINT funding_source_credit_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_entry_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_invoice_fkey FOREIGN KEY (invoice) REFERENCES invoice(id) ON DELETE CASCADE;


--
-- Name: invoice_entry_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_entry_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id);


--
-- Name: invoice_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES invoice_item_type(code);


--
-- Name: invoice_item_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_invoice_fkey FOREIGN KEY (invoice) REFERENCES invoice(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: invoice_item_po_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_po_item_fkey FOREIGN KEY (po_item) REFERENCES po_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_payment_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_payment_method_fkey FOREIGN KEY (payment_method) REFERENCES invoice_payment_method(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id);


--
-- Name: invoice_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.org_unit(id);


--
-- Name: invoice_recv_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_recv_method_fkey FOREIGN KEY (recv_method) REFERENCES invoice_method(code);


--
-- Name: invoice_shipper_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_shipper_fkey FOREIGN KEY (shipper) REFERENCES provider(id);


--
-- Name: lineitem_alert_text_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_attr_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_attr
    ADD CONSTRAINT lineitem_attr_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_eg_bib_id_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_eg_bib_id_fkey FOREIGN KEY (eg_bib_id) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_alert_text_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_alert_text_fkey FOREIGN KEY (alert_text) REFERENCES lineitem_alert_text(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_picklist_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_picklist_fkey FOREIGN KEY (picklist) REFERENCES picklist(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_provider_attr_definition_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_queued_record_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_bib_record(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_selector_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_selector_fkey FOREIGN KEY (selector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_usr_attr_definition_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES invoice_item_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_address_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_address
    ADD CONSTRAINT provider_address_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact_address_contact_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_contact_address
    ADD CONSTRAINT provider_contact_address_contact_fkey FOREIGN KEY (contact) REFERENCES provider_contact(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_contact
    ADD CONSTRAINT provider_contact_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_default_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_default_claim_policy_fkey FOREIGN KEY (default_claim_policy) REFERENCES claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_holding_subfield_map_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_ordering_agency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_ordering_agency_fkey FOREIGN KEY (ordering_agency) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES serial_claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_type_fkey FOREIGN KEY (type) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_item_fkey FOREIGN KEY (item) REFERENCES serial.item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_type_fkey FOREIGN KEY (type) REFERENCES claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_request_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_request_eg_bib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_eg_bib_fkey FOREIGN KEY (eg_bib) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


--
-- Name: user_request_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE;


--
-- Name: user_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id);


--
-- Name: user_request_request_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_request_type_fkey FOREIGN KEY (request_type) REFERENCES user_request_type(id);


--
-- Name: user_request_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: postgres
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id);


SET search_path = action, pg_catalog;

--
-- Name: action_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT action_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: action_circulation_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT action_circulation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: artc_tc_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT artc_tc_fkey FOREIGN KEY (target_copy) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_checkin_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_checkin_workstation_fkey FOREIGN KEY (checkin_workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_copy_location_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_circ_fkey FOREIGN KEY (circ) REFERENCES circulation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES config.circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_parent_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_parent_circ_fkey FOREIGN KEY (parent_circ) REFERENCES circulation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_col_val_fieldset_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_fieldset_fkey FOREIGN KEY (fieldset) REFERENCES fieldset(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_owning_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_stored_query_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES query.stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_copy_map_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT hold_copy_map_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_notification_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_notification_notify_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_notify_staff_fkey FOREIGN KEY (notify_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_cancel_cause_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_cancel_cause_fkey FOREIGN KEY (cancel_cause) REFERENCES hold_request_cancel_cause(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_current_shelf_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_current_shelf_lib_fkey FOREIGN KEY (current_shelf_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_fulfillment_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_fulfillment_lib_fkey FOREIGN KEY (fulfillment_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_fulfillment_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_fulfillment_staff_fkey FOREIGN KEY (fulfillment_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_note_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request_note
    ADD CONSTRAINT hold_request_note_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_request_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_requestor_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_requestor_fkey FOREIGN KEY (requestor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_sms_carrier_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_sms_carrier_fkey FOREIGN KEY (sms_carrier) REFERENCES config.sms_carrier(id);


--
-- Name: hold_request_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_transit_copy_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_patron_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_patron_fkey FOREIGN KEY (patron) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_transit_copy_reservation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_reservation_fkey FOREIGN KEY (reservation) REFERENCES booking.reservation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_answer_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_answer
    ADD CONSTRAINT survey_answer_question_fkey FOREIGN KEY (question) REFERENCES survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey
    ADD CONSTRAINT survey_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_question_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_question
    ADD CONSTRAINT survey_question_survey_fkey FOREIGN KEY (survey) REFERENCES survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_answer_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_answer_fkey FOREIGN KEY (answer) REFERENCES survey_answer(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_question_fkey FOREIGN KEY (question) REFERENCES survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_survey_fkey FOREIGN KEY (survey) REFERENCES survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_copy_status_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_copy_status_fkey FOREIGN KEY (copy_status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_dest_fkey FOREIGN KEY (dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_prev_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_prev_dest_fkey FOREIGN KEY (prev_dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_prev_hop_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_prev_hop_fkey FOREIGN KEY (prev_hop) REFERENCES transit_copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_source_fkey; Type: FK CONSTRAINT; Schema: action; Owner: postgres
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_source_fkey FOREIGN KEY (source) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = action_trigger, pg_catalog;

--
-- Name: environment_collector_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_collector_fkey FOREIGN KEY (collector) REFERENCES collector(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: environment_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_async_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_async_output_fkey FOREIGN KEY (async_output) REFERENCES event_output(id);


--
-- Name: event_definition_cleanup_failure_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_cleanup_failure_fkey FOREIGN KEY (cleanup_failure) REFERENCES cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_cleanup_success_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_cleanup_success_fkey FOREIGN KEY (cleanup_success) REFERENCES cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_hook_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_hook_fkey FOREIGN KEY (hook) REFERENCES hook(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_opt_in_setting_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_opt_in_setting_fkey FOREIGN KEY (opt_in_setting) REFERENCES config.usr_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_owner_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_reactor_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_reactor_fkey FOREIGN KEY (reactor) REFERENCES reactor(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_validator_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_validator_fkey FOREIGN KEY (validator) REFERENCES validator(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_error_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_error_output_fkey FOREIGN KEY (error_output) REFERENCES event_output(id);


--
-- Name: event_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_params_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_template_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: postgres
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_template_output_fkey FOREIGN KEY (template_output) REFERENCES event_output(id);


SET search_path = actor, pg_catalog;

--
-- Name: actor_org_unit_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_holds_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_holds_address_fkey FOREIGN KEY (holds_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_ill_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_ill_address_fkey FOREIGN KEY (ill_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_proximity_adjustment_circ_mod_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT actor_org_unit_proximity_adjustment_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES config.circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_proximity_copy_location_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT actor_org_unit_proximity_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_sceum_sc_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_sceum_tu_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_tu_fkey FOREIGN KEY (target_usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_entry_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_entry_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT actor_stat_cat_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_home_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_home_ou_fkey FOREIGN KEY (home_ou) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_profile_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_profile_fkey FOREIGN KEY (profile) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: address_alert_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY address_alert
    ADD CONSTRAINT address_alert_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: card_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hours_of_operation_id_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY hours_of_operation
    ADD CONSTRAINT hours_of_operation_id_fkey FOREIGN KEY (id) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_address_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_address
    ADD CONSTRAINT org_address_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map_lasso_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_lasso_fkey FOREIGN KEY (lasso) REFERENCES org_lasso(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_closed_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_closed
    ADD CONSTRAINT org_unit_closed_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_parent_node_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_parent_node_fkey FOREIGN KEY (parent_node) REFERENCES org_unit_custom_tree_node(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_tree_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_tree_fkey FOREIGN KEY (tree) REFERENCES org_unit_custom_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_fiscal_calendar_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_fiscal_calendar_fkey FOREIGN KEY (fiscal_calendar) REFERENCES acq.fiscal_calendar(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_ou_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_ou_type_fkey FOREIGN KEY (ou_type) REFERENCES org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_parent_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_parent_ou_fkey FOREIGN KEY (parent_ou) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_proximity_adjustment_hold_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_pickup_lib_fkey FOREIGN KEY (hold_pickup_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_hold_request_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_request_lib_fkey FOREIGN KEY (hold_request_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_item_circ_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_circ_lib_fkey FOREIGN KEY (item_circ_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_item_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_owning_lib_fkey FOREIGN KEY (item_owning_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_name_fkey FOREIGN KEY (name) REFERENCES config.org_unit_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_type_parent_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY org_unit_type
    ADD CONSTRAINT org_unit_type_parent_fkey FOREIGN KEY (parent) REFERENCES org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry_grp_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_grp_fkey FOREIGN KEY (grp) REFERENCES search_filter_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry_query_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_query_fkey FOREIGN KEY (query) REFERENCES search_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT search_filter_group_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_stat_cat_entry_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_entry_fkey FOREIGN KEY (stat_cat_entry) REFERENCES stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: toolbar_org_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_org_fkey FOREIGN KEY (org) REFERENCES org_unit(id) ON DELETE CASCADE;


--
-- Name: toolbar_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE;


--
-- Name: toolbar_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_ws_fkey FOREIGN KEY (ws) REFERENCES workstation(id) ON DELETE CASCADE;


--
-- Name: usr_activity_etype_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_etype_fkey FOREIGN KEY (etype) REFERENCES config.usr_activity_type(id);


--
-- Name: usr_activity_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE SET NULL;


--
-- Name: usr_address_replaces_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_replaces_fkey FOREIGN KEY (replaces) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_ident_type2_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_ident_type2_fkey FOREIGN KEY (ident_type2) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_ident_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_ident_type_fkey FOREIGN KEY (ident_type) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_net_access_level_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_net_access_level_fkey FOREIGN KEY (net_access_level) REFERENCES config.net_access_level(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_note_creator_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_creator_fkey FOREIGN KEY (creator) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_note_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_opt_in_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_opt_in_ws_fkey FOREIGN KEY (opt_in_ws) REFERENCES workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_staff_fkey FOREIGN KEY (staff) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_password_reset_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_password_reset
    ADD CONSTRAINT usr_password_reset_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_saved_search_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT usr_saved_search_owner_fkey FOREIGN KEY (owner) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_name_fkey FOREIGN KEY (name) REFERENCES config.usr_setting_type(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_standing_fkey FOREIGN KEY (standing) REFERENCES config.standing(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_staff_fkey FOREIGN KEY (staff) REFERENCES usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_standing_penalty_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_standing_penalty_fkey FOREIGN KEY (standing_penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: workstation_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: postgres
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = asset, pg_catalog;

--
-- Name: a_sc_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT a_sc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sc_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sc_sce_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sce_fkey FOREIGN KEY (stat_cat_entry) REFERENCES stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sce_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT a_sce_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sce_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT a_sce_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT asset_call_number_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_note_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT asset_call_number_note_record_fkey FOREIGN KEY (call_number) REFERENCES call_number(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_call_number_fkey FOREIGN KEY (call_number) REFERENCES call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_note_copy_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT asset_copy_note_copy_fkey FOREIGN KEY (owning_copy) REFERENCES copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT asset_copy_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_label_class_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_label_class_fkey FOREIGN KEY (label_class) REFERENCES call_number_class(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_prefix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_prefix_fkey FOREIGN KEY (prefix) REFERENCES call_number_prefix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_prefix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_prefix
    ADD CONSTRAINT call_number_prefix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: call_number_suffix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_suffix_fkey FOREIGN KEY (suffix) REFERENCES call_number_suffix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_suffix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY call_number_suffix
    ADD CONSTRAINT call_number_suffix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: circ_mod_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT circ_mod_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map_lgroup_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_lgroup_fkey FOREIGN KEY (lgroup) REFERENCES copy_location_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT copy_location_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order_org_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT copy_location_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_part_map_part_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_part_map
    ADD CONSTRAINT copy_part_map_part_fkey FOREIGN KEY (part) REFERENCES biblio.monograph_part(id) ON DELETE CASCADE;


--
-- Name: copy_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: uri_call_number_map_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_call_number_fkey FOREIGN KEY (call_number) REFERENCES call_number(id);


--
-- Name: uri_call_number_map_uri_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: postgres
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_uri_fkey FOREIGN KEY (uri) REFERENCES uri(id);


SET search_path = authority, pg_catalog;

--
-- Name: bib_linking_authority_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_authority_fkey FOREIGN KEY (authority) REFERENCES record_entry(id);


--
-- Name: bib_linking_bib_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_bib_fkey FOREIGN KEY (bib) REFERENCES biblio.record_entry(id);


--
-- Name: browse_axis_authority_field_map_axis_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_axis_fkey FOREIGN KEY (axis) REFERENCES browse_axis(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis_authority_field_map_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_field_fkey FOREIGN KEY (field) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis_sorter_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_sorter_fkey FOREIGN KEY (sorter) REFERENCES config.record_attr_definition(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field_main_entry_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_main_entry_fkey FOREIGN KEY (main_entry) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_authority_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_authority_field_fkey FOREIGN KEY (authority_field) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: simple_heading_atag_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_atag_fkey FOREIGN KEY (atag) REFERENCES control_set_authority_field(id);


--
-- Name: simple_heading_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id);


--
-- Name: thesaurus_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: postgres
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = biblio, pg_catalog;

--
-- Name: biblio_record_entry_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_owner_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: monograph_part_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT monograph_part_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id);


--
-- Name: peer_bib_copy_map_peer_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_record_fkey FOREIGN KEY (peer_record) REFERENCES record_entry(id);


--
-- Name: peer_bib_copy_map_peer_type_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: postgres
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_type_fkey FOREIGN KEY (peer_type) REFERENCES peer_type(id);


SET search_path = booking, pg_catalog;

--
-- Name: booking_reservation_usr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT booking_reservation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map_attr_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_attr_value_fkey FOREIGN KEY (attr_value) REFERENCES resource_attr_value(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map_reservation_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_reservation_fkey FOREIGN KEY (reservation) REFERENCES reservation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_capture_staff_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_capture_staff_fkey FOREIGN KEY (capture_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_current_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_current_resource_fkey FOREIGN KEY (current_resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_request_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_target_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_target_resource_fkey FOREIGN KEY (target_resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_target_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_target_resource_type_fkey FOREIGN KEY (target_resource_type) REFERENCES resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_resource_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_attr_fkey FOREIGN KEY (resource_attr) REFERENCES resource_attr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_fkey FOREIGN KEY (resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_value_fkey FOREIGN KEY (value) REFERENCES resource_attr_value(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_resource_type_fkey FOREIGN KEY (resource_type) REFERENCES resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_attr_fkey FOREIGN KEY (attr) REFERENCES resource_attr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_type_fkey FOREIGN KEY (type) REFERENCES resource_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_record_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: postgres
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = config, pg_catalog;

--
-- Name: circ_limit_set_circ_mod_map_circ_mod_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES circ_modifier(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_circ_mod_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map_copy_loc_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_copy_loc_fkey FOREIGN KEY (copy_loc) REFERENCES asset.copy_location(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map_matchpoint_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_matchpoint_fkey FOREIGN KEY (matchpoint) REFERENCES circ_matrix_matchpoint(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_circ_lib_fkey FOREIGN KEY (copy_circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_location_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_owning_lib_fkey FOREIGN KEY (copy_owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_duration_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_duration_rule_fkey FOREIGN KEY (duration_rule) REFERENCES rule_circ_duration(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES hard_due_date(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_max_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_max_fine_rule_fkey FOREIGN KEY (max_fine_rule) REFERENCES rule_max_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_recurring_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_recurring_fine_rule_fkey FOREIGN KEY (recurring_fine_rule) REFERENCES rule_recurring_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: coded_value_map_ctype_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY coded_value_map
    ADD CONSTRAINT coded_value_map_ctype_fkey FOREIGN KEY (ctype) REFERENCES record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_barcode_completion_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY barcode_completion
    ADD CONSTRAINT config_barcode_completion_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_billing_type_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT config_billing_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_filter_dialog_filter_set_creator_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT config_filter_dialog_filter_set_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_filter_dialog_filter_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT config_filter_dialog_filter_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_org_unit_setting_type_log_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT config_org_unit_setting_type_log_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_remote_account_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY remote_account
    ADD CONSTRAINT config_remote_account_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set_interface_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_interface_fkey FOREIGN KEY (interface) REFERENCES filter_dialog_interface(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hard_due_date_values_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES hard_due_date(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_age_hold_protect_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_age_hold_protect_rule_fkey FOREIGN KEY (age_hold_protect_rule) REFERENCES rule_age_hold_protect(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_item_circ_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_circ_ou_fkey FOREIGN KEY (item_circ_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_item_owning_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_owning_ou_fkey FOREIGN KEY (item_owning_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_pickup_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pickup_ou_fkey FOREIGN KEY (pickup_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_request_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_request_ou_fkey FOREIGN KEY (request_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_requestor_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_requestor_grp_fkey FOREIGN KEY (requestor_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_transit_range_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_transit_range_fkey FOREIGN KEY (transit_range) REFERENCES actor.org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_usr_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_usr_grp_fkey FOREIGN KEY (usr_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: i18n_core_translation_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY i18n_core
    ADD CONSTRAINT i18n_core_translation_fkey FOREIGN KEY (translation) REFERENCES i18n_locale(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: idl_field_doc_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY idl_field_doc
    ADD CONSTRAINT idl_field_doc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: marc21_physical_characteristic_subfield_map_ptype_key_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_ptype_key_fkey FOREIGN KEY (ptype_key) REFERENCES marc21_physical_characteristic_type_map(ptype_key) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: marc21_physical_characteristic_value_map_ptype_subfield_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_ptype_subfield_fkey FOREIGN KEY (ptype_subfield) REFERENCES marc21_physical_characteristic_subfield_map(id);


--
-- Name: metabib_class_ts_map_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_class_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES ts_config_list(id);


--
-- Name: metabib_field_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_field_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_format_fkey FOREIGN KEY (format) REFERENCES xml_transform(name);


--
-- Name: metabib_field_index_norm_map_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_field_fkey FOREIGN KEY (field) REFERENCES metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_ts_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES metabib_field(id);


--
-- Name: metabib_field_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES ts_config_list(id);


--
-- Name: metabib_search_alias_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_search_alias_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_fkey FOREIGN KEY (field) REFERENCES metabib_field(id);


--
-- Name: org_unit_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES settings_group(name);


--
-- Name: org_unit_setting_type_log_field_name_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_field_name_fkey FOREIGN KEY (field_name) REFERENCES org_unit_setting_type(name);


--
-- Name: record_attr_definition_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_format_fkey FOREIGN KEY (format) REFERENCES xml_transform(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_definition_phys_char_sf_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_phys_char_sf_fkey FOREIGN KEY (phys_char_sf) REFERENCES marc21_physical_characteristic_subfield_map(id);


--
-- Name: record_attr_index_norm_map_attr_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_attr_fkey FOREIGN KEY (attr) REFERENCES record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: update_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT update_perm_fkey FOREIGN KEY (update_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: use_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT use_perm_fkey FOREIGN KEY (use_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES settings_group(name);


--
-- Name: view_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT view_perm_fkey FOREIGN KEY (view_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_circ_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_circ_weights_fkey FOREIGN KEY (circ_weights) REFERENCES circ_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_hold_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_hold_weights_fkey FOREIGN KEY (hold_weights) REFERENCES hold_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_attr_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z3950_attr_source_fkey FOREIGN KEY (source) REFERENCES z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_source_credentials_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_source_fkey FOREIGN KEY (source) REFERENCES z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_source_creds_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: postgres
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_creds_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES biblio_record_entry_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES biblio_record_entry_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_target_biblio_record_entry_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_target_biblio_record_entry_fkey FOREIGN KEY (target_biblio_record_entry) REFERENCES biblio.record_entry(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES call_number_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES call_number_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_target_call_number_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_target_call_number_fkey FOREIGN KEY (target_call_number) REFERENCES asset.call_number(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES copy_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES copy_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_target_copy_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_target_copy_fkey FOREIGN KEY (target_copy) REFERENCES asset.copy(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES user_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES user_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_target_user_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_target_user_fkey FOREIGN KEY (target_user) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket_note
    ADD CONSTRAINT user_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: postgres
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = metabib, pg_catalog;

--
-- Name: browse_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_entry(id);


--
-- Name: browse_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: metabib_author_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY author_field_entry
    ADD CONSTRAINT metabib_author_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_author_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY author_field_entry
    ADD CONSTRAINT metabib_author_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_full_rec_record_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY real_full_rec
    ADD CONSTRAINT metabib_full_rec_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_identifier_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_identifier_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_keyword_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY keyword_field_entry
    ADD CONSTRAINT metabib_keyword_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_keyword_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY keyword_field_entry
    ADD CONSTRAINT metabib_keyword_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_master_record_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY metarecord
    ADD CONSTRAINT metabib_metarecord_master_record_fkey FOREIGN KEY (master_record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_source_map_metarecord_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_metarecord_fkey FOREIGN KEY (metarecord) REFERENCES metarecord(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_source_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_series_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY series_field_entry
    ADD CONSTRAINT metabib_series_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_series_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY series_field_entry
    ADD CONSTRAINT metabib_series_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_subject_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY subject_field_entry
    ADD CONSTRAINT metabib_subject_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_subject_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY subject_field_entry
    ADD CONSTRAINT metabib_subject_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_title_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY title_field_entry
    ADD CONSTRAINT metabib_title_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_title_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY title_field_entry
    ADD CONSTRAINT metabib_title_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_id_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: postgres
--

ALTER TABLE ONLY record_attr
    ADD CONSTRAINT record_attr_id_fkey FOREIGN KEY (id) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


SET search_path = money, pg_catalog;

--
-- Name: billing_btype_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY billing
    ADD CONSTRAINT billing_btype_fkey FOREIGN KEY (btype) REFERENCES config.billing_type(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bnm_desk_payment_cash_drawer_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_cash_drawer_fkey FOREIGN KEY (cash_drawer) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_collector_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_collector_fkey FOREIGN KEY (collector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_location_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_location_fkey FOREIGN KEY (location) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: money_billable_xact_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: postgres
--

ALTER TABLE ONLY billable_xact
    ADD CONSTRAINT money_billable_xact_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold_org_unit_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold_penalty_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_penalty_fkey FOREIGN KEY (penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree_parent_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_parent_fkey FOREIGN KEY (parent) REFERENCES grp_tree(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map_work_ou_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: postgres
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_work_ou_fkey FOREIGN KEY (work_ou) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = query, pg_catalog;

--
-- Name: case_branch_condition_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_condition_fkey FOREIGN KEY (condition) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch_result_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_result_fkey FOREIGN KEY (result) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_bind_variable_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_bind_variable_fkey FOREIGN KEY (bind_variable) REFERENCES bind_variable(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_cast_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_cast_type_fkey FOREIGN KEY (cast_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_function_id_fkey FOREIGN KEY (function_id) REFERENCES function_sig(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_left_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_left_operand_fkey FOREIGN KEY (left_operand) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_right_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_right_operand_fkey FOREIGN KEY (right_operand) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_subquery_fkey FOREIGN KEY (subquery) REFERENCES stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_function_call_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_function_call_fkey FOREIGN KEY (function_call) REFERENCES expression(id);


--
-- Name: from_relation_on_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_on_clause_fkey FOREIGN KEY (on_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_parent_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_parent_relation_fkey FOREIGN KEY (parent_relation) REFERENCES from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_subquery_fkey FOREIGN KEY (subquery) REFERENCES stored_query(id);


--
-- Name: function_param_def_datatype_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_datatype_fkey FOREIGN KEY (datatype) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_param_def_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_function_id_fkey FOREIGN KEY (function_id) REFERENCES function_sig(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_sig_return_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY function_sig
    ADD CONSTRAINT function_sig_return_type_fkey FOREIGN KEY (return_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_expression_fkey FOREIGN KEY (expression) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence_child_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_child_query_fkey FOREIGN KEY (child_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence_parent_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_parent_query_fkey FOREIGN KEY (parent_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column_column_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_column_type_fkey FOREIGN KEY (column_type) REFERENCES datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column_from_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_from_relation_fkey FOREIGN KEY (from_relation) REFERENCES from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_expression_fkey FOREIGN KEY (expression) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_from_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_from_clause_fkey FOREIGN KEY (from_clause) REFERENCES from_relation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_having_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_having_clause_fkey FOREIGN KEY (having_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_limit_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_limit_count_fkey FOREIGN KEY (limit_count) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_offset_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_offset_count_fkey FOREIGN KEY (offset_count) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_where_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_where_clause_fkey FOREIGN KEY (where_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield_composite_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_composite_type_fkey FOREIGN KEY (composite_type) REFERENCES datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield_subfield_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: postgres
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_subfield_type_fkey FOREIGN KEY (subfield_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = reporter, pg_catalog;

--
-- Name: output_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_parent_fkey FOREIGN KEY (parent) REFERENCES output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_folder_fkey FOREIGN KEY (folder) REFERENCES report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_parent_fkey FOREIGN KEY (parent) REFERENCES report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_template_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_template_fkey FOREIGN KEY (template) REFERENCES template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_folder_fkey FOREIGN KEY (folder) REFERENCES output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_report_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_report_fkey FOREIGN KEY (report) REFERENCES report(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_runner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_runner_fkey FOREIGN KEY (runner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_folder_fkey FOREIGN KEY (folder) REFERENCES template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_parent_fkey FOREIGN KEY (parent) REFERENCES template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: postgres
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment_field_fkey; Type: FK CONSTRAINT; Schema: search; Owner: postgres
--

ALTER TABLE ONLY relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = serial, pg_catalog;

--
-- Name: basic_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY basic_summary
    ADD CONSTRAINT basic_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: caption_and_pattern_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_bind_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_bind_call_number_fkey FOREIGN KEY (bind_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_bind_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_bind_unit_template_fkey FOREIGN KEY (bind_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_holding_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_holding_lib_fkey FOREIGN KEY (holding_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_receive_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_receive_call_number_fkey FOREIGN KEY (receive_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_receive_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_receive_unit_template_fkey FOREIGN KEY (receive_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: index_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY index_summary
    ADD CONSTRAINT index_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_caption_and_pattern_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_caption_and_pattern_fkey FOREIGN KEY (caption_and_pattern) REFERENCES caption_and_pattern(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_issuance_fkey FOREIGN KEY (issuance) REFERENCES issuance(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note_item_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_item_fkey FOREIGN KEY (item) REFERENCES item(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_stream_fkey FOREIGN KEY (stream) REFERENCES stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_unit_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_unit_fkey FOREIGN KEY (unit) REFERENCES unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_uri_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_uri_fkey FOREIGN KEY (uri) REFERENCES asset.uri(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: materialized_holding_code_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_issuance_fkey FOREIGN KEY (issuance) REFERENCES issuance(id) ON DELETE CASCADE;


--
-- Name: record_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry_record_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user_reader_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_reader_fkey FOREIGN KEY (reader) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_stream_fkey FOREIGN KEY (stream) REFERENCES stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_call_number_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stream_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY stream
    ADD CONSTRAINT stream_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES biblio.record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: supplement_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: postgres
--

ALTER TABLE ONLY supplement_summary
    ADD CONSTRAINT supplement_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout_transform_fkey; Type: FK CONSTRAINT; Schema: unapi; Owner: postgres
--

ALTER TABLE ONLY bre_output_layout
    ADD CONSTRAINT bre_output_layout_transform_fkey FOREIGN KEY (transform) REFERENCES config.xml_transform(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = url_verify, pg_catalog;

--
-- Name: session_container_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_container_fkey FOREIGN KEY (container) REFERENCES container.biblio_record_entry_bucket(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_creator_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_owning_lib_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_item_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_item_fkey FOREIGN KEY (item) REFERENCES container.biblio_record_entry_bucket_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_redirect_from_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_redirect_from_fkey FOREIGN KEY (redirect_from) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_selector_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT url_selector_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_url_selector_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_url_selector_fkey FOREIGN KEY (url_selector) REFERENCES url_selector(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_attempt_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_attempt_fkey FOREIGN KEY (attempt) REFERENCES verification_attempt(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_redirect_to_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_redirect_to_fkey FOREIGN KEY (redirect_to) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_url_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_url_fkey FOREIGN KEY (url) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt_usr_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: postgres
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: authority_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES queued_authority_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_queue_item_attr_def_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT bib_queue_item_attr_def_fkey FOREIGN KEY (item_attr_def) REFERENCES import_item_attr_definition(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_bib_trash_fields_grp_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_grp_fkey FOREIGN KEY (grp) REFERENCES import_bib_trash_group(id);


--
-- Name: import_bib_trash_group_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: import_item_attr_definition_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_definition_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_definition_fkey FOREIGN KEY (definition) REFERENCES import_item_attr_definition(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_record_fkey FOREIGN KEY (record) REFERENCES queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT imported_as_fkey FOREIGN KEY (imported_as) REFERENCES asset.copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: match_set_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT match_set_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: match_set_point_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_point_parent_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_parent_fkey FOREIGN KEY (parent) REFERENCES match_set_point(id);


--
-- Name: match_set_point_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: match_set_quality_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_quality_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: merge_profile_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT merge_profile_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_field_fkey FOREIGN KEY (field) REFERENCES authority_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_record_fkey FOREIGN KEY (record) REFERENCES queued_authority_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_queue_fkey FOREIGN KEY (queue) REFERENCES authority_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_field_fkey FOREIGN KEY (field) REFERENCES bib_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_record_fkey FOREIGN KEY (record) REFERENCES queued_bib_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_bib_source_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_bib_source_fkey FOREIGN KEY (bib_source) REFERENCES config.bib_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: postgres
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_queue_fkey FOREIGN KEY (queue) REFERENCES bib_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- PostgreSQL database dump complete
--

