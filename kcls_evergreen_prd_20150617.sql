--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: evergreen; Type: DATABASE; Schema: -; Owner: postgres
--

CREATE DATABASE evergreen_prd WITH TEMPLATE = template0 ENCODING = 'UTF8' LC_COLLATE = 'C' LC_CTYPE = 'C';


ALTER DATABASE evergreen_prd OWNER TO postgres;

\connect evergreen_prd

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: acq; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA acq;


ALTER SCHEMA acq OWNER TO evergreen;

--
-- Name: action; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA action;


ALTER SCHEMA action OWNER TO evergreen;

--
-- Name: action_trigger; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA action_trigger;


ALTER SCHEMA action_trigger OWNER TO evergreen;

--
-- Name: actor; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA actor;


ALTER SCHEMA actor OWNER TO evergreen;

--
-- Name: SCHEMA actor; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON SCHEMA actor IS '
/*
 * Copyright (C) 2009  Equinox Software, Inc. / Georgia Public Library Service
 * Scott McKellar <scott@esilibrary.com>
 *
 * Schema: query
 *
 * Contains tables designed to represent user-defined queries for
 * reports and the like.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: asset; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA asset;


ALTER SCHEMA asset OWNER TO evergreen;

--
-- Name: auditor; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA auditor;


ALTER SCHEMA auditor OWNER TO evergreen;

--
-- Name: authority; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA authority;


ALTER SCHEMA authority OWNER TO evergreen;

--
-- Name: biblio; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA biblio;


ALTER SCHEMA biblio OWNER TO evergreen;

--
-- Name: booking; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA booking;


ALTER SCHEMA booking OWNER TO evergreen;

--
-- Name: cmd; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cmd;


ALTER SCHEMA cmd OWNER TO postgres;

--
-- Name: collectionhq; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA collectionhq;


ALTER SCHEMA collectionhq OWNER TO evergreen;

--
-- Name: config; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA config;


ALTER SCHEMA config OWNER TO evergreen;

--
-- Name: SCHEMA config; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON SCHEMA config IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * The config schema holds static configuration data for the
 * Open-ILS installation.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: container; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA container;


ALTER SCHEMA container OWNER TO evergreen;

--
-- Name: envisionware; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA envisionware;


ALTER SCHEMA envisionware OWNER TO evergreen;

--
-- Name: esi; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi;


ALTER SCHEMA esi OWNER TO evergreen;

--
-- Name: esi16538; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi16538;


ALTER SCHEMA esi16538 OWNER TO evergreen;

--
-- Name: esi_14812; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi_14812;


ALTER SCHEMA esi_14812 OWNER TO evergreen;

--
-- Name: evergreen; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA evergreen;


ALTER SCHEMA evergreen OWNER TO evergreen;

--
-- Name: extend_reporter; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA extend_reporter;


ALTER SCHEMA extend_reporter OWNER TO evergreen;

--
-- Name: m_enum; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_enum;


ALTER SCHEMA m_enum OWNER TO evergreen;

--
-- Name: m_kcls; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls;


ALTER SCHEMA m_kcls OWNER TO evergreen;

--
-- Name: m_kcls2; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls2;


ALTER SCHEMA m_kcls2 OWNER TO evergreen;

--
-- Name: m_kcls3; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls3;


ALTER SCHEMA m_kcls3 OWNER TO evergreen;

--
-- Name: m_kcls_call_fix; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_call_fix;


ALTER SCHEMA m_kcls_call_fix OWNER TO evergreen;

--
-- Name: m_kcls_circhist; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_circhist;


ALTER SCHEMA m_kcls_circhist OWNER TO evergreen;

--
-- Name: m_kcls_gap; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_gap;


ALTER SCHEMA m_kcls_gap OWNER TO evergreen;

--
-- Name: m_kcls_holds; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_holds;


ALTER SCHEMA m_kcls_holds OWNER TO evergreen;

--
-- Name: m_kcls_holdsall; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_holdsall;


ALTER SCHEMA m_kcls_holdsall OWNER TO evergreen;

--
-- Name: m_kcls_holdsall2; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_holdsall2;


ALTER SCHEMA m_kcls_holdsall2 OWNER TO evergreen;

--
-- Name: m_kcls_holdsall3; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_holdsall3;


ALTER SCHEMA m_kcls_holdsall3 OWNER TO evergreen;

--
-- Name: m_kcls_holdsfix; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_holdsfix;


ALTER SCHEMA m_kcls_holdsfix OWNER TO evergreen;

--
-- Name: m_kcls_items2; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_items2;


ALTER SCHEMA m_kcls_items2 OWNER TO evergreen;

--
-- Name: m_kcls_items3; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_items3;


ALTER SCHEMA m_kcls_items3 OWNER TO evergreen;

--
-- Name: m_kcls_ord; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_ord;


ALTER SCHEMA m_kcls_ord OWNER TO evergreen;

--
-- Name: m_kcls_ord2; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_ord2;


ALTER SCHEMA m_kcls_ord2 OWNER TO evergreen;

--
-- Name: m_kcls_ord3; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_ord3;


ALTER SCHEMA m_kcls_ord3 OWNER TO evergreen;

--
-- Name: m_kcls_xfr; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_kcls_xfr;


ALTER SCHEMA m_kcls_xfr OWNER TO evergreen;

--
-- Name: m_test; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_test;


ALTER SCHEMA m_test OWNER TO evergreen;

--
-- Name: metabib; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA metabib;


ALTER SCHEMA metabib OWNER TO evergreen;

--
-- Name: migration_tools; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA migration_tools;


ALTER SCHEMA migration_tools OWNER TO evergreen;

--
-- Name: money; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA money;


ALTER SCHEMA money OWNER TO evergreen;

--
-- Name: offline; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA offline;


ALTER SCHEMA offline OWNER TO evergreen;

--
-- Name: permission; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA permission;


ALTER SCHEMA permission OWNER TO evergreen;

--
-- Name: prod_staff_users; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA prod_staff_users;


ALTER SCHEMA prod_staff_users OWNER TO evergreen;

--
-- Name: query; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA query;


ALTER SCHEMA query OWNER TO evergreen;

--
-- Name: reporter; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA reporter;


ALTER SCHEMA reporter OWNER TO evergreen;

--
-- Name: search; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA search;


ALTER SCHEMA search OWNER TO evergreen;

--
-- Name: serial; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA serial;


ALTER SCHEMA serial OWNER TO evergreen;

--
-- Name: sip_temp; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA sip_temp;


ALTER SCHEMA sip_temp OWNER TO evergreen;

--
-- Name: staging; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA staging;


ALTER SCHEMA staging OWNER TO evergreen;

--
-- Name: stats; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA stats;


ALTER SCHEMA stats OWNER TO evergreen;

--
-- Name: unapi; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA unapi;


ALTER SCHEMA unapi OWNER TO evergreen;

--
-- Name: url_verify; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA url_verify;


ALTER SCHEMA url_verify OWNER TO evergreen;

--
-- Name: vandelay; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA vandelay;


ALTER SCHEMA vandelay OWNER TO evergreen;

--
-- Name: plperl; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperl;


ALTER PROCEDURAL LANGUAGE plperl OWNER TO postgres;

--
-- Name: plperlu; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperlu;


ALTER PROCEDURAL LANGUAGE plperlu OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: dblink; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS dblink WITH SCHEMA evergreen;


--
-- Name: EXTENSION dblink; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION dblink IS 'connect to other PostgreSQL databases from within a database';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA evergreen;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: pg_buffercache; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_buffercache WITH SCHEMA evergreen;


--
-- Name: EXTENSION pg_buffercache; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_buffercache IS 'examine the shared buffer cache';


--
-- Name: pg_prewarm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_prewarm WITH SCHEMA evergreen;


--
-- Name: EXTENSION pg_prewarm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_prewarm IS 'prewarm relation data';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA evergreen;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track execution statistics of all SQL statements executed';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: pgstattuple; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgstattuple WITH SCHEMA evergreen;


--
-- Name: EXTENSION pgstattuple; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgstattuple IS 'show tuple-level statistics';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA evergreen;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- Name: xml2; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS xml2 WITH SCHEMA evergreen;


--
-- Name: EXTENSION xml2; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION xml2 IS 'XPath querying and XSLT';


SET search_path = acq, pg_catalog;

--
-- Name: flat_lineitem_detail; Type: TYPE; Schema: acq; Owner: evergreen
--

CREATE TYPE flat_lineitem_detail AS (
	lineitem integer,
	holding integer,
	attr text,
	data text
);


ALTER TYPE acq.flat_lineitem_detail OWNER TO evergreen;

--
-- Name: flat_lineitem_holding_subfield; Type: TYPE; Schema: acq; Owner: evergreen
--

CREATE TYPE flat_lineitem_holding_subfield AS (
	lineitem integer,
	holding integer,
	subfield text,
	data text
);


ALTER TYPE acq.flat_lineitem_holding_subfield OWNER TO evergreen;

SET search_path = action, pg_catalog;

--
-- Name: circ_chain_summary; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE circ_chain_summary AS (
	num_circs integer,
	start_time timestamp with time zone,
	checkout_workstation text,
	last_renewal_time timestamp with time zone,
	last_stop_fines text,
	last_stop_fines_time timestamp with time zone,
	last_renewal_workstation text,
	last_checkin_workstation text,
	last_checkin_time timestamp with time zone,
	last_checkin_scan_time timestamp with time zone
);


ALTER TYPE action.circ_chain_summary OWNER TO evergreen;

--
-- Name: circ_matrix_test_result; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE circ_matrix_test_result AS (
	success boolean,
	fail_part text,
	buildrows integer[],
	matchpoint integer,
	circulate boolean,
	duration_rule integer,
	recurring_fine_rule integer,
	max_fine_rule integer,
	hard_due_date integer,
	renewals integer,
	grace_period interval,
	limit_groups integer[]
);


ALTER TYPE action.circ_matrix_test_result OWNER TO evergreen;

SET search_path = config, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: circ_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    grp integer NOT NULL,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    ref_flag boolean,
    juvenile_flag boolean,
    is_renewal boolean,
    usr_age_lower_bound interval,
    usr_age_upper_bound interval,
    circulate boolean,
    duration_rule integer,
    recurring_fine_rule integer,
    max_fine_rule integer,
    script_test text,
    total_copy_hold_ratio double precision,
    available_copy_hold_ratio double precision,
    copy_circ_lib integer,
    copy_owning_lib integer,
    hard_due_date integer,
    renewals integer,
    user_home_ou integer,
    grace_period interval,
    marc_bib_level text,
    item_age interval,
    copy_location integer
);


ALTER TABLE config.circ_matrix_matchpoint OWNER TO evergreen;

SET search_path = action, pg_catalog;

--
-- Name: found_circ_matrix_matchpoint; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE found_circ_matrix_matchpoint AS (
	success boolean,
	matchpoint config.circ_matrix_matchpoint,
	buildrows integer[]
);


ALTER TYPE action.found_circ_matrix_matchpoint OWNER TO evergreen;

--
-- Name: hold_stats; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE hold_stats AS (
	hold_count integer,
	copy_count integer,
	available_count integer,
	total_copy_ratio double precision,
	available_copy_ratio double precision
);


ALTER TYPE action.hold_stats OWNER TO evergreen;

--
-- Name: matrix_test_result; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE matrix_test_result AS (
	success boolean,
	matchpoint integer,
	fail_part text
);


ALTER TYPE action.matrix_test_result OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: org_unit_custom_tree_purpose; Type: TYPE; Schema: actor; Owner: evergreen
--

CREATE TYPE org_unit_custom_tree_purpose AS ENUM (
    'opac'
);


ALTER TYPE actor.org_unit_custom_tree_purpose OWNER TO evergreen;

SET search_path = authority, pg_catalog;

--
-- Name: simple_heading_plus; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE simple_heading_plus AS (
	id bigint,
	record bigint,
	atag integer,
	value text,
	sort_value text,
	index_vector tsvector,
	original_text text
);


ALTER TYPE authority.simple_heading_plus OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: marc21_physical_characteristics; Type: TYPE; Schema: biblio; Owner: evergreen
--

CREATE TYPE marc21_physical_characteristics AS (
	id integer,
	record bigint,
	ptype text,
	subfield integer,
	value integer
);


ALTER TYPE biblio.marc21_physical_characteristics OWNER TO evergreen;

--
-- Name: record_ff_map; Type: TYPE; Schema: biblio; Owner: evergreen
--

CREATE TYPE record_ff_map AS (
	record bigint,
	ff_name text,
	ff_value text
);


ALTER TYPE biblio.record_ff_map OWNER TO evergreen;

SET search_path = config, pg_catalog;

--
-- Name: usr_activity_group; Type: TYPE; Schema: config; Owner: evergreen
--

CREATE TYPE usr_activity_group AS ENUM (
    'authen',
    'authz',
    'circ',
    'hold',
    'search'
);


ALTER TYPE config.usr_activity_group OWNER TO evergreen;

SET search_path = evergreen, pg_catalog;

--
-- Name: barcode_set; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE barcode_set AS (
	type text,
	id bigint,
	barcode text
);


ALTER TYPE evergreen.barcode_set OWNER TO evergreen;

--
-- Name: holdings_maintenance; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE holdings_maintenance AS (
	acn_create_date timestamp with time zone,
	acn_creator bigint,
	acn_deleted boolean,
	acn_edit_date timestamp with time zone,
	acn_editor bigint,
	acn_id bigint,
	label text,
	acn_owning_lib integer,
	acn_record bigint,
	label_sortkey text,
	label_class bigint,
	prefix integer,
	suffix integer,
	age_protect integer,
	alert_message text,
	barcode text,
	call_numer bigint,
	circ_as_type text,
	circ_lib integer,
	circ_modifier text,
	circulate boolean,
	copy_number integer,
	create_date timestamp with time zone,
	active_date timestamp with time zone,
	creator bigint,
	deleted boolean,
	dummy_isbn text,
	deposit boolean,
	deposit_amount numeric(6,2),
	dummy_author text,
	dummy_title text,
	edit_date timestamp with time zone,
	editor bigint,
	fine_level integer,
	holdable boolean,
	id bigint,
	load_duration integer,
	location integer,
	opac_visible boolean,
	price numeric(8,2),
	ref boolean,
	status integer,
	status_changed_time timestamp with time zone,
	mint_condition boolean,
	floating boolean,
	cost numeric(8,2),
	checkin_lib integer,
	checkin_staff integer,
	checkin_time timestamp with time zone,
	circ_circ_lib integer,
	circ_staff integer,
	desk_renewal boolean,
	due_date timestamp with time zone,
	duration interval,
	duration_rule text,
	fine_interval interval,
	circ_id bigint,
	max_fine numeric(6,2),
	max_fine_rule text,
	opac_renewal boolean,
	phone_renewal boolean,
	recurring_fine numeric(6,2),
	recurring_fine_rule text,
	renewal_remaining integer,
	grace_period interval,
	stop_fines text,
	stop_fines_time timestamp with time zone,
	target_copy bigint,
	usr integer,
	xact_finish timestamp with time zone,
	xact_start timestamp with time zone,
	create_time timestamp with time zone,
	workstation integer,
	checkin_workstation integer,
	checkin_scan_time timestamp with time zone,
	parent_circ bigint,
	unrecovered boolean,
	copy_location integer
);


ALTER TYPE evergreen.holdings_maintenance OWNER TO evergreen;

--
-- Name: matched_records; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE matched_records AS (
	create_date timestamp with time zone,
	creator integer,
	edit_date timestamp with time zone,
	id bigint,
	quality integer,
	source integer,
	tcn_source text,
	tcn_value text,
	_id text,
	match_score integer,
	match_quality integer
);


ALTER TYPE evergreen.matched_records OWNER TO evergreen;

--
-- Name: patch; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE patch AS (
	patch text
);


ALTER TYPE evergreen.patch OWNER TO evergreen;

SET search_path = metabib, pg_catalog;

--
-- Name: field_entry_template; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE field_entry_template AS (
	field_class text,
	field integer,
	facet_field boolean,
	search_field boolean,
	browse_field boolean,
	source bigint,
	value text,
	authority bigint,
	sort_value text
);


ALTER TYPE metabib.field_entry_template OWNER TO evergreen;

--
-- Name: flat_browse_entry_appearance; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE flat_browse_entry_appearance AS (
	browse_entry bigint,
	value text,
	fields text,
	authorities text,
	sources integer,
	row_number integer,
	accurate boolean,
	pivot_point bigint,
	sees text,
	asources integer,
	aaccurate text
);


ALTER TYPE metabib.flat_browse_entry_appearance OWNER TO evergreen;

--
-- Name: rec_desc_type; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE rec_desc_type AS (
	item_type text,
	item_form text,
	bib_level text,
	control_type text,
	char_encoding text,
	enc_level text,
	audience text,
	lit_form text,
	type_mat text,
	cat_form text,
	pub_status text,
	item_lang text,
	vr_format text,
	date1 text,
	date2 text
);


ALTER TYPE metabib.rec_desc_type OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: auth_n_bib; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE auth_n_bib AS (
	primary_auth bigint,
	auths bigint[],
	bibs bigint[]
);


ALTER TYPE public.auth_n_bib OWNER TO evergreen;

--
-- Name: ean13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ean13;


--
-- Name: ean13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ean13_in(cstring) RETURNS ean13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_in';


ALTER FUNCTION public.ean13_in(cstring) OWNER TO evergreen;

--
-- Name: ean13_out(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ean13_out(ean13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(ean13) OWNER TO evergreen;

--
-- Name: ean13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ean13 (
    INTERNALLENGTH = 8,
    INPUT = ean13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ean13 OWNER TO evergreen;

--
-- Name: TYPE ean13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE ean13 IS 'International European Article Number (EAN13)';


--
-- Name: ghstore; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ghstore;


--
-- Name: ghstore_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_in(cstring) RETURNS ghstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_in';


ALTER FUNCTION public.ghstore_in(cstring) OWNER TO evergreen;

--
-- Name: ghstore_out(ghstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_out(ghstore) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_out';


ALTER FUNCTION public.ghstore_out(ghstore) OWNER TO evergreen;

--
-- Name: ghstore; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ghstore (
    INTERNALLENGTH = variable,
    INPUT = ghstore_in,
    OUTPUT = ghstore_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.ghstore OWNER TO evergreen;

--
-- Name: hstore; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE hstore;


--
-- Name: hstore_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_in(cstring) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_in';


ALTER FUNCTION public.hstore_in(cstring) OWNER TO evergreen;

--
-- Name: hstore_out(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_out(hstore) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_out';


ALTER FUNCTION public.hstore_out(hstore) OWNER TO evergreen;

--
-- Name: hstore_recv(internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_recv(internal) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_recv';


ALTER FUNCTION public.hstore_recv(internal) OWNER TO evergreen;

--
-- Name: hstore_send(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_send(hstore) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_send';


ALTER FUNCTION public.hstore_send(hstore) OWNER TO evergreen;

--
-- Name: hstore; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE hstore (
    INTERNALLENGTH = variable,
    INPUT = hstore_in,
    OUTPUT = hstore_out,
    RECEIVE = hstore_recv,
    SEND = hstore_send,
    ALIGNMENT = int4,
    STORAGE = extended
);


ALTER TYPE public.hstore OWNER TO evergreen;

--
-- Name: isbn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE isbn;


--
-- Name: isbn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isbn_in(cstring) RETURNS isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_in';


ALTER FUNCTION public.isbn_in(cstring) OWNER TO evergreen;

--
-- Name: isn_out(isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_out(isbn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(isbn) OWNER TO evergreen;

--
-- Name: isbn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE isbn (
    INTERNALLENGTH = 8,
    INPUT = isbn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.isbn OWNER TO evergreen;

--
-- Name: TYPE isbn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE isbn IS 'International Standard Book Number (ISBN)';


--
-- Name: isbn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE isbn13;


--
-- Name: ean13_out(isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ean13_out(isbn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(isbn13) OWNER TO evergreen;

--
-- Name: isbn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isbn13_in(cstring) RETURNS isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_in';


ALTER FUNCTION public.isbn13_in(cstring) OWNER TO evergreen;

--
-- Name: isbn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE isbn13 (
    INTERNALLENGTH = 8,
    INPUT = isbn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.isbn13 OWNER TO evergreen;

--
-- Name: TYPE isbn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE isbn13 IS 'International Standard Book Number 13 (ISBN13)';


--
-- Name: ismn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ismn;


--
-- Name: ismn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ismn_in(cstring) RETURNS ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_in';


ALTER FUNCTION public.ismn_in(cstring) OWNER TO evergreen;

--
-- Name: isn_out(ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_out(ismn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(ismn) OWNER TO evergreen;

--
-- Name: ismn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ismn (
    INTERNALLENGTH = 8,
    INPUT = ismn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ismn OWNER TO evergreen;

--
-- Name: TYPE ismn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE ismn IS 'International Standard Music Number (ISMN)';


--
-- Name: ismn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ismn13;


--
-- Name: ean13_out(ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ean13_out(ismn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(ismn13) OWNER TO evergreen;

--
-- Name: ismn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ismn13_in(cstring) RETURNS ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_in';


ALTER FUNCTION public.ismn13_in(cstring) OWNER TO evergreen;

--
-- Name: ismn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE ismn13 (
    INTERNALLENGTH = 8,
    INPUT = ismn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ismn13 OWNER TO evergreen;

--
-- Name: TYPE ismn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE ismn13 IS 'International Standard Music Number 13 (ISMN13)';


--
-- Name: issn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE issn;


--
-- Name: isn_out(issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_out(issn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(issn) OWNER TO evergreen;

--
-- Name: issn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION issn_in(cstring) RETURNS issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_in';


ALTER FUNCTION public.issn_in(cstring) OWNER TO evergreen;

--
-- Name: issn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE issn (
    INTERNALLENGTH = 8,
    INPUT = issn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.issn OWNER TO evergreen;

--
-- Name: TYPE issn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE issn IS 'International Standard Serial Number (ISSN)';


--
-- Name: issn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE issn13;


--
-- Name: ean13_out(issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ean13_out(issn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(issn13) OWNER TO evergreen;

--
-- Name: issn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION issn13_in(cstring) RETURNS issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_in';


ALTER FUNCTION public.issn13_in(cstring) OWNER TO evergreen;

--
-- Name: issn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE issn13 (
    INTERNALLENGTH = 8,
    INPUT = issn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.issn13 OWNER TO evergreen;

--
-- Name: TYPE issn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE issn13 IS 'International Standard Serial Number 13 (ISSN13)';


--
-- Name: tablefunc_crosstab_2; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_2 AS (
	row_name text,
	category_1 text,
	category_2 text
);


ALTER TYPE public.tablefunc_crosstab_2 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_3; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_3 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text
);


ALTER TYPE public.tablefunc_crosstab_3 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_4 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text,
	category_4 text
);


ALTER TYPE public.tablefunc_crosstab_4 OWNER TO postgres;

--
-- Name: upc; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE upc;


--
-- Name: isn_out(upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_out(upc) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(upc) OWNER TO evergreen;

--
-- Name: upc_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION upc_in(cstring) RETURNS upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'upc_in';


ALTER FUNCTION public.upc_in(cstring) OWNER TO evergreen;

--
-- Name: upc; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE upc (
    INTERNALLENGTH = 8,
    INPUT = upc_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.upc OWNER TO evergreen;

--
-- Name: TYPE upc; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE upc IS 'Universal Product Code (UPC)';


SET search_path = search, pg_catalog;

--
-- Name: search_args; Type: TYPE; Schema: search; Owner: evergreen
--

CREATE TYPE search_args AS (
	id integer,
	field_class text,
	field_name text,
	table_alias text,
	term text,
	term_type text
);


ALTER TYPE search.search_args OWNER TO evergreen;

--
-- Name: search_result; Type: TYPE; Schema: search; Owner: evergreen
--

CREATE TYPE search_result AS (
	id bigint,
	rel numeric,
	record integer,
	total integer,
	checked integer,
	visible integer,
	deleted integer,
	excluded integer
);


ALTER TYPE search.search_result OWNER TO evergreen;

SET search_path = vandelay, pg_catalog;

--
-- Name: authority_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE authority_queue_queue_type AS ENUM (
    'authority'
);


ALTER TYPE vandelay.authority_queue_queue_type OWNER TO evergreen;

--
-- Name: bib_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE bib_queue_queue_type AS ENUM (
    'bib',
    'acq'
);


ALTER TYPE vandelay.bib_queue_queue_type OWNER TO evergreen;

--
-- Name: compile_profile; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE compile_profile AS (
	add_rule text,
	replace_rule text,
	preserve_rule text,
	strip_rule text
);


ALTER TYPE vandelay.compile_profile OWNER TO evergreen;

--
-- Name: flat_marc; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE flat_marc AS (
	tag character(3),
	ind1 text,
	ind2 text,
	subfield text,
	value text
);


ALTER TYPE vandelay.flat_marc OWNER TO evergreen;

--
-- Name: match_set_test_result; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE match_set_test_result AS (
	record bigint,
	quality integer
);


ALTER TYPE vandelay.match_set_test_result OWNER TO evergreen;

--
-- Name: tcn_data; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE tcn_data AS (
	tcn text,
	tcn_source text,
	used boolean
);


ALTER TYPE vandelay.tcn_data OWNER TO evergreen;

SET search_path = acq, pg_catalog;

--
-- Name: attribute_debits(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION attribute_debits() RETURNS void
    LANGUAGE plpgsql
    AS $$
/*
Function to attribute expenditures and encumbrances to funding source credits,
and thereby to funding sources.

Read the debits in chonological order, attributing each one to one or
more funding source credits.  Constraints:

1. Don't attribute more to a credit than the amount of the credit.

2. For a given fund, don't attribute more to a funding source than the
source has allocated to that fund.

3. Attribute debits to credits with deadlines before attributing them to
credits without deadlines.  Otherwise attribute to the earliest credits
first, based on the deadline date when present, or on the effective date
when there is no deadline.  Use funding_source_credit.id as a tie-breaker.
This ordering is defined by an ORDER BY clause on the view
acq.ordered_funding_source_credit.

Start by truncating the table acq.debit_attribution.  Then insert a row
into that table for each attribution.  If a debit cannot be fully
attributed, insert a row for the unattributable balance, with the 
funding_source_credit and credit_amount columns NULL.
*/
DECLARE
	curr_fund_source_bal RECORD;
	seqno                INT;     -- sequence num for credits applicable to a fund
	fund_credit          RECORD;  -- current row in temp t_fund_credit table
	fc                   RECORD;  -- used for loading t_fund_credit table
	sc                   RECORD;  -- used for loading t_fund_credit table
	--
	-- Used exclusively in the main loop:
	--
	deb                 RECORD;   -- current row from acq.fund_debit table
	curr_credit_bal     RECORD;   -- current row from temp t_credit table
	debit_balance       NUMERIC;  -- amount left to attribute for current debit
	conv_debit_balance  NUMERIC;  -- debit balance in currency of the fund
	attr_amount         NUMERIC;  -- amount being attributed, in currency of debit
	conv_attr_amount    NUMERIC;  -- amount being attributed, in currency of source
	conv_cred_balance   NUMERIC;  -- credit_balance in the currency of the fund
	conv_alloc_balance  NUMERIC;  -- allocated balance in the currency of the fund
	attrib_count        INT;      -- populates id of acq.debit_attribution
BEGIN
	--
	-- Load a temporary table.  For each combination of fund and funding source,
	-- load an entry with the total amount allocated to that fund by that source.
	-- This sum may reflect transfers as well as original allocations.  We will
	-- reduce this balance whenever we attribute debits to it.
	--
	CREATE TEMP TABLE t_fund_source_bal
	ON COMMIT DROP AS
		SELECT
			fund AS fund,
			funding_source AS source,
			sum( amount ) AS balance
		FROM
			acq.fund_allocation
		GROUP BY
			fund,
			funding_source
		HAVING
			sum( amount ) > 0;
	--
	CREATE INDEX t_fund_source_bal_idx
		ON t_fund_source_bal( fund, source );
	-------------------------------------------------------------------------------
	--
	-- Load another temporary table.  For each fund, load zero or more
	-- funding source credits from which that fund can get money.
	--
	CREATE TEMP TABLE t_fund_credit (
		fund        INT,
		seq         INT,
		credit      INT
	) ON COMMIT DROP;
	--
	FOR fc IN
		SELECT DISTINCT fund
		FROM acq.fund_allocation
		ORDER BY fund
	LOOP                  -- Loop over the funds
		seqno := 1;
		FOR sc IN
			SELECT
				ofsc.id
			FROM
				acq.ordered_funding_source_credit AS ofsc
			WHERE
				ofsc.funding_source IN
				(
					SELECT funding_source
					FROM acq.fund_allocation
					WHERE fund = fc.fund
				)
    		ORDER BY
    		    ofsc.sort_priority,
    		    ofsc.sort_date,
    		    ofsc.id
		LOOP                        -- Add each credit to the list
			INSERT INTO t_fund_credit (
				fund,
				seq,
				credit
			) VALUES (
				fc.fund,
				seqno,
				sc.id
			);
			--RAISE NOTICE 'Fund % credit %', fc.fund, sc.id;
			seqno := seqno + 1;
		END LOOP;     -- Loop over credits for a given fund
	END LOOP;         -- Loop over funds
	--
	CREATE INDEX t_fund_credit_idx
		ON t_fund_credit( fund, seq );
	-------------------------------------------------------------------------------
	--
	-- Load yet another temporary table.  This one is a list of funding source
	-- credits, with their balances.  We shall reduce those balances as we
	-- attribute debits to them.
	--
	CREATE TEMP TABLE t_credit
	ON COMMIT DROP AS
        SELECT
            fsc.id AS credit,
            fsc.funding_source AS source,
            fsc.amount AS balance,
            fs.currency_type AS currency_type
        FROM
            acq.funding_source_credit AS fsc,
            acq.funding_source fs
        WHERE
            fsc.funding_source = fs.id
			AND fsc.amount > 0;
	--
	CREATE INDEX t_credit_idx
		ON t_credit( credit );
	--
	-------------------------------------------------------------------------------
	--
	-- Now that we have loaded the lookup tables: loop through the debits,
	-- attributing each one to one or more funding source credits.
	-- 
	truncate table acq.debit_attribution;
	--
	attrib_count := 0;
	FOR deb in
		SELECT
			fd.id,
			fd.fund,
			fd.amount,
			f.currency_type,
			fd.encumbrance
		FROM
			acq.fund_debit fd,
			acq.fund f
		WHERE
			fd.fund = f.id
		ORDER BY
			fd.id
	LOOP
		--RAISE NOTICE 'Debit %, fund %', deb.id, deb.fund;
		--
		debit_balance := deb.amount;
		--
		-- Loop over the funding source credits that are eligible
		-- to pay for this debit
		--
		FOR fund_credit IN
			SELECT
				credit
			FROM
				t_fund_credit
			WHERE
				fund = deb.fund
			ORDER BY
				seq
		LOOP
			--RAISE NOTICE '   Examining credit %', fund_credit.credit;
			--
			-- Look up the balance for this credit.  If it's zero, then
			-- it's not useful, so treat it as if you didn't find it.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_credit_bal
			FROM t_credit
			WHERE
				credit = fund_credit.credit
				AND balance > 0;
			--
			IF curr_credit_bal IS NULL THEN
				--
				-- This credit is exhausted; try the next one.
				--
				CONTINUE;
			END IF;
			--
			--
			-- At this point we have an applicable credit with some money left.
			-- Now see if the relevant funding_source has any money left.
			--
			-- Look up the balance of the allocation for this combination of
			-- fund and source.  If you find such an entry, but it has a zero
			-- balance, then it's not useful, so treat it as unfound.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_fund_source_bal
			FROM t_fund_source_bal
			WHERE
				fund = deb.fund
				AND source = curr_credit_bal.source
				AND balance > 0;
			--
			IF curr_fund_source_bal IS NULL THEN
				--
				-- This fund/source doesn't exist or is already exhausted,
				-- so we can't use this credit.  Go on to the next one.
				--
				CONTINUE;
			END IF;
			--
			-- Convert the available balances to the currency of the fund
			--
			conv_alloc_balance := curr_fund_source_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			conv_cred_balance := curr_credit_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			--
			-- Determine how much we can attribute to this credit: the minimum
			-- of the debit amount, the fund/source balance, and the
			-- credit balance
			--
			--RAISE NOTICE '   deb bal %', debit_balance;
			--RAISE NOTICE '      source % balance %', curr_credit_bal.source, conv_alloc_balance;
			--RAISE NOTICE '      credit % balance %', curr_credit_bal.credit, conv_cred_balance;
			--
			conv_attr_amount := NULL;
			attr_amount := debit_balance;
			--
			IF attr_amount > conv_alloc_balance THEN
				attr_amount := conv_alloc_balance;
				conv_attr_amount := curr_fund_source_bal.balance;
			END IF;
			IF attr_amount > conv_cred_balance THEN
				attr_amount := conv_cred_balance;
				conv_attr_amount := curr_credit_bal.balance;
			END IF;
			--
			-- If we're attributing all of one of the balances, then that's how
			-- much we will deduct from the balances, and we already captured
			-- that amount above.  Otherwise we must convert the amount of the
			-- attribution from the currency of the fund back to the currency of
			-- the funding source.
			--
			IF conv_attr_amount IS NULL THEN
				conv_attr_amount := attr_amount * acq.exchange_ratio(
					deb.currency_type, curr_credit_bal.currency_type );
			END IF;
			--
			-- Insert a row to record the attribution
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				attr_amount,
				curr_credit_bal.credit,
				conv_attr_amount
			);
			--
			-- Subtract the attributed amount from the various balances
			--
			debit_balance := debit_balance - attr_amount;
			curr_fund_source_bal.balance := curr_fund_source_bal.balance - conv_attr_amount;
			--
			IF curr_fund_source_bal.balance <= 0 THEN
				--
				-- This allocation is exhausted.  Delete it so
				-- that we don't waste time looking at it again.
				--
				DELETE FROM t_fund_source_bal
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			ELSE
				UPDATE t_fund_source_bal
				SET balance = balance - conv_attr_amount
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			END IF;
			--
			IF curr_credit_bal.balance <= 0 THEN
				--
				-- This funding source credit is exhausted.  Delete it
				-- so that we don't waste time looking at it again.
				--
				--DELETE FROM t_credit
				--WHERE
				--	credit = curr_credit_bal.credit;
				--
				DELETE FROM t_fund_credit
				WHERE
					credit = curr_credit_bal.credit;
			ELSE
				UPDATE t_credit
				SET balance = curr_credit_bal.balance
				WHERE
					credit = curr_credit_bal.credit;
			END IF;
			--
			-- Are we done with this debit yet?
			--
			IF debit_balance <= 0 THEN
				EXIT;       -- We've fully attributed this debit; stop looking at credits.
			END IF;
		END LOOP;       -- End loop over credits
		--
		IF debit_balance <> 0 THEN
			--
			-- We weren't able to attribute this debit, or at least not
			-- all of it.  Insert a row for the unattributed balance.
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				debit_balance,
				NULL,
				NULL
			);
		END IF;
	END LOOP;   -- End of loop over debits
END;
$$;


ALTER FUNCTION acq.attribute_debits() OWNER TO evergreen;

--
-- Name: audit_acq_lineitem_func(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION audit_acq_lineitem_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_lineitem_history
                SELECT	nextval('acq.acq_lineitem_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_lineitem_func() OWNER TO evergreen;

--
-- Name: audit_acq_purchase_order_func(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION audit_acq_purchase_order_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_purchase_order_history
                SELECT	nextval('acq.acq_purchase_order_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_purchase_order_func() OWNER TO evergreen;

--
-- Name: create_acq_auditor(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM acq.create_acq_seq(sch, tbl);
    PERFORM acq.create_acq_history(sch, tbl);
    PERFORM acq.create_acq_func(sch, tbl);
    PERFORM acq.create_acq_update_trigger(sch, tbl);
    PERFORM acq.create_acq_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION acq.create_acq_auditor(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_func(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE FUNCTION acq.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO acq.$$ || sch || $$_$$ || tbl || $$_history
                SELECT	nextval('acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_func(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_history(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE acq.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_history(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_lifecycle(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE VIEW acq.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT	-1, now() as audit_time, '-' as audit_action, *
              FROM	$$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT	*
              FROM	acq.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_lifecycle(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_seq(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_seq(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_update_trigger(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION create_acq_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE acq.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_update_trigger(sch text, tbl text) OWNER TO evergreen;

--
-- Name: exchange_ratio(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION exchange_ratio(from_ex text, to_ex text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    rat NUMERIC;
BEGIN
    IF from_ex = to_ex THEN
        RETURN 1.0;
    END IF;

    SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = from_ex AND to_currency = to_ex;

    IF FOUND THEN
        RETURN rat;
    ELSE
        SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = to_ex AND to_currency = from_ex;
        IF FOUND THEN
            RETURN 1.0/rat;
        END IF;
    END IF;

    RETURN NULL;

END;
$$;


ALTER FUNCTION acq.exchange_ratio(from_ex text, to_ex text) OWNER TO evergreen;

--
-- Name: exchange_ratio(text, text, numeric); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION exchange_ratio(text, text, numeric) RETURNS numeric
    LANGUAGE sql
    AS $_$
    SELECT $3 * acq.exchange_ratio($1, $2);
$_$;


ALTER FUNCTION acq.exchange_ratio(text, text, numeric) OWNER TO evergreen;

--
-- Name: extract_holding_attr_table(integer, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION extract_holding_attr_table(lineitem integer, tag text) RETURNS SETOF flat_lineitem_holding_subfield
    LANGUAGE plpgsql
    AS $$
DECLARE
    counter INT;
    lida    acq.flat_lineitem_holding_subfield%ROWTYPE;
BEGIN

    SELECT  COUNT(*) INTO counter
      FROM  oils_xpath_table(
                'id',
                'marc',
                'acq.lineitem',
                '//*[@tag="' || tag || '"]',
                'id=' || lineitem
            ) as t(i int,c text);

    FOR i IN 1 .. counter LOOP
        FOR lida IN
            SELECT  * 
              FROM  (   SELECT  id,i,t,v
                          FROM  oils_xpath_table(
                                    'id',
                                    'marc',
                                    'acq.lineitem',
                                    '//*[@tag="' || tag || '"][position()=' || i || ']/*/@code|' ||
                                        '//*[@tag="' || tag || '"][position()=' || i || ']/*[@code]',
                                    'id=' || lineitem
                                ) as t(id int,t text,v text)
                    )x
        LOOP
            RETURN NEXT lida;
        END LOOP;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_holding_attr_table(lineitem integer, tag text) OWNER TO evergreen;

--
-- Name: extract_provider_holding_data(integer); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION extract_provider_holding_data(lineitem_i integer) RETURNS SETOF flat_lineitem_detail
    LANGUAGE plpgsql
    AS $$
DECLARE
    prov_i  INT;
    tag_t   TEXT;
    lida    acq.flat_lineitem_detail%ROWTYPE;
BEGIN
    SELECT provider INTO prov_i FROM acq.lineitem WHERE id = lineitem_i;
    IF NOT FOUND THEN RETURN; END IF;

    SELECT holding_tag INTO tag_t FROM acq.provider WHERE id = prov_i;
    IF NOT FOUND OR tag_t IS NULL THEN RETURN; END IF;

    FOR lida IN
        SELECT  lineitem_i,
                h.holding,
                a.name,
                h.data
          FROM  acq.extract_holding_attr_table( lineitem_i, tag_t ) h
                JOIN acq.provider_holding_subfield_map a USING (subfield)
          WHERE a.provider = prov_i
    LOOP
        RETURN NEXT lida;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_provider_holding_data(lineitem_i integer) OWNER TO evergreen;

--
-- Name: fap_limit_100(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION fap_limit_100() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
--
total_percent numeric;
--
BEGIN
    SELECT
        sum( percent )
    INTO
        total_percent
    FROM
        acq.fund_allocation_percent AS fap
    WHERE
        fap.funding_source = NEW.funding_source;
    --
    IF total_percent > 100 THEN
        RAISE EXCEPTION 'Total percentages exceed 100 for funding_source %',
            NEW.funding_source;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION acq.fap_limit_100() OWNER TO evergreen;

--
-- Name: find_bad_fy(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION find_bad_fy() RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	first_row  BOOLEAN;
	curr_year  RECORD;
	prev_year  RECORD;
	return_rec RECORD;
BEGIN
	first_row := true;
	FOR curr_year in
		SELECT
			id,
			calendar,
			year,
			year_begin,
			year_end
		FROM
			acq.fiscal_year
		ORDER BY
			calendar,
			year_begin
	LOOP
		--
		IF first_row THEN
			first_row := FALSE;
		ELSIF curr_year.calendar    = prev_year.calendar THEN
			IF curr_year.year_begin > prev_year.year_end THEN
				-- This ugly kludge works around the fact that older
				-- versions of PostgreSQL don't support RETURN QUERY SELECT
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Gap between fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year_begin < prev_year.year_end THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Overlapping fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year < prev_year.year THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Fiscal years out of order'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			END IF;
		END IF;
		--
		prev_year := curr_year;
	END LOOP;
	--
	RETURN;
END;
$$;


ALTER FUNCTION acq.find_bad_fy() OWNER TO evergreen;

--
-- Name: fund_alloc_percent_val(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION fund_alloc_percent_val() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
--
DECLARE
--
dummy int := 0;
--
BEGIN
    SELECT
        1
    INTO
        dummy
    FROM
        acq.fund
    WHERE
        org = NEW.org
        AND code = NEW.fund_code
        LIMIT 1;
    --
    IF dummy = 1 then
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'No fund exists for org % and code %', NEW.org, NEW.fund_code;
    END IF;
END;
$$;


ALTER FUNCTION acq.fund_alloc_percent_val() OWNER TO evergreen;

--
-- Name: po_org_name_date_unique(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION po_org_name_date_unique() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	collision INT;
BEGIN
	--
	-- If order_date is not null, then make sure we don't have a collision
	-- on order_date (truncated to day), org, and name
	--
	IF NEW.order_date IS NULL THEN
		RETURN NEW;
	END IF;
	--
	-- In the WHERE clause, we compare the order_dates without regard to time of day.
	-- We use a pair of inequalities instead of comparing truncated dates so that the
	-- query can do an indexed range scan.
	--
	SELECT 1 INTO collision
	FROM acq.purchase_order
	WHERE
		ordering_agency = NEW.ordering_agency
		AND name = NEW.name
		AND order_date >= date_trunc( 'day', NEW.order_date )
		AND order_date <  date_trunc( 'day', NEW.order_date ) + '1 day'::INTERVAL
		AND id <> NEW.id;
	--
	IF collision IS NULL THEN
		-- okay, no collision
		RETURN NEW;
	ELSE
		-- collision; nip it in the bud
		RAISE EXCEPTION 'Colliding purchase orders: ordering_agency %, date %, name ''%''',
			NEW.ordering_agency, NEW.order_date, NEW.name;
	END IF;
END;
$$;


ALTER FUNCTION acq.po_org_name_date_unique() OWNER TO evergreen;

--
-- Name: propagate_funds_by_org_tree(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_id      INT;
old_fund    RECORD;
org_found   BOOLEAN;
--
BEGIN
	--
	-- Sanity checks
	--
	IF old_year IS NULL THEN
		RAISE EXCEPTION 'Input year argument is NULL';
	ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
		RAISE EXCEPTION 'Input year is out of range';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'Input user id argument is NULL';
	END IF;
	--
	IF org_unit_id IS NULL THEN
		RAISE EXCEPTION 'Org unit id argument is NULL';
	ELSE
		SELECT TRUE INTO org_found
		FROM actor.org_unit
		WHERE id = org_unit_id;
		--
		IF org_found IS NULL THEN
			RAISE EXCEPTION 'Org unit id is invalid';
		END IF;
	END IF;
	--
	-- Loop over the applicable funds
	--
	FOR old_fund in SELECT * FROM acq.fund
	WHERE
		year = old_year
		AND propagate
		AND ( ( include_desc AND org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND org = org_unit_id ) )
    
	LOOP
		BEGIN
			INSERT INTO acq.fund (
				org,
				name,
				year,
				currency_type,
				code,
				rollover,
				propagate,
				balance_warning_percent,
				balance_stop_percent
			) VALUES (
				old_fund.org,
				old_fund.name,
				old_year + 1,
				old_fund.currency_type,
				old_fund.code,
				old_fund.rollover,
				true,
				old_fund.balance_warning_percent,
				old_fund.balance_stop_percent
			)
			RETURNING id INTO new_id;
		EXCEPTION
			WHEN unique_violation THEN
				--RAISE NOTICE 'Fund % already propagated', old_fund.id;
				CONTINUE;
		END;
		--RAISE NOTICE 'Propagating fund % to fund %',
		--	old_fund.code, new_id;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean) OWNER TO evergreen;

--
-- Name: propagate_funds_by_org_unit(integer, integer, integer); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.propagate_funds_by_org_tree( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION acq.propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) OWNER TO evergreen;

--
-- Name: purchase_order_name_default(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION purchase_order_name_default() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.name IS NULL THEN
		NEW.name := NEW.id::TEXT;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION acq.purchase_order_name_default() OWNER TO evergreen;

--
-- Name: rollover_funds_by_org_tree(integer, integer, integer, boolean, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_fund    INT;
new_year    INT := old_year + 1;
org_found   BOOL;
perm_ous    BOOL;
xfer_amount NUMERIC := 0;
roll_fund   RECORD;
deb         RECORD;
detail      RECORD;
roll_distrib_forms BOOL;
--
BEGIN
	--
	-- Sanity checks
	--
	IF old_year IS NULL THEN
		RAISE EXCEPTION 'Input year argument is NULL';
    ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
        RAISE EXCEPTION 'Input year is out of range';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'Input user id argument is NULL';
	END IF;
	--
	IF org_unit_id IS NULL THEN
		RAISE EXCEPTION 'Org unit id argument is NULL';
	ELSE
		--
		-- Validate the org unit
		--
		SELECT TRUE
		INTO org_found
		FROM actor.org_unit
		WHERE id = org_unit_id;
		--
		IF org_found IS NULL THEN
			RAISE EXCEPTION 'Org unit id % is invalid', org_unit_id;
		ELSIF encumb_only THEN
			SELECT INTO perm_ous value::BOOL FROM
			actor.org_unit_ancestor_setting(
				'acq.fund.allow_rollover_without_money', org_unit_id
			);
			IF NOT FOUND OR NOT perm_ous THEN
				RAISE EXCEPTION 'Encumbrance-only rollover not permitted at org %', org_unit_id;
			END IF;
		END IF;
	END IF;
	--
	-- Loop over the propagable funds to identify the details
	-- from the old fund plus the id of the new one, if it exists.
	--
	FOR roll_fund in
	SELECT
	    oldf.id AS old_fund,
	    oldf.org,
	    oldf.name,
	    oldf.currency_type,
	    oldf.code,
		oldf.rollover,
	    newf.id AS new_fund_id
	FROM
    	acq.fund AS oldf
    	LEFT JOIN acq.fund AS newf
        	ON ( oldf.code = newf.code )
	WHERE
 		    oldf.year = old_year
		AND oldf.propagate
        AND newf.year = new_year
		AND ( ( include_desc AND oldf.org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND oldf.org = org_unit_id ) )
	LOOP
		--RAISE NOTICE 'Processing fund %', roll_fund.old_fund;
		--
		IF roll_fund.new_fund_id IS NULL THEN
			--
			-- The old fund hasn't been propagated yet.  Propagate it now.
			--
			INSERT INTO acq.fund (
				org,
				name,
				year,
				currency_type,
				code,
				rollover,
				propagate,
				balance_warning_percent,
				balance_stop_percent
			) VALUES (
				roll_fund.org,
				roll_fund.name,
				new_year,
				roll_fund.currency_type,
				roll_fund.code,
				true,
				true,
				roll_fund.balance_warning_percent,
				roll_fund.balance_stop_percent
			)
			RETURNING id INTO new_fund;
		ELSE
			new_fund = roll_fund.new_fund_id;
		END IF;
		--
		-- Determine the amount to transfer
		--
		SELECT amount
		INTO xfer_amount
		FROM acq.fund_spent_balance
		WHERE fund = roll_fund.old_fund;
		--
		IF xfer_amount <> 0 THEN
			IF NOT encumb_only AND roll_fund.rollover THEN
				--
				-- Transfer balance from old fund to new
				--
				--RAISE NOTICE 'Transferring % from fund % to %', xfer_amount, roll_fund.old_fund, new_fund;
				--
				PERFORM acq.transfer_fund(
					roll_fund.old_fund,
					xfer_amount,
					new_fund,
					xfer_amount,
					user_id,
					'Rollover'
				);
			ELSE
				--
				-- Transfer balance from old fund to the void
				--
				-- RAISE NOTICE 'Transferring % from fund % to the void', xfer_amount, roll_fund.old_fund;
				--
				PERFORM acq.transfer_fund(
					roll_fund.old_fund,
					xfer_amount,
					NULL,
					NULL,
					user_id,
					'Rollover into the void'
				);
			END IF;
		END IF;
		--
		IF roll_fund.rollover THEN
			--
			-- Move any lineitems from the old fund to the new one
			-- where the associated debit is an encumbrance.
			--
			-- Any other tables tying expenditure details to funds should
			-- receive similar treatment.  At this writing there are none.
			--
			UPDATE acq.lineitem_detail
			SET fund = new_fund
			WHERE
    			fund = roll_fund.old_fund -- this condition may be redundant
    			AND fund_debit in
    			(
        			SELECT id
        			FROM acq.fund_debit
        			WHERE
            			fund = roll_fund.old_fund
            			AND encumbrance
    			);
			--
			-- Move encumbrance debits from the old fund to the new fund
			--
			UPDATE acq.fund_debit
			SET fund = new_fund
			wHERE
				fund = roll_fund.old_fund
				AND encumbrance;
		END IF;

		-- Rollover distribution formulae funds
		SELECT INTO roll_distrib_forms value::BOOL FROM
			actor.org_unit_ancestor_setting(
				'acq.fund.rollover_distrib_forms', org_unit_id
			);

		IF roll_distrib_forms THEN
			UPDATE acq.distribution_formula_entry 
				SET fund = roll_fund.new_fund_id
				WHERE fund = roll_fund.old_fund;
		END IF;

		--
		-- Mark old fund as inactive, now that we've closed it
		--
		UPDATE acq.fund
		SET active = FALSE
		WHERE id = roll_fund.old_fund;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean, include_desc boolean) OWNER TO evergreen;

--
-- Name: rollover_funds_by_org_unit(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.rollover_funds_by_org_tree( $1, $2, $3, $4, FALSE );
$_$;


ALTER FUNCTION acq.rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean) OWNER TO evergreen;

--
-- Name: transfer_fund(integer, numeric, integer, numeric, integer, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/* -------------------------------------------------------------------------------

Function to transfer money from one fund to another.

A transfer is represented as a pair of entries in acq.fund_allocation, with a
negative amount for the old (losing) fund and a positive amount for the new
(gaining) fund.  In some cases there may be more than one such pair of entries
in order to pull the money from different funding sources, or more specifically
from different funding source credits.  For each such pair there is also an
entry in acq.fund_transfer.

Since funding_source is a non-nullable column in acq.fund_allocation, we must
choose a funding source for the transferred money to come from.  This choice
must meet two constraints, so far as possible:

1. The amount transferred from a given funding source must not exceed the
amount allocated to the old fund by the funding source.  To that end we
compare the amount being transferred to the amount allocated.

2. We shouldn't transfer money that has already been spent or encumbered, as
defined by the funding attribution process.  We attribute expenses to the
oldest funding source credits first.  In order to avoid transferring that
attributed money, we reverse the priority, transferring from the newest funding
source credits first.  There can be no guarantee that this approach will
avoid overcommitting a fund, but no other approach can do any better.

In this context the age of a funding source credit is defined by the
deadline_date for credits with deadline_dates, and by the effective_date for
credits without deadline_dates, with the proviso that credits with deadline_dates
are all considered "older" than those without.

----------

In the signature for this function, there is one last parameter commented out,
named "funding_source_in".  Correspondingly, the WHERE clause for the query
driving the main loop has an OR clause commented out, which references the
funding_source_in parameter.

If these lines are uncommented, this function will allow the user optionally to
restrict a fund transfer to a specified funding source.  If the source
parameter is left NULL, then there will be no such restriction.

------------------------------------------------------------------------------- */ 
DECLARE
	same_currency      BOOLEAN;
	currency_ratio     NUMERIC;
	old_fund_currency  TEXT;
	old_remaining      NUMERIC;  -- in currency of old fund
	new_fund_currency  TEXT;
	new_fund_active    BOOLEAN;
	new_remaining      NUMERIC;  -- in currency of new fund
	curr_old_amt       NUMERIC;  -- in currency of old fund
	curr_new_amt       NUMERIC;  -- in currency of new fund
	source_addition    NUMERIC;  -- in currency of funding source
	source_deduction   NUMERIC;  -- in currency of funding source
	orig_allocated_amt NUMERIC;  -- in currency of funding source
	allocated_amt      NUMERIC;  -- in currency of fund
	source             RECORD;
BEGIN
	--
	-- Sanity checks
	--
	IF old_fund IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id is NULL';
	END IF;
	--
	IF old_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer is NULL';
	END IF;
	--
	-- The new fund and its amount must be both NULL or both not NULL.
	--
	IF new_fund IS NOT NULL AND new_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer to receiving fund is NULL';
	END IF;
	--
	IF new_fund IS NULL AND new_amount IS NOT NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: receiving fund is NULL, its amount is not NULL';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: user id is NULL';
	END IF;
	--
	-- Initialize the amounts to be transferred, each denominated
	-- in the currency of its respective fund.  They will be
	-- reduced on each iteration of the loop.
	--
	old_remaining := old_amount;
	new_remaining := new_amount;
	--
	-- RAISE NOTICE 'Transferring % in fund % to % in fund %',
	--	old_amount, old_fund, new_amount, new_fund;
	--
	-- Get the currency types of the old and new funds.
	--
	SELECT
		currency_type
	INTO
		old_fund_currency
	FROM
		acq.fund
	WHERE
		id = old_fund;
	--
	IF old_fund_currency IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id % is not defined', old_fund;
	END IF;
	--
	IF new_fund IS NOT NULL THEN
		SELECT
			currency_type,
			active
		INTO
			new_fund_currency,
			new_fund_active
		FROM
			acq.fund
		WHERE
			id = new_fund;
		--
		IF new_fund_currency IS NULL THEN
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is not defined', new_fund;
		ELSIF NOT new_fund_active THEN
			--
			-- No point in putting money into a fund from whence you can't spend it
			--
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is inactive', new_fund;
		END IF;
		--
		IF new_amount = old_amount THEN
			same_currency := true;
			currency_ratio := 1;
		ELSE
			--
			-- We'll have to translate currency between funds.  We presume that
			-- the calling code has already applied an appropriate exchange rate,
			-- so we'll apply the same conversion to each sub-transfer.
			--
			same_currency := false;
			currency_ratio := new_amount / old_amount;
		END IF;
	END IF;
	--
	-- Identify the funding source(s) from which we want to transfer the money.
	-- The principle is that we want to transfer the newest money first, because
	-- we spend the oldest money first.  The priority for spending is defined
	-- by a sort of the view acq.ordered_funding_source_credit.
	--
	FOR source in
		SELECT
			ofsc.id,
			ofsc.funding_source,
			ofsc.amount,
			ofsc.amount * acq.exchange_ratio( fs.currency_type, old_fund_currency )
				AS converted_amt,
			fs.currency_type
		FROM
			acq.ordered_funding_source_credit AS ofsc,
			acq.funding_source fs
		WHERE
			ofsc.funding_source = fs.id
			and ofsc.funding_source IN
			(
				SELECT funding_source
				FROM acq.fund_allocation
				WHERE fund = old_fund
			)
			-- and
			-- (
			-- 	ofsc.funding_source = funding_source_in
			-- 	OR funding_source_in IS NULL
			-- )
		ORDER BY
			ofsc.sort_priority desc,
			ofsc.sort_date desc,
			ofsc.id desc
	LOOP
		--
		-- Determine how much money the old fund got from this funding source,
		-- denominated in the currency types of the source and of the fund.
		-- This result may reflect transfers from previous iterations.
		--
		SELECT
			COALESCE( sum( amount ), 0 ),
			COALESCE( sum( amount )
				* acq.exchange_ratio( source.currency_type, old_fund_currency ), 0 )
		INTO
			orig_allocated_amt,     -- in currency of the source
			allocated_amt           -- in currency of the old fund
		FROM
			acq.fund_allocation
		WHERE
			fund = old_fund
			and funding_source = source.funding_source;
		--	
		-- Determine how much to transfer from this credit, in the currency
		-- of the fund.   Begin with the amount remaining to be attributed:
		--
		curr_old_amt := old_remaining;
		--
		-- Can't attribute more than was allocated from the fund:
		--
		IF curr_old_amt > allocated_amt THEN
			curr_old_amt := allocated_amt;
		END IF;
		--
		-- Can't attribute more than the amount of the current credit:
		--
		IF curr_old_amt > source.converted_amt THEN
			curr_old_amt := source.converted_amt;
		END IF;
		--
		curr_old_amt := trunc( curr_old_amt, 2 );
		--
		old_remaining := old_remaining - curr_old_amt;
		--
		-- Determine the amount to be deducted, if any,
		-- from the old allocation.
		--
		IF old_remaining > 0 THEN
			--
			-- In this case we're using the whole allocation, so use that
			-- amount directly instead of applying a currency translation
			-- and thereby inviting round-off errors.
			--
			source_deduction := - orig_allocated_amt;
		ELSE 
			source_deduction := trunc(
				( - curr_old_amt ) *
					acq.exchange_ratio( old_fund_currency, source.currency_type ),
				2 );
		END IF;
		--
		IF source_deduction <> 0 THEN
			--
			-- Insert negative allocation for old fund in fund_allocation,
			-- converted into the currency of the funding source
			--
			INSERT INTO acq.fund_allocation (
				funding_source,
				fund,
				amount,
				allocator,
				note
			) VALUES (
				source.funding_source,
				old_fund,
				source_deduction,
				user_id,
				'Transfer to fund ' || new_fund
			);
		END IF;
		--
		IF new_fund IS NOT NULL THEN
			--
			-- Determine how much to add to the new fund, in
			-- its currency, and how much remains to be added:
			--
			IF same_currency THEN
				curr_new_amt := curr_old_amt;
			ELSE
				IF old_remaining = 0 THEN
					--
					-- This is the last iteration, so nothing should be left
					--
					curr_new_amt := new_remaining;
					new_remaining := 0;
				ELSE
					curr_new_amt := trunc( curr_old_amt * currency_ratio, 2 );
					new_remaining := new_remaining - curr_new_amt;
				END IF;
			END IF;
			--
			-- Determine how much to add, if any,
			-- to the new fund's allocation.
			--
			IF old_remaining > 0 THEN
				--
				-- In this case we're using the whole allocation, so use that amount
				-- amount directly instead of applying a currency translation and
				-- thereby inviting round-off errors.
				--
				source_addition := orig_allocated_amt;
			ELSIF source.currency_type = old_fund_currency THEN
				--
				-- In this case we don't need a round trip currency translation,
				-- thereby inviting round-off errors:
				--
				source_addition := curr_old_amt;
			ELSE 
				source_addition := trunc(
					curr_new_amt *
						acq.exchange_ratio( new_fund_currency, source.currency_type ),
					2 );
			END IF;
			--
			IF source_addition <> 0 THEN
				--
				-- Insert positive allocation for new fund in fund_allocation,
				-- converted to the currency of the founding source
				--
				INSERT INTO acq.fund_allocation (
					funding_source,
					fund,
					amount,
					allocator,
					note
				) VALUES (
					source.funding_source,
					new_fund,
					source_addition,
					user_id,
					'Transfer from fund ' || old_fund
				);
			END IF;
		END IF;
		--
		IF trunc( curr_old_amt, 2 ) <> 0
		OR trunc( curr_new_amt, 2 ) <> 0 THEN
			--
			-- Insert row in fund_transfer, using amounts in the currency of the funds
			--
			INSERT INTO acq.fund_transfer (
				src_fund,
				src_amount,
				dest_fund,
				dest_amount,
				transfer_user,
				note,
				funding_source_credit
			) VALUES (
				old_fund,
				trunc( curr_old_amt, 2 ),
				new_fund,
				trunc( curr_new_amt, 2 ),
				user_id,
				xfer_note,
				source.id
			);
		END IF;
		--
		if old_remaining <= 0 THEN
			EXIT;                   -- Nothing more to be transferred
		END IF;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) OWNER TO evergreen;

SET search_path = action, pg_catalog;

--
-- Name: age_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION age_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
found char := 'N';
BEGIN

    -- If there are any renewals for this circulation, don't archive or delete
    -- it yet.   We'll do so later, when we archive and delete the renewals.

    SELECT 'Y' INTO found
    FROM action.circulation
    WHERE parent_circ = OLD.id
    LIMIT 1;

    IF found = 'Y' THEN
        RETURN NULL;  -- don't delete
	END IF;

    -- Archive a copy of the old row to action.aged_circulation

    INSERT INTO action.aged_circulation
        (id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ)
      SELECT
        id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ
        FROM action.all_circulation WHERE id = OLD.id;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_circ_on_delete() OWNER TO evergreen;

--
-- Name: age_parent_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION age_parent_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- Having deleted a renewal, we can delete the original circulation (or a previous
    -- renewal, if that's what parent_circ is pointing to).  That deletion will trigger
    -- deletion of any prior parents, etc. recursively.

    IF OLD.parent_circ IS NOT NULL THEN
        DELETE FROM action.circulation
        WHERE id = OLD.parent_circ;
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_parent_circ_on_delete() OWNER TO evergreen;

--
-- Name: apply_fieldset(integer, text, text, text); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	statement TEXT;
	fs_status TEXT;
	fs_pkey_value TEXT;
	fs_query TEXT;
	sep CHAR;
	status_code TEXT;
	msg TEXT;
	update_count INT;
	cv RECORD;
BEGIN
	-- Sanity checks
	IF fieldset_id IS NULL THEN
		RETURN 'Fieldset ID parameter is NULL';
	END IF;
	IF table_name IS NULL THEN
		RETURN 'Table name parameter is NULL';
	END IF;
	IF pkey_name IS NULL THEN
		RETURN 'Primary key name parameter is NULL';
	END IF;
	--
	statement := 'UPDATE ' || table_name || ' SET';
	--
	SELECT
		status,
		quote_literal( pkey_value )
	INTO
		fs_status,
		fs_pkey_value
	FROM
		action.fieldset
	WHERE
		id = fieldset_id;
	--
	IF fs_status IS NULL THEN
		RETURN 'No fieldset found for id = ' || fieldset_id;
	ELSIF fs_status = 'APPLIED' THEN
		RETURN 'Fieldset ' || fieldset_id || ' has already been applied';
	END IF;
	--
	sep := '';
	FOR cv IN
		SELECT  col,
				val
		FROM    action.fieldset_col_val
		WHERE   fieldset = fieldset_id
	LOOP
		statement := statement || sep || ' ' || cv.col
					 || ' = ' || coalesce( quote_literal( cv.val ), 'NULL' );
		sep := ',';
	END LOOP;
	--
	IF sep = '' THEN
		RETURN 'Fieldset ' || fieldset_id || ' has no column values defined';
	END IF;
	--
	-- Add the WHERE clause.  This differs according to whether it's a
	-- single-row fieldset or a query-based fieldset.
	--
	IF query IS NULL        AND fs_pkey_value IS NULL THEN
		RETURN 'Incomplete fieldset: neither a primary key nor a query available';
	ELSIF query IS NOT NULL AND fs_pkey_value IS NULL THEN
	    fs_query := rtrim( query, ';' );
	    statement := statement || ' WHERE ' || pkey_name || ' IN ( '
	                 || fs_query || ' );';
	ELSIF query IS NULL     AND fs_pkey_value IS NOT NULL THEN
		statement := statement || ' WHERE ' || pkey_name || ' = '
				     || fs_pkey_value || ';';
	ELSE  -- both are not null
		RETURN 'Ambiguous fieldset: both a primary key and a query provided';
	END IF;
	--
	-- Execute the update
	--
	BEGIN
		EXECUTE statement;
		GET DIAGNOSTICS update_count = ROW_COUNT;
		--
		IF UPDATE_COUNT > 0 THEN
			status_code := 'APPLIED';
			msg := NULL;
		ELSE
			status_code := 'ERROR';
			msg := 'No eligible rows found for fieldset ' || fieldset_id;
    	END IF;
	EXCEPTION WHEN OTHERS THEN
		status_code := 'ERROR';
		msg := 'Unable to apply fieldset ' || fieldset_id
			   || ': ' || sqlerrm;
	END;
	--
	-- Update fieldset status
	--
	UPDATE action.fieldset
	SET status       = status_code,
	    applied_time = now()
	WHERE id = fieldset_id;
	--
	RETURN msg;
END;
$$;


ALTER FUNCTION action.apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) OWNER TO evergreen;

--
-- Name: FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text); Type: COMMENT; Schema: action; Owner: evergreen
--

COMMENT ON FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) IS '
/**
 * Applies a specified fieldset, using a supplied table name and primary
 * key name.  The query parameter should be non-null only for
 * query-based fieldsets.
 *
 * Returns NULL if successful, or an error message if not.
 */
';


--
-- Name: archive_stat_cats(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION archive_stat_cats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO action.archive_actor_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, asceum.stat_cat, asceum.stat_cat_entry
        FROM actor.stat_cat_entry_usr_map asceum
             JOIN actor.stat_cat sc ON asceum.stat_cat = sc.id
        WHERE NEW.usr = asceum.target_usr AND sc.checkout_archive;
    INSERT INTO action.archive_asset_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, ascecm.stat_cat, asce.value
        FROM asset.stat_cat_entry_copy_map ascecm
             JOIN asset.stat_cat sc ON ascecm.stat_cat = sc.id
             JOIN asset.stat_cat_entry asce ON ascecm.stat_cat_entry = asce.id
        WHERE NEW.target_copy = ascecm.owning_copy AND sc.checkout_archive;
    RETURN NULL;
END;
$$;


ALTER FUNCTION action.archive_stat_cats() OWNER TO evergreen;

--
-- Name: archived_hold_request_insert_trigger(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION archived_hold_request_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF ( NEW.request_time >= '2013-01-01' AND NEW.request_time < '2014-01-01' )
    THEN INSERT INTO action.archived_hold_request_2013 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2012-01-01' AND NEW.request_time < '2013-01-01' )
    THEN INSERT INTO action.archived_hold_request_2012 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2011-01-01' AND NEW.request_time < '2012-01-01' )
    THEN INSERT INTO action.archived_hold_request_2011 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2010-01-01' AND NEW.request_time < '2011-01-01' )
    THEN INSERT INTO action.archived_hold_request_2010 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2009-01-01' AND NEW.request_time < '2010-01-01' )
    THEN INSERT INTO action.archived_hold_request_2009 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2008-01-01' AND NEW.request_time < '2009-01-01' )
    THEN INSERT INTO action.archived_hold_request_2008 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2007-01-01' AND NEW.request_time < '2008-01-01' )
    THEN INSERT INTO action.archived_hold_request_2007 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2006-01-01' AND NEW.request_time < '2007-01-01' )
    THEN INSERT INTO action.archived_hold_request_2006 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2005-01-01' AND NEW.request_time < '2006-01-01' )
    THEN INSERT INTO action.archived_hold_request_2005 VALUES (NEW.*);
ELSE
    RAISE EXCEPTION 'request_time out of range for insert into archived_hold_request_* child tables.';
END IF;
RETURN NULL;
END;
$$;


ALTER FUNCTION action.archived_hold_request_insert_trigger() OWNER TO evergreen;

SET search_path = money, pg_catalog;

--
-- Name: billable_xact; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE billable_xact (
    id bigint NOT NULL,
    usr integer NOT NULL,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean
);


ALTER TABLE money.billable_xact OWNER TO evergreen;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE billable_xact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billable_xact_id_seq OWNER TO evergreen;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE billable_xact_id_seq OWNED BY billable_xact.id;


SET search_path = action, pg_catalog;

--
-- Name: circulation; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass),
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval NOT NULL,
    copy_location integer DEFAULT 1 NOT NULL,
    CONSTRAINT circulation_stop_fines_check CHECK ((stop_fines = ANY (ARRAY['CHECKIN'::text, 'CLAIMSRETURNED'::text, 'LOST'::text, 'MAXFINES'::text, 'RENEW'::text, 'LONGOVERDUE'::text, 'CLAIMSNEVERCHECKEDOUT'::text])))
)
INHERITS (money.billable_xact);


ALTER TABLE action.circulation OWNER TO evergreen;

--
-- Name: circ_chain(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION circ_chain(ctx_circ_id bigint) RETURNS SETOF circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_circ action.circulation%ROWTYPE;
    circ_0 action.circulation%ROWTYPE;
BEGIN

    SELECT INTO tmp_circ * FROM action.circulation WHERE id = ctx_circ_id;

    IF tmp_circ IS NULL THEN
        RETURN NEXT tmp_circ;
    END IF;
    circ_0 := tmp_circ;

    -- find the front of the chain
    WHILE TRUE LOOP
        SELECT INTO tmp_circ * FROM action.circulation WHERE id = tmp_circ.parent_circ;
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        circ_0 := tmp_circ;
    END LOOP;

    -- now send the circs to the caller, oldest to newest
    tmp_circ := circ_0;
    WHILE TRUE LOOP
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        RETURN NEXT tmp_circ;
        SELECT INTO tmp_circ * FROM action.circulation WHERE parent_circ = tmp_circ.id;
    END LOOP;

END;
$$;


ALTER FUNCTION action.circ_chain(ctx_circ_id bigint) OWNER TO evergreen;

--
-- Name: circulation_claims_returned(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION circulation_claims_returned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF OLD.stop_fines IS NULL OR OLD.stop_fines <> NEW.stop_fines THEN
		IF NEW.stop_fines = 'CLAIMSRETURNED' THEN
			UPDATE actor.usr SET claims_returned_count = claims_returned_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'CLAIMSNEVERCHECKEDOUT' THEN
			UPDATE actor.usr SET claims_never_checked_out_count = claims_never_checked_out_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'LOST' THEN
			UPDATE asset.copy SET status = 3 WHERE id = NEW.target_copy;
		END IF;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.circulation_claims_returned() OWNER TO evergreen;

--
-- Name: copy_related_hold_stats(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION copy_related_hold_stats(copy_id integer) RETURNS hold_stats
    LANGUAGE plpgsql
    AS $$
DECLARE
    output          action.hold_stats%ROWTYPE;
    hold_count      INT := 0;
    copy_count      INT := 0;
    available_count INT := 0;
    hold_map_data   RECORD;
BEGIN

    output.hold_count := 0;
    output.copy_count := 0;
    output.available_count := 0;

    SELECT  COUNT( DISTINCT m.hold ) INTO hold_count
      FROM  action.hold_copy_map m
            JOIN action.hold_request h ON (m.hold = h.id)
      WHERE m.target_copy = copy_id
            AND NOT h.frozen;

    output.hold_count := hold_count;

    IF output.hold_count > 0 THEN
        FOR hold_map_data IN
            SELECT  DISTINCT m.target_copy,
                    acp.status
              FROM  action.hold_copy_map m
                    JOIN asset.copy acp ON (m.target_copy = acp.id)
                    JOIN action.hold_request h ON (m.hold = h.id)
              WHERE m.hold IN ( SELECT DISTINCT hold FROM action.hold_copy_map WHERE target_copy = copy_id ) AND NOT h.frozen
        LOOP
            output.copy_count := output.copy_count + 1;
            IF hold_map_data.status IN (0,7,12) THEN
                output.available_count := output.available_count + 1;
            END IF;
        END LOOP;
        output.total_copy_ratio = output.copy_count::FLOAT / output.hold_count::FLOAT;
        output.available_copy_ratio = output.available_count::FLOAT / output.hold_count::FLOAT;

    END IF;

    RETURN output;

END;
$$;


ALTER FUNCTION action.copy_related_hold_stats(copy_id integer) OWNER TO evergreen;

--
-- Name: fill_circ_copy_location(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION fill_circ_copy_location() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    SELECT INTO NEW.copy_location location FROM asset.copy WHERE id = NEW.target_copy;
    RETURN NEW;
END;
$$;


ALTER FUNCTION action.fill_circ_copy_location() OWNER TO evergreen;

--
-- Name: find_circ_matrix_matchpoint(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    item_object asset.copy%ROWTYPE;
    user_object actor.usr%ROWTYPE;
BEGIN
    SELECT INTO item_object * FROM asset.copy 	WHERE id = match_item;
    SELECT INTO user_object * FROM actor.usr	WHERE id = match_user;

    RETURN QUERY SELECT * FROM action.find_circ_matrix_matchpoint( context_ou, item_object, user_object, renewal );
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: usr; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr (
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL,
    last_update_time timestamp with time zone
);


ALTER TABLE actor.usr OWNER TO evergreen;

--
-- Name: TABLE usr; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE usr IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User objects
 *
 * This table contains the core User objects that describe both
 * staff members and patrons.  The difference between the two
 * types of users is based on the user''s permissions.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


SET search_path = asset, pg_catalog;

--
-- Name: copy; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy (
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2),
    active_date timestamp with time zone,
    CONSTRAINT copy_fine_level_check CHECK ((fine_level = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT copy_loan_duration_check CHECK ((loan_duration = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE asset.copy OWNER TO evergreen;

SET search_path = action, pg_catalog;

--
-- Name: find_circ_matrix_matchpoint(integer, asset.copy, actor.usr, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) RETURNS found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    cn_object       asset.call_number%ROWTYPE;
    rec_descriptor  metabib.rec_descriptor%ROWTYPE;
    cur_matchpoint  config.circ_matrix_matchpoint%ROWTYPE;
    matchpoint      config.circ_matrix_matchpoint%ROWTYPE;
    weights         config.circ_matrix_weights%ROWTYPE;
    user_age        INTERVAL;
    my_item_age     INTERVAL;
    denominator     NUMERIC(6,2);
    row_list        INT[];
    result          action.found_circ_matrix_matchpoint;
BEGIN
    -- Assume failure
    result.success = false;

    -- Fetch useful data
    SELECT INTO cn_object       * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor  * FROM metabib.rec_descriptor   WHERE record = cn_object.record;

    -- Pre-generate this so we only calc it once
    IF user_object.dob IS NOT NULL THEN
        SELECT INTO user_age age(user_object.dob);
    END IF;

    -- Ditto
    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- Grab the closest set circ weight setting.
    SELECT INTO weights cw.*
      FROM config.weight_assoc wa
           JOIN config.circ_matrix_weights cw ON (cw.id = wa.circ_weights)
           JOIN actor.org_unit_ancestors_distance( context_ou ) d ON (wa.org_unit = d.id)
      WHERE active
      ORDER BY d.distance
      LIMIT 1;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.grp                 := 11.0;
        weights.org_unit            := 10.0;
        weights.circ_modifier       := 5.0;
        weights.copy_location       := 5.0;
        weights.marc_type           := 4.0;
        weights.marc_form           := 3.0;
        weights.marc_bib_level      := 2.0;
        weights.marc_vr_format      := 2.0;
        weights.copy_circ_lib       := 8.0;
        weights.copy_owning_lib     := 8.0;
        weights.user_home_ou        := 8.0;
        weights.ref_flag            := 1.0;
        weights.juvenile_flag       := 6.0;
        weights.is_renewal          := 7.0;
        weights.usr_age_lower_bound := 0.0;
        weights.usr_age_upper_bound := 0.0;
        weights.item_age            := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_hold_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
            SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
    )
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- Loop over all the potential matchpoints
    FOR cur_matchpoint IN
        SELECT m.*
          FROM  config.circ_matrix_matchpoint m
                /*LEFT*/ JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.grp = upgad.id
                /*LEFT*/ JOIN actor.org_unit_ancestors_distance( context_ou ) ctoua ON m.org_unit = ctoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( cn_object.owning_lib ) cnoua ON m.copy_owning_lib = cnoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.copy_circ_lib = iooua.id
                LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
          WHERE m.active
                -- Permission Groups
             -- AND (m.grp                      IS NULL OR upgad.id IS NOT NULL) -- Optional Permission Group?
                -- Org Units
             -- AND (m.org_unit                 IS NULL OR ctoua.id IS NOT NULL) -- Optional Org Unit?
                AND (m.copy_owning_lib          IS NULL OR cnoua.id IS NOT NULL)
                AND (m.copy_circ_lib            IS NULL OR iooua.id IS NOT NULL)
                AND (m.user_home_ou             IS NULL OR uhoua.id IS NOT NULL)
                -- Circ Type
                AND (m.is_renewal               IS NULL OR m.is_renewal = renewal)
                -- Static User Checks
                AND (m.juvenile_flag            IS NULL OR m.juvenile_flag = user_object.juvenile)
                AND (m.usr_age_lower_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_lower_bound < user_age))
                AND (m.usr_age_upper_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_upper_bound > user_age))
                -- Static Item Checks
                AND (m.circ_modifier            IS NULL OR m.circ_modifier = item_object.circ_modifier)
                AND (m.copy_location            IS NULL OR m.copy_location = item_object.location)
                AND (m.marc_type                IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
                AND (m.marc_form                IS NULL OR m.marc_form = rec_descriptor.item_form)
                AND (m.marc_bib_level           IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
                AND (m.marc_vr_format           IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
                AND (m.ref_flag                 IS NULL OR m.ref_flag = item_object.ref)
                AND (m.item_age                 IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
          ORDER BY
                -- Permission Groups
                CASE WHEN upgad.distance        IS NOT NULL THEN 2^(2*weights.grp - (upgad.distance/denominator)) ELSE 0.0 END +
                -- Org Units
                CASE WHEN ctoua.distance        IS NOT NULL THEN 2^(2*weights.org_unit - (ctoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN cnoua.distance        IS NOT NULL THEN 2^(2*weights.copy_owning_lib - (cnoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN iooua.distance        IS NOT NULL THEN 2^(2*weights.copy_circ_lib - (iooua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN uhoua.distance        IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
                -- Circ Type                    -- Note: 4^x is equiv to 2^(2*x)
                CASE WHEN m.is_renewal          IS NOT NULL THEN 4^weights.is_renewal ELSE 0.0 END +
                -- Static User Checks
                CASE WHEN m.juvenile_flag       IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
                CASE WHEN m.usr_age_lower_bound IS NOT NULL THEN 4^weights.usr_age_lower_bound ELSE 0.0 END +
                CASE WHEN m.usr_age_upper_bound IS NOT NULL THEN 4^weights.usr_age_upper_bound ELSE 0.0 END +
                -- Static Item Checks
                CASE WHEN m.circ_modifier       IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
                CASE WHEN m.copy_location       IS NOT NULL THEN 4^weights.copy_location ELSE 0.0 END +
                CASE WHEN m.marc_type           IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
                CASE WHEN m.marc_form           IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
                CASE WHEN m.marc_vr_format      IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
                CASE WHEN m.ref_flag            IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
                -- Item age has a slight adjustment to weight based on value.
                -- This should ensure that a shorter age limit comes first when all else is equal.
                -- NOTE: This assumes that intervals will normally be in days.
                CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 1 + 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
                -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
                -- This prevents "we changed the table order by updating a rule, and we started getting different results"
                m.id LOOP

        -- Record the full matching row list
        row_list := row_list || cur_matchpoint.id;

        -- No matchpoint yet?
        IF matchpoint.id IS NULL THEN
            -- Take the entire matchpoint as a starting point
            matchpoint := cur_matchpoint;
            CONTINUE; -- No need to look at this row any more.
        END IF;

        -- Incomplete matchpoint?
        IF matchpoint.circulate IS NULL THEN
            matchpoint.circulate := cur_matchpoint.circulate;
        END IF;
        IF matchpoint.duration_rule IS NULL THEN
            matchpoint.duration_rule := cur_matchpoint.duration_rule;
        END IF;
        IF matchpoint.recurring_fine_rule IS NULL THEN
            matchpoint.recurring_fine_rule := cur_matchpoint.recurring_fine_rule;
        END IF;
        IF matchpoint.max_fine_rule IS NULL THEN
            matchpoint.max_fine_rule := cur_matchpoint.max_fine_rule;
        END IF;
        IF matchpoint.hard_due_date IS NULL THEN
            matchpoint.hard_due_date := cur_matchpoint.hard_due_date;
        END IF;
        IF matchpoint.total_copy_hold_ratio IS NULL THEN
            matchpoint.total_copy_hold_ratio := cur_matchpoint.total_copy_hold_ratio;
        END IF;
        IF matchpoint.available_copy_hold_ratio IS NULL THEN
            matchpoint.available_copy_hold_ratio := cur_matchpoint.available_copy_hold_ratio;
        END IF;
        IF matchpoint.renewals IS NULL THEN
            matchpoint.renewals := cur_matchpoint.renewals;
        END IF;
        IF matchpoint.grace_period IS NULL THEN
            matchpoint.grace_period := cur_matchpoint.grace_period;
        END IF;
    END LOOP;

    -- Check required fields
    IF matchpoint.circulate             IS NOT NULL AND
       matchpoint.duration_rule         IS NOT NULL AND
       matchpoint.recurring_fine_rule   IS NOT NULL AND
       matchpoint.max_fine_rule         IS NOT NULL THEN
        -- All there? We have a completed match.
        result.success := true;
    END IF;

    -- Include the assembled matchpoint, even if it isn't complete
    result.matchpoint := matchpoint;

    -- Include (for debugging) the full list of matching rows
    result.buildrows := row_list;

    -- Hand the result back to caller
    RETURN result;
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) OWNER TO evergreen;

--
-- Name: find_hold_matrix_matchpoint(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    requestor_object    actor.usr%ROWTYPE;
    user_object         actor.usr%ROWTYPE;
    item_object         asset.copy%ROWTYPE;
    item_cn_object      asset.call_number%ROWTYPE;
    my_item_age         INTERVAL;
    rec_descriptor      metabib.rec_descriptor%ROWTYPE;
    matchpoint          config.hold_matrix_matchpoint%ROWTYPE;
    weights             config.hold_matrix_weights%ROWTYPE;
    denominator         NUMERIC(6,2);
BEGIN
    SELECT INTO user_object         * FROM actor.usr                WHERE id = match_user;
    SELECT INTO requestor_object    * FROM actor.usr                WHERE id = match_requestor;
    SELECT INTO item_object         * FROM asset.copy               WHERE id = match_item;
    SELECT INTO item_cn_object      * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor      * FROM metabib.rec_descriptor   WHERE record = item_cn_object.record;

    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- The item's owner should probably be the one determining if the item is holdable
    -- How to decide that is debatable. Decided to default to the circ library (where the item lives)
    -- This flag will allow for setting it to the owning library (where the call number "lives")
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.weight_owner_not_circ' AND enabled;

    -- Grab the closest set circ weight setting.
    IF NOT FOUND THEN
        -- Default to circ library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    ELSE
        -- Flag is set, use owning library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    END IF;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.user_home_ou    := 5.0;
        weights.request_ou      := 5.0;
        weights.pickup_ou       := 5.0;
        weights.item_owning_ou  := 5.0;
        weights.item_circ_ou    := 5.0;
        weights.usr_grp         := 7.0;
        weights.requestor_grp   := 8.0;
        weights.circ_modifier   := 4.0;
        weights.marc_type       := 3.0;
        weights.marc_form       := 2.0;
        weights.marc_bib_level  := 1.0;
        weights.marc_vr_format  := 1.0;
        weights.juvenile_flag   := 4.0;
        weights.ref_flag        := 0.0;
        weights.item_age        := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_circ_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
            SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
	)
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- To ATTEMPT to make this work like it used to, make it reverse the user/requestor profile ids.
    -- This may be better implemented as part of the upgrade script?
    -- Set usr_grp = requestor_grp, requestor_grp = 1 or something when this flag is already set
    -- Then remove this flag, of course.
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.usr_not_requestor' AND enabled;

    IF FOUND THEN
        -- Note: This, to me, is REALLY hacky. I put it in anyway.
        -- If you can't tell, this is a single call swap on two variables.
        SELECT INTO user_object.profile, requestor_object.profile
                    requestor_object.profile, user_object.profile;
    END IF;

    -- Select the winning matchpoint into the matchpoint variable for returning
    SELECT INTO matchpoint m.*
      FROM  config.hold_matrix_matchpoint m
            /*LEFT*/ JOIN permission.grp_ancestors_distance( requestor_object.profile ) rpgad ON m.requestor_grp = rpgad.id
            LEFT JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.usr_grp = upgad.id
            LEFT JOIN actor.org_unit_ancestors_distance( pickup_ou ) puoua ON m.pickup_ou = puoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( request_ou ) rqoua ON m.request_ou = rqoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) cnoua ON m.item_owning_ou = cnoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.item_circ_ou = iooua.id
            LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
      WHERE m.active
            -- Permission Groups
         -- AND (m.requestor_grp        IS NULL OR upgad.id IS NOT NULL) -- Optional Requestor Group?
            AND (m.usr_grp              IS NULL OR upgad.id IS NOT NULL)
            -- Org Units
            AND (m.pickup_ou            IS NULL OR (puoua.id IS NOT NULL AND (puoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.request_ou           IS NULL OR (rqoua.id IS NOT NULL AND (rqoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_owning_ou       IS NULL OR (cnoua.id IS NOT NULL AND (cnoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_circ_ou         IS NULL OR (iooua.id IS NOT NULL AND (iooua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.user_home_ou         IS NULL OR (uhoua.id IS NOT NULL AND (uhoua.distance = 0 OR NOT m.strict_ou_match)))
            -- Static User Checks
            AND (m.juvenile_flag        IS NULL OR m.juvenile_flag = user_object.juvenile)
            -- Static Item Checks
            AND (m.circ_modifier        IS NULL OR m.circ_modifier = item_object.circ_modifier)
            AND (m.marc_type            IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
            AND (m.marc_form            IS NULL OR m.marc_form = rec_descriptor.item_form)
            AND (m.marc_bib_level       IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
            AND (m.marc_vr_format       IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
            AND (m.ref_flag             IS NULL OR m.ref_flag = item_object.ref)
            AND (m.item_age             IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
      ORDER BY
            -- Permission Groups
            CASE WHEN rpgad.distance    IS NOT NULL THEN 2^(2*weights.requestor_grp - (rpgad.distance/denominator)) ELSE 0.0 END +
            CASE WHEN upgad.distance    IS NOT NULL THEN 2^(2*weights.usr_grp - (upgad.distance/denominator)) ELSE 0.0 END +
            -- Org Units
            CASE WHEN puoua.distance    IS NOT NULL THEN 2^(2*weights.pickup_ou - (puoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN rqoua.distance    IS NOT NULL THEN 2^(2*weights.request_ou - (rqoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN cnoua.distance    IS NOT NULL THEN 2^(2*weights.item_owning_ou - (cnoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN iooua.distance    IS NOT NULL THEN 2^(2*weights.item_circ_ou - (iooua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN uhoua.distance    IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
            -- Static User Checks       -- Note: 4^x is equiv to 2^(2*x)
            CASE WHEN m.juvenile_flag   IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
            -- Static Item Checks
            CASE WHEN m.circ_modifier   IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
            CASE WHEN m.marc_type       IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
            CASE WHEN m.marc_form       IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
            CASE WHEN m.marc_vr_format  IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
            CASE WHEN m.ref_flag        IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
            -- Item age has a slight adjustment to weight based on value.
            -- This should ensure that a shorter age limit comes first when all else is equal.
            -- NOTE: This assumes that intervals will normally be in days.
            CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
            -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
            -- This prevents "we changed the table order by updating a rule, and we started getting different results"
            m.id;

    -- Return just the ID for now
    RETURN matchpoint.id;
END;
$$;


ALTER FUNCTION action.find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: get_hold_count(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION get_hold_count(bib_record_id integer) RETURNS bigint
    LANGUAGE plpgsql COST 500
    AS $$
DECLARE
    counter INT;
    the_count INT;
BEGIN          
    SELECT holds_count INTO  counter FROM action.hold_count WHERE action.hold_count.record_entry_id = bib_record_id;

    IF FOUND THEN
	RETURN counter;
    ELSE
	SELECT  count("ahr".id ) INTO the_count 
	FROM action.hold_request AS "ahr"  
	WHERE ( 
			( 
				( 
					( "ahr".target IN (SELECT  "acp".id AS "id" 
						FROM asset.copy AS "acp"  
						INNER JOIN asset.call_number AS "acn" 
						ON ( "acn".id = "acp".call_number )   
						INNER JOIN biblio.record_entry AS "bre" 
						ON ( "bre".id = "acn".record AND  "bre".id = bib_record_id ) ) 
						AND "ahr".hold_type IN ('C') 
					) 
				) 
				OR 	(
				 		( "ahr".target IN (SELECT  "acn".id AS "id" 
				 			FROM asset.call_number AS "acn"  
				 			INNER JOIN biblio.record_entry AS "bre" 
				 			ON ( "bre".id = "acn".record AND  "bre".id = bib_record_id ) ) 
				 			AND "ahr".hold_type = 'V' 
				 		) 
				 	) 
				OR  (
						( "ahr".target = bib_record_id AND "ahr".hold_type = 'T' ) 
					) 
			) 
			AND "ahr".cancel_time IS NULL 
			AND "ahr".fulfillment_time IS NULL 
		);
	RETURN the_count;
    END IF;

END;
$$;


ALTER FUNCTION action.get_hold_count(bib_record_id integer) OWNER TO evergreen;

--
-- Name: get_hold_queue_status(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION get_hold_queue_status(integer) RETURNS TABLE(id integer, cut_in_line boolean, request_time timestamp with time zone)
    LANGUAGE sql STABLE
    AS $_$
WITH holds(holdid) AS 
( SELECT acm.hold FROM action.hold_copy_map acm 
  JOIN action.hold_copy_map acm2 USING(target_copy) 
  WHERE acm2.hold=$1) 
  SELECT id, cut_in_line, request_time FROM action.hold_request 
  WHERE id IN (SELECT holdid FROM holds) 
  ORDER BY coalesce(cut_in_line, false ) DESC, request_time; 
$_$;


ALTER FUNCTION action.get_hold_queue_status(integer) OWNER TO evergreen;

--
-- Name: get_hold_queue_status_by_id(integer); Type: FUNCTION; Schema: action; Owner: postgres
--

CREATE FUNCTION get_hold_queue_status_by_id(integer) RETURNS TABLE(id integer, cut_in_line boolean, request_time timestamp with time zone)
    LANGUAGE sql STABLE
    AS $_$
WITH holds(holdid) AS 
( SELECT acm.hold FROM action.hold_copy_map acm 
  JOIN action.hold_copy_map acm2 USING(target_copy) 
  WHERE acm2.hold=$1) 
  SELECT id, cut_in_line, request_time FROM action.hold_request 
  WHERE id IN (SELECT holdid FROM holds) 
  ORDER BY coalesce(cut_in_line, false ) DESC, request_time; 
$_$;


ALTER FUNCTION action.get_hold_queue_status_by_id(integer) OWNER TO postgres;

--
-- Name: hold_copy_calculated_proximity(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer DEFAULT NULL::integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    aoupa           actor.org_unit_proximity_adjustment%ROWTYPE;
    ahr             action.hold_request%ROWTYPE;
    acp             asset.copy%ROWTYPE;
    acn             asset.call_number%ROWTYPE;
    acl             asset.copy_location%ROWTYPE;
    baseline_prox   NUMERIC;

    icl_list        INT[];
    iol_list        INT[];
    isl_list        INT[];
    hpl_list        INT[];
    hrl_list        INT[];

BEGIN

    SELECT * INTO ahr FROM action.hold_request WHERE id = ahr_id;
    SELECT * INTO acp FROM asset.copy WHERE id = acp_id;
    SELECT * INTO acn FROM asset.call_number WHERE id = acp.call_number;
    SELECT * INTO acl FROM asset.copy_location WHERE id = acp.location;

    IF copy_context_ou IS NULL THEN
        copy_context_ou := acp.circ_lib;
    END IF;

    -- First, gather the baseline proximity of "here" to pickup lib
    SELECT prox INTO baseline_prox FROM actor.org_unit_proximity WHERE from_org = copy_context_ou AND to_org = ahr.pickup_lib;

    -- Find any absolute adjustments, and set the baseline prox to that
    SELECT  adj.* INTO aoupa
      FROM  actor.org_unit_proximity_adjustment adj
            LEFT JOIN actor.org_unit_ancestors_distance(copy_context_ou) acp_cl ON (acp_cl.id = adj.item_circ_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(acn.owning_lib) acn_ol ON (acn_ol.id = adj.item_owning_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(acl.owning_lib) acl_ol ON (acn_ol.id = adj.copy_location)
            LEFT JOIN actor.org_unit_ancestors_distance(ahr.pickup_lib) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(ahr.request_lib) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
      WHERE (adj.circ_mod IS NULL OR adj.circ_mod = acp.circ_modifier) AND
        absolute_adjustment AND
        COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
      ORDER BY
            COALESCE(acp_cl.distance,999)
                + COALESCE(acn_ol.distance,999)
                + COALESCE(acl_ol.distance,999)
                + COALESCE(ahr_pl.distance,999)
                + COALESCE(ahr_rl.distance,999),
            adj.pos
      LIMIT 1;

    IF FOUND THEN
        baseline_prox := aoupa.prox_adjustment;
    END IF;

    -- Now find any relative adjustments, and change the baseline prox based on them
    FOR aoupa IN
        SELECT  adj.* 
          FROM  actor.org_unit_proximity_adjustment adj
                LEFT JOIN actor.org_unit_ancestors_distance(copy_context_ou) acp_cl ON (acp_cl.id = adj.item_circ_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(acn.owning_lib) acn_ol ON (acn_ol.id = adj.item_owning_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(acl.owning_lib) acl_ol ON (acn_ol.id = adj.copy_location)
                LEFT JOIN actor.org_unit_ancestors_distance(ahr.pickup_lib) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(ahr.request_lib) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
          WHERE (adj.circ_mod IS NULL OR adj.circ_mod = acp.circ_modifier) AND
            NOT absolute_adjustment AND
            COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
    LOOP
        baseline_prox := baseline_prox + aoupa.prox_adjustment;
    END LOOP;

    RETURN baseline_prox;
END;
$$;


ALTER FUNCTION action.hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer) OWNER TO evergreen;

--
-- Name: hold_copy_calculated_proximity_update(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_copy_calculated_proximity_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.proximity := action.hold_copy_calculated_proximity(NEW.hold,NEW.target_copy);
    RETURN NEW;
END;
$$;


ALTER FUNCTION action.hold_copy_calculated_proximity_update() OWNER TO evergreen;

--
-- Name: hold_request_clear_map(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_request_clear_map() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM action.hold_copy_map WHERE hold = NEW.id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION action.hold_request_clear_map() OWNER TO evergreen;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, FALSE);
$_$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) RETURNS SETOF matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    matchpoint_id        INT;
    user_object        actor.usr%ROWTYPE;
    age_protect_object    config.rule_age_hold_protect%ROWTYPE;
    standing_penalty    config.standing_penalty%ROWTYPE;
    transit_range_ou_type    actor.org_unit_type%ROWTYPE;
    transit_source        actor.org_unit%ROWTYPE;
    item_object        asset.copy%ROWTYPE;
    item_cn_object     asset.call_number%ROWTYPE;
    item_status_object  config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    ou_skip              actor.org_unit_setting%ROWTYPE;
    result            action.matrix_test_result;
    hold_test        config.hold_matrix_matchpoint%ROWTYPE;
    use_active_date   TEXT;
    age_protect_date  TIMESTAMP WITH TIME ZONE;
    hold_count        INT;
    hold_transit_prox    INT;
    frozen_hold_count    INT;
    context_org_list    INT[];
    done            BOOL := FALSE;
    hold_penalty TEXT;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;
    SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( pickup_ou );

    result.success := TRUE;

    -- The HOLD penalty block only applies to new holds.
    -- The CAPTURE penalty block applies to existing holds.
    hold_penalty := 'HOLD';
    IF retargetting THEN
        hold_penalty := 'CAPTURE';
    END IF;

    -- Fail if we couldn't find a user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_object * FROM asset.copy WHERE id = match_item;

    -- Fail if we couldn't find a copy
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO matchpoint_id action.find_hold_matrix_matchpoint(pickup_ou, request_ou, match_item, match_user, match_requestor);
    result.matchpoint := matchpoint_id;

    SELECT INTO ou_skip * FROM actor.org_unit_setting WHERE name = 'circ.holds.target_skip_me' AND org_unit = item_object.circ_lib;

    -- Fail if the circ_lib for the item has circ.holds.target_skip_me set to true
    IF ou_skip.id IS NOT NULL AND ou_skip.value = 'true' THEN
        result.fail_part := 'circ.holds.target_skip_me';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Fail if user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_cn_object * FROM asset.call_number WHERE id = item_object.call_number;
    SELECT INTO item_status_object * FROM config.copy_status WHERE id = item_object.status;
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;

    -- Fail if we couldn't find any matchpoint (requires a default)
    IF matchpoint_id IS NULL THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO hold_test * FROM config.hold_matrix_matchpoint WHERE id = matchpoint_id;

    IF hold_test.holdable IS FALSE THEN
        result.fail_part := 'config.hold_matrix_test.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_object.holdable IS FALSE THEN
        result.fail_part := 'item.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_status_object.holdable IS FALSE THEN
        result.fail_part := 'status.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_location_object.holdable IS FALSE THEN
        result.fail_part := 'location.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF hold_test.transit_range IS NOT NULL THEN
        SELECT INTO transit_range_ou_type * FROM actor.org_unit_type WHERE id = hold_test.transit_range;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO transit_source ou.* FROM actor.org_unit ou JOIN asset.call_number cn ON (cn.owning_lib = ou.id) WHERE cn.id = item_object.call_number;
        ELSE
            SELECT INTO transit_source * FROM actor.org_unit WHERE id = item_object.circ_lib;
        END IF;

        PERFORM * FROM actor.org_unit_descendants( transit_source.id, transit_range_ou_type.depth ) WHERE id = pickup_ou;

        IF NOT FOUND THEN
            result.fail_part := 'transit_range';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;
 
    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND csp.block_list LIKE '%' || hold_penalty || '%' LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    IF hold_test.stop_blocked_user IS TRUE THEN
        FOR standing_penalty IN
            SELECT  DISTINCT csp.*
              FROM  actor.usr_standing_penalty usp
                    JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
              WHERE usr = match_user
                    AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                    AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                    AND csp.block_list LIKE '%CIRC%' LOOP
    
            result.fail_part := standing_penalty.name;
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END LOOP;
    END IF;

    IF hold_test.max_holds IS NOT NULL AND NOT retargetting THEN
        SELECT    INTO hold_count COUNT(*)
          FROM    action.hold_request
          WHERE    usr = match_user
            AND fulfillment_time IS NULL
            AND cancel_time IS NULL
            AND CASE WHEN hold_test.include_frozen_holds THEN TRUE ELSE frozen IS FALSE END;

        IF hold_count >= hold_test.max_holds THEN
            result.fail_part := 'config.hold_matrix_test.max_holds';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    IF item_object.age_protect IS NOT NULL THEN
        SELECT INTO age_protect_object * FROM config.rule_age_hold_protect WHERE id = item_object.age_protect;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_cn_object.owning_lib);
        ELSE
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_object.circ_lib);
        END IF;
        IF use_active_date = 'true' THEN
            age_protect_date := COALESCE(item_object.active_date, NOW());
        ELSE
            age_protect_date := item_object.create_date;
        END IF;
        IF age_protect_date + age_protect_object.age > NOW() THEN
            IF hold_test.distance_is_from_owner THEN
                SELECT INTO item_cn_object * FROM asset.call_number WHERE id = item_object.call_number;
                SELECT INTO hold_transit_prox prox FROM actor.org_unit_proximity WHERE from_org = item_cn_object.owning_lib AND to_org = pickup_ou;
            ELSE
                SELECT INTO hold_transit_prox prox FROM actor.org_unit_proximity WHERE from_org = item_object.circ_lib AND to_org = pickup_ou;
            END IF;

            IF hold_transit_prox > age_protect_object.prox THEN
                result.fail_part := 'config.rule_age_hold_protect.prox';
                result.success := FALSE;
                done := TRUE;
                RETURN NEXT result;
            END IF;
        END IF;
    END IF;

    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) OWNER TO evergreen;

--
-- Name: hold_retarget_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, TRUE );
$_$;


ALTER FUNCTION action.hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: insert_hold_row(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION insert_hold_row() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$
BEGIN

                INSERT INTO action.hold_count (record_entry_id, holds_count) values(new.id, 0);
                
                RETURN NULL;
END
$$;


ALTER FUNCTION action.insert_hold_row() OWNER TO evergreen;

--
-- Name: item_user_circ_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION item_user_circ_test(integer, bigint, integer) RETURNS SETOF circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION action.item_user_circ_test(integer, bigint, integer) OWNER TO evergreen;

--
-- Name: item_user_circ_test(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF circ_matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object             actor.usr%ROWTYPE;
    standing_penalty        config.standing_penalty%ROWTYPE;
    item_object             asset.copy%ROWTYPE;
    item_status_object      config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    result                  action.circ_matrix_test_result;
    circ_test               action.found_circ_matrix_matchpoint;
    circ_matchpoint         config.circ_matrix_matchpoint%ROWTYPE;
    circ_limit_set          config.circ_limit_set%ROWTYPE;
    hold_ratio              action.hold_stats%ROWTYPE;
    penalty_type            TEXT;
    items_out               INT;
    context_org_list        INT[];
    done                    BOOL := FALSE;
BEGIN
    -- Assume success unless we hit a failure condition
    result.success := TRUE;

    -- Need user info to look up matchpoints
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user AND NOT deleted;

    -- (Insta)Fail if we couldn't find the user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Need item info to look up matchpoints
    SELECT INTO item_object * FROM asset.copy WHERE id = match_item AND NOT deleted;

    -- (Insta)Fail if we couldn't find the item
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO circ_test * FROM action.find_circ_matrix_matchpoint(circ_ou, item_object, user_object, renewal);

    circ_matchpoint             := circ_test.matchpoint;
    result.matchpoint           := circ_matchpoint.id;
    result.circulate            := circ_matchpoint.circulate;
    result.duration_rule        := circ_matchpoint.duration_rule;
    result.recurring_fine_rule  := circ_matchpoint.recurring_fine_rule;
    result.max_fine_rule        := circ_matchpoint.max_fine_rule;
    result.hard_due_date        := circ_matchpoint.hard_due_date;
    result.renewals             := circ_matchpoint.renewals;
    result.grace_period         := circ_matchpoint.grace_period;
    result.buildrows            := circ_test.buildrows;

    -- (Insta)Fail if we couldn't find a matchpoint
    IF circ_test.success = false THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- All failures before this point are non-recoverable
    -- Below this point are possibly overridable failures

    -- Fail if the user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate
    IF item_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item isn't in a circulateable status on a non-renewal
    IF NOT renewal AND item_object.status NOT IN ( 0, 7, 8 ) THEN
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    -- Alternately, fail if the item isn't checked out on a renewal
    ELSIF renewal AND item_object.status <> 1 THEN
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate because of the shelving location
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;
    IF item_location_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy_location.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Use Circ OU for penalties and such
    SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( circ_ou );

    IF renewal THEN
        penalty_type = '%RENEW%';
    ELSE
        penalty_type = '%CIRC%';
    END IF;

    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND csp.block_list LIKE penalty_type LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    -- Fail if the test is set to hard non-circulating
    IF circ_matchpoint.circulate IS FALSE THEN
        result.fail_part := 'config.circ_matrix_test.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the total copy-hold ratio is too low
    IF circ_matchpoint.total_copy_hold_ratio IS NOT NULL THEN
        SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
        IF hold_ratio.total_copy_ratio IS NOT NULL AND hold_ratio.total_copy_ratio < circ_matchpoint.total_copy_hold_ratio THEN
            result.fail_part := 'config.circ_matrix_test.total_copy_hold_ratio';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    -- Fail if the available copy-hold ratio is too low
    IF circ_matchpoint.available_copy_hold_ratio IS NOT NULL THEN
        IF hold_ratio.hold_count IS NULL THEN
            SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
        END IF;
        IF hold_ratio.available_copy_ratio IS NOT NULL AND hold_ratio.available_copy_ratio < circ_matchpoint.available_copy_hold_ratio THEN
            result.fail_part := 'config.circ_matrix_test.available_copy_hold_ratio';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    -- Fail if the user has too many items out by defined limit sets
    FOR circ_limit_set IN SELECT ccls.* FROM config.circ_limit_set ccls
      JOIN config.circ_matrix_limit_set_map ccmlsm ON ccmlsm.limit_set = ccls.id
      WHERE ccmlsm.active AND ( ccmlsm.matchpoint = circ_matchpoint.id OR
        ( ccmlsm.matchpoint IN (SELECT * FROM unnest(result.buildrows)) AND ccmlsm.fallthrough )
        ) LOOP
            IF circ_limit_set.items_out > 0 AND NOT renewal THEN
                SELECT INTO context_org_list ARRAY_AGG(aou.id)
                  FROM actor.org_unit_full_path( circ_ou ) aou
                    JOIN actor.org_unit_type aout ON aou.ou_type = aout.id
                  WHERE aout.depth >= circ_limit_set.depth;
                IF circ_limit_set.global THEN
                    WITH RECURSIVE descendant_depth AS (
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                        WHERE ou.id IN (SELECT * FROM unnest(context_org_list))
                            UNION
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                            JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
                    ) SELECT INTO context_org_list ARRAY_AGG(ou.id) FROM actor.org_unit ou JOIN descendant_depth USING (id);
                END IF;
                SELECT INTO items_out COUNT(DISTINCT circ.id)
                  FROM action.circulation circ
                    JOIN asset.copy copy ON (copy.id = circ.target_copy)
                    LEFT JOIN action.circulation_limit_group_map aclgm ON (circ.id = aclgm.circ)
                  WHERE circ.usr = match_user
                    AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                    AND circ.checkin_time IS NULL
                    AND (circ.stop_fines IN ('MAXFINES','LONGOVERDUE') OR circ.stop_fines IS NULL)
                    AND (copy.circ_modifier IN (SELECT circ_mod FROM config.circ_limit_set_circ_mod_map WHERE limit_set = circ_limit_set.id)
                        OR copy.location IN (SELECT copy_loc FROM config.circ_limit_set_copy_loc_map WHERE limit_set = circ_limit_set.id)
                        OR aclgm.limit_group IN (SELECT limit_group FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id)
                    );
                IF items_out >= circ_limit_set.items_out THEN
                    result.fail_part := 'config.circ_matrix_circ_mod_test';
                    result.success := FALSE;
                    done := TRUE;
                    RETURN NEXT result;
                END IF;
            END IF;
            SELECT INTO result.limit_groups result.limit_groups || ARRAY_AGG(limit_group) FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id AND NOT check_only;
    END LOOP;

    -- If we passed everything, return the successful matchpoint
    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO evergreen;

--
-- Name: item_user_renew_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION item_user_renew_test(integer, bigint, integer) RETURNS SETOF circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, TRUE );
$_$;


ALTER FUNCTION action.item_user_renew_test(integer, bigint, integer) OWNER TO evergreen;

--
-- Name: link_circ_limit_groups(bigint, integer[]); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION link_circ_limit_groups(bigint, integer[]) RETURNS void
    LANGUAGE sql
    AS $_$
    INSERT INTO action.circulation_limit_group_map(circ, limit_group) SELECT $1, id FROM config.circ_limit_group WHERE id IN (SELECT * FROM UNNEST($2));
$_$;


ALTER FUNCTION action.link_circ_limit_groups(bigint, integer[]) OWNER TO evergreen;

--
-- Name: modify_hold_count(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION modify_hold_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- on delete, decrement the hold_count
-- on insert, increment the hold count
-- treat the update as delete + insert
DECLARE
	oldrecord BIGINT;
	newrecord BIGINT;
	newholdscount INTEGER;
	hold_type TEXT;
	oldksip BOOLEAN;
	newskip BOOLEAN;
	insert_update BOOLEAN;
	update_delete BOOLEAN;
BEGIN
	IF TG_OP = 'UPDATE' 
		AND NOT (NEW.cancel_time IS DISTINCT FROM OLD.cancel_time 
			OR NEW.fulfillment_time IS DISTINCT FROM OLD.fulfillment_time) 
		AND (NEW.target = OLD.target)
	THEN
		-- nothing to do if we don't update the properties that lead to the hold count changes
		RETURN NULL;
	END IF;

	-- skip if fulfillment_time or cancel_time is not null
	insert_update = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE' ) AND (NEW.fulfillment_time IS NULL AND NEW.cancel_time IS NULL);
	update_delete = (TG_OP = 'DELETE' OR TG_OP = 'UPDATE') AND (OLD.fulfillment_time IS NULL AND OLD.cancel_time IS NULL);

	IF TG_OP = 'DELETE' THEN
		hold_type = OLD.hold_type;
	ELSE
		hold_type = NEW.hold_type;
	END IF;
	
	CASE (hold_type)
		WHEN 'T' THEN
			IF insert_update THEN	
				newrecord = NEW.target;
			END IF;
			IF update_delete THEN
				oldrecord = OLD.target;
			END IF;
		WHEN 'V' THEN
			IF insert_update THEN
				SELECT INTO newrecord acn.record FROM asset.call_number acn WHERE acn.id = NEW.target;
			END IF;
			IF update_delete THEN
				SELECT INTO oldrecord acn.record FROM asset.call_number acn WHERE acn.id = OLD.target;
			END IF;			
		WHEN 'C' THEN
			IF insert_update THEN
				SELECT INTO newrecord acn.record FROM asset.call_number acn JOIN asset.copy acp ON (acn.id = acp.call_number) WHERE acp.id = NEW.target;
			END IF;
			IF update_delete THEN
				SELECT INTO oldrecord acn.record FROM asset.call_number acn JOIN asset.copy acp ON (acn.id = acp.call_number) WHERE acp.id = OLD.target;
			END IF;
	END CASE;

	IF insert_update
	THEN
--		RAISE NOTICE 'RECORD ENTRY TO UPDATE (+1) % HOLD TYPE %', newrecord, hold_type;
		UPDATE action.hold_count SET holds_count = holds_count + 1 WHERE record_entry_id = newrecord RETURNING holds_count INTO newholdscount;
--		RAISE NOTICE 'NEW HOLDS COUNT FOR %: %', newrecord, newholdscount;
	END IF;
	IF update_delete
	THEN
--		RAISE NOTICE 'RECORD ENTRY TO UPDATE (-1) % HOLD TYPE %', oldrecord, hold_type;
		UPDATE action.hold_count SET holds_count = holds_count - 1 WHERE record_entry_id = oldrecord RETURNING holds_count INTO newholdscount;
--		RAISE NOTICE 'NEW HOLDS COUNT FOR %: %', oldrecord, newholdscount;
	END IF;

	RETURN NULL;
		
END;
$$;


ALTER FUNCTION action.modify_hold_count() OWNER TO evergreen;

--
-- Name: purge_circulations(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION purge_circulations() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    usr_keep_age    actor.usr_setting%ROWTYPE;
    usr_keep_start  actor.usr_setting%ROWTYPE;
    org_keep_age    INTERVAL;
    org_use_last    BOOL = false;
    org_age_is_min  BOOL = false;
    org_keep_count  INT;

    keep_age        INTERVAL;

    target_acp      RECORD;
    circ_chain_head action.circulation%ROWTYPE;
    circ_chain_tail action.circulation%ROWTYPE;

    count_purged    INT;
    num_incomplete  INT;

    last_finished   TIMESTAMP WITH TIME ZONE;
BEGIN

    count_purged := 0;

    SELECT value::INTERVAL INTO org_keep_age FROM config.global_flag WHERE name = 'history.circ.retention_age' AND enabled;

    SELECT value::INT INTO org_keep_count FROM config.global_flag WHERE name = 'history.circ.retention_count' AND enabled;
    IF org_keep_count IS NULL THEN
        RETURN count_purged; -- Gimme a count to keep, or I keep them all, forever
    END IF;

    SELECT enabled INTO org_use_last FROM config.global_flag WHERE name = 'history.circ.retention_uses_last_finished';
    SELECT enabled INTO org_age_is_min FROM config.global_flag WHERE name = 'history.circ.retention_age_is_min';

    -- First, find copies with more than keep_count non-renewal circs
    FOR target_acp IN
        SELECT  target_copy,
                COUNT(*) AS total_real_circs
          FROM  action.circulation
          WHERE parent_circ IS NULL
                AND xact_finish IS NOT NULL
          GROUP BY target_copy
          HAVING COUNT(*) > org_keep_count
    LOOP
        -- And, for those, select circs that are finished and older than keep_age
        FOR circ_chain_head IN
            -- For reference, the subquery uses a window function to order the circs newest to oldest and number them
            -- The outer query then uses that information to skip the most recent set the library wants to keep
            -- End result is we don't care what order they come out in, as they are all potentials for deletion.
            SELECT ac.* FROM action.circulation ac JOIN (
              SELECT  rank() OVER (ORDER BY xact_start DESC), ac.id
                FROM  action.circulation ac
                WHERE ac.target_copy = target_acp.target_copy
                  AND ac.parent_circ IS NULL
                ORDER BY ac.xact_start ) ranked USING (id)
                WHERE ranked.rank > org_keep_count
        LOOP

            SELECT * INTO circ_chain_tail FROM action.circ_chain(circ_chain_head.id) ORDER BY xact_start DESC LIMIT 1;
            SELECT COUNT(CASE WHEN xact_finish IS NULL THEN 1 ELSE NULL END), MAX(xact_finish) INTO num_incomplete, last_finished FROM action.circ_chain(circ_chain_head.id);
            CONTINUE WHEN circ_chain_tail.xact_finish IS NULL OR num_incomplete > 0;

            IF NOT org_use_last THEN
                last_finished := circ_chain_tail.xact_finish;
            END IF;

            -- Now get the user settings, if any, to block purging if the user wants to keep more circs
            usr_keep_age.value := NULL;
            SELECT * INTO usr_keep_age FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_age';

            usr_keep_start.value := NULL;
            SELECT * INTO usr_keep_start FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_start';

            IF usr_keep_age.value IS NOT NULL AND usr_keep_start.value IS NOT NULL THEN
                IF oils_json_to_text(usr_keep_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ) THEN
                    keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
                ELSE
                    keep_age := oils_json_to_text(usr_keep_age.value)::INTERVAL;
                END IF;
            ELSIF usr_keep_start.value IS NOT NULL THEN
                keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
            ELSE
                keep_age := COALESCE( org_keep_age, '2000 years'::INTERVAL );
            END IF;

            IF org_age_is_min THEN
                keep_age := GREATEST( keep_age, org_keep_age );
            END IF;

            CONTINUE WHEN AGE(NOW(), last_finished) < keep_age;

            -- We've passed the purging tests, purge the circ chain starting at the end
            -- A trigger should auto-purge the rest of the chain.
            DELETE FROM action.circulation WHERE id = circ_chain_tail.id;

            count_purged := count_purged + 1;

        END LOOP;
    END LOOP;

    return count_purged;
END;
$$;


ALTER FUNCTION action.purge_circulations() OWNER TO evergreen;

--
-- Name: purge_circulations_custom(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    usr_keep_age    actor.usr_setting%ROWTYPE;
    usr_keep_start  actor.usr_setting%ROWTYPE;
    org_keep_age    INTERVAL;
    org_use_last    BOOL = false;
    org_age_is_min  BOOL = false;
    org_keep_count  INT;

    keep_age        INTERVAL;

    target_acp      RECORD;
    circ_chain_head action.circulation%ROWTYPE;
    circ_chain_tail action.circulation%ROWTYPE;

    count_purged    INT;
    num_incomplete  INT;

    last_finished   TIMESTAMP WITH TIME ZONE;
    cmd_main_loop_item int;
    cmd_count_kept int;
    time_start timestamp with time zone;
BEGIN
    time_start = clock_timestamp();
    count_purged := 0;
    cmd_count_kept := 0;
    cmd_main_loop_item := 0;

    SELECT value::INTERVAL INTO org_keep_age FROM config.global_flag WHERE name = 'history.circ.retention_age' AND enabled;
    raise debug 'in_time_start=%; in_time_end=%; org_keep_age=%',in_time_start,in_time_end,org_keep_age;

    SELECT value::INT INTO org_keep_count FROM config.global_flag WHERE name = 'history.circ.retention_count' AND enabled;
    IF org_keep_count IS NULL THEN
        RETURN count_purged; -- Gimme a count to keep, or I keep them all, forever
    END IF;

    SELECT enabled INTO org_use_last FROM config.global_flag WHERE name = 'history.circ.retention_uses_last_finished';
    SELECT enabled INTO org_age_is_min FROM config.global_flag WHERE name = 'history.circ.retention_age_is_min';

        -- And, for those, select circs that are finished and older than keep_age
        FOR circ_chain_head IN
            SELECT ac.* FROM action.circulation ac
                WHERE 1=1
                  AND ac.parent_circ IS NULL
                  AND xact_finish < now() - coalesce(org_keep_age,'2000 years'::interval)
                  AND xact_finish between in_time_start and in_time_end
        LOOP
            cmd_main_loop_item := cmd_main_loop_item + 1;
            if (cmd_main_loop_item - 1) % 1000 = 0 then
                raise debug '% Main loop item %...',(extract(epoch from (clock_timestamp()-time_start))/60)::int,cmd_main_loop_item;
            end if;

            SELECT * INTO circ_chain_tail FROM action.circ_chain(circ_chain_head.id) ORDER BY xact_start DESC LIMIT 1;
            SELECT COUNT(CASE WHEN xact_finish IS NULL THEN 1 ELSE NULL END), MAX(xact_finish) INTO num_incomplete, last_finished FROM action.circ_chain(circ_chain_head.id);
            CONTINUE WHEN circ_chain_tail.xact_finish IS NULL OR num_incomplete > 0;

            IF NOT org_use_last THEN
                last_finished := circ_chain_tail.xact_finish;
            END IF;

            -- Now get the user settings, if any, to block purging if the user wants to keep more circs
            usr_keep_age.value := NULL;
            SELECT * INTO usr_keep_age FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_age';

            usr_keep_start.value := NULL;
            SELECT * INTO usr_keep_start FROM actor.usr_setting WHERE usr = circ_chain_head.usr AND name = 'history.circ.retention_start';

            IF usr_keep_age.value IS NOT NULL AND usr_keep_start.value IS NOT NULL THEN
                IF oils_json_to_text(usr_keep_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ) THEN
                    keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
                ELSE
                    keep_age := oils_json_to_text(usr_keep_age.value)::INTERVAL;
                END IF;
            ELSIF usr_keep_start.value IS NOT NULL THEN
                keep_age := AGE(NOW(), oils_json_to_text(usr_keep_start.value)::TIMESTAMPTZ);
            ELSE
                keep_age := COALESCE( org_keep_age, '2000 years'::INTERVAL );
            END IF;

            IF org_age_is_min THEN
                keep_age := GREATEST( keep_age, org_keep_age );
            END IF;

           if AGE(NOW(), last_finished) < keep_age then
               cmd_count_kept := cmd_count_kept + 1;
           end if;
           CONTINUE WHEN AGE(NOW(), last_finished) < keep_age;

            -- We've passed the purging tests, purge the circ chain starting at the end
            -- A trigger should auto-purge the rest of the chain.
            DELETE FROM action.circulation WHERE id = circ_chain_tail.id;

            count_purged := count_purged + 1;
            if count_purged % 1000 = 0 then
               raise debug 'Purged Chains %', count_purged;
            end if;
        END LOOP;

    raise debug '% Done. Purged Chains=% Kept Chains=%',(extract(epoch from (clock_timestamp()-time_start))/60)::int,count_purged,cmd_count_kept;
    return count_purged;
END;
$$;


ALTER FUNCTION action.purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) OWNER TO evergreen;

--
-- Name: FUNCTION purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone); Type: COMMENT; Schema: action; Owner: evergreen
--

COMMENT ON FUNCTION purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) IS 'KCLS custom version of action.purge_circulations. Achieves the same results much more quickly by eliminating consideration of global_flag value "history.circ.retention_count", and targeting a specific date range.';


--
-- Name: push_circ_due_time(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION push_circ_due_time() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (EXTRACT(EPOCH FROM NEW.duration)::INT % EXTRACT(EPOCH FROM '1 day'::INTERVAL)::INT) = 0 THEN
        NEW.due_date = (NEW.due_date::DATE + '1 day'::INTERVAL - '1 second'::INTERVAL)::TIMESTAMPTZ;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION action.push_circ_due_time() OWNER TO evergreen;

--
-- Name: summarize_circ_chain(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION summarize_circ_chain(ctx_circ_id bigint) RETURNS circ_chain_summary
    LANGUAGE plpgsql
    AS $$

DECLARE

    -- first circ in the chain
    circ_0 action.circulation%ROWTYPE;

    -- last circ in the chain
    circ_n action.circulation%ROWTYPE;

    -- circ chain under construction
    chain action.circ_chain_summary;
    tmp_circ action.circulation%ROWTYPE;

BEGIN
    
    chain.num_circs := 0;
    FOR tmp_circ IN SELECT * FROM action.circ_chain(ctx_circ_id) LOOP

        IF chain.num_circs = 0 THEN
            circ_0 := tmp_circ;
        END IF;

        chain.num_circs := chain.num_circs + 1;
        circ_n := tmp_circ;
    END LOOP;

    chain.start_time := circ_0.xact_start;
    chain.last_stop_fines := circ_n.stop_fines;
    chain.last_stop_fines_time := circ_n.stop_fines_time;
    chain.last_checkin_time := circ_n.checkin_time;
    chain.last_checkin_scan_time := circ_n.checkin_scan_time;
    SELECT INTO chain.checkout_workstation name FROM actor.workstation WHERE id = circ_0.workstation;
    SELECT INTO chain.last_checkin_workstation name FROM actor.workstation WHERE id = circ_n.checkin_workstation;

    IF chain.num_circs > 1 THEN
        chain.last_renewal_time := circ_n.xact_start;
        SELECT INTO chain.last_renewal_workstation name FROM actor.workstation WHERE id = circ_n.workstation;
    END IF;

    RETURN chain;

END;
$$;


ALTER FUNCTION action.summarize_circ_chain(ctx_circ_id bigint) OWNER TO evergreen;

--
-- Name: survey_response_answer_date_fixup(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION survey_response_answer_date_fixup() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	NEW.answer_date := NOW();
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.survey_response_answer_date_fixup() OWNER TO evergreen;

--
-- Name: temp_hold_updates(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION temp_hold_updates() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$
BEGIN
	INSERT INTO public.temp_holds_table (id, target, hold_type) VALUES (NEW.id, NEW.target, NEW.hold_type);
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.temp_hold_updates() OWNER TO evergreen;

--
-- Name: usr_visible_circ_copies(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION usr_visible_circ_copies(integer) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT DISTINCT(target_copy) FROM action.usr_visible_circs($1)
$_$;


ALTER FUNCTION action.usr_visible_circ_copies(integer) OWNER TO evergreen;

--
-- Name: usr_visible_circs(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION usr_visible_circs(usr_id integer) RETURNS SETOF circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    c               action.circulation%ROWTYPE;
    view_age        INTERVAL;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_start';

    IF usr_view_age.value IS NOT NULL AND usr_view_start.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSIF usr_view_start.value IS NOT NULL THEN
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    ELSE
        -- User did not opt in
        RETURN;
    END IF;

    FOR c IN
        SELECT  *
          FROM  action.circulation
          WHERE usr = usr_id
                AND parent_circ IS NULL
                AND xact_start > NOW() - view_age
          ORDER BY xact_start DESC
    LOOP
        RETURN NEXT c;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_circs(usr_id integer) OWNER TO evergreen;

--
-- Name: hold_request; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request (
    id integer NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    requestor integer NOT NULL,
    usr integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT false NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer,
    CONSTRAINT sms_check CHECK (((sms_notify IS NULL) OR (sms_carrier IS NOT NULL)))
);


ALTER TABLE action.hold_request OWNER TO evergreen;

--
-- Name: usr_visible_holds(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION usr_visible_holds(usr_id integer) RETURNS SETOF hold_request
    LANGUAGE plpgsql
    AS $$
DECLARE
    h               action.hold_request%ROWTYPE;
    view_age        INTERVAL;
    view_count      INT;
    usr_view_count  actor.usr_setting%ROWTYPE;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_count FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_count';
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_start';

    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND fulfillment_time IS NULL
                AND cancel_time IS NULL
          ORDER BY request_time DESC
    LOOP
        RETURN NEXT h;
    END LOOP;

    IF usr_view_start.value IS NULL THEN
        RETURN;
    END IF;

    IF usr_view_age.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSE
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    END IF;

    IF usr_view_count.value IS NOT NULL THEN
        view_count := oils_json_to_text(usr_view_count.value)::INT;
    ELSE
        view_count := 1000;
    END IF;

    -- show some fulfilled/canceled holds
    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND ( fulfillment_time IS NOT NULL OR cancel_time IS NOT NULL )
                AND request_time > NOW() - view_age
          ORDER BY request_time DESC
          LIMIT view_count
    LOOP
        RETURN NEXT h;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_holds(usr_id integer) OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: address_alert; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE address_alert (
    id integer NOT NULL,
    owner integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    match_all boolean DEFAULT true NOT NULL,
    alert_message text NOT NULL,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    mailing_address boolean DEFAULT false NOT NULL,
    billing_address boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.address_alert OWNER TO evergreen;

--
-- Name: address_alert_matches(integer, text, text, text, text, text, text, text, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean DEFAULT false, billing_address boolean DEFAULT false) RETURNS SETOF address_alert
    LANGUAGE sql
    AS $_$

SELECT *
FROM actor.address_alert
WHERE
    active
    AND owner IN (SELECT id FROM actor.org_unit_ancestors($1)) 
    AND (
        (NOT mailing_address AND NOT billing_address)
        OR (mailing_address AND $9)
        OR (billing_address AND $10)
    )
    AND (
            (
                match_all
                AND COALESCE($2, '') ~* COALESCE(street1,   '.*')
                AND COALESCE($3, '') ~* COALESCE(street2,   '.*')
                AND COALESCE($4, '') ~* COALESCE(city,      '.*')
                AND COALESCE($5, '') ~* COALESCE(county,    '.*')
                AND COALESCE($6, '') ~* COALESCE(state,     '.*')
                AND COALESCE($7, '') ~* COALESCE(country,   '.*')
                AND COALESCE($8, '') ~* COALESCE(post_code, '.*')
            ) OR (
                NOT match_all 
                AND (  
                       $2 ~* street1
                    OR $3 ~* street2
                    OR $4 ~* city
                    OR $5 ~* county
                    OR $6 ~* state
                    OR $7 ~* country
                    OR $8 ~* post_code
                )
            )
        )
    ORDER BY actor.org_unit_proximity(owner, $1)
$_$;


ALTER FUNCTION actor.address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean, billing_address boolean) OWNER TO evergreen;

--
-- Name: approve_pending_address(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION approve_pending_address(pending_id integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_id INT;
BEGIN
    SELECT INTO old_id replaces FROM actor.usr_address where id = pending_id;
    IF old_id IS NULL THEN
        UPDATE actor.usr_address SET pending = 'f' WHERE id = pending_id;
        RETURN pending_id;
    END IF;
    -- address replaces an existing address
    DELETE FROM actor.usr_address WHERE id = -old_id;
    UPDATE actor.usr_address SET id = -id WHERE id = old_id;
    UPDATE actor.usr_address SET replaces = NULL, id = old_id, pending = 'f' WHERE id = pending_id;
    RETURN old_id;
END
$$;


ALTER FUNCTION actor.approve_pending_address(pending_id integer) OWNER TO evergreen;

--
-- Name: FUNCTION approve_pending_address(pending_id integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION approve_pending_address(pending_id integer) IS '
/**
 * Replaces an address with a pending address.  This is done by giving the pending 
 * address the ID of the old address.  The replaced address is retained with -id.
 */
';


--
-- Name: au_updated(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION au_updated() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.last_update_time := now();
	RETURN NEW;
END;
$$;


ALTER FUNCTION actor.au_updated() OWNER TO evergreen;

--
-- Name: usr_standing_penalty; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_standing_penalty (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    standing_penalty integer NOT NULL,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE actor.usr_standing_penalty OWNER TO evergreen;

--
-- Name: TABLE usr_standing_penalty; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE usr_standing_penalty IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User standing penalties
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: calculate_system_penalties(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION calculate_system_penalties(match_user integer, context_org integer) RETURNS SETOF usr_standing_penalty
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object         actor.usr%ROWTYPE;
    new_sp_row          actor.usr_standing_penalty%ROWTYPE;
    existing_sp_row     actor.usr_standing_penalty%ROWTYPE;
    collections_fines   permission.grp_penalty_threshold%ROWTYPE;
    max_fines           permission.grp_penalty_threshold%ROWTYPE;
    max_overdue         permission.grp_penalty_threshold%ROWTYPE;
    max_items_out       permission.grp_penalty_threshold%ROWTYPE;
    tmp_grp             INT;
    items_overdue       INT;
    items_out           INT;
    context_org_list    INT[];
    current_fines        NUMERIC(8,2) := 0.0;
    tmp_fines            NUMERIC(8,2);
    tmp_groc            RECORD;
    tmp_circ            RECORD;
    tmp_org             actor.org_unit%ROWTYPE;
    tmp_penalty         config.standing_penalty%ROWTYPE;
    tmp_depth           INTEGER;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;

    -- Max fines
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a high fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 1 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 1;

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL ) l USING (id);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 1;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max overdue
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many overdue items
    LOOP
        tmp_grp := user_object.profile;
        LOOP

            SELECT * INTO max_overdue FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 2 AND org_unit = tmp_org.id;

            IF max_overdue.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_overdue.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_overdue.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_overdue.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 2;

        SELECT  INTO items_overdue COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_overdue.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
            AND circ.checkin_time IS NULL
            AND circ.due_date < NOW()
            AND (circ.stop_fines = 'MAXFINES' OR circ.stop_fines IS NULL);

        IF items_overdue >= max_overdue.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_overdue.org_unit;
            new_sp_row.standing_penalty := 2;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max out
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many checked out items
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_items_out FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 3 AND org_unit = tmp_org.id;

            IF max_items_out.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_items_out.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;


    -- Fail if the user has too many items checked out
    IF max_items_out.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_items_out.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 3;

        SELECT  INTO items_out COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_items_out.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
                AND circ.checkin_time IS NULL
                AND (circ.stop_fines IN ('MAXFINES','LONGOVERDUE') OR circ.stop_fines IS NULL);

           IF items_out >= max_items_out.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_items_out.org_unit;
            new_sp_row.standing_penalty := 3;
            RETURN NEXT new_sp_row;
           END IF;
    END IF;

    -- Start over for collections warning
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a collections-level fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 4 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 4;

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND r.xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND g.xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND circ.xact_finish IS NULL ) l USING (id);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 4;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for in collections
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Remove the in-collections penalty if the user has paid down enough
    -- This penalty is different, because this code is not responsible for creating 
    -- new in-collections penalties, only for removing them
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 30 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        SELECT INTO context_org_list ARRAY_ACCUM(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        -- first, see if the user had paid down to the threshold
        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND r.xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND g.xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND circ.xact_finish IS NULL ) l USING (id);

        IF current_fines IS NULL OR current_fines <= max_fines.threshold THEN
            -- patron has paid down enough

            SELECT INTO tmp_penalty * FROM config.standing_penalty WHERE id = 30;

            IF tmp_penalty.org_depth IS NOT NULL THEN

                -- since this code is not responsible for applying the penalty, it can't 
                -- guarantee the current context org will match the org at which the penalty 
                --- was applied.  search up the org tree until we hit the configured penalty depth
                SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;
                SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;

                WHILE tmp_depth >= tmp_penalty.org_depth LOOP

                    RETURN QUERY
                        SELECT  *
                          FROM  actor.usr_standing_penalty
                          WHERE usr = match_user
                                AND org_unit = tmp_org.id
                                AND (stop_date IS NULL or stop_date > NOW())
                                AND standing_penalty = 30;

                    IF tmp_org.parent_ou IS NULL THEN
                        EXIT;
                    END IF;

                    SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;
                    SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;
                END LOOP;

            ELSE

                -- no penalty depth is defined, look for exact matches

                RETURN QUERY
                    SELECT  *
                      FROM  actor.usr_standing_penalty
                      WHERE usr = match_user
                            AND org_unit = max_fines.org_unit
                            AND (stop_date IS NULL or stop_date > NOW())
                            AND standing_penalty = 30;
            END IF;
    
        END IF;

    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION actor.calculate_system_penalties(match_user integer, context_org integer) OWNER TO evergreen;

--
-- Name: create_default_pickup_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION create_default_pickup_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'INSERT' THEN
	INSERT INTO actor.usr_setting (usr, name, value)
	VALUES (new.id, 'opac.default_pickup_location', '"' || new.home_ou::text || '"');
    END IF;

    IF TG_OP = 'UPDATE' THEN
	PERFORM * FROM actor.usr_setting WHERE usr = new.id AND name ILIKE 'opac.default_pickup_location';

	IF NOT FOUND THEN
	    INSERT INTO actor.usr_setting (usr, name, value)
	    VALUES (new.id, 'opac.default_pickup_location', '"' || new.home_ou::text || '"');
	ELSE
	    UPDATE actor.usr_setting SET value = '"' || new.home_ou::text || '"' WHERE usr = new.id AND name ILIKE 'opac.default_pickup_location' AND value LIKE '""';
	END IF;
	
    END IF;
    RETURN new;
END;
$$;


ALTER FUNCTION actor.create_default_pickup_location() OWNER TO evergreen;

--
-- Name: crypt_pw_insert(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION crypt_pw_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW.passwd = MD5( NEW.passwd );
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_insert() OWNER TO evergreen;

--
-- Name: crypt_pw_update(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION crypt_pw_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.passwd <> OLD.passwd THEN
			NEW.passwd = MD5( NEW.passwd );
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_update() OWNER TO evergreen;

--
-- Name: ignore_update_default_pickup_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION ignore_update_default_pickup_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'UPDATE' AND new.value ILIKE '""' AND new.name ILIKE 'opac.default_pickup_location' THEN
	SELECT '"' || au.home_ou::text || '"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    END IF;

    RETURN new;

END;
$$;


ALTER FUNCTION actor.ignore_update_default_pickup_location() OWNER TO evergreen;

--
-- Name: ignore_update_default_search_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION ignore_update_default_search_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'UPDATE' AND new.value NOT ILIKE '"1"' AND new.name ILIKE 'opac.default_search_location' THEN
                SELECT '"1"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    ELSIF TG_OP = 'INSERT' AND new.value NOT ILIKE '"1"' AND new.name ILIKE 'opac.default_search_location' THEN
                SELECT '"1"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    END IF;

    RETURN new;

END;
$$;


ALTER FUNCTION actor.ignore_update_default_search_location() OWNER TO evergreen;

--
-- Name: usr_activity; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_activity (
    id bigint NOT NULL,
    usr integer,
    etype integer NOT NULL,
    event_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.usr_activity OWNER TO evergreen;

--
-- Name: insert_usr_activity(integer, text, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) RETURNS SETOF usr_activity
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_row actor.usr_activity%ROWTYPE;
BEGIN
    SELECT id INTO new_row.etype FROM actor.usr_activity_get_type(ewho, ewhat, ehow);
    IF FOUND THEN
        new_row.usr := usr;
        INSERT INTO actor.usr_activity (usr, etype) 
            VALUES (usr, new_row.etype)
            RETURNING * INTO new_row;
        RETURN NEXT new_row;
    END IF;
END;
$$;


ALTER FUNCTION actor.insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) OWNER TO evergreen;

--
-- Name: org_unit; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit (
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean DEFAULT true NOT NULL,
    fiscal_calendar integer DEFAULT 1 NOT NULL
);


ALTER TABLE actor.org_unit OWNER TO evergreen;

--
-- Name: org_unit_ancestor_at_depth(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_ancestor_at_depth(integer, integer) RETURNS org_unit
    LANGUAGE sql STABLE
    AS $_$
	SELECT	a.*
	  FROM	actor.org_unit a
	  WHERE	id = ( SELECT FIRST(x.id)
	  		 FROM	actor.org_unit_ancestors($1) x
			   	JOIN actor.org_unit_type y
					ON x.ou_type = y.id AND y.depth = $2);
$_$;


ALTER FUNCTION actor.org_unit_ancestor_at_depth(integer, integer) OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: is_json(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_json(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;                    
    my $json = shift();
    eval { JSON::XS->new->allow_nonref->decode( $json ) };   
    return $@ ? 0 : 1;
$_$;


ALTER FUNCTION public.is_json(text) OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: org_unit_setting; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_setting (
    id bigint NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL,
    CONSTRAINT aous_must_be_json CHECK (public.is_json(value))
);


ALTER TABLE actor.org_unit_setting OWNER TO evergreen;

--
-- Name: TABLE org_unit_setting; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE org_unit_setting IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Org Unit settings
 *
 * This table contains any arbitrary settings that a client
 * program would like to save for an org unit.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: org_unit_ancestor_setting(text, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer) RETURNS SETOF org_unit_setting
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
DECLARE
    setting RECORD;
    cur_org INT;
BEGIN
    cur_org := org_id;
    LOOP
        SELECT INTO setting * FROM actor.org_unit_setting WHERE org_unit = cur_org AND name = setting_name;
        IF FOUND THEN
            RETURN NEXT setting;
            EXIT;
        END IF;
        SELECT INTO cur_org parent_ou FROM actor.org_unit WHERE id = cur_org;
        EXIT WHEN cur_org IS NULL;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION actor.org_unit_ancestor_setting(setting_name text, org_id integer) OWNER TO evergreen;

--
-- Name: FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer) IS '
/**
* Search "up" the org_unit tree until we find the first occurrence of an 
* org_unit_setting with the given name.
*/
';


--
-- Name: org_unit_ancestors(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_ancestors(integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT ou.* FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad USING (id) ORDER BY ouad.distance DESC;
$_$;


ALTER FUNCTION actor.org_unit_ancestors(integer) OWNER TO evergreen;

--
-- Name: org_unit_ancestors_distance(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT * FROM org_unit_ancestors_distance;
$_$;


ALTER FUNCTION actor.org_unit_ancestors_distance(integer) OWNER TO evergreen;

--
-- Name: org_unit_combined_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_combined_ancestors(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			UNION
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_combined_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_common_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_common_ancestors(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			INTERSECT
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_common_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_descendants(integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_descendants(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 100
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ad ON (ad.id = ou.id)
          WHERE ad.depth = $2
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ), anscestor_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants_distance(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.id, oudd.distance+1
            FROM actor.org_unit ou JOIN org_unit_descendants_distance oudd ON ou.parent_ou = oudd.id
    )
    SELECT * FROM org_unit_descendants_distance;
$_$;


ALTER FUNCTION actor.org_unit_descendants_distance(integer) OWNER TO evergreen;

--
-- Name: org_unit_full_path(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_full_path(integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 2
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			UNION
	SELECT	*
	  FROM	actor.org_unit_descendants($1);
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer) OWNER TO evergreen;

--
-- Name: org_unit_full_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_full_path(integer, integer) RETURNS SETOF org_unit
    LANGUAGE sql STABLE ROWS 2
    AS $_$
	SELECT	* FROM actor.org_unit_full_path((actor.org_unit_ancestor_at_depth($1, $2)).id)
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_parent_protect(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_parent_protect() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	DECLARE
		current_aou actor.org_unit%ROWTYPE;
		seen_ous    INT[];
		depth_count INT;
	BEGIN
		current_aou := NEW;
		depth_count := 0;
		seen_ous := ARRAY[NEW.id];

		IF (TG_OP = 'UPDATE') THEN
			IF (NEW.parent_ou IS NOT DISTINCT FROM OLD.parent_ou) THEN
				RETURN NEW; -- Doing an UPDATE with no change, just return it
			END IF;
		END IF;

		LOOP
			IF current_aou.parent_ou IS NULL THEN -- Top of the org tree?
				RETURN NEW; -- No loop. Carry on.
			END IF;
			IF current_aou.parent_ou = ANY(seen_ous) THEN -- Parent is one we have seen?
				RAISE 'OU LOOP: Saw % twice', current_aou.parent_ou; -- LOOP! ABORT!
			END IF;
			-- Get the next one!
			SELECT INTO current_aou * FROM actor.org_unit WHERE id = current_aou.parent_ou;
			seen_ous := seen_ous || current_aou.id;
			depth_count := depth_count + 1;
			IF depth_count = 100 THEN
				RAISE 'OU CHECK TOO DEEP';
			END IF;
		END LOOP;

		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.org_unit_parent_protect() OWNER TO evergreen;

--
-- Name: org_unit_prox_update(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_prox_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN


IF TG_OP = 'DELETE' THEN

    DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);

END IF;

IF TG_OP = 'UPDATE' THEN

    IF NEW.parent_ou <> OLD.parent_ou THEN

        DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);
            INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
            SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
                FROM  actor.org_unit l, actor.org_unit r
                WHERE (l.id = NEW.id or r.id = NEW.id);

    END IF;

END IF;

IF TG_OP = 'INSERT' THEN

     INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
     SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
         FROM  actor.org_unit l, actor.org_unit r
         WHERE (l.id = NEW.id or r.id = NEW.id);

END IF;

RETURN null;

END;
$$;


ALTER FUNCTION actor.org_unit_prox_update() OWNER TO evergreen;

--
-- Name: org_unit_proximity(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_proximity(integer, integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
	SELECT COUNT(id)::INT FROM (
		SELECT id FROM actor.org_unit_combined_ancestors($1, $2)
			EXCEPT
		SELECT id FROM actor.org_unit_common_ancestors($1, $2)
	) z;
$_$;


ALTER FUNCTION actor.org_unit_proximity(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_simple_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION org_unit_simple_path(integer, integer) RETURNS integer[]
    LANGUAGE sql STABLE
    AS $_$
    WITH RECURSIVE descendant_depth(id, path) AS (
        SELECT  aou.id,
                ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
          WHERE aou.id = $2
            UNION ALL
        SELECT  aou.id,
                dd.path || ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
                JOIN descendant_depth dd ON (dd.id = aou.parent_ou)
    ) SELECT dd.path
        FROM actor.org_unit aou
        JOIN descendant_depth dd USING (id)
        WHERE aou.id = $1 ORDER BY dd.path;
$_$;


ALTER FUNCTION actor.org_unit_simple_path(integer, integer) OWNER TO evergreen;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield actor.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM actor.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM actor.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.stat_cat_check() OWNER TO evergreen;

SET search_path = config, pg_catalog;

--
-- Name: usr_activity_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_activity_type (
    id integer NOT NULL,
    ewho text,
    ewhat text,
    ehow text,
    label text NOT NULL,
    egroup usr_activity_group NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    transient boolean DEFAULT false NOT NULL,
    CONSTRAINT one_of_wwh CHECK ((COALESCE(ewho, ewhat, ehow) IS NOT NULL))
);


ALTER TABLE config.usr_activity_type OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: usr_activity_get_type(text, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_activity_get_type(ewho text, ewhat text, ehow text) RETURNS SETOF config.usr_activity_type
    LANGUAGE sql
    AS $_$
SELECT * FROM config.usr_activity_type 
    WHERE 
        enabled AND 
        (ewho  IS NULL OR ewho  = $1) AND
        (ewhat IS NULL OR ewhat = $2) AND
        (ehow  IS NULL OR ehow  = $3) 
    ORDER BY 
        -- BOOL comparisons sort false to true
        COALESCE(ewho, '')  != COALESCE($1, ''),
        COALESCE(ewhat,'')  != COALESCE($2, ''),
        COALESCE(ehow, '')  != COALESCE($3, '') 
    LIMIT 1;
$_$;


ALTER FUNCTION actor.usr_activity_get_type(ewho text, ewhat text, ehow text) OWNER TO evergreen;

--
-- Name: usr_activity_transient_trg(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_activity_transient_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM actor.usr_activity act USING config.usr_activity_type atype
        WHERE atype.transient AND 
            NEW.etype = atype.id AND
            act.etype = atype.id AND
            act.usr = NEW.usr;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.usr_activity_transient_trg() OWNER TO evergreen;

--
-- Name: usr_delete(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_delete(src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_profile actor.usr.profile%type;
	old_home_ou actor.usr.home_ou%type;
	new_profile actor.usr.profile%type;
	new_home_ou actor.usr.home_ou%type;
	new_name    text;
	new_dob     actor.usr.dob%type;
BEGIN
	SELECT
		id || '-PURGED-' || now(),
		profile,
		home_ou,
		dob
	INTO
		new_name,
		old_profile,
		old_home_ou,
		new_dob
	FROM
		actor.usr
	WHERE
		id = src_usr;
	--
	-- Quit if no such user
	--
	IF old_profile IS NULL THEN
		RETURN;
	END IF;
	--
	perform actor.usr_purge_data( src_usr, dest_usr );
	--
	-- Find the root grp_tree and the root org_unit.  This would be simpler if we 
	-- could assume that there is only one root.  Theoretically, someday, maybe,
	-- there could be multiple roots, so we take extra trouble to get the right ones.
	--
	SELECT
		id
	INTO
		new_profile
	FROM
		permission.grp_ancestors( old_profile )
	WHERE
		parent is null;
	--
	SELECT
		id
	INTO
		new_home_ou
	FROM
		actor.org_unit_ancestors( old_home_ou )
	WHERE
		parent_ou is null;
	--
	-- Truncate date of birth
	--
	IF new_dob IS NOT NULL THEN
		new_dob := date_trunc( 'year', new_dob );
	END IF;
	--
	UPDATE
		actor.usr
		SET
			card = NULL,
			profile = new_profile,
			usrname = new_name,
			email = NULL,
			passwd = random()::text,
			standing = DEFAULT,
			ident_type = 
			(
				SELECT MIN( id )
				FROM config.identification_type
			),
			ident_value = NULL,
			ident_type2 = NULL,
			ident_value2 = NULL,
			net_access_level = DEFAULT,
			photo_url = NULL,
			prefix = NULL,
			first_given_name = new_name,
			second_given_name = NULL,
			family_name = new_name,
			suffix = NULL,
			alias = NULL,
			day_phone = NULL,
			evening_phone = NULL,
			other_phone = NULL,
			mailing_address = NULL,
			billing_address = NULL,
			home_ou = new_home_ou,
			dob = new_dob,
			active = FALSE,
			master_account = DEFAULT, 
			super_user = DEFAULT,
			barred = FALSE,
			deleted = TRUE,
			juvenile = DEFAULT,
			usrgroup = 0,
			claims_returned_count = DEFAULT,
			credit_forward_balance = DEFAULT,
			last_xact_id = DEFAULT,
			alert_message = NULL,
			create_date = now(),
			expire_date = now()
	WHERE
		id = src_usr;
END;
$$;


ALTER FUNCTION actor.usr_delete(src_usr integer, dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_delete(src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION usr_delete(src_usr integer, dest_usr integer) IS '
/**
 * Logically deletes a user.  Removes personally identifiable information,
 * and purges associated data in other tables.
 */
';


--
-- Name: usr_merge(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	bucket_row RECORD;
	picklist_row RECORD;
	queue_row RECORD;
	folder_row RECORD;
BEGIN

    -- do some initial cleanup 
    UPDATE actor.usr SET card = NULL WHERE id = src_usr;
    UPDATE actor.usr SET mailing_address = NULL WHERE id = src_usr;
    UPDATE actor.usr SET billing_address = NULL WHERE id = src_usr;

    -- actor.*
    IF del_cards THEN
        DELETE FROM actor.card where usr = src_usr;
    ELSE
        IF deactivate_cards THEN
            UPDATE actor.card SET active = 'f' WHERE usr = src_usr;
        END IF;
        UPDATE actor.card SET usr = dest_usr WHERE usr = src_usr;
    END IF;


    IF del_addrs THEN
        DELETE FROM actor.usr_address WHERE usr = src_usr;
    ELSE
        UPDATE actor.usr_address SET usr = dest_usr WHERE usr = src_usr;
    END IF;

    UPDATE actor.usr_note SET usr = dest_usr WHERE usr = src_usr;
    -- dupes are technically OK in actor.usr_standing_penalty, should manually delete them...
    UPDATE actor.usr_standing_penalty SET usr = dest_usr WHERE usr = src_usr;
    PERFORM actor.usr_merge_rows('actor.usr_org_unit_opt_in', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('actor.usr_setting', 'usr', src_usr, dest_usr);

    -- permission.*
    PERFORM actor.usr_merge_rows('permission.usr_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_object_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_grp_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_work_ou_map', 'usr', src_usr, dest_usr);


    -- container.*
	
	-- For each *_bucket table: transfer every bucket belonging to src_usr
	-- into the custody of dest_usr.
	--
	-- In order to avoid colliding with an existing bucket owned by
	-- the destination user, append the source user's id (in parenthesese)
	-- to the name.  If you still get a collision, add successive
	-- spaces to the name and keep trying until you succeed.
	--
	FOR bucket_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE container.user_bucket_item SET target_user = dest_usr WHERE target_user = src_usr;

    -- vandelay.*
	-- transfer queues the same way we transfer buckets (see above)
	FOR queue_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = queue_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    -- money.*
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'collector', src_usr, dest_usr);
    UPDATE money.billable_xact SET usr = dest_usr WHERE usr = src_usr;
    UPDATE money.billing SET voider = dest_usr WHERE voider = src_usr;
    UPDATE money.bnm_payment SET accepting_usr = dest_usr WHERE accepting_usr = src_usr;

    -- action.*
    UPDATE action.circulation SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
    UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;

    UPDATE action.hold_request SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
    UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
    UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;

    UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET patron = dest_usr WHERE patron = src_usr;
    UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.survey_response SET usr = dest_usr WHERE usr = src_usr;

    -- acq.*
    UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
    UPDATE acq.fund_transfer SET transfer_user = dest_usr WHERE transfer_user = src_usr;

	-- transfer picklists the same way we transfer buckets (see above)
	FOR picklist_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = picklist_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
    UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.provider_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.provider_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_usr_attr_definition SET usr = dest_usr WHERE usr = src_usr;

    -- asset.*
    UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;

    -- serial.*
    UPDATE serial.record_entry SET creator = dest_usr WHERE creator = src_usr;
    UPDATE serial.record_entry SET editor = dest_usr WHERE editor = src_usr;

    -- reporter.*
    -- It's not uncommon to define the reporter schema in a replica 
    -- DB only, so don't assume these tables exist in the write DB.
    BEGIN
    	UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;

    -- Finally, delete the source user
    DELETE FROM actor.usr WHERE id = src_usr;

END;
$$;


ALTER FUNCTION actor.usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) OWNER TO evergreen;

--
-- Name: FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) IS '
/**
 * Merges all user date from src_usr to dest_usr.  When collisions occur, 
 * keep dest_usr''s data and delete src_usr''s data.
 */
';


--
-- Name: usr_merge_rows(text, text, integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    sel TEXT;
    upd TEXT;
    del TEXT;
    cur_row RECORD;
BEGIN
    sel := 'SELECT id::BIGINT FROM ' || table_name || ' WHERE ' || quote_ident(col_name) || ' = ' || quote_literal(src_usr);
    upd := 'UPDATE ' || table_name || ' SET ' || quote_ident(col_name) || ' = ' || quote_literal(dest_usr) || ' WHERE id = ';
    del := 'DELETE FROM ' || table_name || ' WHERE id = ';
    FOR cur_row IN EXECUTE sel LOOP
        BEGIN
            --RAISE NOTICE 'Attempting to merge % %', table_name, cur_row.id;
            EXECUTE upd || cur_row.id;
        EXCEPTION WHEN unique_violation THEN
            --RAISE NOTICE 'Deleting conflicting % %', table_name, cur_row.id;
            EXECUTE del || cur_row.id;
        END;
    END LOOP;
END;
$$;


ALTER FUNCTION actor.usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) IS '
/**
 * Attempts to move each row of the specified table from src_user to dest_user.  
 * Where conflicts exist, the conflicting "source" row is deleted.
 */
';


--
-- Name: usr_purge_data(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	renamable_row RECORD;
	dest_usr INTEGER;
BEGIN

	IF specified_dest_usr IS NULL THEN
		dest_usr := 1; -- Admin user on stock installs
	ELSE
		dest_usr := specified_dest_usr;
	END IF;

	UPDATE actor.usr SET
		active = FALSE,
		card = NULL,
		mailing_address = NULL,
		billing_address = NULL
	WHERE id = src_usr;

	-- acq.*
	UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
	UPDATE acq.lineitem SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.lineitem SET selector = dest_usr WHERE selector = src_usr;
	UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
	DELETE FROM acq.lineitem_usr_attr_definition WHERE usr = src_usr;

	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE acq.picklist SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.picklist SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
	UPDATE acq.purchase_order SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.purchase_order SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.claim_event SET creator = dest_usr WHERE creator = src_usr;

	-- action.*
	DELETE FROM action.circulation WHERE usr = src_usr;
	UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
	UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;
	UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;
	UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
	UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
	DELETE FROM action.hold_request WHERE usr = src_usr;
	UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
	UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.non_cataloged_circulation WHERE patron = src_usr;
	UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.survey_response WHERE usr = src_usr;
	UPDATE action.fieldset SET owner = dest_usr WHERE owner = src_usr;

	-- actor.*
	DELETE FROM actor.card WHERE usr = src_usr;
	DELETE FROM actor.stat_cat_entry_usr_map WHERE target_usr = src_usr;

	-- The following update is intended to avoid transient violations of a foreign
	-- key constraint, whereby actor.usr_address references itself.  It may not be
	-- necessary, but it does no harm.
	UPDATE actor.usr_address SET replaces = NULL
		WHERE usr = src_usr AND replaces IS NOT NULL;
	DELETE FROM actor.usr_address WHERE usr = src_usr;
	DELETE FROM actor.usr_note WHERE usr = src_usr;
	UPDATE actor.usr_note SET creator = dest_usr WHERE creator = src_usr;
	DELETE FROM actor.usr_org_unit_opt_in WHERE usr = src_usr;
	UPDATE actor.usr_org_unit_opt_in SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM actor.usr_setting WHERE usr = src_usr;
	DELETE FROM actor.usr_standing_penalty WHERE usr = src_usr;
	UPDATE actor.usr_standing_penalty SET staff = dest_usr WHERE staff = src_usr;

	-- asset.*
	UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;

	-- auditor.*
	DELETE FROM auditor.actor_usr_address_history WHERE id = src_usr;
	DELETE FROM auditor.actor_usr_history WHERE id = src_usr;
	UPDATE auditor.asset_call_number_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_call_number_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.asset_copy_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_copy_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.biblio_record_entry_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.biblio_record_entry_history SET editor  = dest_usr WHERE editor  = src_usr;

	-- biblio.*
	UPDATE biblio.record_entry SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_entry SET editor = dest_usr WHERE editor = src_usr;
	UPDATE biblio.record_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_note SET editor = dest_usr WHERE editor = src_usr;

	-- container.*
	-- Update buckets with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	DELETE FROM container.user_bucket_item WHERE target_user = src_usr;

	-- money.*
	DELETE FROM money.billable_xact WHERE usr = src_usr;
	DELETE FROM money.collections_tracker WHERE usr = src_usr;
	UPDATE money.collections_tracker SET collector = dest_usr WHERE collector = src_usr;

	-- permission.*
	DELETE FROM permission.usr_grp_map WHERE usr = src_usr;
	DELETE FROM permission.usr_object_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_work_ou_map WHERE usr = src_usr;

	-- reporter.*
	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
	-- do nothing
	END;

	-- vandelay.*
	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

END;
$$;


ALTER FUNCTION actor.usr_purge_data(src_usr integer, specified_dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer) IS '
/**
 * Finds rows dependent on a given row in actor.usr and either deletes them
 * or reassigns them to a different user.
 */
';


SET search_path = asset, pg_catalog;

--
-- Name: acp_created(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION acp_created() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
        NEW.active_date := now();
    END IF;
    IF NEW.status_changed_time IS NULL THEN
        NEW.status_changed_time := now();
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_created() OWNER TO evergreen;

--
-- Name: acp_status_changed(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION acp_status_changed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.status <> OLD.status AND NOT (NEW.status = 0 AND OLD.status = 7) THEN
        NEW.status_changed_time := now();
        IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
            NEW.active_date := now();
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_status_changed() OWNER TO evergreen;

--
-- Name: autogenerate_placeholder_barcode(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION autogenerate_placeholder_barcode() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.barcode LIKE '@@%' THEN
		NEW.barcode := '@@' || NEW.id;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION asset.autogenerate_placeholder_barcode() OWNER TO evergreen;

--
-- Name: cache_copy_visibility(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION cache_copy_visibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    add_front       TEXT;
    add_back        TEXT;
    add_base_query  TEXT;
    add_peer_query  TEXT;
    remove_query    TEXT;
    do_add          BOOLEAN := false;
    do_remove       BOOLEAN := false;
BEGIN
    add_base_query := $$
        SELECT  cp.id, cp.circ_lib, cn.record, cn.id AS call_number, cp.location, cp.status
          FROM  asset.copy cp
                JOIN asset.call_number cn ON (cn.id = cp.call_number)
                JOIN actor.org_unit a ON (cp.circ_lib = a.id)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN config.copy_status cs ON (cp.status = cs.id)
                JOIN biblio.record_entry b ON (cn.record = b.id)
          WHERE NOT cp.deleted
                AND NOT cn.deleted
                AND NOT b.deleted
                AND cs.opac_visible
                AND cl.opac_visible
                AND cp.opac_visible
                AND a.opac_visible
    $$;
    add_peer_query := $$
        SELECT  cp.id, cp.circ_lib, pbcm.peer_record AS record, NULL AS call_number, cp.location, cp.status
          FROM  asset.copy cp
                JOIN biblio.peer_bib_copy_map pbcm ON (pbcm.target_copy = cp.id)
                JOIN actor.org_unit a ON (cp.circ_lib = a.id)
                JOIN asset.copy_location cl ON (cp.location = cl.id)
                JOIN config.copy_status cs ON (cp.status = cs.id)
          WHERE NOT cp.deleted
                AND cs.opac_visible
                AND cl.opac_visible
                AND cp.opac_visible
                AND a.opac_visible
    $$;
    add_front := $$
        INSERT INTO asset.opac_visible_copies (copy_id, circ_lib, record)
          SELECT id, circ_lib, record FROM (
    $$;
    add_back := $$
        ) AS x
    $$;
 
    remove_query := $$ DELETE FROM asset.opac_visible_copies WHERE copy_id IN ( SELECT id FROM asset.copy WHERE $$;

    IF TG_TABLE_NAME = 'peer_bib_copy_map' THEN
        IF TG_OP = 'INSERT' THEN
            add_peer_query := add_peer_query || ' AND cp.id = ' || NEW.target_copy || ' AND pbcm.peer_record = ' || NEW.peer_record;
            EXECUTE add_front || add_peer_query || add_back;
            RETURN NEW;
        ELSE
            remove_query := 'DELETE FROM asset.opac_visible_copies WHERE copy_id = ' || OLD.target_copy || ' AND record = ' || OLD.peer_record || ';';
            EXECUTE remove_query;
            RETURN OLD;
        END IF;
    END IF;

    IF TG_OP = 'INSERT' THEN

        IF TG_TABLE_NAME IN ('copy', 'unit') THEN
            add_base_query := add_base_query || ' AND cp.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    -- handle items first, since with circulation activity
    -- their statuses change frequently
    IF TG_TABLE_NAME IN ('copy', 'unit') THEN

        IF OLD.location    <> NEW.location OR
           OLD.call_number <> NEW.call_number OR
           OLD.status      <> NEW.status OR
           OLD.circ_lib    <> NEW.circ_lib THEN
            -- any of these could change visibility, but
            -- we'll save some queries and not try to calculate
            -- the change directly
            do_remove := true;
            do_add := true;
        ELSE

            IF OLD.deleted <> NEW.deleted THEN
                IF NEW.deleted THEN
                    do_remove := true;
                ELSE
                    do_add := true;
                END IF;
            END IF;

            IF OLD.opac_visible <> NEW.opac_visible THEN
                IF OLD.opac_visible THEN
                    do_remove := true;
                ELSIF NOT do_remove THEN -- handle edge case where deleted item
                                        -- is also marked opac_visible
                    do_add := true;
                END IF;
            END IF;

        END IF;

        IF do_remove THEN
            DELETE FROM asset.opac_visible_copies WHERE copy_id = NEW.id;
        END IF;
        IF do_add THEN
            add_base_query := add_base_query || ' AND cp.id = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    IF TG_TABLE_NAME IN ('call_number', 'record_entry') THEN -- these have a 'deleted' column
 
        IF OLD.deleted AND NEW.deleted THEN -- do nothing

            RETURN NEW;
 
        ELSIF NEW.deleted THEN -- remove rows
 
            IF TG_TABLE_NAME = 'call_number' THEN
                DELETE FROM asset.opac_visible_copies WHERE copy_id IN (SELECT id FROM asset.copy WHERE call_number = NEW.id);
            ELSIF TG_TABLE_NAME = 'record_entry' THEN
                DELETE FROM asset.opac_visible_copies WHERE record = NEW.id;
            END IF;
 
            RETURN NEW;
 
        ELSIF OLD.deleted THEN -- add rows
 
            IF TG_TABLE_NAME = 'call_number' THEN
                add_base_query := add_base_query || ' AND cn.id = ' || NEW.id;
                EXECUTE add_front || add_base_query || add_back;
            ELSIF TG_TABLE_NAME = 'record_entry' THEN
                add_base_query := add_base_query || ' AND cn.record = ' || NEW.id;
                add_peer_query := add_peer_query || ' AND pbcm.peer_record = ' || NEW.id;
                EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
            END IF;
 
            RETURN NEW;
 
        END IF;
 
    END IF;

    IF TG_TABLE_NAME = 'call_number' THEN

        IF OLD.record <> NEW.record THEN
            -- call number is linked to different bib
            remove_query := remove_query || 'call_number = ' || NEW.id || ');';
            EXECUTE remove_query;
            add_base_query := add_base_query || ' AND cn.id = ' || NEW.id;
            EXECUTE add_front || add_base_query || add_back;
        END IF;

        RETURN NEW;

    END IF;

    IF TG_TABLE_NAME IN ('record_entry') THEN
        RETURN NEW; -- don't have 'opac_visible'
    END IF;

    -- actor.org_unit, asset.copy_location, asset.copy_status
    IF NEW.opac_visible = OLD.opac_visible THEN -- do nothing

        RETURN NEW;

    ELSIF NEW.opac_visible THEN -- add rows

        IF TG_TABLE_NAME = 'org_unit' THEN
            add_base_query := add_base_query || ' AND cp.circ_lib = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.circ_lib = ' || NEW.id;
        ELSIF TG_TABLE_NAME = 'copy_location' THEN
            add_base_query := add_base_query || ' AND cp.location = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.location = ' || NEW.id;
        ELSIF TG_TABLE_NAME = 'copy_status' THEN
            add_base_query := add_base_query || ' AND cp.status = ' || NEW.id;
            add_peer_query := add_peer_query || ' AND cp.status = ' || NEW.id;
        END IF;
 
        EXECUTE add_front || add_base_query || ' UNION ' || add_peer_query || add_back;
 
    ELSE -- delete rows

        IF TG_TABLE_NAME = 'org_unit' THEN
            remove_query := 'DELETE FROM asset.opac_visible_copies WHERE circ_lib = ' || NEW.id || ';';
        ELSIF TG_TABLE_NAME = 'copy_location' THEN
            remove_query := remove_query || 'location = ' || NEW.id || ');';
        ELSIF TG_TABLE_NAME = 'copy_status' THEN
            remove_query := remove_query || 'status = ' || NEW.id || ');';
        END IF;
 
        EXECUTE remove_query;
 
    END IF;
 
    RETURN NEW;
END;
$_$;


ALTER FUNCTION asset.cache_copy_visibility() OWNER TO evergreen;

--
-- Name: FUNCTION cache_copy_visibility(); Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON FUNCTION cache_copy_visibility() IS '
Trigger function to update the copy OPAC visiblity cache.
';


--
-- Name: get_holdings_maintenance_page(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION get_holdings_maintenance_page(tcn_value bigint) RETURNS SETOF evergreen.holdings_maintenance
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
   r holdings_maintenance;
   
BEGIN

FOR r IN

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, acp.age_protect, acp.alert_message, acp.barcode, acp.call_number, acp.circ_as_type, acp.circ_lib, acp.circ_modifier, acp.circulate, acp.copy_number, acp.create_date, acp.active_date, acp.creator, acp.deleted, acp.dummy_isbn, acp.deposit, acp.deposit_amount, acp.dummy_author, acp.dummy_title, acp.edit_date, acp.editor, acp.fine_level, acp.holdable, acp.id, acp.loan_duration, acp.LOCATION, acp.opac_visible, acp.price, acp.REF, acp.STATUS, acp.status_changed_time, acp.mint_condition, acp.floating, acp.COST, circ.checkin_lib, circ.checkin_staff, circ.checkin_time, circ.circ_lib, circ.circ_staff, circ.desk_renewal, circ.due_date, circ.duration, circ.duration_rule, circ.fine_interval, circ.id, circ.max_fine, circ.max_fine_rule, circ.opac_renewal, circ.phone_renewal, circ.recurring_fine, circ.recurring_fine_rule, circ.renewal_remaining, circ.grace_period, circ.stop_fines, circ.stop_fines_time, circ.target_copy, circ.usr, circ.xact_finish, circ.xact_start, circ.create_time, circ.workstation, circ.checkin_workstation, circ.checkin_scan_time, circ.parent_circ, circ.unrecovered, circ.copy_location

	FROM asset.COPY AS acp 

	JOIN asset.call_number acn ON (acp.call_number = acn.id)
	JOIN actor.org_unit aou ON (acn.owning_lib = aou.id)
	JOIN action.circulation circ ON (acp.id = circ.target_copy)


	WHERE acn.record = tcn_value 
		AND circ.xact_start = (
			SELECT c.xact 
			FROM ( 
				SELECT target_copy, max(xact_start) AS xact 
				FROM action.circulation 
				WHERE target_copy = acp.id  
				GROUP BY target_copy) AS c)
		AND aou.parent_ou = '1' 
		AND acn.deleted = 'f' 
		AND acn.LABEL <> '##URI##'
		AND acp.deleted = 'f'

UNION ALL

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, acp.age_protect, acp.alert_message, acp.barcode, acp.call_number, acp.circ_as_type, acp.circ_lib, acp.circ_modifier, acp.circulate, acp.copy_number, acp.create_date, acp.active_date, acp.creator, acp.deleted, acp.dummy_isbn, acp.deposit, acp.deposit_amount, acp.dummy_author, acp.dummy_title, acp.edit_date, acp.editor, acp.fine_level, acp.holdable, acp.id, acp.loan_duration, acp.LOCATION, acp.opac_visible, acp.price, acp.REF, acp.STATUS, acp.status_changed_time, acp.mint_condition, acp.floating, acp.COST, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null

	FROM asset.COPY AS acp 

	JOIN asset.call_number acn ON (acp.call_number = acn.id)
	JOIN actor.org_unit aou ON (acn.owning_lib = aou.id)


	WHERE acn.record = tcn_value 
		AND acp.id NOT IN (SELECT circ.target_copy
			FROM action.circulation circ
			WHERE circ.target_copy = acp.id)
		AND aou.parent_ou = '1' 
		AND acn.deleted = 'f' 
		AND acn.LABEL <> '##URI##'
		AND acp.deleted = 'f'

UNION ALL

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null

	FROM asset.call_number AS acn
	LEFT OUTER JOIN asset.copy AS acp
	ON acn.id = acp.call_number
	WHERE acn.record = tcn_value
	AND acn.deleted = 'f'
	AND acp.id IS NULL




LOOP
RETURN NEXT r;
END LOOP;

RETURN;

END;
$$;


ALTER FUNCTION asset.get_holdings_maintenance_page(tcn_value bigint) OWNER TO evergreen;

--
-- Name: label_normalizer(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION label_normalizer() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sortkey        TEXT := '';
BEGIN
    sortkey := NEW.label_sortkey;

    IF NEW.label_class IS NULL THEN
            NEW.label_class := COALESCE(
            (
                SELECT substring(value from E'\\d+')::integer
                FROM actor.org_unit_ancestor_setting('cat.default_classification_scheme', NEW.owning_lib)
            ), 1
        );
    END IF;

    EXECUTE 'SELECT ' || acnc.normalizer || '(' || 
       quote_literal( NEW.label ) || ')'
       FROM asset.call_number_class acnc
       WHERE acnc.id = NEW.label_class
       INTO sortkey;
    NEW.label_sortkey = sortkey;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.label_normalizer() OWNER TO evergreen;

--
-- Name: label_normalizer_dewey(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION label_normalizer_dewey(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    # Derived from the Koha C4::ClassSortRoutine::Dewey module
    # Copyright (C) 2007 LibLime
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    my $init = uc(shift);
    $init =~ s/^\s+//;
    $init =~ s/\s+$//;
    $init =~ s!/!!g;
    $init =~ s/^([\p{IsAlpha}]+)/$1 /;
    my @tokens = split /\.|\s+/, $init;
    my $digit_group_count = 0;
    for (my $i = 0; $i <= $#tokens; $i++) {
        if ($tokens[$i] =~ /^\d+$/) {
            $digit_group_count++;
            if (2 == $digit_group_count) {
                $tokens[$i] = sprintf("%-15.15s", $tokens[$i]);
                $tokens[$i] =~ tr/ /0/;
            }
        }
    }
    my $key = join("_", @tokens);
    $key =~ s/[^\p{IsAlnum}_]//g;

    return $key;

$_$;


ALTER FUNCTION asset.label_normalizer_dewey(text) OWNER TO evergreen;

--
-- Name: label_normalizer_generic(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION label_normalizer_generic(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    # Created after looking at the Koha C4::ClassSortRoutine::Generic module,
    # thus could probably be considered a derived work, although nothing was
    # directly copied - but to err on the safe side of providing attribution:
    # Copyright (C) 2007 LibLime
    # Copyright (C) 2011 Equinox Software, Inc (Steve Callendar)
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    # Converts the callnumber to uppercase
    # Strips spaces from start and end of the call number
    # Converts anything other than letters, digits, and periods into spaces
    # Collapses multiple spaces into a single underscore
    my $callnum = uc(shift);
    $callnum =~ s/^\s//g;
    $callnum =~ s/\s$//g;
    # NOTE: this previously used underscores, but this caused sorting issues
    # for the "before" half of page 0 on CN browse, sorting CNs containing a
    # decimal before "whole number" CNs
    $callnum =~ s/[^A-Z0-9_.]/ /g;
    $callnum =~ s/ {2,}/ /g;

    return $callnum;
$_$;


ALTER FUNCTION asset.label_normalizer_generic(text) OWNER TO evergreen;

--
-- Name: label_normalizer_lc(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION label_normalizer_lc(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use strict;
    use warnings;

    # Library::CallNumber::LC is currently hosted at http://code.google.com/p/library-callnumber-lc/
    # The author hopes to upload it to CPAN some day, which would make our lives easier
    use Library::CallNumber::LC;

    my $callnum = Library::CallNumber::LC->new(shift);
    return $callnum->normalize();

$_$;


ALTER FUNCTION asset.label_normalizer_lc(text) OWNER TO evergreen;

--
-- Name: merge_record_assets(bigint, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION merge_record_assets(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    moved_objects INT := 0;
    source_cn     asset.call_number%ROWTYPE;
    target_cn     asset.call_number%ROWTYPE;
    target_mrc    biblio.record_entry.marc%TYPE;
    metarec       metabib.metarecord%ROWTYPE;
    hold          action.hold_request%ROWTYPE;
    ser_rec       serial.record_entry%ROWTYPE;
    acq_lineitem  acq.lineitem%ROWTYPE;
    uri_count     INT := 0;
    counter       INT := 0;
    uri_datafield TEXT;
    uri_text      TEXT := '';
BEGIN

    -- move any 856 entries on records that have at least one MARC-mapped URI entry
    SELECT  INTO uri_count COUNT(*)
      FROM  asset.uri_call_number_map m
            JOIN asset.call_number cn ON (m.call_number = cn.id)
      WHERE cn.record = source_record;

    IF uri_count > 0 THEN

        SELECT  COUNT(*) INTO counter
          FROM  oils_xpath_table(
                    'id',
                    'marc',
                    'biblio.record_entry',
                    '//*[@tag="856"]',
                    'id=' || source_record
                ) as t(i int,c text);

        FOR i IN 1 .. counter LOOP
            SELECT  '<datafield xmlns="http://www.loc.gov/MARC21/slim"' ||
                        ' tag="856"' ||
                        ' ind1="' || FIRST(ind1) || '"'  ||
                        ' ind2="' || FIRST(ind2) || '">' ||
                        array_to_string(
                            array_accum(
                                '<subfield code="' || subfield || '">' ||
                                regexp_replace(
                                    regexp_replace(
                                        regexp_replace(data,'&','&amp;','g'),
                                        '>', '&gt;', 'g'
                                    ),
                                    '<', '&lt;', 'g'
                                ) || '</subfield>'
                            ), ''
                        ) || '</datafield>' INTO uri_datafield
              FROM  oils_xpath_table(
                        'id',
                        'marc',
                        'biblio.record_entry',
                        '//*[@tag="856"][position()=' || i || ']/@ind1|' ||
                        '//*[@tag="856"][position()=' || i || ']/@ind2|' ||
                        '//*[@tag="856"][position()=' || i || ']/*/@code|' ||
                        '//*[@tag="856"][position()=' || i || ']/*[@code]',
                        'id=' || source_record
                    ) as t(id int,ind1 text, ind2 text,subfield text,data text);

            uri_text := uri_text || uri_datafield;
        END LOOP;

        IF uri_text <> '' THEN
            UPDATE  biblio.record_entry
              SET   marc = regexp_replace(marc,'(</[^>]*record>)', uri_text || E'\\1')
              WHERE id = target_record;
        END IF;

    END IF;

    -- Find and move metarecords to the target record
    SELECT  INTO metarec *
      FROM  metabib.metarecord
      WHERE master_record = source_record;

    IF FOUND THEN
        UPDATE  metabib.metarecord
          SET   master_record = target_record,
            mods = NULL
          WHERE id = metarec.id;

        moved_objects := moved_objects + 1;
    END IF;

    -- Find call numbers attached to the source ...
    FOR source_cn IN SELECT * FROM asset.call_number WHERE record = source_record LOOP

        SELECT  INTO target_cn *
          FROM  asset.call_number
          WHERE label = source_cn.label
            AND owning_lib = source_cn.owning_lib
            AND record = target_record
            AND NOT deleted;

        -- ... and if there's a conflicting one on the target ...
        IF FOUND THEN

            -- ... move the copies to that, and ...
            UPDATE  asset.copy
              SET   call_number = target_cn.id
              WHERE call_number = source_cn.id;

            -- ... move V holds to the move-target call number
            FOR hold IN SELECT * FROM action.hold_request WHERE target = source_cn.id AND hold_type = 'V' LOOP

                UPDATE  action.hold_request
                  SET   target = target_cn.id
                  WHERE id = hold.id;

                moved_objects := moved_objects + 1;
            END LOOP;

        -- ... if not ...
        ELSE
            -- ... just move the call number to the target record
            UPDATE  asset.call_number
              SET   record = target_record
              WHERE id = source_cn.id;
        END IF;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find T holds targeting the source record ...
    FOR hold IN SELECT * FROM action.hold_request WHERE target = source_record AND hold_type = 'T' LOOP

        -- ... and move them to the target record
        UPDATE  action.hold_request
          SET   target = target_record
          WHERE id = hold.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find serial records targeting the source record ...
    FOR ser_rec IN SELECT * FROM serial.record_entry WHERE record = source_record LOOP
        -- ... and move them to the target record
        UPDATE  serial.record_entry
          SET   record = target_record
          WHERE id = ser_rec.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find acq lineitems targeting the source record ...
    SELECT marc INTO target_mrc FROM biblio.record_entry WHERE id = target_record;
    FOR acq_lineitem IN SELECT * FROM acq.lineitem WHERE eg_bib_id = source_record LOOP
        -- ... and move them to the target record, updating marc as well
        UPDATE  acq.lineitem
          SET   eg_bib_id = target_record
          WHERE id = acq_lineitem.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Finally, "delete" the source record
    DELETE FROM biblio.record_entry WHERE id = source_record;

    -- That's all, folks!
    RETURN moved_objects;
END;
$$;


ALTER FUNCTION asset.merge_record_assets(target_record bigint, source_record bigint) OWNER TO evergreen;

--
-- Name: metarecord_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION metarecord_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_metarecord_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_metarecord_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.metarecord_copy_count(place integer, rid bigint, staff boolean) OWNER TO evergreen;

--
-- Name: metarecord_has_holdable_copy(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION metarecord_has_holdable_copy(rid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
            JOIN metabib.metarecord_source_map mmsm ON acn.record = mmsm.source
        WHERE
            mmsm.metarecord = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION asset.metarecord_has_holdable_copy(rid bigint) OWNER TO evergreen;

--
-- Name: normalize_affix_sortkey(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION normalize_affix_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.normalize_affix_sortkey() OWNER TO evergreen;

--
-- Name: opac_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
                JOIN metabib.metarecord_source_map m ON (m.source = av.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION opac_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;   
                
    RETURN;     
END;            
$$;


ALTER FUNCTION asset.opac_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION opac_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
                JOIN metabib.metarecord_source_map m ON (m.source = av.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION opac_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( av.id ),
                trans
          FROM  
                actor.org_unit_descendants(ans.id) d
                JOIN asset.opac_visible_copies av ON (av.record = rid AND av.circ_lib = d.id)
                JOIN asset.copy cp ON (cp.id = av.copy_id)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_record_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: record_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION record_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_record_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_record_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.record_copy_count(place integer, rid bigint, staff boolean) OWNER TO evergreen;

--
-- Name: record_has_holdable_copy(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION record_has_holdable_copy(rid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
        WHERE
            acn.record = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION asset.record_has_holdable_copy(rid bigint) OWNER TO evergreen;

--
-- Name: refresh_opac_visible_copies_mat_view(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION refresh_opac_visible_copies_mat_view() RETURNS void
    LANGUAGE sql
    AS $$

    TRUNCATE TABLE asset.opac_visible_copies;

    INSERT INTO asset.opac_visible_copies (copy_id, circ_lib, record)
    SELECT  cp.id, cp.circ_lib, cn.record
    FROM  asset.copy cp
        JOIN asset.call_number cn ON (cn.id = cp.call_number)
        JOIN actor.org_unit a ON (cp.circ_lib = a.id)
        JOIN asset.copy_location cl ON (cp.location = cl.id)
        JOIN config.copy_status cs ON (cp.status = cs.id)
        JOIN biblio.record_entry b ON (cn.record = b.id)
    WHERE NOT cp.deleted
        AND NOT cn.deleted
        AND NOT b.deleted
        AND cs.opac_visible
        AND cl.opac_visible
        AND cp.opac_visible
        AND a.opac_visible
            UNION
    SELECT  cp.id, cp.circ_lib, pbcm.peer_record AS record
    FROM  asset.copy cp
        JOIN biblio.peer_bib_copy_map pbcm ON (pbcm.target_copy = cp.id)
        JOIN actor.org_unit a ON (cp.circ_lib = a.id)
        JOIN asset.copy_location cl ON (cp.location = cl.id)
        JOIN config.copy_status cs ON (cp.status = cs.id)
    WHERE NOT cp.deleted
        AND cs.opac_visible
        AND cl.opac_visible
        AND cp.opac_visible
        AND a.opac_visible;

$$;


ALTER FUNCTION asset.refresh_opac_visible_copies_mat_view() OWNER TO evergreen;

--
-- Name: FUNCTION refresh_opac_visible_copies_mat_view(); Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON FUNCTION refresh_opac_visible_copies_mat_view() IS '
Rebuild the copy OPAC visibility cache.  Useful during migrations.
';


--
-- Name: staff_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION staff_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION staff_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE         
    ans RECORD; 
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION staff_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE         
    ans RECORD; 
    trans INT;
BEGIN           
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_record_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield asset.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM asset.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM asset.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.stat_cat_check() OWNER TO evergreen;

SET search_path = auditor, pg_catalog;

--
-- Name: audit_acq_fund_debit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_acq_fund_debit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_fund_debit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, fund, origin_amount, origin_currency_type, amount, encumbrance, debit_type, xfer_destination, create_time )
                SELECT  nextval('auditor.acq_fund_debit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.fund, OLD.origin_amount, OLD.origin_currency_type, OLD.amount, OLD.encumbrance, OLD.debit_type, OLD.xfer_destination, OLD.create_time
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_fund_debit_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_entry_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_acq_invoice_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, lineitem, inv_item_count, phys_item_count, note, billed_per_item, cost_billed, actual_cost, amount_paid )
                SELECT  nextval('auditor.acq_invoice_entry_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.lineitem, OLD.inv_item_count, OLD.phys_item_count, OLD.note, OLD.billed_per_item, OLD.cost_billed, OLD.actual_cost, OLD.amount_paid
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_entry_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_acq_invoice_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, receiver, provider, shipper, recv_date, recv_method, inv_type, inv_ident, payment_auth, payment_method, note, complete )
                SELECT  nextval('auditor.acq_invoice_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.receiver, OLD.provider, OLD.shipper, OLD.recv_date, OLD.recv_method, OLD.inv_type, OLD.inv_ident, OLD.payment_auth, OLD.payment_method, OLD.note, OLD.complete
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_item_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_acq_invoice_item_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_item_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, fund_debit, inv_item_type, title, author, note, cost_billed, actual_cost, fund, amount_paid, po_item, target )
                SELECT  nextval('auditor.acq_invoice_item_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.fund_debit, OLD.inv_item_type, OLD.title, OLD.author, OLD.note, OLD.cost_billed, OLD.actual_cost, OLD.fund, OLD.amount_paid, OLD.po_item, OLD.target
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_item_func() OWNER TO evergreen;

--
-- Name: audit_acq_lineitem_detail_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_acq_lineitem_detail_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_lineitem_detail_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, lineitem, fund, fund_debit, eg_copy_id, barcode, cn_label, note, collection_code, circ_modifier, owning_lib, location, recv_time, cancel_reason, receiver )
                SELECT  nextval('auditor.acq_lineitem_detail_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.lineitem, OLD.fund, OLD.fund_debit, OLD.eg_copy_id, OLD.barcode, OLD.cn_label, OLD.note, OLD.collection_code, OLD.circ_modifier, OLD.owning_lib, OLD.location, OLD.recv_time, OLD.cancel_reason, OLD.receiver
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_lineitem_detail_func() OWNER TO evergreen;

--
-- Name: audit_action_trigger_event_definition_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_action_trigger_event_definition_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.action_trigger_event_definition_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, active, owner, name, hook, validator, reactor, cleanup_success, cleanup_failure, delay, max_delay, usr_field, opt_in_setting, delay_field, group_field, template, granularity )
                SELECT  nextval('auditor.action_trigger_event_definition_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.active, OLD.owner, OLD.name, OLD.hook, OLD.validator, OLD.reactor, OLD.cleanup_success, OLD.cleanup_failure, OLD.delay, OLD.max_delay, OLD.usr_field, OLD.opt_in_setting, OLD.delay_field, OLD.group_field, OLD.template, OLD.granularity
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_action_trigger_event_definition_func() OWNER TO evergreen;

--
-- Name: audit_actor_org_unit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_actor_org_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_org_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, parent_ou, ou_type, ill_address, holds_address, mailing_address, billing_address, shortname, name, email, phone, opac_visible, fiscal_calendar )
                SELECT  nextval('auditor.actor_org_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.parent_ou, OLD.ou_type, OLD.ill_address, OLD.holds_address, OLD.mailing_address, OLD.billing_address, OLD.shortname, OLD.name, OLD.email, OLD.phone, OLD.opac_visible, OLD.fiscal_calendar
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_org_unit_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_address_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_actor_usr_address_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_address_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, valid, within_city_limits, address_type, usr, street1, street2, city, county, state, country, post_code, pending, replaces )
                SELECT  nextval('auditor.actor_usr_address_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.valid, OLD.within_city_limits, OLD.address_type, OLD.usr, OLD.street1, OLD.street2, OLD.city, OLD.county, OLD.state, OLD.country, OLD.post_code, OLD.pending, OLD.replaces
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_address_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_actor_usr_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, card, profile, usrname, email, passwd, standing, ident_type, ident_value, ident_type2, ident_value2, net_access_level, photo_url, prefix, first_given_name, second_given_name, family_name, suffix, alias, day_phone, evening_phone, other_phone, mailing_address, billing_address, home_ou, dob, active, master_account, super_user, barred, deleted, juvenile, usrgroup, claims_returned_count, credit_forward_balance, last_xact_id, alert_message, create_date, expire_date, claims_never_checked_out_count, last_update_time )
                SELECT  nextval('auditor.actor_usr_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.card, OLD.profile, OLD.usrname, OLD.email, OLD.passwd, OLD.standing, OLD.ident_type, OLD.ident_value, OLD.ident_type2, OLD.ident_value2, OLD.net_access_level, OLD.photo_url, OLD.prefix, OLD.first_given_name, OLD.second_given_name, OLD.family_name, OLD.suffix, OLD.alias, OLD.day_phone, OLD.evening_phone, OLD.other_phone, OLD.mailing_address, OLD.billing_address, OLD.home_ou, OLD.dob, OLD.active, OLD.master_account, OLD.super_user, OLD.barred, OLD.deleted, OLD.juvenile, OLD.usrgroup, OLD.claims_returned_count, OLD.credit_forward_balance, OLD.last_xact_id, OLD.alert_message, OLD.create_date, OLD.expire_date, OLD.claims_never_checked_out_count, OLD.last_update_time
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_setting_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_actor_usr_setting_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_setting_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, usr, name, value )
                SELECT  nextval('auditor.actor_usr_setting_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.usr, OLD.name, OLD.value
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_setting_func() OWNER TO evergreen;

--
-- Name: audit_asset_call_number_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_asset_call_number_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_call_number_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, create_date, editor, edit_date, record, owning_lib, label, deleted, label_class, label_sortkey, prefix, suffix )
                SELECT  nextval('auditor.asset_call_number_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.creator, OLD.create_date, OLD.editor, OLD.edit_date, OLD.record, OLD.owning_lib, OLD.label, OLD.deleted, OLD.label_class, OLD.label_sortkey, OLD.prefix, OLD.suffix
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_call_number_func() OWNER TO evergreen;

--
-- Name: audit_asset_copy_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_asset_copy_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_copy_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, mint_condition, cost, active_date )
                SELECT  nextval('auditor.asset_copy_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.mint_condition, OLD.cost, OLD.active_date
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_copy_func() OWNER TO evergreen;

--
-- Name: audit_biblio_record_entry_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_biblio_record_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
INSERT INTO auditor.biblio_record_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, editor, source, quality, create_date, edit_date, active, deleted, fingerprint, tcn_source, tcn_value, marc, last_xact_id, owner, share_depth, cataloging_date )
SELECT nextval('auditor.biblio_record_entry_pkey_seq'),
now(),
SUBSTR(TG_OP,1,1),
eg_user,
eg_ws,
OLD.id, OLD.creator, OLD.editor, OLD.source, OLD.quality, OLD.create_date, OLD.edit_date, OLD.active, OLD.deleted, OLD.fingerprint, OLD.tcn_source, OLD.tcn_value, OLD.marc, OLD.last_xact_id, OLD.owner, OLD.share_depth, OLD.cataloging_date
FROM auditor.get_audit_info();
RETURN NULL;
END;
$$;


ALTER FUNCTION auditor.audit_biblio_record_entry_func() OWNER TO evergreen;

--
-- Name: audit_serial_unit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION audit_serial_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.serial_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, mint_condition, cost, sort_key, detailed_contents, summary_contents, active_date )
                SELECT  nextval('auditor.serial_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.mint_condition, OLD.cost, OLD.sort_key, OLD.detailed_contents, OLD.summary_contents, OLD.active_date
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_serial_unit_func() OWNER TO evergreen;

--
-- Name: clear_audit_info(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION clear_audit_info() RETURNS void
    LANGUAGE plperlu
    AS $_X$
    delete($_SHARED{"eg_audit_user"});
    delete($_SHARED{"eg_audit_ws"});
$_X$;


ALTER FUNCTION auditor.clear_audit_info() OWNER TO evergreen;

--
-- Name: create_auditor(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM auditor.create_auditor_seq(sch, tbl);
    PERFORM auditor.create_auditor_history(sch, tbl);
    PERFORM auditor.create_auditor_func(sch, tbl);
    PERFORM auditor.create_auditor_update_trigger(sch, tbl);
    PERFORM auditor.create_auditor_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION auditor.create_auditor(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_func(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE OR REPLACE FUNCTION auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO auditor.$$ || sch || $$_$$ || tbl || $$_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, $$
            || array_to_string(column_list, ', ') || $$ )
                SELECT  nextval('auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.$$ || array_to_string(column_list, ', OLD.') || $$
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_func(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_history(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE auditor.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            audit_user  INT,
            audit_ws    INT,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_history(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_lifecycle(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE VIEW auditor.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT -1 AS audit_id,
                   now() AS audit_time,
                   '-' AS audit_action,
                   -1 AS audit_user,
                   -1 AS audit_ws,
                   $$ || array_to_string(column_list, ', ') || $$
              FROM $$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT audit_id, audit_time, audit_action, audit_user, audit_ws,
            $$ || array_to_string(column_list, ', ') || $$
              FROM auditor.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_lifecycle(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_seq(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_seq(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_update_trigger(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION create_auditor_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_update_trigger(sch text, tbl text) OWNER TO evergreen;

--
-- Name: fix_columns(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION fix_columns() RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    current_table TEXT = ''; -- Storage for post-loop main table name
    current_audit_table TEXT = ''; -- Storage for post-loop audit table name
    query TEXT = ''; -- Storage for built query
    cr RECORD; -- column record object
    alter_t BOOL = false; -- Has the alter table command been appended yet
    auditor_cores TEXT[] = ARRAY[]::TEXT[]; -- Core auditor function list (filled inside of loop)
    core_column TEXT; -- The current core column we are adding
BEGIN
    FOR cr IN
        WITH audit_tables AS ( -- Basic grab of auditor tables. Anything in the auditor namespace, basically. With oids.
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS ( -- Union of auditor tables with their "main" tables. With oids.
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        ),
        column_lists AS ( -- All columns associated with the auditor or main table, grouped by the main table's oid.
            SELECT DISTINCT ON (main_oid, attname) t.main_oid, a.attname
            FROM table_set t
            JOIN pg_catalog.pg_attribute a ON a.attrelid IN (t.main_oid, t.audit_oid)
            WHERE attnum > 0 AND NOT attisdropped
        ),
        column_defs AS ( -- The motherload, every audit table and main table plus column names and defs.
            SELECT audit_table,
                   main_namespace,
                   main_table,
                   a.attname AS main_column, -- These two will be null for columns that have since been deleted, or for auditor core columns
                   pg_catalog.format_type(a.atttypid, a.atttypmod) AS main_column_def,
                   b.attname AS audit_column, -- These two will be null for columns that have since been added
                   pg_catalog.format_type(b.atttypid, b.atttypmod) AS audit_column_def
            FROM table_set t
            JOIN column_lists c USING (main_oid)
            LEFT JOIN pg_catalog.pg_attribute a ON a.attname = c.attname AND a.attrelid = t.main_oid AND a.attnum > 0 AND NOT a.attisdropped
            LEFT JOIN pg_catalog.pg_attribute b ON b.attname = c.attname AND b.attrelid = t.audit_oid AND b.attnum > 0 AND NOT b.attisdropped
        )
        -- Nice sorted output from the above
        SELECT * FROM column_defs WHERE main_column_def IS DISTINCT FROM audit_column_def ORDER BY main_namespace, main_table, main_column, audit_column
    LOOP
        IF current_table <> (cr.main_namespace || '.' || cr.main_table) THEN -- New table?
            FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Update missing core auditor columns
                IF NOT alter_t THEN -- Add ALTER TABLE if we haven't already
                    query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                    alter_t:=TRUE;
                ELSE
                    query:=query || $$,$$;
                END IF;
                -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
                query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
            END LOOP;
            IF alter_t THEN -- Open alter table = needs a semicolon
                query:=query || $$; $$;
                alter_t:=FALSE;
                IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
                    -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
                    -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
                    EXECUTE query;
                    EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                        $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
                    EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                        $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
                    query:='';
                END IF;
            END IF;
            -- New table means we reset the list of needed auditor core columns
            auditor_cores = ARRAY['audit_id bigint', 'audit_time timestamp with time zone', 'audit_action text', 'audit_user integer', 'audit_ws integer'];
            -- And store some values for use later, because we can't rely on cr in all places.
            current_table:=cr.main_namespace || '.' || cr.main_table;
            current_audit_table:=cr.audit_table;
        END IF;
        IF cr.main_column IS NULL AND cr.audit_column LIKE 'audit_%' THEN -- Core auditor column?
            -- Remove core from list of cores
            SELECT INTO auditor_cores array_agg(core) FROM unnest(auditor_cores) AS core WHERE core != (cr.audit_column || ' ' || cr.audit_column_def);
        ELSIF cr.main_column IS NULL THEN -- Main column doesn't exist, and it isn't an auditor column. Needs dropping from the auditor.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ DROP COLUMN $$ || cr.audit_column;
        ELSIF cr.audit_column IS NULL AND cr.main_column IS NOT NULL THEN -- New column auditor doesn't have. Add it.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ADD COLUMN $$ || cr.main_column || $$ $$ || cr.main_column_def;
        ELSIF cr.main_column IS NOT NULL AND cr.audit_column IS NOT NULL THEN -- Both sides have this column, but types differ. Fix that.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ALTER COLUMN $$ || cr.audit_column || $$ TYPE $$ || cr.main_column_def;
        END IF;
    END LOOP;
    FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Repeat this outside of the loop to catch the last table
        IF NOT alter_t THEN
            query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
            alter_t:=TRUE;
        ELSE
            query:=query || $$,$$;
        END IF;
        -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
        query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
    END LOOP;
    IF alter_t THEN -- Open alter table = needs a semicolon
        query:=query || $$;$$;
        IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
            -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
            -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
            EXECUTE query;
            EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
            EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
            query:='';
        END IF;
    END IF;
    EXECUTE query;
END;
$_X$;


ALTER FUNCTION auditor.fix_columns() OWNER TO evergreen;

--
-- Name: get_audit_info(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION get_audit_info() RETURNS TABLE(eg_user integer, eg_ws integer)
    LANGUAGE plperlu
    AS $_X$
    return [{eg_user => $_SHARED{"eg_audit_user"}, eg_ws => $_SHARED{"eg_audit_ws"}}];
$_X$;


ALTER FUNCTION auditor.get_audit_info() OWNER TO evergreen;

--
-- Name: set_audit_info(integer, integer); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION set_audit_info(integer, integer) RETURNS void
    LANGUAGE plperlu
    AS $_X$
    $_SHARED{"eg_audit_user"} = $_[0];
    $_SHARED{"eg_audit_ws"} = $_[1];
$_X$;


ALTER FUNCTION auditor.set_audit_info(integer, integer) OWNER TO evergreen;

--
-- Name: update_auditors(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION update_auditors() RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
    auditor_name TEXT;
    table_schema TEXT;
    table_name TEXT;
BEGIN
    -- Drop Lifecycle view(s) before potential column changes
    FOR auditor_name IN
        SELECT c.relname
            FROM pg_catalog.pg_class c
                JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind = 'v' AND n.nspname = 'auditor' LOOP
        EXECUTE $$ DROP VIEW auditor.$$ || auditor_name || $$;$$;
    END LOOP;
    -- Fix all column discrepencies
    PERFORM auditor.fix_columns();
    -- Re-create trigger functions and lifecycle views
    FOR table_schema, table_name IN
        WITH audit_tables AS (
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS (
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        )
        SELECT main_namespace, main_table FROM table_set LOOP
        
        PERFORM auditor.create_auditor_func(table_schema, table_name);
        PERFORM auditor.create_auditor_lifecycle(table_schema, table_name);
    END LOOP;
    RETURN TRUE;
END;
$_$;


ALTER FUNCTION auditor.update_auditors() OWNER TO evergreen;

SET search_path = authority, pg_catalog;

--
-- Name: atag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_authority_tags(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(id) FROM authority.control_set_authority_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.atag_authority_tags(atag text) OWNER TO evergreen;

--
-- Name: atag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_authority_tags_refs(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT  ARRAY_CAT(
                ARRAY[a.id],
                (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.id)
            )
      FROM  authority.control_set_authority_field a
      WHERE a.tag = $1
$_$;


ALTER FUNCTION authority.atag_authority_tags_refs(atag text) OWNER TO evergreen;

--
-- Name: atag_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_center(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_top(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_heading(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_rank(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: atag_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION atag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.atag_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_authority_tags(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(field) FROM authority.browse_axis_authority_field_map WHERE axis = $1;
$_$;


ALTER FUNCTION authority.axis_authority_tags(a text) OWNER TO evergreen;

--
-- Name: axis_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_authority_tags_refs(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT  ARRAY_CAT(
                ARRAY[a.field],
                (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.field)
            )
      FROM  authority.browse_axis_authority_field_map a
      WHERE axis = $1
$_$;


ALTER FUNCTION authority.axis_authority_tags_refs(a text) OWNER TO evergreen;

--
-- Name: axis_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_center(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_top(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_heading(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_rank(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: axis_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION axis_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.axis_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_authority_tags(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_ACCUM(authority_field) FROM authority.control_set_bib_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.btag_authority_tags(btag text) OWNER TO evergreen;

--
-- Name: btag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_authority_tags_refs(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT  ARRAY_CAT(
                ARRAY[a.authority_field],
                (SELECT ARRAY_ACCUM(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.authority_field)
            )
      FROM  authority.control_set_bib_field a
      WHERE a.tag = $1
$_$;


ALTER FUNCTION authority.btag_authority_tags_refs(btag text) OWNER TO evergreen;

--
-- Name: btag_browse_center(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_center(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_browse_center_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_center_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_browse_top(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_top(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_browse_top_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_browse_top_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_search_heading(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_heading(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_search_heading_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_heading_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_search_rank(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_rank(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: btag_search_rank_refs(text, text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION btag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags_refs($1), $2, $3, $4)
$_$;


ALTER FUNCTION authority.btag_search_rank_refs(a text, q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: authority_linking; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE authority_linking (
    id bigint NOT NULL,
    source bigint NOT NULL,
    target bigint NOT NULL,
    field integer NOT NULL
);


ALTER TABLE authority.authority_linking OWNER TO evergreen;

--
-- Name: calculate_authority_linking(bigint, integer, xml); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION calculate_authority_linking(rec_id bigint, rec_control_set integer, rec_marc_xml xml) RETURNS SETOF authority_linking
    LANGUAGE plpgsql
    AS $_$
DECLARE
    acsaf       authority.control_set_authority_field%ROWTYPE;
    link        TEXT;
    aal         authority.authority_linking%ROWTYPE;
BEGIN
    -- ver s
    IF rec_control_set IS NULL THEN
        -- No control_set on record?  Guess at one
        SELECT control_set INTO rec_control_set
            FROM authority.control_set_authority_field
            WHERE tag IN (
                SELECT UNNEST(
                    XPATH('//*[starts-with(@tag,"1")]/@tag',rec_marc_xml)::TEXT[]
                )
            ) LIMIT 1;

        IF NOT FOUND THEN
            RAISE WARNING 'Could not even guess at control set for authority record %', rec_id;
            RETURN;
        END IF;
    END IF;

    aal.source := rec_id;

    FOR acsaf IN
        SELECT * FROM authority.control_set_authority_field
        WHERE control_set = rec_control_set
            AND linking_subfield IS NOT NULL
            AND main_entry IS NOT NULL
    LOOP
        -- Loop over the trailing-number contents of all linking subfields
        FOR link IN
            SELECT  SUBSTRING( x::TEXT, '\d+$' )
              FROM  UNNEST(
                        XPATH(
                            '//*[@tag="'
                                || acsaf.tag
                                || '"]/*[@code="'
                                || acsaf.linking_subfield
                                || '"]/text()',
                            rec_marc_xml
                        )
                    ) x
        LOOP

            -- Ignore links that are null, malformed, circular, or point to
            -- non-existent authority records.
            IF link IS NOT NULL AND link::BIGINT <> rec_id THEN
                PERFORM * FROM authority.record_entry WHERE id = link::BIGINT;
                IF FOUND THEN
                    aal.target := link::BIGINT;
                    aal.field := acsaf.id;
                    RETURN NEXT aal;
                END IF;
            END IF;
        END LOOP;
    END LOOP;
END;
$_$;


ALTER FUNCTION authority.calculate_authority_linking(rec_id bigint, rec_control_set integer, rec_marc_xml xml) OWNER TO evergreen;

--
-- Name: full_rec; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE full_rec (
    id bigint NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL,
    sort_value text
);


ALTER TABLE authority.full_rec OWNER TO evergreen;

--
-- Name: flatten_marc(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION flatten_marc(text) RETURNS SETOF full_rec
    LANGUAGE plperlu
    AS $_$

use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;

MARC::Charset->assume_unicode(1);

my $xml = shift;
my $r = MARC::Record->new_from_xml( $xml );

return_next( { tag => 'LDR', value => $r->leader } );

for my $f ( $r->fields ) {
    if ($f->is_control_field) {
        return_next({ tag => $f->tag, value => $f->data });
    } else {
        for my $s ($f->subfields) {
            return_next({
                tag      => $f->tag,
                ind1     => $f->indicator(1),
                ind2     => $f->indicator(2),
                subfield => $s->[0],
                value    => $s->[1]
            });

        }
    }
}

return undef;

$_$;


ALTER FUNCTION authority.flatten_marc(text) OWNER TO evergreen;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION flatten_marc(rid bigint) RETURNS SETOF full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
    auth    authority.record_entry%ROWTYPE;
    output  authority.full_rec%ROWTYPE;
    field   RECORD;
BEGIN
    SELECT INTO auth * FROM authority.record_entry WHERE id = rid;

    FOR field IN SELECT * FROM vandelay.flatten_marc( auth.marc ) LOOP
        output.record := rid;
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        output.value := field.value;
        output.sort_value := naco_normalize(field.value);

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION authority.flatten_marc(rid bigint) OWNER TO evergreen;

--
-- Name: generate_overlay_template(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION generate_overlay_template(bigint) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT authority.generate_overlay_template( marc ) FROM authority.record_entry WHERE id = $1;
$_$;


ALTER FUNCTION authority.generate_overlay_template(bigint) OWNER TO evergreen;

--
-- Name: generate_overlay_template(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION generate_overlay_template(source_xml text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    cset                INT;
    main_entry          authority.control_set_authority_field%ROWTYPE;
    bib_field           authority.control_set_bib_field%ROWTYPE;
    auth_id             INT DEFAULT oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', source_xml)::INT;
    tmp_data            XML;
    replace_data        XML[] DEFAULT '{}'::XML[];
    replace_rules       TEXT[] DEFAULT '{}'::TEXT[];
    auth_field          XML[];
    auth_i1             TEXT;
    auth_i2             TEXT;
BEGIN
    IF auth_id IS NULL THEN
        RETURN NULL;
    END IF;

    -- Default to the LoC controll set
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    -- if none, make a best guess
    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN (
                    SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marc::XML)::TEXT[])
                      FROM  authority.record_entry
                      WHERE id = auth_id
                )
          LIMIT 1;
    END IF;

    -- if STILL none, no-op change
    IF cset IS NULL THEN
        RETURN XMLELEMENT(
            name record,
            XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
            XMLELEMENT( name leader, '00881nam a2200193   4500'),
            XMLELEMENT(
                name datafield,
                XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
                XMLELEMENT(
                    name subfield,
                    XMLATTRIBUTES('d' AS code),
                    '901c'
                )
            )
        )::TEXT;
    END IF;

    FOR main_entry IN SELECT * FROM authority.control_set_authority_field acsaf WHERE acsaf.control_set = cset AND acsaf.main_entry IS NULL LOOP
        auth_field := XPATH('//*[@tag="'||main_entry.tag||'"][1]',source_xml::XML);
        auth_i1 = (XPATH('@ind1',auth_field[1]))[1];
        auth_i2 = (XPATH('@ind2',auth_field[1]))[1];
        IF ARRAY_LENGTH(auth_field,1) > 0 THEN
            FOR bib_field IN SELECT * FROM authority.control_set_bib_field WHERE authority_field = main_entry.id LOOP
                SELECT XMLELEMENT( -- XMLAGG avoids magical <element> creation, but requires unnest subquery
                    name datafield,
                    XMLATTRIBUTES(bib_field.tag AS tag, auth_i1 AS ind1, auth_i2 AS ind2),
                    XMLAGG(UNNEST)
                ) INTO tmp_data FROM UNNEST(XPATH('//*[local-name()="subfield"]', auth_field[1]));
                replace_data := replace_data || tmp_data;
                replace_rules := replace_rules || ( bib_field.tag || main_entry.sf_list || E'[0~\\)' || auth_id || '$]' );
                tmp_data = NULL;
            END LOOP;
            EXIT;
        END IF;
    END LOOP;

    SELECT XMLAGG(UNNEST) INTO tmp_data FROM UNNEST(replace_data);

    RETURN XMLELEMENT(
        name record,
        XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
        XMLELEMENT( name leader, '00881nam a2200193   4500'),
        tmp_data,
        XMLELEMENT(
            name datafield,
            XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
            XMLELEMENT(
                name subfield,
                XMLATTRIBUTES('r' AS code),
                ARRAY_TO_STRING(replace_rules,',')
            )
        )
    )::TEXT;
END;
$_$;


ALTER FUNCTION authority.generate_overlay_template(source_xml text) OWNER TO evergreen;

--
-- Name: generate_overlay_template(text, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION generate_overlay_template(text, bigint) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;

    MARC::Charset->assume_unicode(1);

    my $xml = shift;
    my $r = MARC::Record->new_from_xml( $xml );

    return undef unless ($r);

    my $id = shift() || $r->subfield( '901' => 'c' );
    $id =~ s/^\s*(?:\([^)]+\))?\s*(.+)\s*?$/$1/;
    return undef unless ($id); # We need an ID!

    my $tmpl = MARC::Record->new();
    $tmpl->encoding( 'UTF-8' );

    my @rule_fields;
    for my $field ( $r->field( '1..' ) ) { # Get main entry fields from the authority record

        my $tag = $field->tag;
        my $i1 = $field->indicator(1);
        my $i2 = $field->indicator(2);
        my $sf = join '', map { $_->[0] } $field->subfields;
        my @data = map { @$_ } $field->subfields;

        my @replace_them;

        # Map the authority field to bib fields it can control.
        if ($tag >= 100 and $tag <= 111) {       # names
            @replace_them = map { $tag + $_ } (0, 300, 500, 600, 700);
        } elsif ($tag eq '130') {                # uniform title
            @replace_them = qw/130 240 440 730 830/;
        } elsif ($tag >= 150 and $tag <= 155) {  # subjects
            @replace_them = ($tag + 500);
        } elsif ($tag >= 180 and $tag <= 185) {  # floating subdivisions
            @replace_them = qw/100 400 600 700 800 110 410 610 710 810 111 411 611 711 811 130 240 440 730 830 650 651 655/;
        } else {
            next;
        }

        # Dummy up the bib-side data
        $tmpl->append_fields(
            map {
                MARC::Field->new( $_, $i1, $i2, @data )
            } @replace_them
        );

        # Construct some 'replace' rules
        push @rule_fields, map { $_ . $sf . '[0~\)' .$id . '$]' } @replace_them;
    }

    # Insert the replace rules into the template
    $tmpl->append_fields(
        MARC::Field->new( '905' => ' ' => ' ' => 'r' => join(',', @rule_fields ) )
    );

    $xml = $tmpl->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;

    return $xml;

$_X$;


ALTER FUNCTION authority.generate_overlay_template(text, bigint) OWNER TO evergreen;

--
-- Name: get_5xx_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION get_5xx_heading(w_subfield text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes a w subfield as input.  It returns the heading to be displayed for the
--  reference.  The headings are stored in authority.display_5xx_headings.
--  The current version only looks at the first position (0) of the w subfield.  It then looks
--  in authority.display_5xx_headings for a match and returns that heading.  If no match is found
--  it selects from authority.display_5xx_headings where w subfield position 0 is null, which is 
--  the default 5xx heading.  (See Also)
--
--  The table is built to be expandable for the future and this function could be modified to check
--  more positions.
DECLARE
     subfield_0	text;
     return_heading text;
BEGIN
     SELECT substring(w_subfield FROM '.') INTO subfield_0;

     SELECT heading INTO return_heading
     FROM authority.display_5xx_headings
     WHERE w_subfield_0 = subfield_0;

     IF return_heading IS NULL THEN
	SELECT heading INTO return_heading
	FROM authority.display_5xx_headings
	WHERE w_subfield_0 IS NULL;
     END IF;
	
     RETURN return_heading;
END;    
$$;


ALTER FUNCTION authority.get_5xx_heading(w_subfield text) OWNER TO evergreen;

--
-- Name: heading_changed(text, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION heading_changed(old_marc text, new_marc text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
  old_heading text;
  new_heading text;
BEGIN
     -- Grab the 1XX field of each authority marc.
     old_heading := substring(old_marc from '<datafield tag="1[0-9][0-9]".*?</datafield>');
     new_heading := substring(new_marc from '<datafield tag="1[0-9][0-9]".*?</datafield>');
     
     IF old_heading = new_heading THEN
         RETURN FALSE;
     ELSE
         RETURN TRUE;
     END IF;

  END $$;


ALTER FUNCTION authority.heading_changed(old_marc text, new_marc text) OWNER TO evergreen;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    ashs    authority.simple_heading%ROWTYPE;
    mbe_row metabib.browse_entry%ROWTYPE;
    mbe_id  BIGINT;
    ash_id  BIGINT;
    search_class text;
    field_id integer;
    are_row authority.record_entry%ROWTYPE;
    bre_row biblio.record_entry%ROWTYPE;
BEGIN
    --ver 2.1 KMAIN-1119
    IF NEW.deleted IS TRUE THEN -- If this authority is deleted
        -- Remove the actual linking subfields present in
        -- marc bib records that is controlled by this one
         FOR bre_row IN SELECT * FROM biblio.record_entry bre
             INNER JOIN authority.bib_linking abl
             ON bre.id = abl.bib AND abl.authority = NEW.id LOOP

             UPDATE biblio.record_entry
             SET marc = (SELECT regexp_replace(bre_row.marc,E'<subfield[^>]*?code="0">\\([A-Z]+\\)' || NEW.id || '</subfield>','','g'))
             WHERE id = bre_row.id;

         END LOOP;
        DELETE FROM authority.bib_linking WHERE authority = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM authority.full_rec WHERE record = NEW.id; -- Avoid validating fields against deleted authority records
        DELETE FROM authority.simple_heading WHERE record = NEW.id;
        -- Remove the actual linking subfields present in
        -- authority records that target this one
         FOR are_row IN SELECT * FROM authority.record_entry auth
             INNER JOIN authority.authority_linking aal
             ON auth.id = aal.source AND aal.target = NEW.id LOOP

             UPDATE authority.record_entry
             SET marc = (SELECT regexp_replace(are_row.marc,E'<subfield[^>]*?code="0">\\([A-Z]+\\)' || NEW.id || '</subfield>','','g'))
             WHERE id = are_row.id;

         END LOOP;
        DELETE FROM authority.authority_linking
            WHERE source = NEW.id OR target = NEW.id;

        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;

        -- KMAIN-1521
        -- Did the authority heading change? No need to propagate to bibs if the heading did not change
		IF authority.heading_changed(OLD.marc, NEW.marc) THEN
            -- Propagate these updates to any linked bib records
            PERFORM authority.propagate_changes(NEW.id) FROM authority.record_entry WHERE id = NEW.id;
        END IF;
        
        DELETE FROM authority.simple_heading WHERE record = NEW.id;
        DELETE FROM authority.authority_linking WHERE source = NEW.id;
    END IF;

    INSERT INTO authority.authority_linking (source, target, field)
        SELECT source, target, field FROM authority.calculate_authority_linking(
            NEW.id, NEW.control_set, NEW.marc::XML
        );

    FOR ashs IN SELECT * FROM authority.simple_heading_set(NEW.marc) LOOP

        -- Get the search_class
        SELECT INTO search_class, field_id cmf.field_class, cmf.id
            FROM authority.control_set_auth_field_metabib_field_map_refs AS acsafmfmr
            JOIN config.metabib_field AS cmf
            ON acsafmfmr.metabib_field = cmf.id
            WHERE acsafmfmr.authority_field = ashs.atag;

        INSERT INTO authority.simple_heading (record,atag,value,sort_value)
            VALUES (ashs.record, ashs.atag, ashs.value, ashs.sort_value);

        ash_id := CURRVAL('authority.simple_heading_id_seq'::REGCLASS);

        -- CASE statement switches on search_class to use the correct browse table (author, series, subject, title)
        CASE search_class
            WHEN 'author' THEN
                SELECT INTO mbe_row * FROM metabib.browse_author_entry
                    WHERE sort_value = ashs.sort_value
                    ORDER BY id;

                IF FOUND THEN
                    mbe_id := mbe_row.id;
                ELSE
                    INSERT INTO metabib.browse_author_entry
                        ( value, sort_value, truncated_sort_value ) VALUES
                        ( ashs.value, ashs.sort_value, substr(ashs.sort_value, 1, 2700) );

                    mbe_id := CURRVAL('metabib.browse_author_entry_id_seq'::REGCLASS);
                END IF;

                INSERT INTO metabib.browse_author_entry_simple_heading_map (entry,simple_heading) VALUES (mbe_id,ash_id);

            WHEN 'series' THEN
                SELECT INTO mbe_row * FROM metabib.browse_series_entry
                    WHERE sort_value = ashs.sort_value
                    ORDER BY id;

                IF FOUND THEN
                    mbe_id := mbe_row.id;
                ELSE
                    INSERT INTO metabib.browse_series_entry
                        ( value, sort_value, truncated_sort_value ) VALUES
                        ( ashs.value, ashs.sort_value, substr(ashs.sort_value, 1, 2700) );

                    mbe_id := CURRVAL('metabib.browse_series_entry_id_seq'::REGCLASS);
                END IF;

                INSERT INTO metabib.browse_series_entry_simple_heading_map (entry,simple_heading) VALUES (mbe_id,ash_id);

            WHEN 'subject' THEN
                SELECT INTO mbe_row * FROM metabib.browse_subject_entry
                    WHERE sort_value = ashs.sort_value
                    ORDER BY id;

                IF FOUND THEN
                    mbe_id := mbe_row.id;
                ELSE
                    INSERT INTO metabib.browse_subject_entry
                        ( value, sort_value, truncated_sort_value ) VALUES
                        ( ashs.value, ashs.sort_value, substr(ashs.sort_value, 1, 2700) );

                    mbe_id := CURRVAL('metabib.browse_subject_entry_id_seq'::REGCLASS);
                END IF;

                INSERT INTO metabib.browse_subject_entry_simple_heading_map (entry,simple_heading) VALUES (mbe_id,ash_id);

            WHEN 'title' THEN
                SELECT INTO mbe_row * FROM metabib.browse_title_entry
                    WHERE sort_value = ashs.sort_value
                    ORDER BY id;

                IF FOUND THEN
                    mbe_id := mbe_row.id;
                ELSE
                    INSERT INTO metabib.browse_title_entry
                        ( value, sort_value, truncated_sort_value ) VALUES
                        ( ashs.value, ashs.sort_value, substr(ashs.sort_value, 1, 2700) );

                    mbe_id := CURRVAL('metabib.browse_title_entry_id_seq'::REGCLASS);
                END IF;

                INSERT INTO metabib.browse_title_entry_simple_heading_map (entry,simple_heading) VALUES (mbe_id,ash_id);

            ELSE
                -- mainly to handle when search_class is 'keyword'
        END CASE;

    END LOOP;

    -- Flatten and insert the afr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM authority.reingest_authority_full_rec(NEW.id);
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            PERFORM authority.reingest_authority_rec_descriptor(NEW.id);
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION authority.indexing_ingest_or_delete() OWNER TO evergreen;

--
-- Name: map_thesaurus_to_control_set(); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION map_thesaurus_to_control_set() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.control_set IS NULL THEN
        SELECT  control_set INTO NEW.control_set
          FROM  authority.thesaurus
          WHERE vandelay.marc21_extract_fixed_field(NEW.marc,'Subj') = code;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION authority.map_thesaurus_to_control_set() OWNER TO evergreen;

--
-- Name: merge_records(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION merge_records(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    moved_objects INT := 0;
    bib_id        INT := 0;
    bib_rec       biblio.record_entry%ROWTYPE;
    auth_link     authority.bib_linking%ROWTYPE;
    ingest_same   boolean;
BEGIN

    -- Defining our terms:
    -- "target record" = the record that will survive the merge
    -- "source record" = the record that is sacrifing its existence and being
    --   replaced by the target record

    -- 1. Update all bib records with the ID from target_record in their $0
    FOR bib_rec IN SELECT bre.* FROM biblio.record_entry bre
      INNER JOIN authority.bib_linking abl ON abl.bib = bre.id
      WHERE abl.authority = source_record LOOP

        UPDATE biblio.record_entry
          SET marc = REGEXP_REPLACE(marc,
            E'(<subfield\\s+code="0"\\s*>[^<]*?\\))' || source_record || '<',
            E'\\1' || target_record || '<', 'g')
          WHERE id = bib_rec.id;

          moved_objects := moved_objects + 1;
    END LOOP;

    -- 2. Grab the current value of reingest on same MARC flag
    SELECT enabled INTO ingest_same
      FROM config.internal_flag
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 3. Temporarily set reingest on same to TRUE
    UPDATE config.internal_flag
      SET enabled = TRUE
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 4. Make a harmless update to target_record to trigger auto-update
    --    in linked bibliographic records
    UPDATE authority.record_entry
      SET deleted = FALSE
      WHERE id = target_record;

    -- 5. "Delete" source_record
    DELETE FROM authority.record_entry
      WHERE id = source_record;

    -- 6. Set "reingest on same MARC" flag back to initial value
    UPDATE config.internal_flag
      SET enabled = ingest_same
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    RETURN moved_objects;
END;
$_$;


ALTER FUNCTION authority.merge_records(target_record bigint, source_record bigint) OWNER TO evergreen;

--
-- Name: normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT authority.normalize_heading($1, FALSE);
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text) OWNER TO evergreen;

--
-- Name: FUNCTION normalize_heading(marcxml text); Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON FUNCTION normalize_heading(marcxml text) IS '
/**
* Extract the authority heading, thesaurus, and NACO-normalized values
* from an authority record. The primary purpose is to build a unique
* index to defend against duplicated authority records from the same
* thesaurus.
*/
';


--
-- Name: normalize_heading(text, boolean); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION normalize_heading(marcxml text, no_thesaurus boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    sf_node         TEXT;
    tag_node        TEXT;
    thes_code       TEXT;
    cset            INT;
    heading_text    TEXT;
    tmp_text        TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN
    --ver1.0
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    thes_code := vandelay.marc21_extract_fixed_field(marcxml,'Subj');
    IF thes_code IS NULL THEN
        thes_code := '|';
    ELSIF thes_code = 'z' THEN
        thes_code := COALESCE( oils_xpath_string('//*[@tag="040"]/*[@code="f"][1]', marcxml), '' );
    END IF;

    heading_text := '';
    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset AND main_entry IS NULL LOOP
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        first_sf := TRUE;

        FOR tag_node IN SELECT unnest(oils_xpath('//*[@tag="'||tag_used||'"]',marcxml)) LOOP
            FOR sf_node IN SELECT unnest(oils_xpath('./*[contains("'||acsaf.sf_list||'",@code)]',tag_node)) LOOP

                tmp_text := oils_xpath_string('.', sf_node);
                sf := oils_xpath_string('./@code', sf_node);

                IF first_sf AND tmp_text IS NOT NULL AND nfi_used IS NOT NULL THEN

                    tmp_text := SUBSTRING(
                        tmp_text FROM
                        COALESCE(
                            NULLIF(
                                REGEXP_REPLACE(
                                    oils_xpath_string('./@ind'||nfi_used, tag_node),
                                    $$\D+$$,
                                    '',
                                    'g'
                                ),
                                ''
                            )::INT,
                            0
                        ) + 1
                    );

                END IF;

                first_sf := FALSE;

                IF tmp_text IS NOT NULL AND tmp_text <> '' THEN
                    heading_text := heading_text || E'\u2021' || sf || ' ' || tmp_text;
                END IF;
            END LOOP;

            EXIT WHEN heading_text <> '';
        END LOOP;

        EXIT WHEN heading_text <> '';
    END LOOP;

    IF heading_text <> '' THEN
        IF no_thesaurus IS TRUE THEN
            heading_text := tag_used || ' ' || public.naco_normalize(heading_text);
        ELSE
            heading_text := tag_used || '_' || COALESCE(nfi_used,'-') || '_' || thes_code || ' ' || public.naco_normalize(heading_text);
        END IF;
    ELSE
        heading_text := 'NOHEADING_' || thes_code || ' ' || MD5(marcxml);
    END IF;

    RETURN heading_text;
END;
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text, no_thesaurus boolean) OWNER TO evergreen;

--
-- Name: ongoing_generate_auth_ids_for_auth_to_auth_given_date(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION ongoing_generate_auth_ids_for_auth_to_auth_given_date(import_date text) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    base_ids          	BIGINT[];
    base_one		BIGINT;
    base_query	        TEXT;
    results_cursor	REFCURSOR;
    add_query		TEXT;
    auths               BIGINT[];
    linked_auths	BIGINT[];

BEGIN
    -- ver 1.0 - KMAIN-1113

    -- Generate a list of auth records that have been modified or created on the given day.
    base_query := 'SELECT COALESCE(ARRAY_AGG(id), ARRAY[]::BIGINT[]) FROM authority.record_entry WHERE edit_date BETWEEN ''' || import_date || ' 00:00:00-07'' AND ''' || import_date || ' 23:59:59-07'' AND NOT deleted';   

    OPEN results_cursor FOR EXECUTE base_query;
    FETCH results_cursor INTO base_ids;

    auths := base_ids;

    FOREACH base_one IN ARRAY base_ids
    LOOP
        -- Find the auth id's that should link with the given auth id
        SELECT * INTO linked_auths FROM  authority.unlinked_auths_to_given_auth_id(base_one);
        -- Combine newly found auth id's (linked_auths) to previously found ones (auths)
        SELECT INTO auths ARRAY( SELECT unnest(auths) AS e UNION SELECT unnest(linked_auths) AS e ORDER BY e);
    END LOOP;

    RETURN QUERY SELECT unnest(auths);
END;
$$;


ALTER FUNCTION authority.ongoing_generate_auth_ids_for_auth_to_auth_given_date(import_date text) OWNER TO evergreen;

--
-- Name: propagate_changes(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION propagate_changes(aid bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT authority.propagate_changes( authority, bib ) FROM authority.bib_linking WHERE authority = $1;
$_$;


ALTER FUNCTION authority.propagate_changes(aid bigint) OWNER TO evergreen;

--
-- Name: propagate_changes(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION propagate_changes(aid bigint, bid bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$
    UPDATE  biblio.record_entry
      SET   marc = vandelay.merge_record_xml( marc, authority.generate_overlay_template( $1 ) )
      WHERE id = $2;
    SELECT $1;
$_$;


ALTER FUNCTION authority.propagate_changes(aid bigint, bid bigint) OWNER TO evergreen;

--
-- Name: reingest_authority_full_rec(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION reingest_authority_full_rec(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.full_rec WHERE record = auth_id;
    INSERT INTO authority.full_rec (record, tag, ind1, ind2, subfield, value, sort_value)
        SELECT record, tag, ind1, ind2, subfield, value, sort_value FROM authority.flatten_marc( auth_id );

    RETURN;
END;
$$;


ALTER FUNCTION authority.reingest_authority_full_rec(auth_id bigint) OWNER TO evergreen;

--
-- Name: reingest_authority_rec_descriptor(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION reingest_authority_rec_descriptor(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.rec_descriptor WHERE record = auth_id;
    INSERT INTO authority.rec_descriptor (record, record_status, encoding_level, thesaurus)
        SELECT  auth_id,
                vandelay.marc21_extract_fixed_field(marc,'RecStat'),
                vandelay.marc21_extract_fixed_field(marc,'ELvl'),
                vandelay.marc21_extract_fixed_field(marc,'Subj')
          FROM  authority.record_entry
          WHERE id = auth_id;
     RETURN;
 END;
 $$;


ALTER FUNCTION authority.reingest_authority_rec_descriptor(auth_id bigint) OWNER TO evergreen;

--
-- Name: simple_heading_browse_center(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_browse_center(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 9) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
    boffset             INT DEFAULT 0;
    aoffset             INT DEFAULT 0;
    blimit              INT DEFAULT 0;
    alimit              INT DEFAULT 0;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q);

    IF page = 0 THEN
        blimit := pagesize / 2;
        alimit := blimit;

        IF pagesize % 2 <> 0 THEN
            alimit := alimit + 1;
        END IF;
    ELSE
        blimit := pagesize;
        alimit := blimit;

        boffset := pagesize / 2;
        aoffset := boffset;

        IF pagesize % 2 <> 0 THEN
            boffset := boffset + 1;
        END IF;
    END IF;

    IF page <= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                  FROM  authority.simple_heading ash
                  WHERE ash.atag = ANY (atag_list)
                        AND ash.sort_value < pivot_sort_value
                  ORDER BY ash.sort_value DESC
                  LIMIT blimit
                  OFFSET ABS(page) * pagesize - boffset
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT  ash.id
              FROM  authority.simple_heading ash
              WHERE ash.atag = ANY (atag_list)
                    AND ash.sort_value >= pivot_sort_value
              ORDER BY ash.sort_value
              LIMIT alimit
              OFFSET ABS(page) * pagesize - aoffset;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_center(atag_list integer[], q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: simple_heading_browse_top(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_browse_top(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q);

    IF page < 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                  FROM  authority.simple_heading ash
                  WHERE ash.atag = ANY (atag_list)
                        AND ash.sort_value < pivot_sort_value
                  ORDER BY ash.sort_value DESC
                  LIMIT pagesize
                  OFFSET (ABS(page) - 1) * pagesize
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
        RETURN QUERY
            -- "bottom" half of the browse results
            SELECT  ash.id
              FROM  authority.simple_heading ash
              WHERE ash.atag = ANY (atag_list)
                    AND ash.sort_value >= pivot_sort_value
              ORDER BY ash.sort_value
              LIMIT pagesize
              OFFSET ABS(page) * pagesize ;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_top(atag_list integer[], q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: simple_heading_find_pivot(integer[], text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_find_pivot(a integer[], q text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    sort_value_row  RECORD;
    value_row       RECORD;
    t_term          TEXT;
BEGIN

    t_term := public.naco_normalize(q);

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
      INTO  sort_value_row
      FROM  authority.simple_heading ash
      WHERE ash.atag = ANY (a)
            AND ash.sort_value >= t_term
      ORDER BY rank DESC, ash.sort_value
      LIMIT 1;

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
      INTO  value_row
      FROM  authority.simple_heading ash
      WHERE ash.atag = ANY (a)
            AND ash.value >= t_term
      ORDER BY rank DESC, ash.sort_value
      LIMIT 1;

    IF value_row.rank > sort_value_row.rank THEN
        RETURN value_row.sort_value;
    ELSE
        RETURN sort_value_row.sort_value;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_find_pivot(a integer[], q text) OWNER TO evergreen;

--
-- Name: simple_heading_plus_set(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_plus_set(marcxml text) RETURNS SETOF simple_heading_plus
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    res             authority.simple_heading_plus%ROWTYPE;
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    cset            INT;
    heading_text    TEXT;
    original_text   TEXT;
    joiner_text    TEXT;
    sort_text       TEXT;
    tmp_text        TEXT;
    tmp_xml         TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN

    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    res.record := auth_id;

    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset LOOP

        res.atag := acsaf.id;
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        joiner_text := COALESCE(acsaf.joiner, ' ');

        FOR tmp_xml IN SELECT UNNEST(XPATH('//*[@tag="'||tag_used||'"]', marcxml::XML)) LOOP

            heading_text := public.naco_normalize(COALESCE(
                oils_xpath_string('//subfield[contains("'||acsaf.sf_list||'",@code)]', tmp_xml::TEXT, joiner_text),
                ''));

            original_text = COALESCE(
                oils_xpath_string('//subfield[contains("'||acsaf.display_sf_list||'",@code)]', tmp_xml::TEXT),
                '');

            original_text = REGEXP_REPLACE(original_text, '^\s+|\s+$/', '','g');

            IF nfi_used IS NOT NULL THEN

                sort_text := SUBSTRING(
                    heading_text FROM
                    COALESCE(
                        NULLIF(
                            REGEXP_REPLACE(
                                oils_xpath_string('./@ind'||nfi_used, tmp_xml::TEXT),
                                $$\D+$$,
                                '',
                                'g'
                            ),
                            ''
                        )::INT,
                        0
                    ) + 1
                );

            ELSE
                sort_text := heading_text;
            END IF;

            IF heading_text IS NOT NULL AND heading_text <> '' THEN
                res.value := heading_text;
                res.sort_value := public.naco_normalize(sort_text);
                res.index_vector = to_tsvector('keyword'::regconfig, res.sort_value);
                res.original_text := original_text;
                RETURN NEXT res;
            END IF;

        END LOOP;

    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION authority.simple_heading_plus_set(marcxml text) OWNER TO evergreen;

--
-- Name: simple_heading_search_heading(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_search_heading(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
      ORDER BY ash.sort_value
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_heading(atag_list integer[], q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: simple_heading_search_rank(integer[], text, integer, integer); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_search_rank(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
      ORDER BY ts_rank_cd(ash.index_vector,ptsq.term,14)::numeric
                    + CASE WHEN ash.sort_value LIKE t.term || '%' THEN 2 ELSE 0 END
                    + CASE WHEN ash.value LIKE t.term || '%' THEN 1 ELSE 0 END DESC
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_rank(atag_list integer[], q text, page integer, pagesize integer) OWNER TO evergreen;

--
-- Name: simple_heading; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE simple_heading (
    id bigint NOT NULL,
    record bigint NOT NULL,
    atag integer NOT NULL,
    value text NOT NULL,
    sort_value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE authority.simple_heading OWNER TO evergreen;

--
-- Name: simple_heading_set(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_heading_set(marcxml text) RETURNS SETOF simple_heading
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    res             authority.simple_heading%ROWTYPE;
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    cset            INT;
    heading_text    TEXT;
    joiner_text    TEXT;
    sort_text       TEXT;
    tmp_text        TEXT;
    tmp_xml         TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN
    --ver1.0
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    res.record := auth_id;

    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset LOOP

        res.atag := acsaf.id;
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        joiner_text := COALESCE(acsaf.joiner, ' ');

        FOR tmp_xml IN SELECT UNNEST(XPATH('//*[@tag="'||tag_used||'"]', marcxml::XML)) LOOP

            heading_text := COALESCE(
                oils_xpath_string('./*[contains("'||acsaf.display_sf_list||'",@code)]', tmp_xml::TEXT, joiner_text),
                ''
            );
            IF nfi_used IS NOT NULL THEN
                sort_text := SUBSTRING(
                    heading_text FROM
                    COALESCE(
                        NULLIF(
                            REGEXP_REPLACE(
                                oils_xpath_string('./@ind'||nfi_used, tmp_xml::TEXT),
                                $$\D+$$,
                                '',
                                'g'
                            ),
                            ''
                        )::INT,
                        0
                    ) + 1
                );
            ELSE
                sort_text := heading_text;
            END IF;
            IF heading_text IS NOT NULL AND heading_text <> '' THEN
                res.value := heading_text;
                res.sort_value := public.naco_normalize(sort_text);
                res.index_vector = to_tsvector('keyword'::regconfig, res.sort_value);
                RETURN NEXT res;
            END IF;
        END LOOP;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION authority.simple_heading_set(marcxml text) OWNER TO evergreen;

--
-- Name: simple_normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION simple_normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT authority.normalize_heading($1, TRUE);
$_$;


ALTER FUNCTION authority.simple_normalize_heading(marcxml text) OWNER TO evergreen;

--
-- Name: unlinked_auths_to_given_auth_id(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION unlinked_auths_to_given_auth_id(auth_id bigint) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    wheres          	TEXT[];
    single_where	TEXT;
    query	        TEXT;
    results_cursor	REFCURSOR;
    auths                BIGINT[];
    first		INT	:= 1;

BEGIN
    -- ver 1.0 - KMAIN-1105

    SELECT INTO wheres COALESCE(ARRAY_AGG('subfield = ''' || subfield || ''' AND value = ''' || value || ''''), ARRAY[]::TEXT[])
        FROM authority.full_rec WHERE record = auth_id AND tag LIKE '1__';

    query := 'SELECT COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[]) FROM (';

    FOREACH single_where IN ARRAY wheres
    LOOP
        IF first < 1 THEN
            -- not first subquery
            query := query || ' INTERSECT (SELECT record FROM authority.full_rec WHERE ' || single_where || ' AND tag NOT LIKE ''1__'')';
        ELSE
            -- first subquery
            query := query || '(SELECT record FROM authority.full_rec WHERE ' || single_where || ' AND tag NOT LIKE ''1__'')';
            first := 0;
        END IF;
    END LOOP;

    query := query || ') AS X';

    OPEN results_cursor FOR EXECUTE query;

    FETCH results_cursor INTO auths;

    RETURN auths;
END;
$$;


ALTER FUNCTION authority.unlinked_auths_to_given_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: unlinked_bibs_to_given_auth_id(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION unlinked_bibs_to_given_auth_id(auth_id bigint) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    wheres          	TEXT[];
    single_where	TEXT;
    query	        TEXT;
    results_cursor	REFCURSOR;
    bibs                BIGINT[];
    first		INT	:= 1;

BEGIN
    -- ver 2.0 - KMAIN-1090: This version compares the authority.full_rec to metabib.real_full_rec.

    SELECT INTO wheres COALESCE(ARRAY_AGG('subfield = ''' || subfield || ''' AND value = ''' || value || ''''), ARRAY[]::TEXT[])
        FROM authority.full_rec WHERE record = auth_id AND tag ILIKE '1__';

    query := 'SELECT COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[]) FROM (';

    FOREACH single_where IN ARRAY wheres
    LOOP
        IF first < 1 THEN
            -- not first subquery
            query := query || ' INTERSECT (SELECT record FROM metabib.real_full_rec WHERE ' || single_where || ')';
        ELSE
            -- first subquery
            query := query || '(SELECT record FROM metabib.real_full_rec WHERE ' || single_where || ')';
            first := 0;
        END IF;
    END LOOP;

    query := query || ') AS X';

    OPEN results_cursor FOR EXECUTE query;

    FETCH results_cursor INTO bibs;

    RETURN bibs;
END;
$$;


ALTER FUNCTION authority.unlinked_bibs_to_given_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: unlinked_bibs_to_given_auth_text(text, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION unlinked_bibs_to_given_auth_text(search_class text, hundredxx_value text) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    bibs        BIGINT[];
BEGIN
    -- ver 0.1

    -- Add % to end to take into consideration additonal characters like '.' and date ($d).
    -- This may get us more bibs then wanted but will a little more is better than missing some.
    hundredXX_value := hundredXX_value || '%';

    CASE search_class
        WHEN 'author' THEN
            SELECT INTO bibs COALESCE(ARRAY_AGG(mbaedm.source), ARRAY[]::BIGINT[])
                FROM metabib.browse_author_entry AS mbae
                LEFT OUTER JOIN metabib.browse_author_entry_simple_heading_map AS mbaeshm
                ON mbae.id = mbaeshm.entry
                JOIN metabib.browse_author_entry_def_map AS mbaedm
                ON mbae.id = mbaedm.entry
                WHERE mbaeshm.id IS NULL AND mbae.value ILIKE hundredXX_value;

        WHEN 'title' THEN
            -- title means series title
            -- SELECT INTO bibs COALESCE(ARRAY_AGG(mbsedm.source), ARRAY[]::BIGINT[])
            --    FROM metabib.browse_series_entry AS mbse
            --    LEFT OUTER JOIN metabib.browse_series_entry_simple_heading_map AS mbseshm
            --    ON mbse.id = mbseshm.entry
            --    JOIN metabib.browse_series_entry_def_map AS mbsedm
            --    ON mbse.id = mbsedm.entry
            --    WHERE mbseshm.id IS NULL AND mbse.value ILIKE hundredXX_value;

            SELECT INTO bibs COALESCE(ARRAY_AGG(mbtedm.source), ARRAY[]::BIGINT[])
                FROM metabib.browse_title_entry AS mbte
                LEFT OUTER JOIN metabib.browse_title_entry_simple_heading_map AS mbteshm
                ON mbte.id = mbteshm.entry
                JOIN metabib.browse_title_entry_def_map AS mbtedm
                ON mbte.id = mbtedm.entry
                WHERE mbteshm.id IS NULL AND mbte.value ILIKE hundredXX_value;

        WHEN 'subject' THEN
            SELECT INTO bibs COALESCE(ARRAY_AGG(mbsedm.source), ARRAY[]::BIGINT[])
                FROM metabib.browse_subject_entry AS mbse
                LEFT OUTER JOIN metabib.browse_subject_entry_simple_heading_map AS mbseshm
                ON mbse.id = mbseshm.entry
                JOIN metabib.browse_subject_entry_def_map AS mbsedm
                ON mbse.id = mbsedm.entry
                WHERE mbseshm.id IS NULL AND mbse.value ILIKE hundredXX_value;

        ELSE

        END CASE;

    RETURN bibs;
END;
$_$;


ALTER FUNCTION authority.unlinked_bibs_to_given_auth_text(search_class text, hundredxx_value text) OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: check_marcxml_well_formed(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION check_marcxml_well_formed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF xml_is_well_formed(NEW.marc) THEN
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'Attempted to % MARCXML that is not well formed', TG_OP;
    END IF;
    
END;
$$;


ALTER FUNCTION biblio.check_marcxml_well_formed() OWNER TO evergreen;

--
-- Name: extract_fingerprint(text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_fingerprint(marc text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
	idx		config.biblio_fingerprint%ROWTYPE;
	xfrm		config.xml_transform%ROWTYPE;
	prev_xfrm	TEXT;
	transformed_xml	TEXT;
	xml_node	TEXT;
	xml_node_list	TEXT[];
	raw_text	TEXT;
    output_text TEXT := '';
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

	-- Loop over the indexing entries
	FOR idx IN SELECT * FROM config.biblio_fingerprint ORDER BY format, id LOOP

		SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

		-- See if we can skip the XSLT ... it's expensive
		IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
			-- Can't skip the transform
			IF xfrm.xslt <> '---' THEN
				transformed_xml := oils_xslt_process(marc,xfrm.xslt);
			ELSE
				transformed_xml := marc;
			END IF;

			prev_xfrm := xfrm.name;
		END IF;

		raw_text := COALESCE(
            naco_normalize(
                ARRAY_TO_STRING(
                    oils_xpath(
                        '//text()',
                        (oils_xpath(
                            idx.xpath,
                            transformed_xml,
                            ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] 
                        ))[1]
                    ),
                    ''
                )
            ),
            ''
        );

        raw_text := REGEXP_REPLACE(raw_text, E'\\[.+?\\]', E'');
        raw_text := REGEXP_REPLACE(raw_text, E'\\mthe\\M|\\man?d?d\\M', E'', 'g'); -- arg! the pain!

        IF idx.first_word IS TRUE THEN
            raw_text := REGEXP_REPLACE(raw_text, E'^(\\w+).*?$', E'\\1');
        END IF;

		output_text := output_text || REGEXP_REPLACE(raw_text, E'\\s+', '', 'g');

	END LOOP;

    RETURN output_text;

END;
$_$;


ALTER FUNCTION biblio.extract_fingerprint(marc text) OWNER TO evergreen;

--
-- Name: extract_languages(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_languages(bigint) RETURNS tsvector
    LANGUAGE plpgsql
    AS $_$

DECLARE
    alt_lang    text;
    lang        text;
    subfields   text;
BEGIN
    lang := biblio.marc21_extract_fixed_field($1, 'Lang');

--  read MARC 041 subfields from actor.org_unit_setting.opac_additional_language_subfields
--  trim any '"' chars, split into array of subfields

    SELECT value INTO subfields FROM actor.org_unit_setting where name like 'opac.additional_language_subfields';
--
--  query MARC 041 specified subfields for additional search languages
--
    FOR alt_lang IN (SELECT value FROM biblio.flatten_marc($1) where tag='041' and POSITION(subfield IN subfields) > 0)
    LOOP
        lang := lang || ' ' || alt_lang;
    END LOOP;

    return lang::tsvector;
END;
$_$;


ALTER FUNCTION biblio.extract_languages(bigint) OWNER TO evergreen;

--
-- Name: extract_located_uris(bigint, text, integer); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner_list  TEXT[];
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;
BEGIN

    -- Clear any URI mappings and call numbers for this bib.
    -- This leads to acn / auricnm inflation, but also enables
    -- old acn/auricnm's to go away and for bibs to be deleted.
    FOR uri_cn_id IN SELECT id FROM asset.call_number WHERE record = bib_id AND label = '##URI##' AND NOT deleted LOOP
        DELETE FROM asset.uri_call_number_map WHERE call_number = uri_cn_id;
        DELETE FROM asset.call_number WHERE id = uri_cn_id;
    END LOOP;

    uris := oils_xpath('//*[@tag="856" and (@ind1="4" or @ind1="1") and (@ind2="0" or @ind2="1")]',marcxml);
    IF ARRAY_UPPER(uris,1) > 0 THEN
        FOR i IN 1 .. ARRAY_UPPER(uris, 1) LOOP
            -- First we pull info out of the 856
            uri_xml     := uris[i];

            uri_href    := (oils_xpath('//*[@code="u"]/text()',uri_xml))[1];
            uri_label   := (oils_xpath('//*[@code="y"]/text()|//*[@code="3"]/text()|//*[@code="u"]/text()',uri_xml))[1];
            uri_use     := (oils_xpath('//*[@code="z"]/text()|//*[@code="2"]/text()|//*[@code="n"]/text()',uri_xml))[1];
            CONTINUE WHEN uri_href IS NULL OR uri_label IS NULL;

            -- Get the distinct list of libraries wanting to use 
            SELECT  ARRAY_ACCUM(
                        DISTINCT REGEXP_REPLACE(
                            x,
                            $re$^.*?\((\w+)\).*$$re$,
                            E'\\1'
                        )
                    ) INTO uri_owner_list
              FROM  UNNEST(
                        oils_xpath(
                            '//*[@code="9"]/text()|//*[@code="w"]/text()|//*[@code="n"]/text()',
                            uri_xml
                        )
                    )x;

            IF ARRAY_UPPER(uri_owner_list,1) > 0 THEN

                -- look for a matching uri
                SELECT id INTO uri_id FROM asset.uri WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active;
                IF NOT FOUND THEN -- create one
                    INSERT INTO asset.uri (label, href, use_restriction) VALUES (uri_label, uri_href, uri_use);
                    IF uri_use IS NULL THEN
                        SELECT id INTO uri_id FROM asset.uri WHERE label = uri_label AND href = uri_href AND use_restriction IS NULL AND active;
                    ELSE
                        SELECT id INTO uri_id FROM asset.uri WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active;
                    END IF;
                END IF;

                FOR j IN 1 .. ARRAY_UPPER(uri_owner_list, 1) LOOP
                    uri_owner := uri_owner_list[j];

                    SELECT id INTO uri_owner_id FROM actor.org_unit WHERE shortname = uri_owner;
                    CONTINUE WHEN NOT FOUND;

                    -- we need a call number to link through
                    SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    IF NOT FOUND THEN
                        INSERT INTO asset.call_number (owning_lib, record, create_date, edit_date, creator, editor, label)
                            VALUES (uri_owner_id, bib_id, 'now', 'now', editor_id, editor_id, '##URI##');
                        SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    END IF;

                    -- now, link them if they're not already
                    SELECT id INTO uri_map_id FROM asset.uri_call_number_map WHERE call_number = uri_cn_id AND uri = uri_id;
                    IF NOT FOUND THEN
                        INSERT INTO asset.uri_call_number_map (call_number, uri) VALUES (uri_cn_id, uri_id);
                    END IF;

                END LOOP;

            END IF;

        END LOOP;
    END IF;

    RETURN;
END;
$_$;


ALTER FUNCTION biblio.extract_located_uris(bib_id bigint, marcxml text, editor_id integer) OWNER TO evergreen;

--
-- Name: extract_metabib_field_entry(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_metabib_field_entry(bigint) RETURNS SETOF metabib.field_entry_template
    LANGUAGE sql
    AS $_$
    SELECT * FROM biblio.extract_metabib_field_entry($1, ' ');
    $_$;


ALTER FUNCTION biblio.extract_metabib_field_entry(bigint) OWNER TO evergreen;

--
-- Name: extract_metabib_field_entry(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) RETURNS SETOF metabib.field_entry_template
    LANGUAGE plpgsql
    AS $_$
DECLARE
    bib     biblio.record_entry%ROWTYPE;
    idx     config.metabib_field%ROWTYPE;
    xfrm        config.xml_transform%ROWTYPE;
    prev_xfrm   TEXT;
    transformed_xml TEXT;
    xml_node    TEXT;
    xml_node_list   TEXT[];
    facet_text  TEXT;
    browse_text TEXT;
    sort_value  TEXT;
    raw_text    TEXT;
    curr_text   TEXT;
    joiner      TEXT := default_joiner; -- XXX will index defs supply a joiner?
    authority_text TEXT;
    authority_link BIGINT;
    output_row  metabib.field_entry_template%ROWTYPE;
BEGIN
    --ver2.0 - KMAIN-1162
    -- Start out with no field-use bools set
    output_row.browse_field = FALSE;
    output_row.facet_field = FALSE;
    output_row.search_field = FALSE;

    -- Get the record
    SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

    -- Loop over the indexing entries
    FOR idx IN SELECT * FROM config.metabib_field ORDER BY format LOOP

        joiner := COALESCE(idx.joiner, default_joiner);

        SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

        -- See if we can skip the XSLT ... it's expensive
        IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
            -- Can't skip the transform
            IF xfrm.xslt <> '---' THEN
                transformed_xml := oils_xslt_process(bib.marc,xfrm.xslt);
            ELSE
                transformed_xml := bib.marc;
            END IF;

            prev_xfrm := xfrm.name;
        END IF;

        xml_node_list := perl_oils_xpath( idx.xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );

        raw_text := NULL;
        FOR xml_node IN SELECT x FROM unnest(xml_node_list) AS x LOOP
            CONTINUE WHEN xml_node !~ E'^\\s*<';

            -- XXX much of this should be moved into oils_xpath_string...
            curr_text := ARRAY_TO_STRING(evergreen.array_remove_item_by_value(evergreen.array_remove_item_by_value(
                oils_xpath( '//text()',
                    REGEXP_REPLACE(
                        REGEXP_REPLACE( -- This escapes all &s not followed by "amp;".  Data ise returned from oils_xpath (above) in UTF-8, not entity encoded
                            REGEXP_REPLACE( -- This escapes embeded <s
                                xml_node,
                                $re$(>[^<]+)(<)([^>]+<)$re$,
                                E'\\1&lt;\\3',
                                'g'
                            ),
                            '&(?!amp;)',
                            '&amp;',
                            'g'
                        ),
                        E'\\s+',
                        ' ',
                        'g'
                    )
                ), ' '), ''),
                joiner
            );

            CONTINUE WHEN curr_text IS NULL OR curr_text = '';

            IF raw_text IS NOT NULL THEN
                raw_text := raw_text || joiner;
            END IF;

            raw_text := COALESCE(raw_text,'') || curr_text;

            -- autosuggest/metabib.browse_entry
            IF idx.browse_field THEN

                IF idx.browse_xpath IS NOT NULL AND idx.browse_xpath <> '' THEN
                    browse_text := oils_xpath_string( idx.browse_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    browse_text := curr_text;
                END IF;

                IF idx.browse_sort_xpath IS NOT NULL AND
                    idx.browse_sort_xpath <> '' THEN

                    sort_value := oils_xpath_string(
                        idx.browse_sort_xpath, xml_node, joiner,
                        ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]
                    );
                ELSE
                    sort_value := browse_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = idx.id;
                output_row.source = rid;
                -- outer regexp_replace keeps all '.' expect the last one.
                -- inner regexp_replace removes all connecting whitespace and replaces it with a single space
                output_row.value = BTRIM(REGEXP_REPLACE(REGEXP_REPLACE(browse_text, E'\\s+', ' ', 'g'), E'\\.$', '', 'g'));
                output_row.sort_value :=
                    public.naco_normalize(sort_value);

                output_row.authority := NULL;

                IF idx.authority_xpath IS NOT NULL AND idx.authority_xpath <> '' THEN
                    authority_text := oils_xpath_string(
                        idx.authority_xpath, xml_node, joiner,
                        ARRAY[
                            ARRAY[xfrm.prefix, xfrm.namespace_uri],
                            ARRAY['xlink','http://www.w3.org/1999/xlink']
                        ]
                    );

                    IF authority_text ~ '^\d+$' THEN
                        authority_link := authority_text::BIGINT;
                        PERFORM * FROM authority.record_entry WHERE id = authority_link;
                        IF FOUND THEN
                            output_row.authority := authority_link;
                        END IF;
                    END IF;

                END IF;

                output_row.browse_field = TRUE;
                -- Returning browse rows with search_field = true for search+browse
                -- configs allows us to retain granularity of being able to search
                -- browse fields with "starts with" type operators (for example, for
                -- titles of songs in music albums)
                IF idx.search_field THEN
                    output_row.search_field = TRUE;
                END IF;
                RETURN NEXT output_row;
                output_row.browse_field = FALSE;
                output_row.search_field = FALSE;
                output_row.sort_value := NULL;
            END IF;

            -- insert raw node text for faceting
            IF idx.facet_field THEN

                IF idx.facet_xpath IS NOT NULL AND idx.facet_xpath <> '' THEN
                    facet_text := oils_xpath_string( idx.facet_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    facet_text := curr_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = -1 * idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(REGEXP_REPLACE(facet_text, E'\\s+', ' ', 'g'), E'\\.+', '', 'g'));

                output_row.facet_field = TRUE;
                RETURN NEXT output_row;
                output_row.facet_field = FALSE;
            END IF;

        END LOOP;

        CONTINUE WHEN raw_text IS NULL OR raw_text = '';

        -- insert combined node text for searching
        IF idx.search_field THEN

            IF idx.field_class = 'identifier' AND idx.name = 'bibcn' THEN
                output_row.field_class = 'call_number';
                output_row.browse_field = TRUE;
                output_row.sort_value = public.naco_normalize_keep_decimal(raw_text,'');
                output_row.value = raw_text;
            ELSE
                output_row.field_class = idx.field_class;
                output_row.value = BTRIM(REGEXP_REPLACE(REGEXP_REPLACE(raw_text, E'\\s+', ' ', 'g'), E'\\.+', '', 'g'));
            END IF;

            output_row.field = idx.id;
            output_row.source = rid;

            output_row.search_field = TRUE;
            RETURN NEXT output_row;
            output_row.search_field = FALSE;
        END IF;

    END LOOP;

END;

$_$;


ALTER FUNCTION biblio.extract_metabib_field_entry(rid bigint, default_joiner text) OWNER TO evergreen;

--
-- Name: extract_quality(text, text, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION extract_quality(marc text, best_lang text, best_type text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    qual        INT;
    ldr         TEXT;
    tval        TEXT;
    tval_rec    RECORD;
    bval        TEXT;
    bval_rec    RECORD;
    type_map    RECORD;
    ff_pos      RECORD;
    ff_tag_data TEXT;
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

    -- First, the count of tags
    qual := ARRAY_UPPER(oils_xpath('*[local-name()="datafield"]', marc), 1);

    -- now go through a bunch of pain to get the record type
    IF best_type IS NOT NULL THEN
        ldr := (oils_xpath('//*[local-name()="leader"]/text()', marc))[1];

        IF ldr IS NOT NULL THEN
            SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
            SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


            tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
            bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

            -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

            SELECT * INTO type_map FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';

            IF type_map.code IS NOT NULL THEN
                IF best_type = type_map.code THEN
                    qual := qual + qual / 2;
                END IF;

                FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = 'Lang' AND rec_type = type_map.code ORDER BY tag DESC LOOP
                    ff_tag_data := SUBSTRING((oils_xpath('//*[@tag="' || ff_pos.tag || '"]/text()',marc))[1], ff_pos.start_pos + 1, ff_pos.length);
                    IF ff_tag_data = best_lang THEN
                            qual := qual + 100;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    END IF;

    -- Now look for some quality metrics
    -- DCL record?
    IF ARRAY_UPPER(oils_xpath('//*[@tag="040"]/*[@code="a" and contains(.,"DLC")]', marc), 1) = 1 THEN
        qual := qual + 10;
    END IF;

    -- From OCLC?
    IF (oils_xpath('//*[@tag="003"]/text()', marc))[1] ~* E'oclo?c' THEN
        qual := qual + 10;
    END IF;

    RETURN qual;

END;
$$;


ALTER FUNCTION biblio.extract_quality(marc text, best_lang text, best_type text) OWNER TO evergreen;

--
-- Name: fingerprint_trigger(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION fingerprint_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- For TG_ARGV, first param is language (like 'eng'), second is record type (like 'BKS')

    IF NEW.deleted IS TRUE THEN -- we don't much care, then, do we?
        RETURN NEW;
    END IF;

    NEW.fingerprint := biblio.extract_fingerprint(NEW.marc);
    NEW.quality := biblio.extract_quality(NEW.marc, TG_ARGV[0], TG_ARGV[1]);

    RETURN NEW;

END;
$$;


ALTER FUNCTION biblio.fingerprint_trigger() OWNER TO evergreen;

SET search_path = metabib, pg_catalog;

--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.full_rec_id_seq OWNER TO evergreen;

--
-- Name: real_full_rec; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE real_full_rec (
    id bigint DEFAULT nextval('full_rec_id_seq'::regclass) NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL
)
WITH (autovacuum_enabled=true);


ALTER TABLE metabib.real_full_rec OWNER TO evergreen;

--
-- Name: full_rec; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW full_rec AS
    SELECT real_full_rec.id, real_full_rec.record, real_full_rec.tag, real_full_rec.ind1, real_full_rec.ind2, real_full_rec.subfield, "substring"(real_full_rec.value, 1, 1024) AS value, real_full_rec.index_vector FROM real_full_rec;


ALTER TABLE metabib.full_rec OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION flatten_marc(rid bigint) RETURNS SETOF metabib.full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib biblio.record_entry%ROWTYPE;
    output  metabib.full_rec%ROWTYPE;
    field   RECORD;
BEGIN
    SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

    FOR field IN SELECT * FROM vandelay.flatten_marc( bib.marc ) LOOP
        output.record := rid;
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        output.value := field.value;

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION biblio.flatten_marc(rid bigint) OWNER TO evergreen;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_value      TEXT;
    new_attrs       HSTORE := ''::HSTORE;
    attr_def        config.record_attr_definition%ROWTYPE;
BEGIN

    IF NEW.deleted IS TRUE THEN -- If this bib is deleted
        PERFORM * FROM config.internal_flag WHERE
            name = 'ingest.metarecord_mapping.preserve_on_delete' AND enabled;
        IF NOT FOUND THEN
            -- One needs to keep these around to support searches
            -- with the #deleted modifier, so one should turn on the named
            -- internal flag for that functionality.
            DELETE FROM metabib.metarecord_source_map WHERE source = NEW.id;
            DELETE FROM metabib.record_attr WHERE id = NEW.id;
        END IF;

        DELETE FROM authority.bib_linking WHERE bib = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM biblio.peer_bib_copy_map WHERE peer_record = NEW.id; -- Separate any multi-homed items
        DELETE FROM metabib.browse_author_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        DELETE FROM metabib.browse_series_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        DELETE FROM metabib.browse_subject_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        DELETE FROM metabib.browse_title_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        DELETE FROM metabib.browse_call_number_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;
    END IF;

    -- Record authority linking
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_linking' AND enabled;
    IF NOT FOUND THEN
        PERFORM biblio.map_authority_linking( NEW.id, NEW.marc );
    END IF;

    -- Flatten and insert the mfr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM metabib.reingest_metabib_full_rec(NEW.id);

        -- Now we pull out attribute data, which is dependent on the mfr for all but XPath-based fields
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            FOR attr_def IN SELECT * FROM config.record_attr_definition ORDER BY format LOOP

                IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
                    SELECT  ARRAY_TO_STRING(ARRAY_ACCUM(value), COALESCE(attr_def.joiner,' ')) INTO attr_value
                      FROM  (SELECT * FROM metabib.full_rec ORDER BY tag, subfield) AS x
                      WHERE record = NEW.id
                            AND tag LIKE attr_def.tag
                            AND CASE
                                WHEN attr_def.sf_list IS NOT NULL 
                                    THEN POSITION(subfield IN attr_def.sf_list) > 0
                                ELSE TRUE
                                END
                      GROUP BY tag
                      ORDER BY tag
                      LIMIT 1;

                ELSIF attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
                    attr_value := biblio.marc21_extract_fixed_field(NEW.id, attr_def.fixed_field);

                ELSIF attr_def.xpath IS NOT NULL THEN -- and xpath expression

                    SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;
            
                    -- See if we can skip the XSLT ... it's expensive
                    IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                        -- Can't skip the transform
                        IF xfrm.xslt <> '---' THEN
                            transformed_xml := oils_xslt_process(NEW.marc,xfrm.xslt);
                        ELSE
                            transformed_xml := NEW.marc;
                        END IF;
            
                        prev_xfrm := xfrm.name;
                    END IF;

                    IF xfrm.name IS NULL THEN
                        -- just grab the marcxml (empty) transform
                        SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                        prev_xfrm := xfrm.name;
                    END IF;

                    attr_value := oils_xpath_string(attr_def.xpath, transformed_xml, COALESCE(attr_def.joiner,' '), ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]);

                ELSIF attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
                    SELECT  m.value INTO attr_value
                      FROM  biblio.marc21_physical_characteristics(NEW.id) v
                            JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
                      WHERE v.subfield = attr_def.phys_char_sf
                      LIMIT 1; -- Just in case ...

                END IF;

                -- apply index normalizers to attr_value
                FOR normalizer IN
                    SELECT  n.func AS func,
                            n.param_count AS param_count,
                            m.params AS params
                      FROM  config.index_normalizer n
                            JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
                      WHERE attr = attr_def.name
                      ORDER BY m.pos LOOP
                        EXECUTE 'SELECT ' || normalizer.func || '(' ||
                            COALESCE( quote_literal( attr_value ), 'NULL' ) ||
                            CASE
                                WHEN normalizer.param_count > 0
                                    THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                                    ELSE ''
                                END ||
                            ')' INTO attr_value;
        
                END LOOP;

                -- Add the new value to the hstore
                new_attrs := new_attrs || hstore( attr_def.name, attr_value );

            END LOOP;

            IF TG_OP = 'INSERT' OR OLD.deleted THEN -- initial insert OR revivication
                DELETE FROM metabib.record_attr WHERE id = NEW.id;
                INSERT INTO metabib.record_attr (id, attrs) VALUES (NEW.id, new_attrs);
            ELSE
                UPDATE metabib.record_attr SET attrs = new_attrs WHERE id = NEW.id;
            END IF;

        END IF;
    END IF;

    -- Gather and insert the field entry data
    PERFORM metabib.reingest_metabib_field_entries(NEW.id);

    -- Located URI magic
    IF TG_OP = 'INSERT' THEN
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_located_uri' AND enabled;
        IF NOT FOUND THEN
            PERFORM biblio.extract_located_uris( NEW.id, NEW.marc, NEW.editor );
        END IF;
    ELSE
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_located_uri' AND enabled;
        IF NOT FOUND THEN
            PERFORM biblio.extract_located_uris( NEW.id, NEW.marc, NEW.editor );
        END IF;
    END IF;

    -- (re)map metarecord-bib linking
    IF TG_OP = 'INSERT' THEN -- if not deleted and performing an insert, check for the flag
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_insert' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    ELSE -- we're doing an update, and we're not deleted, remap
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_update' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.indexing_ingest_or_delete() OWNER TO evergreen;

--
-- Name: map_authority_linking(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION map_authority_linking(bibid bigint, marc text) RETURNS bigint
    LANGUAGE sql
    AS $_$
    DELETE FROM authority.bib_linking WHERE bib = $1;
    INSERT INTO authority.bib_linking (bib, authority)
        SELECT  y.bib,
                y.authority
          FROM (    SELECT  DISTINCT $1 AS bib,
                            BTRIM(remove_paren_substring(txt))::BIGINT AS authority
                      FROM  unnest(oils_xpath('//*[@code="0"]/text()',$2)) x(txt)
                      WHERE BTRIM(remove_paren_substring(txt)) ~ $re$^\d+$$re$
                ) y JOIN authority.record_entry r ON r.id = y.authority;
    SELECT $1;
$_$;


ALTER FUNCTION biblio.map_authority_linking(bibid bigint, marc text) OWNER TO evergreen;

--
-- Name: marc21_extract_all_fixed_fields(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION marc21_extract_all_fixed_fields(rid bigint) RETURNS SETOF record_ff_map
    LANGUAGE sql
    AS $_$
    SELECT $1 AS record, ff_name, ff_value FROM vandelay.marc21_extract_all_fixed_fields( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_extract_all_fixed_fields(rid bigint) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION marc21_extract_fixed_field(rid bigint, ff text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_extract_fixed_field( (SELECT marc FROM biblio.record_entry WHERE id = $1), $2 );
$_$;


ALTER FUNCTION biblio.marc21_extract_fixed_field(rid bigint, ff text) OWNER TO evergreen;

--
-- Name: marc21_physical_characteristics(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION marc21_physical_characteristics(rid bigint) RETURNS SETOF marc21_physical_characteristics
    LANGUAGE sql
    AS $_$
    SELECT id, $1 AS record, ptype, subfield, value FROM vandelay.marc21_physical_characteristics( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_physical_characteristics(rid bigint) OWNER TO evergreen;

SET search_path = config, pg_catalog;

--
-- Name: marc21_rec_type_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc21_rec_type_map (
    code text NOT NULL,
    type_val text NOT NULL,
    blvl_val text NOT NULL
);


ALTER TABLE config.marc21_rec_type_map OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: marc21_record_type(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION marc21_record_type(rid bigint) RETURNS config.marc21_rec_type_map
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_record_type( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_record_type(rid bigint) OWNER TO evergreen;

--
-- Name: next_autogen_tcn_value(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION next_autogen_tcn_value() RETURNS text
    LANGUAGE plpgsql
    AS $$
	BEGIN RETURN 'AUTOGENERATED-' || nextval('biblio.autogen_tcn_value_seq'::TEXT); END;
$$;


ALTER FUNCTION biblio.next_autogen_tcn_value() OWNER TO evergreen;

--
-- Name: normalize_biblio_monograph_part_sortkey(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION normalize_biblio_monograph_part_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.normalize_biblio_monograph_part_sortkey() OWNER TO evergreen;

--
-- Name: update_language_filter(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION update_language_filter() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    lang    tsvector;
    lang_filter bigint;
BEGIN
    lang := biblio.extract_languages(NEW.id);

    SELECT metabib.language_filter.source INTO lang_filter FROM metabib.language_filter WHERE NEW.id = metabib.language_filter.source;

    IF FOUND THEN
    UPDATE metabib.language_filter SET value = lang WHERE metabib.language_filter.source = NEW.id;
    ELSE
    INSERT INTO metabib.language_filter(source, value) VALUES (NEW.id, lang);
    END IF;

    RETURN NEW;

END;
$$;


ALTER FUNCTION biblio.update_language_filter() OWNER TO evergreen;

SET search_path = cmd, pg_catalog;

--
-- Name: ranked_volumes_ex(bigint, integer, integer, evergreen.hstore, evergreen.hstore, integer); Type: FUNCTION; Schema: cmd; Owner: postgres
--

CREATE FUNCTION ranked_volumes_ex(bibid bigint, ouid integer, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE
    AS $_$
    SELECT ua.id, ua.name, ua.label_sortkey, MIN(ua.rank) AS rank FROM (
        SELECT acn.id, aou.name, acn.label_sortkey,
            RANK() OVER w
        FROM asset.call_number acn
            JOIN asset.copy acp ON (acn.id = acp.call_number)
            JOIN actor.org_unit_descendants( $2, COALESCE(
                $3, (
                    SELECT depth
                    FROM actor.org_unit_type aout
                        INNER JOIN actor.org_unit ou ON ou_type = aout.id
                    WHERE ou.id = $2
                ), $6)
            ) AS aou ON (acp.circ_lib = aou.id)
        WHERE acn.record = $1
            AND acn.deleted IS FALSE
            AND acp.deleted IS FALSE
        GROUP BY acn.id, acp.status, aou.name, acn.label_sortkey, aou.id
        WINDOW w AS (
            ORDER BY evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status)
        )
    ) AS ua
    GROUP BY ua.id, ua.name, ua.label_sortkey
    ORDER BY rank, ua.name, ua.label_sortkey
    LIMIT ($4 -> 'acn')::INT
    OFFSET ($5 -> 'acn')::INT;
$_$;


ALTER FUNCTION cmd.ranked_volumes_ex(bibid bigint, ouid integer, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, pref_lib integer) OWNER TO postgres;

SET search_path = collectionhq, pg_catalog;

--
-- Name: attempt_price(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION attempt_price(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    attempt_value ALIAS FOR $1;
    output TEXT;
  BEGIN
    FOR output IN
      EXECUTE 'SELECT (REGEXP_REPLACE(' || quote_literal(attempt_value) || E', E\'[^0-9\.]\', \'\', \'g\')::NUMERIC(8,2) * 100)::INTEGER AS a;'
    LOOP
      RETURN output;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      FOR output IN
        EXECUTE E'SELECT \'\' AS a;'
      LOOP
        RETURN output;
      END LOOP;
  END;
$_$;


ALTER FUNCTION collectionhq.attempt_price(text) OWNER TO evergreen;

--
-- Name: attempt_year(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION attempt_year(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    attempt_value ALIAS FOR $1;
    output TEXT;
  BEGIN
    FOR output IN
      EXECUTE 'SELECT SUBSTRING(REGEXP_REPLACE(' || quote_literal(attempt_value) || E', E\'[^0-9]\', \'\', \'g\') FROM 1 FOR 4) AS a;'
    LOOP
      RETURN output;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      FOR output IN
        EXECUTE E'SELECT \'\' AS a;'
      LOOP
        RETURN output;
      END LOOP;
  END;
$_$;


ALTER FUNCTION collectionhq.attempt_year(text) OWNER TO evergreen;

--
-- Name: quote(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION quote(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    value ALIAS FOR $1;
    output TEXT;
  BEGIN
    IF value IS NOT NULL AND value <> '' THEN
      RETURN '##' || value || '##';
    ELSE
      RETURN '';
    END IF;
  END;
$_$;


ALTER FUNCTION collectionhq.quote(text) OWNER TO evergreen;

--
-- Name: write_bib_rows_to_stdout(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION write_bib_rows_to_stdout(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_bib_rows_to_stdout('LIBRARYCODE', org_unit_id);

  DECLARE
    library_service_code ALIAS FOR $1;
    org_unit_id ALIAS FOR $2;
    isbn TEXT := '';
    title TEXT := '';
    author TEXT := '';
    edition_num TEXT := '';
    publication_date TEXT := '';
    publisher TEXT := '';
    price TEXT := '';
    lms_item_type TEXT := '';
    class_num TEXT := '';
    extract_date TEXT := '';
    output TEXT := '';
    lms_bib_id BIGINT;
    num_rows INTEGER := 0;

  BEGIN
    
    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
    FOR lms_bib_id IN
      SELECT DISTINCT bre.id FROM biblio.record_entry bre JOIN asset.call_number acn ON (acn.record = bre.id) WHERE acn.owning_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) AND NOT acn.deleted AND NOT bre.deleted
    LOOP

      SELECT r.isbn[1],
             SUBSTRING(r.title FROM 1 FOR 100),
             SUBSTRING(r.author FROM 1 FOR 50)
      INTO isbn, title, author
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;
      SELECT 
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="250"][1]/marc:subfield[@code="a"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'a') FROM 1 FOR 20),
        collectionHQ.attempt_year((XPATH('//marc:datafield[@tag="260"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT),
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="260"][1]/marc:subfield[@code="b"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'b') FROM 1 FOR 100),
        collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT),
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="082"][1]/marc:subfield[@code="a"][1]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'a') FROM 1 FOR 20)
      INTO edition_num, publication_date, publisher, price, class_num
      FROM biblio.record_entry
      WHERE id = lms_bib_id;

      SELECT circ_modifier INTO lms_item_type FROM asset.copy c, asset.call_number cn WHERE cn.record = lms_bib_id AND cn.id = c.call_number AND NOT cn.deleted AND NOT c.deleted LIMIT 1;
  
      output := 
        '##BIB##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(library_service_code), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '') || ','
        || COALESCE(collectionHQ.quote(title), '') || ','
        || COALESCE(collectionHQ.quote(author), '') || ','
        || COALESCE(collectionHQ.quote(edition_num), '') || ','
        || COALESCE(collectionHQ.quote(publication_date), '') || ','
        || COALESCE(collectionHQ.quote(publisher), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(lms_item_type), '') || ','
        || COALESCE(collectionHQ.quote(class_num), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '');
  
       RAISE INFO '%', output;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;
    RETURN '';

  END;

$_$;


ALTER FUNCTION collectionhq.write_bib_rows_to_stdout(text, integer) OWNER TO evergreen;

--
-- Name: write_item_rows_to_stdout(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION write_item_rows_to_stdout(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_item_rows_to_stdout ('LIBRARYCODE',org_unit_id);

  DECLARE
    item BIGINT;
    authority_code ALIAS FOR $1;
    org_unit_id ALIAS for $2;
    lms_bib_id BIGINT;
    library_code TEXT;
    bar_code TEXT;
    last_use_date TEXT;
    cumulative_use_total TEXT;
    cumulative_use_current TEXT;
    status TEXT;
    date_added TEXT;
    price TEXT;
    purchase_code TEXT;
    rotating_stock TEXT;
    lib_supsel_tag TEXT;
    gen_supsel_tag TEXT;
    notes TEXT;
    extract_date TEXT;
    collection_code TEXT;
    collection_code_level_2 TEXT;
    filter_level_1 TEXT;
    filter_level_2 TEXT;
    filter_level_3 TEXT;
    filter_level_4 TEXT;
    isbn TEXT := '';
    output TEXT := '';
    arrived TIMESTAMPTZ;
    num_rows INTEGER := 0;

  BEGIN

    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
    FOR item, arrived, cumulative_use_total IN
      SELECT cp.id, dest_recv_time, COALESCE(sum(DISTINCT c.circ_count), 0::bigint) + COALESCE(count(DISTINCT circ.id), 0::bigint) + COALESCE(count(DISTINCT acirc.id), 0::bigint) AS circ_count
      FROM asset.copy cp
      LEFT JOIN extend_reporter.legacy_circ_count c USING (id)
      LEFT JOIN (SELECT max(dest_recv_time) as dest_recv_time, target_copy, dest from action.transit_copy group by target_copy, dest) atc ON (cp.id = atc.target_copy AND cp.circ_lib = atc.dest)
      LEFT JOIN action.circulation circ ON circ.target_copy = cp.id
      LEFT JOIN action.aged_circulation acirc ON acirc.target_copy = cp.id
      WHERE NOT cp.deleted AND cp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) GROUP BY cp.id, dest_recv_time ORDER BY cp.id
    LOOP

      SELECT cn.record, cn.label
      INTO lms_bib_id, filter_level_1
      FROM asset.call_number cn, asset.copy c 
      WHERE c.call_number = cn.id AND c.id =  item;
      SELECT r.isbn[1] INTO isbn
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;
      SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
             REPLACE(create_date::DATE::TEXT, '-', ''),
             CASE floating WHEN TRUE THEN 'Y' ELSE NULL END
      INTO price, bar_code, status, date_added, rotating_stock
      FROM asset.copy ac 
      WHERE id = item;
      IF price IS NULL OR price = '' THEN
        SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
        INTO price
        FROM biblio.record_entry
        WHERE id = lms_bib_id;
      END IF;
      SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;
      /* SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1; */
      SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM ( SELECT action.aged_circulation.xact_start FROM action.aged_circulation where target_copy = item UNION SELECT action.circulation.xact_start FROM action.circulation where target_copy = item) as lu  order by xact_start DESC limit 1;
      
      IF arrived IS NOT NULL THEN
        SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
      ELSE
      cumulative_use_current := '0'; 
      END IF;
      SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;
      SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;
  
      purchase_code := ''; -- FIXME do we want something else here?
      lib_supsel_tag := ''; -- FIXME do we want something else here?
      gen_supsel_tag := ''; -- FIXME do we want something else here?
      collection_code_level_2 := ''; -- FIXME do we want something else here?
      filter_level_2 := ''; -- FIXME do we want something else here?
      filter_level_3 := ''; -- FIXME do we want something else here?
      filter_level_4 := ''; -- FIXME do we want something else here?
  
      output := '##HOLD##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(authority_code), '') || ','
        || COALESCE(collectionHQ.quote(library_code), '') || ','
        || COALESCE(collectionHQ.quote(bar_code), '') || ','
        || COALESCE(collectionHQ.quote(last_use_date), '') || ','
        || COALESCE(cumulative_use_total, '') || ','
        || COALESCE(cumulative_use_current, '') || ','
        || COALESCE(collectionHQ.quote(status), '') || ','
        || COALESCE(collectionHQ.quote(date_added), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(purchase_code), '') || ','
        || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
        || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(notes), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '') || ','
        || COALESCE(collectionHQ.quote(collection_code), '') || ','
        || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '');
  
       RAISE INFO '%', output;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;
    RETURN '';
  END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout(text, integer) OWNER TO postgres;

--
-- Name: write_item_rows_to_stdout_new(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION write_item_rows_to_stdout_new(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_item_rows_to_stdout ('LIBRARYCODE',org_unit_id);

  DECLARE
    item BIGINT;
    authority_code ALIAS FOR $1;
    org_unit_id ALIAS for $2;
    lms_bib_id BIGINT;
    library_code TEXT;
    bar_code TEXT;
    last_use_date TEXT;
    cumulative_use_total TEXT;
    cumulative_use_current TEXT;
    status TEXT;
    date_added TEXT;
    price TEXT;
    purchase_code TEXT;
    rotating_stock TEXT;
    lib_supsel_tag TEXT;
    gen_supsel_tag TEXT;
    notes TEXT;
    extract_date TEXT;
    collection_code TEXT;
    collection_code_level_2 TEXT;
    filter_level_1 TEXT;
    filter_level_2 TEXT;
    filter_level_3 TEXT;
    filter_level_4 TEXT;
    isbn TEXT := '';
    output TEXT := '';
    arrived TIMESTAMPTZ;
    num_rows INTEGER := 0;

  BEGIN

    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
    FOR item, arrived, cumulative_use_total IN
      SELECT cp.id, dest_recv_time, COALESCE(sum(c.circ_count), 0::bigint) + COALESCE(count(circ.id), 0::bigint) + COALESCE(count(acirc.id), 0::bigint) AS circ_count
      FROM asset.copy cp
      LEFT JOIN extend_reporter.legacy_circ_count c USING (id)
      LEFT JOIN (SELECT max(dest_recv_time) as dest_recv_time, target_copy, dest from action.transit_copy group by target_copy, dest) atc ON (cp.id = atc.target_copy AND cp.circ_lib = atc.dest)
      LEFT JOIN action.circulation circ ON circ.target_copy = cp.id
      LEFT JOIN action.aged_circulation acirc ON acirc.target_copy = cp.id
      WHERE NOT cp.deleted AND cp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) GROUP BY cp.id, dest_recv_time ORDER BY cp.id
    LOOP

      SELECT cn.record, cn.label
      INTO lms_bib_id, filter_level_1
      FROM asset.call_number cn, asset.copy c 
      WHERE c.call_number = cn.id AND c.id =  item;
      SELECT r.isbn[1] INTO isbn
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;
      SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
             REPLACE(create_date::DATE::TEXT, '-', ''),
             CASE floating WHEN TRUE THEN 'Y' ELSE NULL END
      INTO price, bar_code, status, date_added, rotating_stock
      FROM asset.copy ac 
      WHERE id = item;
      IF price IS NULL OR price = '' THEN
        SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
        INTO price
        FROM biblio.record_entry
        WHERE id = lms_bib_id;
      END IF;
      SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;
      SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1;
      
      IF arrived IS NOT NULL THEN
        SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
      ELSE
      cumulative_use_current := '0'; 
      END IF;
      SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;
      SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;
  
      purchase_code := ''; -- FIXME do we want something else here?
      lib_supsel_tag := ''; -- FIXME do we want something else here?
      gen_supsel_tag := ''; -- FIXME do we want something else here?
      collection_code_level_2 := ''; -- FIXME do we want something else here?
      filter_level_2 := ''; -- FIXME do we want something else here?
      filter_level_3 := ''; -- FIXME do we want something else here?
      filter_level_4 := ''; -- FIXME do we want something else here?
  
      output := '##HOLD##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(authority_code), '') || ','
        || COALESCE(collectionHQ.quote(library_code), '') || ','
        || COALESCE(collectionHQ.quote(bar_code), '') || ','
        || COALESCE(collectionHQ.quote(last_use_date), '') || ','
        || COALESCE(cumulative_use_total, '') || ','
        || COALESCE(cumulative_use_current, '') || ','
        || COALESCE(collectionHQ.quote(status), '') || ','
        || COALESCE(collectionHQ.quote(date_added), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(purchase_code), '') || ','
        || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
        || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(notes), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '') || ','
        || COALESCE(collectionHQ.quote(collection_code), '') || ','
        || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '');
  
       RAISE INFO '%', output;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;

  END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout_new(text, integer) OWNER TO postgres;

--
-- Name: write_item_rows_to_stdout_old(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION write_item_rows_to_stdout_old(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_item_rows_to_stdout ('LIBRARYCODE',org_unit_id);

  DECLARE
    item BIGINT;
    authority_code ALIAS FOR $1;
    org_unit_id ALIAS for $2;
    lms_bib_id BIGINT;
    library_code TEXT;
    bar_code TEXT;
    last_use_date TEXT;
    cumulative_use_total TEXT;
    cumulative_use_current TEXT;
    status TEXT;
    date_added TEXT;
    price TEXT;
    purchase_code TEXT;
    rotating_stock TEXT;
    lib_supsel_tag TEXT;
    gen_supsel_tag TEXT;
    notes TEXT;
    extract_date TEXT;
    collection_code TEXT;
    collection_code_level_2 TEXT;
    filter_level_1 TEXT;
    filter_level_2 TEXT;
    filter_level_3 TEXT;
    filter_level_4 TEXT;
    isbn TEXT := '';
    output TEXT := '';
    arrived TIMESTAMPTZ;
    num_rows INTEGER := 0;

    start1 timestamp;
    start2 timestamp;
    start3 timestamp;
    start4 timestamp;
    start5 timestamp;
    start6 timestamp;
    start7 timestamp;
    start8 timestamp;
    start9 timestamp;
    start10 timestamp;
    start11 timestamp;

    total1 interval := 0;
    total2 interval := 0;
    total3 interval := 0;
    total4 interval := 0;
    total5 interval := 0;
    total6 interval := 0;
    total7 interval := 0;
    total8 interval := 0;
    total9 interval := 0;
    total10 interval := 0;
    total11 interval := 0;

  BEGIN

    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;

    FOR item IN
      SELECT id FROM asset.copy WHERE NOT deleted AND circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) ORDER BY id
    LOOP
      
      start1 = clock_timestamp();

      SELECT cn.record, cn.label
      INTO lms_bib_id, filter_level_1
      FROM asset.call_number cn, asset.copy c 
      WHERE c.call_number = cn.id AND c.id =  item;
      SELECT r.isbn[1] INTO isbn
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;

      start2 = clock_timestamp();

      SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
             REPLACE(create_date::DATE::TEXT, '-', ''),
             CASE floating WHEN TRUE THEN 'Y' ELSE NULL END
      INTO price, bar_code, status, date_added, rotating_stock
      FROM asset.copy ac 
      WHERE id = item;

      start3 = clock_timestamp();

      IF price IS NULL OR price = '' THEN
        SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
        INTO price
        FROM biblio.record_entry
        WHERE id = lms_bib_id;
      END IF;

      start4 = clock_timestamp();

      SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;

      start5 = clock_timestamp();
      
      SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1;

      start6 = clock_timestamp();

      SELECT circ_count INTO cumulative_use_total FROM extend_reporter.full_circ_count WHERE id = item;
      IF cumulative_use_total IS NULL THEN
        cumulative_use_total := '0';
      END IF;


      SELECT MAX(dest_recv_time) INTO arrived
      FROM action.transit_copy atc
      JOIN asset.copy ac ON (ac.id = atc.target_copy AND ac.circ_lib = atc.dest)
      WHERE ac.id = item;

      start7 = clock_timestamp();

      IF arrived IS NOT NULL THEN
        SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
      ELSE
      cumulative_use_current := '0'; 
      END IF;

      start8 = clock_timestamp();

      SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;

      start9 = clock_timestamp();

      SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;

      start10 = clock_timestamp();
  
      purchase_code := ''; -- FIXME do we want something else here?
      lib_supsel_tag := ''; -- FIXME do we want something else here?
      gen_supsel_tag := ''; -- FIXME do we want something else here?
      collection_code_level_2 := ''; -- FIXME do we want something else here?
      filter_level_2 := ''; -- FIXME do we want something else here?
      filter_level_3 := ''; -- FIXME do we want something else here?
      filter_level_4 := ''; -- FIXME do we want something else here?
  
      output := '##HOLD##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(authority_code), '') || ','
        || COALESCE(collectionHQ.quote(library_code), '') || ','
        || COALESCE(collectionHQ.quote(bar_code), '') || ','
        || COALESCE(collectionHQ.quote(last_use_date), '') || ','
        || COALESCE(cumulative_use_total, '') || ','
        || COALESCE(cumulative_use_current, '') || ','
        || COALESCE(collectionHQ.quote(status), '') || ','
        || COALESCE(collectionHQ.quote(date_added), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(purchase_code), '') || ','
        || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
        || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(notes), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '') || ','
        || COALESCE(collectionHQ.quote(collection_code), '') || ','
        || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '');

        start11 = clock_timestamp();
  
       RAISE INFO '%', output;

       total1 = total1 + start2 - start1;
       total2 = total2 + start3 - start2;
       total3 = total3 + start4 - start3;
       total4 = total4 + start5 - start4;
       total5 = total5 + start6 - start5;
       total6 = total6 + start7 - start6;
       total7 = total7 + start8 - start7;
       total8 = total8 + start9 - start8;
       total9 = total9 + start10 - start9;
       total10 = total10 + start11 - start10;
       total11 = total11 + start11 - start1;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN 
          RAISE INFO '% rows written', num_rows;
          RAISE INFO 'total time % num rows %', total11, num_rows;
       END IF;
       EXIT WHEN (num_rows = 300000);

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;

    RAISE INFO 'time: 1: % 2: % 3: % 4: % 5: % 6: % 7: % 8: % 9: % 10: %', total1, total2, total3, total4, total5, total6, total7, total8, total9, total10;
    RAISE INFO 'total time % num rows %', total11, num_rows;
    RETURN 'x';

  END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout_old(text, integer) OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: create_or_update_code_unknown(); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION create_or_update_code_unknown() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE config.coded_value_map
SET code = 'x' WHERE code = ' ' AND ctype = 'audience';
RETURN NULL;
END;
$$;


ALTER FUNCTION config.create_or_update_code_unknown() OWNER TO evergreen;

--
-- Name: interval_to_seconds(interval); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION interval_to_seconds(interval_val interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN EXTRACT( EPOCH FROM interval_val );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_val interval) OWNER TO evergreen;

--
-- Name: interval_to_seconds(text); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION interval_to_seconds(interval_string text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN config.interval_to_seconds( interval_string::INTERVAL );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_string text) OWNER TO evergreen;

--
-- Name: update_coded_value_map(text, text, text, text, boolean, text, boolean, boolean); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text DEFAULT NULL::text, in_opac_visible boolean DEFAULT NULL::boolean, in_search_label text DEFAULT NULL::text, in_is_simple boolean DEFAULT NULL::boolean, add_only boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_row config.coded_value_map%ROWTYPE;
BEGIN
    -- Look for a current value
    SELECT INTO current_row * FROM config.coded_value_map WHERE ctype = in_ctype AND code = in_code;
    -- If we have one..
    IF FOUND AND NOT add_only THEN
        -- Update anything we were handed
        current_row.value := COALESCE(current_row.value, in_value);
        current_row.description := COALESCE(current_row.description, in_description);
        current_row.opac_visible := COALESCE(current_row.opac_visible, in_opac_visible);
        current_row.search_label := COALESCE(current_row.search_label, in_search_label);
        current_row.is_simple := COALESCE(current_row.is_simple, in_is_simple);
        UPDATE config.coded_value_map
            SET
                value = current_row.value,
                description = current_row.description,
                opac_visible = current_row.opac_visible,
                search_label = current_row.search_label,
                is_simple = current_row.is_simple
            WHERE id = current_row.id;
    ELSE
        INSERT INTO config.coded_value_map(ctype, code, value, description, opac_visible, search_label, is_simple) VALUES
            (in_ctype, in_code, in_value, in_description, COALESCE(in_opac_visible, TRUE), in_search_label, COALESCE(in_is_simple, FALSE));
    END IF;
END;
$$;


ALTER FUNCTION config.update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) OWNER TO evergreen;

--
-- Name: update_hard_due_dates(); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION update_hard_due_dates() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    temp_value  config.hard_due_date_values%ROWTYPE;
    updated     INT := 0;
BEGIN
    FOR temp_value IN
      SELECT  DISTINCT ON (hard_due_date) *
        FROM  config.hard_due_date_values
        WHERE active_date <= NOW() -- We've passed (or are at) the rollover time
        ORDER BY hard_due_date, active_date DESC -- Latest (nearest to us) active time
   LOOP
        UPDATE  config.hard_due_date
          SET   ceiling_date = temp_value.ceiling_date
          WHERE id = temp_value.hard_due_date
                AND ceiling_date <> temp_value.ceiling_date; -- Time is equal if we've already updated the chdd

        IF FOUND THEN
            updated := updated + 1;
        END IF;
    END LOOP;

    RETURN updated;
END;
$$;


ALTER FUNCTION config.update_hard_due_dates() OWNER TO evergreen;

--
-- Name: z3950_source_credentials_apply(text, integer, text, text); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1 FROM config.z3950_source_credentials
        WHERE owner = org AND source = src;

    IF FOUND THEN
        IF COALESCE(uname, '') = '' AND COALESCE(passwd, '') = '' THEN
            DELETE FROM config.z3950_source_credentials 
                WHERE owner = org AND source = src;
        ELSE 
            UPDATE config.z3950_source_credentials 
                SET username = uname, password = passwd
                WHERE owner = org AND source = src;
        END IF;
    ELSE
        IF COALESCE(uname, '') <> '' OR COALESCE(passwd, '') <> '' THEN
            INSERT INTO config.z3950_source_credentials
                (source, owner, username, password) 
                VALUES (src, org, uname, passwd);
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION config.z3950_source_credentials_apply(src text, org integer, uname text, passwd text) OWNER TO evergreen;

--
-- Name: z3950_source_credentials; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE z3950_source_credentials (
    id integer NOT NULL,
    owner integer NOT NULL,
    source text NOT NULL,
    username text,
    password text
);


ALTER TABLE config.z3950_source_credentials OWNER TO evergreen;

--
-- Name: z3950_source_credentials_lookup(text, integer); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION z3950_source_credentials_lookup(source text, owner integer) RETURNS z3950_source_credentials
    LANGUAGE sql STABLE
    AS $_$

    SELECT creds.* 
    FROM config.z3950_source_credentials creds
        JOIN actor.org_unit aou ON (aou.id = creds.owner)
        JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
    WHERE creds.source = $1 AND creds.owner IN ( 
        SELECT id FROM actor.org_unit_ancestors($2) 
    )
    ORDER BY aout.depth DESC LIMIT 1;

$_$;


ALTER FUNCTION config.z3950_source_credentials_lookup(source text, owner integer) OWNER TO evergreen;

SET search_path = container, pg_catalog;

--
-- Name: clear_all_expired_circ_history_items(); Type: FUNCTION; Schema: container; Owner: evergreen
--

CREATE FUNCTION clear_all_expired_circ_history_items() RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete expired circulation bucket items for all users that have
-- a setting for patron.max_reading_list_interval.
--
DECLARE
    today        TIMESTAMP WITH TIME ZONE;
    threshold    TIMESTAMP WITH TIME ZONE;
	usr_setting  RECORD;
BEGIN
	SELECT date_trunc( 'day', now() ) INTO today;
	--
	FOR usr_setting in
		SELECT
			usr,
			value
		FROM
			actor.usr_setting
		WHERE
			name = 'patron.max_reading_list_interval'
	LOOP
		--
		-- Make sure the setting is a valid interval
		--
		BEGIN
			threshold := today - CAST( translate( usr_setting.value, '"', '' ) AS INTERVAL );
		EXCEPTION
			WHEN OTHERS THEN
				RAISE NOTICE 'Invalid setting patron.max_reading_list_interval for user %: ''%''',
					usr_setting.usr, usr_setting.value;
				CONTINUE;
		END;
		--
		--RAISE NOTICE 'User % threshold %', usr_setting.usr, threshold;
		--
    	DELETE FROM container.copy_bucket_item
    	WHERE
        	bucket IN
        	(
        	    SELECT
        	        id
        	    FROM
        	        container.copy_bucket
        	    WHERE
        	        owner = usr_setting.usr
        	        AND btype = 'circ_history'
        	)
        	AND create_time < threshold;
	END LOOP;
	--
END;
$$;


ALTER FUNCTION container.clear_all_expired_circ_history_items() OWNER TO evergreen;

--
-- Name: FUNCTION clear_all_expired_circ_history_items(); Type: COMMENT; Schema: container; Owner: evergreen
--

COMMENT ON FUNCTION clear_all_expired_circ_history_items() IS '
/*
 * Delete expired circulation bucket items for all users that have
 * a setting for patron.max_reading_list_interval.
*/
';


--
-- Name: clear_expired_circ_history_items(integer); Type: FUNCTION; Schema: container; Owner: evergreen
--

CREATE FUNCTION clear_expired_circ_history_items(ac_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete old circulation bucket items for a specified user.
-- "Old" means older than the interval specified by a
-- user-level setting, if it is so specified.
--
DECLARE
    threshold TIMESTAMP WITH TIME ZONE;
BEGIN
	-- Sanity check
	IF ac_usr IS NULL THEN
		RETURN;
	END IF;
	-- Determine the threshold date that defines "old".  Subtract the
	-- interval from the system date, then truncate to midnight.
	SELECT
		date_trunc( 
			'day',
			now() - CAST( translate( value, '"', '' ) AS INTERVAL )
		)
	INTO
		threshold
	FROM
		actor.usr_setting
	WHERE
		usr = ac_usr
		AND name = 'patron.max_reading_list_interval';
	--
	IF threshold is null THEN
		-- No interval defined; don't delete anything
		-- RAISE NOTICE 'No interval defined for user %', ac_usr;
		return;
	END IF;
	--
	-- RAISE NOTICE 'Date threshold: %', threshold;
	--
	-- Threshold found; do the delete
	delete from container.copy_bucket_item
	where
		bucket in
		(
			select
				id
			from
				container.copy_bucket
			where
				owner = ac_usr
				and btype = 'circ_history'
		)
		and create_time < threshold;
	--
	RETURN;
END;
$$;


ALTER FUNCTION container.clear_expired_circ_history_items(ac_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION clear_expired_circ_history_items(ac_usr integer); Type: COMMENT; Schema: container; Owner: evergreen
--

COMMENT ON FUNCTION clear_expired_circ_history_items(ac_usr integer) IS '
/*
 * Delete old circulation bucket items for a specified user.
 * "Old" means older than the interval specified by a
 * user-level setting, if it is so specified.
*/
';


SET search_path = esi, pg_catalog;

--
-- Name: show_encode_version(); Type: FUNCTION; Schema: esi; Owner: evergreen
--

CREATE FUNCTION show_encode_version() RETURNS text
    LANGUAGE plperlu
    AS $_$
  use Encode;
  return $Encode::VERSION;
$_$;


ALTER FUNCTION esi.show_encode_version() OWNER TO evergreen;

--
-- Name: throttle_hold_queue_position_queries(integer, interval); Type: FUNCTION; Schema: esi; Owner: evergreen
--

CREATE FUNCTION throttle_hold_queue_position_queries(max_queries integer DEFAULT 20, max_duration interval DEFAULT '00:00:02'::interval) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    num_running INTEGER;
BEGIN
    -- terminate any that are running longer than the allowed
    -- duration
    PERFORM pg_cancel_backend(pid)
    FROM pg_stat_activity
    WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$
    AND state <> 'idle'
    AND NOW() - query_start > max_duration;

    -- and terminate them all if there are too many
    SELECT COUNT(*)
    INTO num_running
    FROM pg_stat_activity
    WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$;
    IF num_running > max_queries THEN
        RAISE WARNING 'Terminating hold queue position calculations: % were running',  num_running;
        PERFORM pg_cancel_backend(pid)
        FROM pg_stat_activity
        WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$
    	AND state <> 'idle';
    END IF;   
END;
$_$;


ALTER FUNCTION esi.throttle_hold_queue_position_queries(max_queries integer, max_duration interval) OWNER TO evergreen;

SET search_path = evergreen, pg_catalog;

--
-- Name: array_overlap_check(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION array_overlap_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    fld     TEXT;
    cnt     INT;
BEGIN
    fld := TG_ARGV[1];
    EXECUTE 'SELECT COUNT(*) FROM '|| TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME ||' WHERE '|| fld ||' && ($1).'|| fld INTO cnt USING NEW;
    IF cnt > 0 THEN
        RAISE EXCEPTION 'Cannot insert duplicate array into field % of table %', fld, TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME;
    END IF;
    RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.array_overlap_check() OWNER TO evergreen;

--
-- Name: array_remove_item_by_value(anyarray, anyelement); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION array_remove_item_by_value(inp anyarray, el anyelement) RETURNS anyarray
    LANGUAGE sql STABLE
    AS $_$ SELECT ARRAY_ACCUM(x.e) FROM UNNEST( $1 ) x(e) WHERE x.e <> $2; $_$;


ALTER FUNCTION evergreen.array_remove_item_by_value(inp anyarray, el anyelement) OWNER TO evergreen;

--
-- Name: change_db_setting(text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION change_db_setting(setting_name text, settings text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET ' || quote_ident(setting_name) || ' = ' || array_to_string(settings, ',');
END;

$$;


ALTER FUNCTION evergreen.change_db_setting(setting_name text, settings text[]) OWNER TO evergreen;

--
-- Name: cmd_ahr_query(integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION cmd_ahr_query(integer) RETURNS TABLE(id integer, cut_in_line boolean, request_time timestamp with time zone)
    LANGUAGE sql
    AS $_$
WITH holds(holdid) AS 
( SELECT acm.hold FROM action.hold_copy_map acm 
  JOIN action.hold_copy_map acm2 USING(target_copy) 
  WHERE acm2.hold=$1) 
  SELECT id, cut_in_line, request_time FROM action.hold_request WHERE id IN (SELECT holdid FROM holds) ORDER BY coalesce(cut_in_line, false ) DESC, request_time; 
$_$;


ALTER FUNCTION evergreen.cmd_ahr_query(integer) OWNER TO evergreen;

--
-- Name: coded_value_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION coded_value_map_normalizer(input text, ctype text) RETURNS text
    LANGUAGE sql
    AS $_$
        SELECT COALESCE(value,$1) 
            FROM config.coded_value_map 
            WHERE ctype = $2 AND code = $1;
$_$;


ALTER FUNCTION evergreen.coded_value_map_normalizer(input text, ctype text) OWNER TO evergreen;

--
-- Name: could_be_serial_holding_code(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION could_be_serial_holding_code(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;
    use MARC::Field;

    eval {
        my $holding_code = (new JSON::XS)->decode(shift);
        new MARC::Field('999', @$holding_code);
    };  
    return $@ ? 0 : 1;
$_$;


ALTER FUNCTION evergreen.could_be_serial_holding_code(text) OWNER TO evergreen;

--
-- Name: extract_marc_field_set(text, bigint, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION extract_marc_field_set(text, bigint, text, text) RETURNS SETOF text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    FOR output IN
        SELECT x.t FROM (
            SELECT id,t
                FROM  oils_xpath_table(
                    'id', 'marc', $1, $3, 'id = ' || $2)
                AS t(id int, t text))x
        LOOP
        IF $4 IS NOT NULL THEN
            SELECT INTO output (SELECT regexp_replace(output, $4, '', 'g'));
        END IF;
        RETURN NEXT output;
    END LOOP;
    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.extract_marc_field_set(text, bigint, text, text) OWNER TO evergreen;

--
-- Name: facet_force_nfc(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION facet_force_nfc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.value := evergreen.force_unicode_normal_form(NEW.value,'NFC');
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.facet_force_nfc() OWNER TO evergreen;

--
-- Name: fake_fkey_tgr(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION fake_fkey_tgr() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    copy_id BIGINT;
BEGIN
    EXECUTE 'SELECT ($1).' || quote_ident(TG_ARGV[0]) INTO copy_id USING NEW;
    PERFORM * FROM asset.copy WHERE id = copy_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Key (%.%=%) does not exist in asset.copy', TG_TABLE_SCHEMA, TG_TABLE_NAME, copy_id;
    END IF;
    RETURN NULL;
END;
$_$;


ALTER FUNCTION evergreen.fake_fkey_tgr() OWNER TO evergreen;

--
-- Name: force_unicode_normal_form(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION force_unicode_normal_form(string text, form text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
use Unicode::Normalize 'normalize';
return normalize($_[1],$_[0]); # reverse the params
$_X$;


ALTER FUNCTION evergreen.force_unicode_normal_form(string text, form text) OWNER TO evergreen;

--
-- Name: generic_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION generic_map_normalizer(text, text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
my $string = shift;
my %map;

my $default = $string;

$_ = shift;
while (/^\s*?(.*?)\s*?=>\s*?(\S+)\s*/) {
    if ($1 eq '') {
        $default = $2;
    } else {
        $map{$2} = [split(/\s*,\s*/, $1)];
    }
    $_ = $';	
}

for my $key ( keys %map ) {
    return $key if (grep { $_ eq $string } @{ $map{$key} });
}

return $default;

$_X$;


ALTER FUNCTION evergreen.generic_map_normalizer(text, text) OWNER TO evergreen;

--
-- Name: get_barcodes(integer, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION get_barcodes(select_ou integer, type text, in_barcode text) RETURNS SETOF barcode_set
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_barcode TEXT;
    barcode_len INT;
    completion_len  INT;
    asset_barcodes  TEXT[];
    actor_barcodes  TEXT[];
    do_asset    BOOL = false;
    do_serial   BOOL = false;
    do_booking  BOOL = false;
    do_actor    BOOL = false;
    completion_set  config.barcode_completion%ROWTYPE;
BEGIN

    IF position('asset' in type) > 0 THEN
        do_asset = true;
    END IF;
    IF position('serial' in type) > 0 THEN
        do_serial = true;
    END IF;
    IF position('booking' in type) > 0 THEN
        do_booking = true;
    END IF;
    IF do_asset OR do_serial OR do_booking THEN
        asset_barcodes = asset_barcodes || in_barcode;
    END IF;
    IF position('actor' in type) > 0 THEN
        do_actor = true;
        actor_barcodes = actor_barcodes || in_barcode;
    END IF;

    barcode_len := length(in_barcode);

    FOR completion_set IN
      SELECT * FROM config.barcode_completion
        WHERE active
        AND org_unit IN (SELECT aou.id FROM actor.org_unit_ancestors(select_ou) aou)
        LOOP
        IF completion_set.prefix IS NULL THEN
            completion_set.prefix := '';
        END IF;
        IF completion_set.suffix IS NULL THEN
            completion_set.suffix := '';
        END IF;
        IF completion_set.length = 0 OR completion_set.padding IS NULL OR length(completion_set.padding) = 0 THEN
            cur_barcode = completion_set.prefix || in_barcode || completion_set.suffix;
        ELSE
            completion_len = completion_set.length - length(completion_set.prefix) - length(completion_set.suffix);
            IF completion_len >= barcode_len THEN
                IF completion_set.padding_end THEN
                    cur_barcode = rpad(in_barcode, completion_len, completion_set.padding);
                ELSE
                    cur_barcode = lpad(in_barcode, completion_len, completion_set.padding);
                END IF;
                cur_barcode = completion_set.prefix || cur_barcode || completion_set.suffix;
            END IF;
        END IF;
        IF completion_set.actor THEN
            actor_barcodes = actor_barcodes || cur_barcode;
        END IF;
        IF completion_set.asset THEN
            asset_barcodes = asset_barcodes || cur_barcode;
        END IF;
    END LOOP;

    IF do_asset AND do_serial THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM ONLY asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_asset THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_serial THEN
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    END IF;
    IF do_booking THEN
        RETURN QUERY SELECT 'booking'::TEXT, id::BIGINT, barcode FROM booking.resource WHERE barcode = ANY(asset_barcodes);
    END IF;
    IF do_actor THEN
        RETURN QUERY SELECT 'actor'::TEXT, c.usr::BIGINT, c.barcode FROM actor.card c JOIN actor.usr u ON c.usr = u.id WHERE c.barcode = ANY(actor_barcodes) AND c.active AND NOT u.deleted ORDER BY usr;
    END IF;
    RETURN;
END;
$$;


ALTER FUNCTION evergreen.get_barcodes(select_ou integer, type text, in_barcode text) OWNER TO evergreen;

--
-- Name: FUNCTION get_barcodes(select_ou integer, type text, in_barcode text); Type: COMMENT; Schema: evergreen; Owner: evergreen
--

COMMENT ON FUNCTION get_barcodes(select_ou integer, type text, in_barcode text) IS '
Given user input, find an appropriate barcode in the proper class.

Will add prefix/suffix information to do so, and return all results.
';


--
-- Name: get_locale_name(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION get_locale_name(locale text, OUT name text, OUT description text) RETURNS record
    LANGUAGE plpgsql STABLE COST 1
    AS $$
DECLARE
    eg_locale TEXT;
BEGIN
    eg_locale := LOWER(SUBSTRING(locale FROM 1 FOR 2)) || '-' || UPPER(SUBSTRING(locale FROM 4 FOR 2));
        
    SELECT i18nc.string INTO name
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.name';

    IF name IS NULL THEN
       SELECT i18nl.name INTO name
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;

    SELECT i18nc.string INTO description
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.description';

    IF description IS NULL THEN
       SELECT i18nl.description INTO description
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;
END;
$$;


ALTER FUNCTION evergreen.get_locale_name(locale text, OUT name text, OUT description text) OWNER TO evergreen;

--
-- Name: located_uris(bigint, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION located_uris(bibid bigint, ouid integer, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank integer)
    LANGUAGE sql STABLE
    AS $_$
    SELECT acn.id, aou.name, acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number 
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           INNER JOIN actor.org_unit_ancestors( COALESCE($3, $2) ) aou ON (acn.owning_lib = aou.id)
      WHERE acn.record = $1
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE
    UNION
    SELECT acn.id, aou.name, acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number 
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           INNER JOIN actor.org_unit_ancestors( $2 ) aou ON (acn.owning_lib = aou.id)
      WHERE acn.record = $1
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE;
$_$;


ALTER FUNCTION evergreen.located_uris(bibid bigint, ouid integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION evergreen.lowercase(text) OWNER TO evergreen;

--
-- Name: lpad_number_substrings(text, text, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION lpad_number_substrings(text, text, integer) RETURNS text
    LANGUAGE plperlu
    AS $_$
    my $string = shift;
    my $pad = shift;
    my $len = shift;
    my $find = $len - 1;

    while ($string =~ /(?:^|\D)(\d{1,$find})(?:$|\D)/) {
        my $padded = $1;
        $padded = $pad x ($len - length($padded)) . $padded;
        $string =~ s/$1/$padded/sg;
    }

    return $string;
$_$;


ALTER FUNCTION evergreen.lpad_number_substrings(text, text, integer) OWNER TO evergreen;

--
-- Name: maintain_901(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION maintain_901() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $schema = $_TD->{table_schema};
my $marc = MARC::Record->new_from_xml($_TD->{new}{marc});

my @old901s = $marc->field('901');
$marc->delete_fields(@old901s);

if ($schema eq 'biblio') {
    my $tcn_value = $_TD->{new}{tcn_value};

    # Set TCN value to record ID?
    my $id_as_tcn = spi_exec_query("
        SELECT enabled
        FROM config.global_flag
        WHERE name = 'cat.bib.use_id_for_tcn'
    ");
    if (($id_as_tcn->{processed}) && $id_as_tcn->{rows}[0]->{enabled} eq 't') {
        $tcn_value = $_TD->{new}{id}; 
    }

    my $new_901 = MARC::Field->new("901", " ", " ",
        "a" => $tcn_value,
        "b" => $_TD->{new}{tcn_source},
        "c" => $_TD->{new}{id},
        "t" => $schema
    );

    if ($_TD->{new}{owner}) {
        $new_901->add_subfields("o" => $_TD->{new}{owner});
    }

    if ($_TD->{new}{share_depth}) {
        $new_901->add_subfields("d" => $_TD->{new}{share_depth});
    }

    $marc->append_fields($new_901);
} elsif ($schema eq 'authority') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
} elsif ($schema eq 'serial') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
        "o" => $_TD->{new}{owning_lib},
    );

    if ($_TD->{new}{record}) {
        $new_901->add_subfields("r" => $_TD->{new}{record});
    }

    $marc->append_fields($new_901);
} else {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
}

my $xml = $marc->as_xml_record();
$xml =~ s/\n//sgo;
$xml =~ s/^<\?xml.+\?\s*>//go;
$xml =~ s/>\s+</></go;
$xml =~ s/\p{Cc}//go;

# Embed a version of OpenILS::Application::AppUtils->entityize()
# to avoid having to set PERL5LIB for PostgreSQL as well

# If we are going to convert non-ASCII characters to XML entities,
# we had better be dealing with a UTF8 string to begin with
$xml = decode_utf8($xml);

$xml = NFC($xml);

# Convert raw ampersands to entities
$xml =~ s/&(?!\S+;)/&amp;/gso;

# Convert Unicode characters to entities
$xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

$xml =~ s/[\x00-\x1f]//go;
$_TD->{new}{marc} = $xml;

return "MODIFY";
$_X$;


ALTER FUNCTION evergreen.maintain_901() OWNER TO evergreen;

--
-- Name: maintain_control_numbers(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION maintain_control_numbers() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $record = MARC::Record->new_from_xml($_TD->{new}{marc});
my $schema = $_TD->{table_schema};
my $rec_id = $_TD->{new}{id};

# Short-circuit if maintaining control numbers per MARC21 spec is not enabled
my $enable = spi_exec_query("SELECT enabled FROM config.global_flag WHERE name = 'cat.maintain_control_numbers'");
if (!($enable->{processed}) or $enable->{rows}[0]->{enabled} eq 'f') {
    return;
}

# Get the control number identifier from an OU setting based on $_TD->{new}{owner}
my $ou_cni = 'EVRGRN';

my $owner;
if ($schema eq 'serial') {
    $owner = $_TD->{new}{owning_lib};
} else {
    # are.owner and bre.owner can be null, so fall back to the consortial setting
    $owner = $_TD->{new}{owner} || 1;
}

my $ous_rv = spi_exec_query("SELECT value FROM actor.org_unit_ancestor_setting('cat.marc_control_number_identifier', $owner)");
if ($ous_rv->{processed}) {
    $ou_cni = $ous_rv->{rows}[0]->{value};
    $ou_cni =~ s/"//g; # Stupid VIM syntax highlighting"
} else {
    # Fall back to the shortname of the OU if there was no OU setting
    $ous_rv = spi_exec_query("SELECT shortname FROM actor.org_unit WHERE id = $owner");
    if ($ous_rv->{processed}) {
        $ou_cni = $ous_rv->{rows}[0]->{shortname};
    }
}

my ($create, $munge) = (0, 0);

my @scns = $record->field('035');

foreach my $id_field ('001', '003') {
    my $spec_value;
    my @controls = $record->field($id_field);

    if ($id_field eq '001') {
        $spec_value = $rec_id;
    } else {
        $spec_value = $ou_cni;
    }

    # Create the 001/003 if none exist
    if (scalar(@controls) == 1) {
        # Only one field; check to see if we need to munge it
        unless (grep $_->data() eq $spec_value, @controls) {
            $munge = 1;
        }
    } else {
        # Delete the other fields, as with more than 1 001/003 we do not know which 003/001 to match
        foreach my $control (@controls) {
            $record->delete_field($control);
        }
        $record->insert_fields_ordered(MARC::Field->new($id_field, $spec_value));
        $create = 1;
    }
}

my $cn = $record->field('001')->data();
# Special handling of OCLC numbers, often found in records that lack 003
if ($cn =~ /^o(c[nm]|n)\d/) {
    $cn =~ s/^o(c[nm]|n)0*(\d+)/$2/;
    $record->field('003')->data('OCoLC');
    $create = 0;
}

# Now, if we need to munge the 001, we will first push the existing 001/003
# into the 035; but if the record did not have one (and one only) 001 and 003
# to begin with, skip this process
if ($munge and not $create) {

    my $scn = "(" . $record->field('003')->data() . ")" . $cn;

    # Do not create duplicate 035 fields
    unless (grep $_->subfield('a') eq $scn, @scns) {
        $record->insert_fields_ordered(MARC::Field->new('035', '', '', 'a' => $scn));
    }
}

# Set the 001/003 and update the MARC
if ($create or $munge) {
    $record->field('001')->data($rec_id);
    $record->field('003')->data($ou_cni);

    my $xml = $record->as_xml_record();
    $xml =~ s/\n//sgo;
    $xml =~ s/^<\?xml.+\?\s*>//go;
    $xml =~ s/>\s+</></go;
    $xml =~ s/\p{Cc}//go;

    # Embed a version of OpenILS::Application::AppUtils->entityize()
    # to avoid having to set PERL5LIB for PostgreSQL as well

    # If we are going to convert non-ASCII characters to XML entities,
    # we had better be dealing with a UTF8 string to begin with
    $xml = decode_utf8($xml);

    $xml = NFC($xml);

    # Convert raw ampersands to entities
    $xml =~ s/&(?!\S+;)/&amp;/gso;

    # Convert Unicode characters to entities
    $xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

    $xml =~ s/[\x00-\x1f]//go;
    $_TD->{new}{marc} = $xml;

    return "MODIFY";
}

return;
$_X$;


ALTER FUNCTION evergreen.maintain_control_numbers() OWNER TO evergreen;

--
-- Name: oils_xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) RETURNS SETOF record
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    xpath_list  TEXT[];
    select_list TEXT[];
    where_list  TEXT[];
    q           TEXT;
    out_record  RECORD;
    empty_test  RECORD;
BEGIN
    xpath_list := STRING_TO_ARRAY( xpaths, '|' );

    select_list := ARRAY_APPEND( select_list, key || '::INT AS key' );

    FOR i IN 1 .. ARRAY_UPPER(xpath_list,1) LOOP
        IF xpath_list[i] = 'null()' THEN
            select_list := ARRAY_APPEND( select_list, 'NULL::TEXT AS c_' || i );
        ELSE
            select_list := ARRAY_APPEND(
                select_list,
                $sel$
                unnest(
                    COALESCE(
                        NULLIF(
                            oils_xpath(
                                $sel$ ||
                                    quote_literal(
                                        CASE
                                            WHEN xpath_list[i] ~ $re$/[^/[]*@[^/]+$$re$ OR xpath_list[i] ~ $re$text\(\)$$re$ THEN xpath_list[i]
                                            ELSE xpath_list[i] || '//text()'
                                        END
                                    ) ||
                                $sel$,
                                $sel$ || document_field || $sel$
                            ),
                           '{}'::TEXT[]
                        ),
                        '{NULL}'::TEXT[]
                    )
                ) AS c_$sel$ || i
            );
            where_list := ARRAY_APPEND(
                where_list,
                'c_' || i || ' IS NOT NULL'
            );
        END IF;
    END LOOP;

    q := $q$
SELECT * FROM (
    SELECT $q$ || ARRAY_TO_STRING( select_list, ', ' ) || $q$ FROM $q$ || relation_name || $q$ WHERE ($q$ || criteria || $q$)
)x WHERE $q$ || ARRAY_TO_STRING( where_list, ' OR ' );
    -- RAISE NOTICE 'query: %', q;

    FOR out_record IN EXECUTE q LOOP
        RETURN NEXT out_record;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) OWNER TO evergreen;

--
-- Name: org_top(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION org_top() RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $$ SELECT * FROM actor.org_unit WHERE parent_ou IS NULL LIMIT 1; $$;


ALTER FUNCTION evergreen.org_top() OWNER TO evergreen;

--
-- Name: ous_change_log(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION ous_change_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = NEW.name AND org_unit = NEW.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (NEW.org_unit, original, NEW.value, NEW.name);
        
        RETURN NEW;
    END;
$$;


ALTER FUNCTION evergreen.ous_change_log() OWNER TO evergreen;

--
-- Name: ous_delete_log(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION ous_delete_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = OLD.name AND org_unit = OLD.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (OLD.org_unit, original, 'null', OLD.name);
        
        RETURN OLD;
    END;
$$;


ALTER FUNCTION evergreen.ous_delete_log() OWNER TO evergreen;

--
-- Name: perl_oils_xpath(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION perl_oils_xpath(text, text) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT perl_oils_xpath( $1, $2, '{}'::TEXT[]);$_$;


ALTER FUNCTION evergreen.perl_oils_xpath(text, text) OWNER TO evergreen;

--
-- Name: perl_oils_xpath(text, text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION perl_oils_xpath(xpath text, xml text, ns text[]) RETURNS text[]
    LANGUAGE plperlu
    AS $_X$
  use strict;
  use XML::LibXML;

  my $xpath = shift;
  my $doc = shift;
  my $ns_string = shift || '';

  my %ns_list = $ns_string =~ m/\{([^{,]+),([^}]+)\}/g;

  # The following approach uses the older XML::LibXML 1.69 / XML::LibXSLT 1.68
  # methods of parsing XML documents and stylesheets, in the hopes of broader
  # compatibility with distributions
  my $parser = eval { $_SHARED{'_xslt_process'}{parsers}{xml} || XML::LibXML->new() };

  return undef if ($@);

  # Cache the XML parser, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xml} = $parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xml});

  # parse the doc
  my $dom = eval { $parser->parse_string($doc) };

  return undef if ($@);

  # Register the requested namespaces
  $dom->documentElement->setNamespace( $ns_list{$_} => $_ ) for ( keys %ns_list );
  my $xpc = XML::LibXML::XPathContext->new;
  $xpc->registerNs( $ns_list{$_} => $_ ) for ( keys %ns_list );

  # Gather and return nodes
  my @nodes = $dom->findnodes($xpath);

  return [ map { $_->toStringC14N } @nodes ];
$_X$;


ALTER FUNCTION evergreen.perl_oils_xpath(xpath text, xml text, ns text[]) OWNER TO evergreen;

--
-- Name: rank_cp_status(integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION rank_cp_status(status integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    WITH totally_available AS (
        SELECT id, 0 AS avail_rank
        FROM config.copy_status
        WHERE opac_visible IS TRUE
            AND copy_active IS TRUE
            AND id != 1 -- "Checked out"
    ), almost_available AS (
        SELECT id, 10 AS avail_rank
        FROM config.copy_status
        WHERE holdable IS TRUE
            AND opac_visible IS TRUE
            AND copy_active IS FALSE
            OR id = 1 -- "Checked out"
    )
    SELECT COALESCE(
        (SELECT avail_rank FROM totally_available WHERE $1 IN (id)),
        (SELECT avail_rank FROM almost_available WHERE $1 IN (id)),
        100
    );
$_$;


ALTER FUNCTION evergreen.rank_cp_status(status integer) OWNER TO evergreen;

--
-- Name: rank_ou(integer, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION rank_ou(lib integer, search_lib integer, pref_lib integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    SELECT COALESCE(

        -- lib matches search_lib
        (SELECT CASE WHEN $1 = $2 THEN -20000 END),

        -- lib matches pref_lib
        (SELECT CASE WHEN $1 = $3 THEN -10000 END),


        -- pref_lib is a child of search_lib and lib is a child of pref lib.  
        (SELECT distance - 5000
            FROM actor.org_unit_descendants_distance($3) 
            WHERE id = $1 AND $3 IN (
                SELECT id FROM actor.org_unit_descendants($2))),

        -- lib is a child of search_lib
        (SELECT distance FROM actor.org_unit_descendants_distance($2) WHERE id = $1),

        -- all others pay cash
        1000
    );
$_$;


ALTER FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: ranked_volumes(bigint, integer, integer, hstore, hstore, integer, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION ranked_volumes(bibid bigint, ouid integer, depth integer DEFAULT NULL::integer, slimit hstore DEFAULT NULL::hstore, soffset hstore DEFAULT NULL::hstore, pref_lib integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[]) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE
    AS $_$
    SELECT ua.id, ua.name, ua.label_sortkey, MIN(ua.rank) AS rank FROM (
        SELECT acn.id, aou.name, acn.label_sortkey,
            evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status),
            RANK() OVER w
        FROM asset.call_number acn
            JOIN asset.copy acp ON (acn.id = acp.call_number)
            JOIN actor.org_unit_descendants( $2, COALESCE(
                $3, (
                    SELECT depth
                    FROM actor.org_unit_type aout
                        INNER JOIN actor.org_unit ou ON ou_type = aout.id
                    WHERE ou.id = $2
                ), $6)
            ) AS aou ON (acp.circ_lib = aou.id)
        WHERE acn.record = $1
            AND acn.deleted IS FALSE
            AND acp.deleted IS FALSE
            AND CASE WHEN ('exclude_invisible_acn' = ANY($7)) THEN 
                EXISTS (
                    SELECT 1 
                    FROM asset.opac_visible_copies 
                    WHERE copy_id = acp.id AND record = acn.record
                ) ELSE TRUE END
        GROUP BY acn.id, acp.status, aou.name, acn.label_sortkey, aou.id
        WINDOW w AS (
            ORDER BY evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status)
        )
    ) AS ua
    GROUP BY ua.id, ua.name, ua.label_sortkey
    ORDER BY rank, ua.name, ua.label_sortkey
    LIMIT ($4 -> 'acn')::INT
    OFFSET ($5 -> 'acn')::INT;
$_$;


ALTER FUNCTION evergreen.ranked_volumes(bibid bigint, ouid integer, depth integer, slimit hstore, soffset hstore, pref_lib integer, includes text[]) OWNER TO evergreen;

--
-- Name: regexp_split_to_array(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION regexp_split_to_array(text, text) RETURNS text[]
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
    return encode_array_literal([split $_[1], $_[0]]);
$_X$;


ALTER FUNCTION evergreen.regexp_split_to_array(text, text) OWNER TO evergreen;

--
-- Name: rel_bump(text[], text, text[], numeric[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION rel_bump(terms text[], value text, bumps text[], mults numeric[]) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
use strict;
my ($terms,$value,$bumps,$mults) = @_;

my $retval = 1;

for (my $id = 0; $id < @$bumps; $id++) {
        if ($bumps->[$id] eq 'first_word') {
                $retval *= $mults->[$id] if ($value =~ /^$terms->[0]/);
        } elsif ($bumps->[$id] eq 'full_match') {
                my $fullmatch = join(' ', @$terms);
                $retval *= $mults->[$id] if ($value =~ /^$fullmatch$/);
        } elsif ($bumps->[$id] eq 'word_order') {
                my $wordorder = join('.*', @$terms);
                $retval *= $mults->[$id] if ($value =~ /$wordorder/);
        }
}
return $retval;
$_$;


ALTER FUNCTION evergreen.rel_bump(terms text[], value text, bumps text[], mults numeric[]) OWNER TO evergreen;

--
-- Name: upgrade_deps_block_check(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_deps_block_check(my_db_patch text, my_applied_to text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NOT evergreen.upgrade_verify_no_dep_conflicts( my_db_patch ) THEN
        RAISE EXCEPTION '
Upgrade script % can not be applied:
  applied deprecated scripts %
  applied superseded scripts %
  deprecated by %
  superseded by %',
            my_db_patch,
            ARRAY_ACCUM(evergreen.upgrade_list_applied_deprecates(my_db_patch)),
            ARRAY_ACCUM(evergreen.upgrade_list_applied_supersedes(my_db_patch)),
            evergreen.upgrade_list_applied_deprecated(my_db_patch),
            evergreen.upgrade_list_applied_superseded(my_db_patch);
    END IF;

    INSERT INTO config.upgrade_log (version, applied_to) VALUES (my_db_patch, my_applied_to);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION evergreen.upgrade_deps_block_check(my_db_patch text, my_applied_to text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_deprecated(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_list_applied_deprecated(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && deprecates
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecated(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_deprecates(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_list_applied_deprecates(my_db_patch text) RETURNS SETOF patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version::TEXT[] && d.deprecates)
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecates(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_superseded(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_list_applied_superseded(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && supersedes
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_superseded(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_supersedes(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_list_applied_supersedes(my_db_patch text) RETURNS SETOF patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version::TEXT[] && d.supersedes)
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_supersedes(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_verify_no_dep_conflicts(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION upgrade_verify_no_dep_conflicts(my_db_patch text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT  COUNT(*) = 0
      FROM  (SELECT * FROM evergreen.upgrade_list_applied_deprecates( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_supersedes( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_deprecated( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_superseded( $1 ))x
$_$;


ALTER FUNCTION evergreen.upgrade_verify_no_dep_conflicts(my_db_patch text) OWNER TO evergreen;

--
-- Name: xml_escape(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION xml_escape(str text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT REPLACE(REPLACE(REPLACE($1,
       '&', '&amp;'),
       '<', '&lt;'),
       '>', '&gt;');
$_$;


ALTER FUNCTION evergreen.xml_escape(str text) OWNER TO evergreen;

--
-- Name: xml_pretty_print(xml); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION xml_pretty_print(input xml) RETURNS xml
    LANGUAGE sql
    AS $_$
SELECT xslt_process($1::text,
$$<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    version="1.0">
   <xsl:output method="xml" omit-xml-declaration="yes" indent="yes"/>
   <xsl:strip-space elements="*"/>
   <xsl:template match="@*|node()">
     <xsl:copy>
       <xsl:apply-templates select="@*|node()"/>
     </xsl:copy>
   </xsl:template>
 </xsl:stylesheet>
$$::text)::XML
$_$;


ALTER FUNCTION evergreen.xml_pretty_print(input xml) OWNER TO evergreen;

--
-- Name: FUNCTION xml_pretty_print(input xml); Type: COMMENT; Schema: evergreen; Owner: evergreen
--

COMMENT ON FUNCTION xml_pretty_print(input xml) IS 'Simple pretty printer for XML, as written by Andrew Dunstan at http://goo.gl/zBHIk';


SET search_path = m_kcls, pg_catalog;

--
-- Name: add_default_008(text); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION add_default_008(text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval { 
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $f008 = $marc->field('008');
    if (!defined($f008) or $f008->data =~ /^\s*$/) {
       $marc->delete_field($f008) if defined $f008;
       my $str008 = '101015s20uu    xx |||||||||||||||| eng d';
       my $sf260c = $marc->subfield('260', 'c');
       if (defined $sf260c and $sf260c =~ /(\d{4})/) {
         substr($str008, 7, 4) = $1;
       }
       $marc->insert_fields_ordered(MARC::Field->new('008', $str008));
    }
    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };
  return $xml;
$_$;


ALTER FUNCTION m_kcls.add_default_008(text) OWNER TO evergreen;

--
-- Name: add_default_008_2(text); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION add_default_008_2(text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval { 
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $f008 = $marc->field('008');
    if (defined($f008) and length($f008->data()) > 20) {
       $str008 = $f008->data();
       if (substr($str008, 7, 4) eq '    ') {
       my $sf260c = $marc->subfield('260', 'c');
       if (defined $sf260c and $sf260c =~ /(\d{4})/) {
         substr($str008, 7, 4) = $1;
         substr($str008, 6, 1) = 's' if substr($str008, 6, 1) eq ' ';
         $f008->update($str008);
         $xml = $marc->as_xml_record;
         $xml =~ s/^<\?.+?\?>$//mo;
         $xml =~ s/\n//sgo;
         $xml =~ s/>\s+</></sgo;
       }
      }
    }
  };
  return $xml;
$_$;


ALTER FUNCTION m_kcls.add_default_008_2(text) OWNER TO evergreen;

--
-- Name: name_parse(text); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION name_parse(text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
    DECLARE
        full_name TEXT := $1;
        temp TEXT;
        family_name TEXT := '';
        first_given_name TEXT := '';
        second_given_name TEXT := '';
        suffix TEXT := '';
        prefix TEXT := '';
    BEGIN
        temp := full_name;
        family_name := BTRIM( REGEXP_REPLACE(temp,E'^([^,]*)\\s*,.*$',E'\\1') );
        first_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*([^,\\s]*)\\s*.*$',E'\\1') ELSE 'N
/A' END );
        second_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*[^,\\s]*\\s*(.*)$',E'\\1') ELSE '
'  END );

        RETURN ARRAY[ family_name, first_given_name, second_given_name ];
    END;
$_$;


ALTER FUNCTION m_kcls.name_parse(text) OWNER TO evergreen;

--
-- Name: parse_address(text[]); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION parse_address(lines text[]) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
        line1 TEXT := '';
        line2 TEXT := '';
        city TEXT := '';
        state TEXT := '';
        zip TEXT := '';
        city_state_zip TEXT := '';
        country TEXT := 'USA';
        line_count INTEGER := array_upper(lines, 1);
BEGIN
  IF line_count = 1 THEN
     -- no choice
     line1 := lines[1];
  ELSIF line_count = 2 THEN
     line1 := lines[1];
     city_state_zip := lines[2];
  ELSIF line_count = 3 THEN
     IF UPPER(lines[3]) = 'CANADA' THEN
        line1 := lines[1];
        city_state_zip := lines[2];
        country := 'CANADA';
     ELSE
        line1 := lines[1];
        line2 := lines[2];
        city_state_zip := lines[3];
     END IF;
  ELSIF line_count > 3 THEN
     IF UPPER(lines[4]) = 'CANADA' THEN
        line1 := lines[1];
        line2 := lines[2];
        city_state_zip := lines[3];
        country := 'CANADA';
     ELSE
        line1 := lines[1];
        line2 := lines[2] || ' ' || lines[3];
        city_state_zip := lines[4];
     END IF;
  END IF;
  city_state_zip := REGEXP_REPLACE(city_state_zip, E'\\s+', E' ', 'g');
        zip := CASE WHEN city_state_zip ~ E'\\d\\d\\d\\d\\d' THEN REGEXP_REPLACE( city_state_zip, E'^.*(\\d\\d\\d\\d\\d-?\\d*).*$',
E'\\1' ) ELSE '' END;
        city_state_zip := REGEXP_REPLACE( city_state_zip, E'^(.*)\\d\\d\\d\\d\\d-?\\d*(.*)$', E'\\1\\2');
        city_state_zip := BTRIM(city_state_zip);
        IF city_state_zip ~ ',' THEN
            state := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\2');
            city := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\1');
        ELSE
            IF city_state_zip ~ E'\\s+[A-Z][A-Z]$' THEN
                state := REGEXP_REPLACE( city_state_zip, E'^.*,?\\s+([A-Z][A-Z])$', E'\\1' );
                city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s+[A-Z][A-Z]$', E'\\1\\2' );
            ELSE
                IF city_state_zip ~ E'^\\S+$'  THEN
                    city := city_state_zip;
                    state := 'N/A';
                ELSE
                    state := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\2');
                    city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\1');
                END IF;
            END IF;
        END IF;
  line1 := BTRIM(line1);
  line2 := BTRIM(line2);
  city := BTRIM(city);
  state := BTRIM(state);
  zip := BTRIM(zip);
  COUNTRY := BTRIM(country);
  RETURN ARRAY[line1, line2, city, state, zip, country];
END;
$_$;


ALTER FUNCTION m_kcls.parse_address(lines text[]) OWNER TO evergreen;

--
-- Name: quick_hold_target(); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION quick_hold_target() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    x_hold_id INTEGER;


    x_copy_id INTEGER;
BEGIN
    FOR x_hold_id IN SELECT hold_id FROM m_kcls.best_avail_copies ORDER BY bib_id, request_time  LOOP
      DELETE FROM action.hold_copy_map WHERE hold = x_hold_id;
      INSERT INTO action.hold_copy_map (hold, target_copy)


        SELECT hold_id, copy_id FROM m_kcls.best_avail_copies
        WHERE hold_id = x_hold_id;
      SELECT min(copy_id) INTO x_copy_id FROM m_kcls.best_avail_copies
                            WHERE hold_id = x_hold_id;
      UPDATE action.hold_request
        SET prev_check_time = now(),
            current_copy = x_copy_id
        WHERE id = x_hold_id;
      DELETE FROM m_kcls.best_avail_copies WHERE copy_id = x_copy_id;
      DELETE FROM m_kcls.best_avail_copies WHERE hold_id = x_hold_id;
      
    END LOOP;
END;
$$;


ALTER FUNCTION m_kcls.quick_hold_target() OWNER TO evergreen;

--
-- Name: reingest_specific_metabib_field_entries(bigint, integer[]); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION reingest_specific_metabib_field_entries(bib_id bigint, fields integer[]) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    fclass          RECORD;
    ind_data        metabib.field_entry_template%ROWTYPE;
    field_clause    TEXT := '';
    i               INT;
BEGIN
    FOR i IN 1 .. array_upper(fields, 1) LOOP
        field_clause := field_clause || fields[i] || ',';
    END LOOP;
    field_clause := substring(field_clause from 1 for character_length(field_clause) - 1);
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        FOR fclass IN SELECT * FROM config.metabib_field WHERE id = ANY(fields) LOOP
            -- RAISE NOTICE 'Emptying out %', fclass.name;
            EXECUTE $$DELETE FROM metabib.$$ || fclass.field_class || $$_field_entry WHERE source = $$ || bib_id ||
            $$ AND field IN ($$ || field_clause || ')';
        END LOOP;
        DELETE FROM metabib.facet_entry WHERE source = bib_id AND field = ANY(fields);
    END IF;

    FOR ind_data IN SELECT * FROM m_kcls.extract_specific_metabib_field_entries( bib_id, fields, ' ' ) LOOP
        IF NOT(abs(ind_data.field) = ANY(fields)) THEN
            CONTINUE;
        END IF;
        IF  ind_data.field < 0 THEN
            ind_data.field = -1 * ind_data.field;
            INSERT INTO metabib.facet_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        ELSE
            EXECUTE $$
                INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value)
                    VALUES ($$ ||
                        quote_literal(ind_data.field) || $$, $$ ||
                        quote_literal(ind_data.source) || $$, $$ ||
                        quote_literal(ind_data.value) ||
                    $$);$$;
        END IF;

    END LOOP;

    RETURN;
END;
$_X$;


ALTER FUNCTION m_kcls.reingest_specific_metabib_field_entries(bib_id bigint, fields integer[]) OWNER TO evergreen;

--
-- Name: renorm_field_entry(text, integer, bigint, bigint); Type: FUNCTION; Schema: m_kcls; Owner: evergreen
--

CREATE FUNCTION renorm_field_entry(field_class text, fld integer, offst bigint, lim bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
  upd TEXT;
BEGIN
  upd := 'UPDATE metabib.' || field_class || '_field_entry ';
  upd := upd || $$
    SET id = id
    WHERE id IN (
    SELECT id$$;
  upd := upd || ' FROM metabib.' || field_class || '_field_entry' ||
  ' WHERE field = ' || fld ||
  ' ORDER BY id' ||
  ' OFFSET ' || offst || ' LIMIT ' || lim || ')';
  EXECUTE upd;

END;
$_$;


ALTER FUNCTION m_kcls.renorm_field_entry(field_class text, fld integer, offst bigint, lim bigint) OWNER TO evergreen;

SET search_path = m_kcls2, pg_catalog;

--
-- Name: parse_address(text[]); Type: FUNCTION; Schema: m_kcls2; Owner: evergreen
--

CREATE FUNCTION parse_address(lines text[]) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
        line1 TEXT := '';
        line2 TEXT := '';
        city TEXT := '';
        state TEXT := '';
        zip TEXT := '';
        city_state_zip TEXT := '';
        country TEXT := 'USA';
        line_count INTEGER := array_upper(lines, 1);
BEGIN
  IF line_count = 1 THEN
     -- no choice
     line1 := lines[1];
  ELSIF line_count = 2 THEN
     line1 := lines[1];
     city_state_zip := lines[2];
  ELSIF line_count = 3 THEN
     IF UPPER(lines[3]) = 'CANADA' THEN
        line1 := lines[1];
        city_state_zip := lines[2];
        country := 'CANADA';
     ELSE
        line1 := lines[1];
        line2 := lines[2];
        city_state_zip := lines[3];
     END IF;
  ELSIF line_count > 3 THEN
     IF UPPER(lines[4]) = 'CANADA' THEN
        line1 := lines[1];
        line2 := lines[2];
        city_state_zip := lines[3];
        country := 'CANADA';
     ELSE
        line1 := lines[1];
        line2 := lines[2] || ' ' || lines[3];
        city_state_zip := lines[4];
     END IF;
  END IF;
  city_state_zip := REGEXP_REPLACE(city_state_zip, E'\\s+', E' ', 'g');
        zip := CASE WHEN city_state_zip ~ E'\\d\\d\\d\\d\\d' THEN REGEXP_REPLACE( city_state_zip, E'^.*(\\d\\d\\d\\d\\d-?\\d*).*$',
E'\\1' ) ELSE '' END;
        city_state_zip := REGEXP_REPLACE( city_state_zip, E'^(.*)\\d\\d\\d\\d\\d-?\\d*(.*)$', E'\\1\\2');
        city_state_zip := BTRIM(city_state_zip);
        IF city_state_zip ~ ',' THEN
            state := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\2');
            city := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\1');
        ELSE
            IF city_state_zip ~ E'\\s+[A-Z][A-Z]$' THEN
                state := REGEXP_REPLACE( city_state_zip, E'^.*,?\\s+([A-Z][A-Z])$', E'\\1' );
                city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s+[A-Z][A-Z]$', E'\\1\\2' );
            ELSE
                IF city_state_zip ~ E'^\\S+$'  THEN
                    city := city_state_zip;
                    state := 'N/A';
                ELSE
                    state := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\2');
                    city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\1');
                END IF;
            END IF;
        END IF;
  line1 := BTRIM(line1);
  line2 := BTRIM(line2);
  city := BTRIM(city);
  state := BTRIM(state);
  zip := BTRIM(zip);
  COUNTRY := BTRIM(country);
  RETURN ARRAY[line1, line2, city, state, zip, country];
END;
$_$;


ALTER FUNCTION m_kcls2.parse_address(lines text[]) OWNER TO evergreen;

--
-- Name: parse_contact(text[]); Type: FUNCTION; Schema: m_kcls2; Owner: evergreen
--

CREATE FUNCTION parse_contact(lines text[]) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
        role TEXT := '';
        email TEXT := '';
        phone TEXT := '';
        line_count INTEGER := array_upper(lines, 1);
        i INTEGER;
BEGIN
   IF line_count > 1 THEN
      FOR i IN 2 .. line_count LOOP
        IF lines[i] ~ E'[0-9]{3}.[0-9]{4}' THEN
           phone := lines[i];
        ELSIF lines[i] ~ E'@' THEN
           email := lines[i];
        ELSE 
           role := lines[i];
         END IF;
      END LOOP;
   END IF;
   role = NULLIF(BTRIM(role), '');
   email = NULLIF(BTRIM(email), '');
   phone = NULLIF(BTRIM(phone), '');
   RETURN ARRAY[role, email, phone];
END;
$$;


ALTER FUNCTION m_kcls2.parse_contact(lines text[]) OWNER TO evergreen;

SET search_path = metabib, pg_catalog;

--
-- Name: autosuggest_prepare_tsquery(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION autosuggest_prepare_tsquery(orig text) RETURNS text[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    orig_ended_in_space     BOOLEAN;
    result                  RECORD;
    plain                   TEXT;
    normalized              TEXT;
BEGIN
    --ver1.0
    orig_ended_in_space := orig ~ E'\\s$';

    orig := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(orig, E'\\W+'), ' '
    );

    normalized := public.naco_normalize(orig); -- also trim()s
    plain := trim(orig);

    IF NOT orig_ended_in_space THEN
        plain := plain || ':*';
        normalized := normalized || ':*';
    END IF;

    plain := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(plain, E'\\s+'), ' & '
    );
    normalized := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(normalized, E'\\s+'), ' & '
    );

    RETURN ARRAY[normalized, plain];
END;
$_$;


ALTER FUNCTION metabib.autosuggest_prepare_tsquery(orig text) OWNER TO evergreen;

--
-- Name: browse(text, text, integer, integer, boolean, bigint, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse(search_class text, browse_term text, context_org integer DEFAULT NULL::integer, context_loc_group integer DEFAULT NULL::integer, staff boolean DEFAULT false, pivot_id bigint DEFAULT NULL::bigint, result_limit integer DEFAULT 10) RETURNS SETOF flat_browse_entry_appearance
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_bound_lower             TEXT;
    v_bound_upper             TEXT;
    core_query              TEXT;
    back_query              TEXT;
    forward_query           TEXT;
    pivot_sort_value        TEXT;
    pivot_sort_fallback     TEXT;
    search_field            INT[];
    context_locations       INT[];
    browse_superpage_size   INT;
    results_skipped         INT := 0;
    back_limit              INT;
    back_to_pivot           INT;
    forward_limit           INT;
    forward_to_pivot        INT;
BEGIN
    --ver1.1 updated with kmain-806
    -- Get search field int list with search_class
    IF search_class = 'id|bibcn' THEN

      SELECT INTO search_class 'call_number';

      SELECT INTO search_field COALESCE(ARRAY_AGG(id), ARRAY[]::INT[])
            FROM config.metabib_field WHERE field_class = 'identifier' AND name = 'bibcn';
      IF pivot_id IS NULL THEN

          pivot_id := metabib.browse_call_number_pivot(browse_term);
      
      END IF;
    ELSE

      SELECT INTO search_field COALESCE(ARRAY_AGG(id), ARRAY[]::INT[])
            FROM config.metabib_field WHERE field_class = search_class;

    -- First, find the pivot if we were given a browse term but not a pivot.
      IF pivot_id IS NULL THEN

          CASE search_class
            WHEN 'author' THEN pivot_id := metabib.browse_author_pivot(search_field, browse_term);
            WHEN 'title' THEN pivot_id := metabib.browse_title_pivot(search_field, browse_term);
            WHEN 'subject' THEN pivot_id := metabib.browse_subject_pivot(search_field, browse_term);
            WHEN 'series' THEN pivot_id := metabib.browse_series_pivot(search_field, browse_term);
          
          END CASE;
      END IF;
    END IF;

    CASE search_class
      WHEN 'author' THEN 
        SELECT INTO pivot_sort_value, pivot_sort_fallback
        truncated_sort_value, value
        FROM metabib.browse_author_entry WHERE id = pivot_id;
      WHEN 'title' THEN
        SELECT INTO pivot_sort_value, pivot_sort_fallback
        truncated_sort_value, value
        FROM metabib.browse_title_entry WHERE id = pivot_id;
      WHEN 'subject' THEN
        SELECT INTO pivot_sort_value, pivot_sort_fallback
        truncated_sort_value, value
        FROM metabib.browse_subject_entry WHERE id = pivot_id;
      WHEN 'series' THEN
        SELECT INTO pivot_sort_value, pivot_sort_fallback
        truncated_sort_value, value
        FROM metabib.browse_series_entry WHERE id = pivot_id;
      WHEN 'call_number' THEN
        SELECT INTO pivot_sort_value, pivot_sort_fallback
        truncated_sort_value, value
        FROM metabib.browse_call_number_entry WHERE id = pivot_id;
          
    END CASE;

     --<<

    -- Bail if we couldn't find a pivot.
    IF pivot_sort_value IS NULL THEN
        RETURN;
    END IF;

    select bound_lower, bound_upper into v_bound_lower, v_bound_upper from metabib.browse_table_bounds(search_class,public.replace_ampersand(pivot_sort_value),result_limit);

    -- Transform the context_loc_group argument (if any) (logc at the
    -- TPAC layer) into a form we'll be able to use.
    IF context_loc_group IS NOT NULL THEN
        SELECT INTO context_locations ARRAY_AGG(location)
            FROM asset.copy_location_group_map
            WHERE lgroup = context_loc_group;
    END IF;

    -- Get the configured size of browse superpages.
    SELECT INTO browse_superpage_size value     -- NULL ok
        FROM config.global_flag
        WHERE enabled AND name = 'opac.browse.holdings_visibility_test_limit';

    -- First we're going to search backward from the pivot, then we're going
    -- to search forward.  In each direction, we need two limits.  At the
    -- lesser of the two limits, we delineate the edge of the result set
    -- we're going to return.  At the greater of the two limits, we find the
    -- pivot value that would represent an offset from the current pivot
    -- at a distance of one "page" in either direction, where a "page" is a
    -- result set of the size specified in the "result_limit" argument.
    --
    -- The two limits in each direction make four derived values in total,
    -- and we calculate them now.
    back_limit := CEIL(result_limit::FLOAT / 2);
    back_to_pivot := result_limit;
    forward_limit := result_limit / 2;
    forward_to_pivot := result_limit - 1;

create temporary table tmp_metabib_browse 
(
    id bigint, 
    value text, 
    sort_value text, 
    --truncated_sort_value_noamp text,
    value_noamp text
) on commit drop;

    -- This is the meat of the SQL query that finds browse entries.  We'll
    -- pass this to a function which uses it with a cursor, so that individual
    -- rows may be fetched in a loop until some condition is satisfied.
    core_query := '
insert into tmp_metabib_browse 
(
    id, 
    value, 
    sort_value, 
    --truncated_sort_value_noamp,
    value_noamp
)
SELECT  mbe.id,
        mbe.value,
        public.replace_ampersand(mbe.sort_value),
        --public.replace_ampersand(mbe.truncated_sort_value), --this column is identical to sort_value
        public.replace_ampersand(mbe.value)
  FROM  metabib.browse_' || search_class || '_entry mbe
  WHERE (
            EXISTS ( -- are there any bibs using this mbe via the requested fields?
                SELECT  1
                  FROM  metabib.browse_' || search_class || '_entry_def_map mbedm
                  WHERE mbedm.entry = mbe.id AND mbedm.def = ANY(' || quote_literal(search_field) || ')
                  LIMIT 1
            )';
    IF search_class != 'call_number' THEN

        core_query := core_query || ' OR EXISTS ( -- are there any authorities using this mbe via the requested fields?
                SELECT  1
                  FROM  metabib.browse_' || search_class || '_entry_simple_heading_map mbeshm
                        JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                        JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                            ash.atag = map.authority_field
                            AND map.metabib_field = ANY(' || quote_literal(search_field) || ')
                        )
                  WHERE mbeshm.entry = mbe.id
            )';

    END IF;
    core_query := core_query || $$
) AND  public.replace_ampersand(mbe.sort_value) between $$ || quote_literal(public.replace_ampersand(v_bound_lower)) || ' and ' || quote_literal(public.replace_ampersand(v_bound_upper));
    execute core_query;
    -- This is the variant of the query for browsing backward.
    back_query := $$select id, value, sort_value from tmp_metabib_browse
where sort_value <= $$ || quote_literal(public.replace_ampersand(pivot_sort_value)) || $$
order by sort_value desc, value_noamp desc$$;

    -- This variant browses forward.
    forward_query := $$select id, value, sort_value from tmp_metabib_browse
where sort_value > $$ || quote_literal(public.replace_ampersand(pivot_sort_value)) || $$
order by sort_value, value_noamp$$;
    -- We now call the function which applies a cursor to the provided
    -- queries, stopping at the appropriate limits and also giving us
    -- the next page's pivot.
    RETURN QUERY
        SELECT * FROM metabib.staged_browse(
            back_query, search_field, context_org, context_locations,
            staff, browse_superpage_size, TRUE, back_limit, back_to_pivot,
            search_class
        ) UNION ALL
        SELECT * FROM metabib.staged_browse(
            forward_query, search_field, context_org, context_locations,
            staff, browse_superpage_size, FALSE, forward_limit, forward_to_pivot,
            search_class
        ) ORDER BY row_number DESC;

END;
$_$;


ALTER FUNCTION metabib.browse(search_class text, browse_term text, context_org integer, context_loc_group integer, staff boolean, pivot_id bigint, result_limit integer) OWNER TO evergreen;

--
-- Name: browse_author_authority_refs_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_author_authority_refs_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbae.id
      FROM  metabib.browse_author_entry mbae
            JOIN metabib.browse_author_entry_simple_heading_map mbaeshm ON ( mbaeshm.entry = mbae.id )
            JOIN authority.simple_heading ash ON ( mbaeshm.simple_heading = ash.id )
            JOIN authority.control_set_auth_field_metabib_field_map_refs_only map ON (
                ash.atag = map.authority_field
                AND map.metabib_field = ANY($1)
            )
      WHERE public.replace_ampersand(mbae.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
            and public.replace_ampersand(mbae.sort_value) <= (select bound_upper from metabib.browse_table_bounds('author',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbae.sort_value), public.replace_ampersand(mbae.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_author_authority_refs_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_author_bib_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_author_bib_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbe.id
      FROM  metabib.browse_author_entry mbe
            JOIN metabib.browse_author_entry_def_map mbedm ON (
                mbedm.entry = mbe.id
                AND mbedm.def = ANY($1)
            )
      WHERE public.replace_ampersand(mbe.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
            and public.replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('author',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbe.sort_value), public.replace_ampersand(mbe.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_author_bib_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_author_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_author_pivot(search_field integer[], browse_term text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $$
    --ver1.0
    SELECT id FROM metabib.browse_author_entry
      WHERE id IN (
                metabib.browse_author_bib_pivot(search_field, browse_term),
                metabib.browse_author_authority_refs_pivot(search_field,browse_term)
            )
      ORDER BY replace_ampersand(sort_value), value LIMIT 1;
$$;


ALTER FUNCTION metabib.browse_author_pivot(search_field integer[], browse_term text) OWNER TO evergreen;

--
-- Name: browse_authority_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_authority_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    -- So far this function is not called.  When its usage is known, depending on
    -- how it is called/used we can use that information to modify it to use the new
    -- broken apart tables for both metabib.browse_entry and metabib.browse_entry_simple_heading_map
    --ver1.1  updated with kmain-806 - added note
    SELECT  mbe.id
      FROM  metabib.browse_entry mbe
    --        JOIN metabib.browse_entry_simple_heading_map mbeshm ON ( mbeshm.entry = mbe.id )
    --        JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
    --        JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
    --            ash.atag = map.authority_field
    --            AND map.metabib_field = ANY($1)
    --        )
      WHERE mbe.sort_value >= public.naco_normalize($2)
      ORDER BY mbe.sort_value, mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_authority_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_call_number_authority_refs_pivot(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_call_number_authority_refs_pivot(text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2 - KMAIN-1168 - removed public.naco_normalize around $1 or browse term
    --reference to public.replace_ampersand has no function except to maintain compatibility with indexes expected by calling functions.
    SELECT  mbe.id
      FROM  metabib.browse_call_number_entry mbe
      WHERE public.replace_ampersand(mbe.sort_value) >= public.naco_normalize_keep_decimal($1, '')
            and public.replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('call_number',public.naco_normalize_keep_decimal($1, ''),1))
      ORDER BY public.replace_ampersand(mbe.sort_value), mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_call_number_authority_refs_pivot(text) OWNER TO evergreen;

--
-- Name: browse_call_number_bib_pivot(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_call_number_bib_pivot(text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2 - KMAIN-1168 - removed public.naco_normalize around $1 or browse term
    SELECT  mbe.id
      FROM  metabib.browse_call_number_entry mbe
      WHERE replace_ampersand(mbe.sort_value) >= public.naco_normalize_keep_decimal($1, '')
            and replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('call_number',public.naco_normalize_keep_decimal($1, ''),1))
      ORDER BY replace_ampersand(mbe.sort_value), mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_call_number_bib_pivot(text) OWNER TO evergreen;

--
-- Name: browse_call_number_pivot(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_call_number_pivot(browse_term text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $$
    --ver1.0
    SELECT id FROM metabib.browse_call_number_entry
      WHERE id IN (
                metabib.browse_call_number_bib_pivot(browse_term),
                metabib.browse_call_number_authority_refs_pivot(browse_term)
            )
      ORDER BY replace_ampersand(sort_value), value LIMIT 1;
$$;


ALTER FUNCTION metabib.browse_call_number_pivot(browse_term text) OWNER TO evergreen;

--
-- Name: browse_normalize(text, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_normalize(facet_text text, mapped_field integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
BEGIN

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = mapped_field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'') --'
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    RETURN facet_text;
END;

$$;


ALTER FUNCTION metabib.browse_normalize(facet_text text, mapped_field integer) OWNER TO evergreen;

--
-- Name: browse_series_authority_refs_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_series_authority_refs_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbse.id
      FROM  metabib.browse_series_entry mbse
            JOIN metabib.browse_series_entry_simple_heading_map mbseshm ON ( mbseshm.entry = mbse.id )
            JOIN authority.simple_heading ash ON ( mbseshm.simple_heading = ash.id )
            JOIN authority.control_set_auth_field_metabib_field_map_refs_only map ON (
                ash.atag = map.authority_field
                AND map.metabib_field = ANY($1)
            )
      WHERE public.replace_ampersand(mbse.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
            and public.replace_ampersand(mbse.sort_value) <= (select bound_upper from metabib.browse_table_bounds('series',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbse.sort_value), public.replace_ampersand(mbse.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_series_authority_refs_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_series_bib_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_series_bib_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbe.id
      FROM  metabib.browse_series_entry mbe
            JOIN metabib.browse_series_entry_def_map mbedm ON (
                mbedm.entry = mbe.id
                AND mbedm.def = ANY($1)
            )
      WHERE public.replace_ampersand(mbe.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
	and public.replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('series',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbe.sort_value), public.replace_ampersand(mbe.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_series_bib_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_series_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_series_pivot(search_field integer[], browse_term text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $$
    --ver1.0
    SELECT id FROM metabib.browse_series_entry
      WHERE id IN (
                metabib.browse_series_bib_pivot(search_field, browse_term),
                metabib.browse_series_authority_refs_pivot(search_field,browse_term)
            )
      ORDER BY replace_ampersand(sort_value), value LIMIT 1;
$$;


ALTER FUNCTION metabib.browse_series_pivot(search_field integer[], browse_term text) OWNER TO evergreen;

--
-- Name: browse_subject_authority_refs_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_subject_authority_refs_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbse.id
      FROM  metabib.browse_subject_entry mbse
            JOIN metabib.browse_subject_entry_simple_heading_map mbseshm ON ( mbseshm.entry = mbse.id )
            JOIN authority.simple_heading ash ON ( mbseshm.simple_heading = ash.id )
            JOIN authority.control_set_auth_field_metabib_field_map_refs_only map ON (
                ash.atag = map.authority_field
                AND map.metabib_field = ANY($1)
            )
      WHERE public.replace_ampersand(mbse.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
            and public.replace_ampersand(mbse.sort_value) <= (select bound_upper from metabib.browse_table_bounds('subject',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbse.sort_value), public.replace_ampersand(mbse.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_subject_authority_refs_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_subject_bib_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_subject_bib_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbe.id
      FROM  metabib.browse_subject_entry mbe
            JOIN metabib.browse_subject_entry_def_map mbedm ON (
                mbedm.entry = mbe.id
                AND mbedm.def = ANY($1)
            )
      WHERE public.replace_ampersand(mbe.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
	and public.replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('subject',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbe.sort_value), public.replace_ampersand(mbe.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_subject_bib_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_subject_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_subject_pivot(search_field integer[], browse_term text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $$
    --ver1.0
    SELECT id FROM metabib.browse_subject_entry
      WHERE id IN (
                metabib.browse_subject_bib_pivot(search_field, browse_term),
                metabib.browse_subject_authority_refs_pivot(search_field,browse_term)
            )
      ORDER BY replace_ampersand(sort_value), value LIMIT 1;
$$;


ALTER FUNCTION metabib.browse_subject_pivot(search_field integer[], browse_term text) OWNER TO evergreen;

--
-- Name: browse_table_bounds(text, text, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_table_bounds(search_class text, browse_term text, result_limit integer, OUT bound_lower text, OUT bound_upper text) RETURNS record
    LANGUAGE plpgsql STABLE STRICT
    AS $$
declare
    histogram text[];
    table_name text;
    table_rows real;
    bucket_width real;
    padding int;
    CHAR_MIN constant text := chr(1);
    CHAR_MAX constant text := U&'\+02ffff\+02ffff'; --http://en.wikipedia.org/wiki/Unicode
begin
    if search_class not in ('author','title','subject','series','call_number') then
        raise 'Invalid value for argument search_class.';
    else
        table_name := 'browse_' || search_class || '_entry';
    end if;
    select reltuples into table_rows from pg_class where relname = table_name
    ;
    select histogram_bounds::text::text[] into histogram
    from pg_stats s 
    where tablename = table_name and attname = 'sort_value'
    ;
    bucket_width := table_rows / array_length(histogram,1); 
    if bucket_width < (result_limit * 2) then
        bound_lower := CHAR_MIN;
        bound_upper := CHAR_MAX;
    else
        padding := (result_limit / bucket_width)::int + 1;
        select lag2, lead2 into bound_lower, bound_upper from
        (
            with bounds as (select unnest(histogram) as boundary)
            select 
                lag(boundary,padding + 1,CHAR_MIN) over (order by boundary) as lag2,
                lag(boundary,padding,CHAR_MIN) over (order by boundary) as lag1,
                boundary as lead1,
                lead(boundary,padding,CHAR_MAX) over (order by boundary) as lead2
            from bounds
        ) sub1
        where browse_term between lag1 and lead1;
    end if;
    return;
end;
$$;


ALTER FUNCTION metabib.browse_table_bounds(search_class text, browse_term text, result_limit integer, OUT bound_lower text, OUT bound_upper text) OWNER TO evergreen;

--
-- Name: FUNCTION browse_table_bounds(search_class text, browse_term text, result_limit integer, OUT bound_lower text, OUT bound_upper text); Type: COMMENT; Schema: metabib; Owner: evergreen
--

COMMENT ON FUNCTION browse_table_bounds(search_class text, browse_term text, result_limit integer, OUT bound_lower text, OUT bound_upper text) IS 'Query postgres table statistics to find boundaries of region containing browse_term.';


--
-- Name: browse_title_authority_refs_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_title_authority_refs_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver2.0 updated with kmain-762: wrapped values in public.replace_ampersand function
    SELECT  mbte.id
      FROM  metabib.browse_title_entry mbte
            JOIN metabib.browse_title_entry_simple_heading_map mbteshm ON ( mbteshm.entry = mbte.id )
            JOIN authority.simple_heading ash ON ( mbteshm.simple_heading = ash.id )
            JOIN authority.control_set_auth_field_metabib_field_map_refs_only map ON (
                ash.atag = map.authority_field
                AND map.metabib_field = ANY($1)
            )
      WHERE public.replace_ampersand(mbte.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
            and public.replace_ampersand(mbte.sort_value) <= (select bound_upper from metabib.browse_table_bounds('title',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbte.sort_value), public.replace_ampersand(mbte.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_title_authority_refs_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_title_bib_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_title_bib_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    --ver1.0
    SELECT  mbe.id
      FROM  metabib.browse_title_entry mbe
            JOIN metabib.browse_title_entry_def_map mbedm ON (
                mbedm.entry = mbe.id
                AND mbedm.def = ANY($1)
            )
      WHERE public.replace_ampersand(mbe.sort_value) >= public.replace_ampersand(public.naco_normalize($2))
	and public.replace_ampersand(mbe.sort_value) <= (select bound_upper from metabib.browse_table_bounds('title',public.replace_ampersand(public.naco_normalize($2)),1))
      ORDER BY public.replace_ampersand(mbe.sort_value), public.replace_ampersand(mbe.value) LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_title_bib_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_title_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION browse_title_pivot(search_field integer[], browse_term text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $$
    --ver1.0
    SELECT id FROM metabib.browse_title_entry
      WHERE id IN (
                metabib.browse_title_bib_pivot(search_field, browse_term),
                metabib.browse_title_authority_refs_pivot(search_field,browse_term)
            )
      ORDER BY replace_ampersand(sort_value), value LIMIT 1;
$$;


ALTER FUNCTION metabib.browse_title_pivot(search_field integer[], browse_term text) OWNER TO evergreen;

--
-- Name: facet_normalize_trigger(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION facet_normalize_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
    facet_text  TEXT;
BEGIN
    facet_text := NEW.value;

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = NEW.field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    NEW.value = facet_text;

    RETURN NEW;
END;
$$;


ALTER FUNCTION metabib.facet_normalize_trigger() OWNER TO evergreen;

--
-- Name: get_browse_author_entry_marc_record(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION get_browse_author_entry_marc_record(browse_entry bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes an id to the browse author entry table and returns the marc for the
--  authority that control the browse author entry.
DECLARE
     marc text;
BEGIN
     SELECT are.marc INTO marc 
     FROM authority.record_entry are
     JOIN authority.simple_heading ash ON are.id = ash.record
     JOIN metabib.browse_author_entry_simple_heading_map mbaeshm ON ash.id = mbaeshm.simple_heading
     JOIN metabib.browse_author_entry mbae ON mbaeshm.entry = mbae.id
     JOIN authority.control_set_authority_field acsaf ON ash.atag = acsaf.id
     WHERE mbae.id = browse_entry AND acsaf.tag ILIKE '1__';
	
     RETURN marc;
END;    
$$;


ALTER FUNCTION metabib.get_browse_author_entry_marc_record(browse_entry bigint) OWNER TO evergreen;

--
-- Name: get_browse_entry_marc_record(bigint, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION get_browse_entry_marc_record(browse_entry bigint, search_class text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes an id to the browse entry series of tables and a type to indicate what
--  table to look into.  It will then fetch the marc record for that the authority that
--  controls the browse entry.
DECLARE
     marc text;
BEGIN
     CASE search_class
		WHEN 'author' THEN marc = metabib.get_browse_author_entry_marc_record(browse_entry);
        WHEN 'subject' THEN marc = metabib.get_browse_subject_entry_marc_record(browse_entry);
        WHEN 'series' THEN marc = metabib.get_browse_series_entry_marc_record(browse_entry);
        ELSE marc = NULL;
     END CASE;
	
     RETURN marc;
END;    
$$;


ALTER FUNCTION metabib.get_browse_entry_marc_record(browse_entry bigint, search_class text) OWNER TO evergreen;

--
-- Name: get_browse_series_entry_marc_record(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION get_browse_series_entry_marc_record(browse_entry bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes an id to the browse series entry table and returns the marc for the
--  authority that control the browse series entry.
DECLARE
     marc text;
BEGIN
     SELECT are.marc INTO marc 
     FROM authority.record_entry are
     JOIN authority.simple_heading ash ON are.id = ash.record
     JOIN metabib.browse_series_entry_simple_heading_map mbseshm ON ash.id = mbseshm.simple_heading
     JOIN metabib.browse_series_entry mbse ON mbseshm.entry = mbse.id
     JOIN authority.control_set_authority_field acsaf ON ash.atag = acsaf.id
     WHERE mbse.id = browse_entry AND acsaf.tag ILIKE '1__';
	
     RETURN marc;
END;    
$$;


ALTER FUNCTION metabib.get_browse_series_entry_marc_record(browse_entry bigint) OWNER TO evergreen;

--
-- Name: get_browse_subject_entry_marc_record(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION get_browse_subject_entry_marc_record(browse_entry bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes an id to the browse subject entry table and returns the marc for the
--  authority that control the browse subject entry.
DECLARE
     marc text;
BEGIN
     SELECT are.marc INTO marc 
     FROM authority.record_entry are
     JOIN authority.simple_heading ash ON are.id = ash.record
     JOIN metabib.browse_subject_entry_simple_heading_map mbseshm ON ash.id = mbseshm.simple_heading
     JOIN metabib.browse_subject_entry mbse ON mbseshm.entry = mbse.id
     JOIN authority.control_set_authority_field acsaf ON ash.atag = acsaf.id
     WHERE mbse.id = browse_entry AND acsaf.tag ILIKE '1__';
	
     RETURN marc;
END;    
$$;


ALTER FUNCTION metabib.get_browse_subject_entry_marc_record(browse_entry bigint) OWNER TO evergreen;

--
-- Name: normalized_field_entry_view(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION normalized_field_entry_view() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

DECLARE
	norm_table		text	:= 	TG_TABLE_SCHEMA || '.normalized_' || TG_TABLE_NAME;
	temp_id			bigint;
BEGIN

IF(TG_OP = 'UPDATE') THEN

EXECUTE 'SELECT id FROM '||norm_table||' WHERE id = '||NEW.id||';' INTO temp_id;

	IF(temp_id IS NOT NULL) THEN
		EXECUTE 'UPDATE '||norm_table||' 
		SET value = '''||search_normalize(NEW.value)||''', ind = get_ind('||NEW.source||','||NEW.field||'), source = '||NEW.source||' WHERE id = '||NEW.id||';';
	ELSE
		EXECUTE 'INSERT INTO '||norm_table||' VALUES ( '||NEW.id||','||NEW.source||', '''||search_normalize(NEW.value)||''', get_ind('||NEW.source||', '||NEW.field||') );';
	END IF;
ELSIF(TG_OP = 'INSERT') THEN

	EXECUTE 'INSERT INTO '||norm_table||' VALUES ( '||NEW.id||','||NEW.source||', '''||search_normalize(NEW.value)||''', get_ind('||NEW.source||', '||NEW.field||') );';

END IF;

RETURN NULL;

END;
$$;


ALTER FUNCTION metabib.normalized_field_entry_view() OWNER TO evergreen;

--
-- Name: reingest_metabib_field_entries(bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean DEFAULT false, skip_browse boolean DEFAULT false, skip_search boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    fclass          RECORD;
    ind_data        metabib.field_entry_template%ROWTYPE;
    mbe_row         metabib.browse_entry%ROWTYPE;
    mbe_id          BIGINT;
    b_skip_facet    BOOL;
    b_skip_browse   BOOL;
    b_skip_search   BOOL;
    value_prepped   TEXT;
    field_class     TEXT;
BEGIN
    --ver1.6 modified by kmain-1119
    SELECT COALESCE(NULLIF(skip_facet, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_facet_indexing' AND enabled)) INTO b_skip_facet;
    SELECT COALESCE(NULLIF(skip_browse, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_browse_indexing' AND enabled)) INTO b_skip_browse;
    SELECT COALESCE(NULLIF(skip_search, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_search_indexing' AND enabled)) INTO b_skip_search;

    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        IF NOT b_skip_search THEN
            FOR fclass IN SELECT * FROM config.metabib_class LOOP
                -- RAISE NOTICE 'Emptying out %', fclass.name;
                EXECUTE $$DELETE FROM metabib.$$ || fclass.name || $$_field_entry WHERE source = $$ || bib_id;
            END LOOP;
        END IF;
        IF NOT b_skip_facet THEN
            DELETE FROM metabib.facet_entry WHERE source = bib_id;
        END IF;
        IF NOT b_skip_browse THEN
            DELETE FROM metabib.browse_author_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_title_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_subject_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_series_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_call_number_entry_def_map WHERE source = bib_id;
        END IF;
    END IF;

    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( bib_id ) LOOP

        --ind_data.field_class -- author, title, subject, etc

        IF ind_data.field < 0 THEN
            ind_data.field = -1 * ind_data.field;
        END IF;

        IF ind_data.facet_field AND NOT b_skip_facet THEN
            INSERT INTO metabib.facet_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        END IF;

        IF ind_data.browse_field AND NOT b_skip_browse THEN
            -- A caveat about this SELECT: this should take care of replacing
            -- old mbe rows when data changes, but not if normalization (by
            -- which I mean specifically the output of
            -- evergreen.oils_tsearch2()) changes.  It may or may not be
            -- expensive to add a comparison of index_vector to index_vector
            -- to the WHERE clause below.

            value_prepped := metabib.browse_normalize(ind_data.value, ind_data.field);
            IF char_length(value_prepped) > 0 THEN
                CASE ind_data.field_class

                  WHEN 'author' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_author_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_author_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_author_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_author_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'title' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_title_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_title_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_title_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_title_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'subject' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_subject_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_subject_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_subject_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_subject_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'series' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_series_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_series_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_series_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_series_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'call_number' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_call_number_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_call_number_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_call_number_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_call_number_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);
                  ELSE
                END CASE;
            END IF;
        END IF;

        IF ind_data.search_field AND NOT b_skip_search THEN
            -- Avoid inserting duplicate rows
            EXECUTE 'SELECT 1 FROM metabib.' || ind_data.field_class ||
                '_field_entry WHERE field = $1 AND source = $2 AND value = $3'
                INTO mbe_id USING ind_data.field, ind_data.source, ind_data.value;
                -- RAISE NOTICE 'Search for an already matching row returned %', mbe_id;
            IF mbe_id IS NULL THEN
                EXECUTE $$
                INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value)
                    VALUES ($$ ||
                        quote_literal(ind_data.field) || $$, $$ ||
                        quote_literal(ind_data.source) || $$, $$ ||
                        quote_literal(ind_data.value) ||
                    $$);$$;
            END IF;
        END IF;

    END LOOP;

    IF NOT b_skip_search THEN
        PERFORM metabib.update_combined_index_vectors(bib_id);
    END IF;

    RETURN;
END;
$_X$;


ALTER FUNCTION metabib.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) OWNER TO evergreen;

--
-- Name: reingest_metabib_full_rec(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION reingest_metabib_full_rec(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        DELETE FROM metabib.real_full_rec WHERE record = bib_id;
    END IF;
    INSERT INTO metabib.real_full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM biblio.flatten_marc( bib_id );

    RETURN;
END;
$$;


ALTER FUNCTION metabib.reingest_metabib_full_rec(bib_id bigint) OWNER TO evergreen;

--
-- Name: remap_metarecord_for_bib(bigint, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    source_count    INT;
    old_mr          BIGINT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    deleted_mrs     BIGINT[];
BEGIN

    DELETE FROM metabib.metarecord_source_map WHERE source = bib_id; -- Rid ourselves of the search-estimate-killing linkage

    FOR tmp_mr IN SELECT  m.* FROM  metabib.metarecord m JOIN metabib.metarecord_source_map s ON (s.metarecord = m.id) WHERE s.source = bib_id LOOP

        IF old_mr IS NULL AND fp = tmp_mr.fingerprint THEN -- Find the first fingerprint-matching
            old_mr := tmp_mr.id;
        ELSE
            SELECT COUNT(*) INTO source_count FROM metabib.metarecord_source_map WHERE metarecord = tmp_mr.id;
            IF source_count = 0 THEN -- No other records
                deleted_mrs := ARRAY_APPEND(deleted_mrs, tmp_mr.id);
                DELETE FROM metabib.metarecord WHERE id = tmp_mr.id;
            END IF;
        END IF;

    END LOOP;

    IF old_mr IS NULL THEN -- we found no suitable, preexisting MR based on old source maps
        SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp; -- is there one for our current fingerprint?
        IF old_mr IS NULL THEN -- nope, create one and grab its id
            INSERT INTO metabib.metarecord ( fingerprint, master_record ) VALUES ( fp, bib_id );
            SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp;
        ELSE -- indeed there is. update it with a null cache and recalcualated master record
            UPDATE  metabib.metarecord
              SET   mods = NULL,
                    master_record = ( SELECT id FROM biblio.record_entry WHERE fingerprint = fp ORDER BY quality DESC LIMIT 1)
              WHERE id = old_mr;
        END IF;
    ELSE -- there was one we already attached to, update its mods cache and master_record
        UPDATE  metabib.metarecord
          SET   mods = NULL,
                master_record = ( SELECT id FROM biblio.record_entry WHERE fingerprint = fp ORDER BY quality DESC LIMIT 1)
          WHERE id = old_mr;
    END IF;

    INSERT INTO metabib.metarecord_source_map (metarecord, source) VALUES (old_mr, bib_id); -- new source mapping

    IF ARRAY_UPPER(deleted_mrs,1) > 0 THEN
        UPDATE action.hold_request SET target = old_mr WHERE target IN ( SELECT unnest(deleted_mrs) ) AND hold_type = 'M'; -- if we had to delete any MRs above, make sure their holds are moved
    END IF;

    RETURN old_mr;

END;
$$;


ALTER FUNCTION metabib.remap_metarecord_for_bib(bib_id bigint, fp text) OWNER TO evergreen;

--
-- Name: remove_duplicate_browse_entries(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION remove_duplicate_browse_entries() RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib_ids         BIGINT[];
    bib_one         BIGINT;
    auth_ids        BIGINT[];
    auth_one		BIGINT;
    be_ids          BIGINT[];
    be_one          BIGINT;

    result_message  TEXT[];
    dup_count       BIGINT;

BEGIN
    -- ver 1.0 - KMAIN-1119

    ---------------------------------- AUTHOR - Duplicates in metabib.browse_author_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_author_entry AS mbe
        JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_author_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_author_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_author_entry AS mbe
	JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_author_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
        FROM (
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_author_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_author_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_author_entry duplicates = ' || dup_count);


    ---------------------------------- SERIES - Duplicates in metabib.browse_series_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_series_entry AS mbe
        JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_series_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_series_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_series_entry AS mbe
	JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_series_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_series_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_series_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_series_entry duplicates = ' || dup_count);


    ---------------------------------- SUBJECT - Duplicates in metabib.browse_subject_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_subject_entry AS mbe
        JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_subject_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_subject_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_subject_entry AS mbe
	JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_subject_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_subject_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_subject_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_subject_entry duplicates = ' || dup_count);


    ---------------------------------- TITLE - Duplicates in metabib.browse_title_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_title_entry AS mbe
        JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_title_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_title_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_title_entry AS mbe
	JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_title_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_title_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_title_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_title_entry duplicates = ' || dup_count);


    ---------------------------------- CALL NUMBER - Duplicates in metabib.browse_call_number_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_call_number_entry AS mbe
        JOIN metabib.browse_call_number_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_call_number_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_call_number_entry AS mbe
        LEFT OUTER JOIN metabib.browse_call_number_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_call_number_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_call_number_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_call_number_entry duplicates = ' || dup_count);


    RETURN result_message;

END;
$$;


ALTER FUNCTION metabib.remove_duplicate_browse_entries() OWNER TO evergreen;

--
-- Name: search_class_to_registered_components(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION search_class_to_registered_components(search_class text) RETURNS SETOF record
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
    search_parts        TEXT[];
    field_name          TEXT;
    search_part_count   INTEGER;
    rec                 RECORD;
    registered_class    config.metabib_class%ROWTYPE;
    registered_alias    config.metabib_search_alias%ROWTYPE;
    registered_field    config.metabib_field%ROWTYPE;
BEGIN
    search_parts := REGEXP_SPLIT_TO_ARRAY(search_class, E'\\|');

    search_part_count := ARRAY_LENGTH(search_parts, 1);
    IF search_part_count = 0 THEN
        RETURN;
    ELSE
        SELECT INTO registered_class
            * FROM config.metabib_class WHERE name = search_parts[1];
        IF FOUND THEN
            IF search_part_count < 2 THEN   -- all fields
                rec := (registered_class.name, NULL::INTEGER);
                RETURN NEXT rec;
                RETURN; -- done
            END IF;
            FOR field_name IN SELECT *
                FROM UNNEST(search_parts[2:search_part_count]) LOOP
                SELECT INTO registered_field
                    * FROM config.metabib_field
                    WHERE name = field_name AND
                        field_class = registered_class.name;
                IF FOUND THEN
                    rec := (registered_class.name, registered_field.id);
                    RETURN NEXT rec;
                END IF;
            END LOOP;
        ELSE
            -- maybe we have an alias?
            SELECT INTO registered_alias
                * FROM config.metabib_search_alias WHERE alias=search_parts[1];
            IF NOT FOUND THEN
                RETURN;
            ELSE
                IF search_part_count < 2 THEN   -- return w/e the alias says
                    rec := (
                        registered_alias.field_class, registered_alias.field
                    );
                    RETURN NEXT rec;
                    RETURN; -- done
                ELSE
                    FOR field_name IN SELECT *
                        FROM UNNEST(search_parts[2:search_part_count]) LOOP
                        SELECT INTO registered_field
                            * FROM config.metabib_field
                            WHERE name = field_name AND
                                field_class = registered_alias.field_class;
                        IF FOUND THEN
                            rec := (
                                registered_alias.field_class,
                                registered_field.id
                            );
                            RETURN NEXT rec;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION metabib.search_class_to_registered_components(search_class text) OWNER TO evergreen;

--
-- Name: set_export_date(bigint, date); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION set_export_date(bib_id bigint, input_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
	PERFORM * FROM metabib.bib_export_data WHERE bib = bib_id;
	IF FOUND THEN 
		UPDATE metabib.bib_export_data SET export_date = input_date
		WHERE bib = bib_id;
	ELSE 
		INSERT INTO metabib.bib_export_data (bib, export_date)
		VALUES (bib_id, input_date);
	END IF;
END;
$$;


ALTER FUNCTION metabib.set_export_date(bib_id bigint, input_date date) OWNER TO evergreen;

--
-- Name: set_import_date(bigint, date); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION set_import_date(bib_id bigint, input_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
	PERFORM * FROM metabib.bib_export_data WHERE bib = bib_id;
	IF FOUND THEN 
		UPDATE metabib.bib_export_data SET import_date = input_date
		WHERE bib = bib_id;
	ELSE 
		INSERT INTO metabib.bib_export_data (bib, import_date)
		VALUES (bib_id, input_date);
	END IF;
END;
$$;


ALTER FUNCTION metabib.set_import_date(bib_id bigint, input_date date) OWNER TO evergreen;

--
-- Name: staged_browse(text, integer[], integer, integer[], boolean, integer, boolean, integer, integer, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION staged_browse(query text, fields integer[], context_org integer, context_locations integer[], staff boolean, browse_superpage_size integer, count_up_from_zero boolean, result_limit integer, next_pivot_pos integer, search_class text) RETURNS SETOF flat_browse_entry_appearance
    LANGUAGE plpgsql
    AS $_$
DECLARE
    curs                    REFCURSOR;
    rec                     RECORD;
    qpfts_query             TEXT;
    aqpfts_query            TEXT;
    afields                 INT[];
    bfields                 INT[];
    result_row              metabib.flat_browse_entry_appearance%ROWTYPE;
    results_skipped         INT := 0;
    row_counter             INT := 0;
    row_number              INT;
    slice_start             INT;
    slice_end               INT;
    full_end                INT;
    all_records             BIGINT[];
    all_brecords             BIGINT[];
    all_arecords            BIGINT[];
    superpage_of_records    BIGINT[];
    superpage_size          INT;
    unauthorized_entry RECORD;
BEGIN
    --ver1.1 updated with kmain-806 - added support for the new metabib.browse_____entry_simple_heading_map tables.
    IF count_up_from_zero THEN
        row_number := 0;
    ELSE
        row_number := -1;
    END IF;

    OPEN curs FOR EXECUTE query;

    LOOP
        FETCH curs INTO rec;
        IF NOT FOUND THEN
            IF result_row.pivot_point IS NOT NULL THEN
                RETURN NEXT result_row;
            END IF;
            RETURN;
        END IF;

        CASE search_class
            WHEN 'author' THEN
				--Is unauthorized, i.e., 4xx on an auth record?
                SELECT INTO unauthorized_entry *
                FROM metabib.browse_author_entry_simple_heading_map mbeshm
                INNER JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                INNER JOIN authority.control_set_authority_field acsaf ON ( acsaf.id = ash.atag AND acsaf.tag like '4__')
                WHERE mbeshm.entry = rec.id;
                
                -- Gather aggregate data based on the MBE row we're looking at now, authority axis
                IF (unauthorized_entry.record IS NOT NULL) THEN
                        --Do unauthorized procedure, use the authorized term's auth record and it's bibs
                        SELECT INTO all_arecords, result_row.sees, afields
                                ARRAY_AGG(DISTINCT abl.bib),
                                STRING_AGG(DISTINCT abl.authority::TEXT, $$,$$),
                                ARRAY_AGG(DISTINCT map.metabib_field)
                        FROM authority.bib_linking abl
                        INNER JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                                map.authority_field = unauthorized_entry.atag
                                AND map.metabib_field = ANY(fields)
                        )
                        WHERE abl.authority = unauthorized_entry.record;
               ELSE
						SELECT INTO all_arecords, result_row.sees, afields
							ARRAY_AGG(DISTINCT abl.bib), -- bibs to check for visibility
							ARRAY_TO_STRING(ARRAY_AGG(DISTINCT aal.source), $$,$$), -- authority record ids
							ARRAY_AGG(DISTINCT map.metabib_field) -- authority-tag-linked CMF rows
						FROM  metabib.browse_author_entry_simple_heading_map mbeshm
						JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
						JOIN authority.authority_linking aal ON ( ash.record = aal.source )
						JOIN authority.bib_linking abl ON ( aal.target = abl.authority )
						JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                        ash.atag = map.authority_field
                        AND map.metabib_field = ANY(fields)
							)
						WHERE mbeshm.entry = rec.id;
				END IF;
				
                -- Gather aggregate data based on the MBE row we're looking at now, bib axis
                SELECT INTO all_brecords, result_row.authorities, bfields
                    ARRAY_AGG(DISTINCT source),
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT authority), $$,$$),
                    ARRAY_AGG(DISTINCT def)
                FROM  metabib.browse_author_entry_def_map
                WHERE entry = rec.id
                    AND def = ANY(fields);

            WHEN 'title' THEN
                -- Gather aggregate data based on the MBE row we're looking at now, authority axis
                SELECT INTO all_arecords, result_row.sees, afields
                    ARRAY_AGG(DISTINCT abl.bib), -- bibs to check for visibility
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT aal.source), $$,$$), -- authority record ids
                    ARRAY_AGG(DISTINCT map.metabib_field) -- authority-tag-linked CMF rows
                FROM  metabib.browse_title_entry_simple_heading_map mbeshm
                    JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                    JOIN authority.authority_linking aal ON ( ash.record = aal.source )
                    JOIN authority.bib_linking abl ON ( aal.target = abl.authority )
                    JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                        ash.atag = map.authority_field
                        AND map.metabib_field = ANY(fields)
                    )
                WHERE mbeshm.entry = rec.id;

                -- Gather aggregate data based on the MBE row we're looking at now, bib axis
                SELECT INTO all_brecords, result_row.authorities, bfields
                    ARRAY_AGG(DISTINCT source),
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT authority), $$,$$),
                    ARRAY_AGG(DISTINCT def)
                FROM  metabib.browse_title_entry_def_map
                WHERE entry = rec.id
                    AND def = ANY(fields);

            WHEN 'subject' THEN
				--Is unauthorized, i.e., 4xx on an auth record?
                SELECT INTO unauthorized_entry *
                FROM metabib.browse_subject_entry_simple_heading_map mbeshm
                INNER JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                INNER JOIN authority.control_set_authority_field acsaf ON ( acsaf.id = ash.atag AND acsaf.tag like '4__')
                WHERE mbeshm.entry = rec.id;
                
                -- Gather aggregate data based on the MBE row we're looking at now, authority axis
                IF (unauthorized_entry.record IS NOT NULL) THEN
                        --Do unauthorized procedure, use the authorized term's auth record and it's bibs
                        SELECT INTO all_arecords, result_row.sees, afields
                                ARRAY_AGG(DISTINCT abl.bib),
                                STRING_AGG(DISTINCT abl.authority::TEXT, $$,$$),
                                ARRAY_AGG(DISTINCT map.metabib_field)
                        FROM authority.bib_linking abl
                        INNER JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                                map.authority_field = unauthorized_entry.atag
                                AND map.metabib_field = ANY(fields)
                        )
                        WHERE abl.authority = unauthorized_entry.record;
               ELSE
						SELECT INTO all_arecords, result_row.sees, afields
								ARRAY_AGG(DISTINCT abl.bib), -- bibs to check for visibility
								ARRAY_TO_STRING(ARRAY_AGG(DISTINCT aal.source), $$,$$), -- authority record ids
								ARRAY_AGG(DISTINCT map.metabib_field) -- authority-tag-linked CMF rows
						FROM  metabib.browse_subject_entry_simple_heading_map mbeshm
						JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
						JOIN authority.authority_linking aal ON ( ash.record = aal.source )
						JOIN authority.bib_linking abl ON ( aal.target = abl.authority )
						JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                        ash.atag = map.authority_field
                        AND map.metabib_field = ANY(fields)
							)
						WHERE mbeshm.entry = rec.id;
				END IF;
				
                -- Gather aggregate data based on the MBE row we're looking at now, bib axis
                SELECT INTO all_brecords, result_row.authorities, bfields
                    ARRAY_AGG(DISTINCT source),
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT authority), $$,$$),
                    ARRAY_AGG(DISTINCT def)
                FROM  metabib.browse_subject_entry_def_map
                WHERE entry = rec.id
                    AND def = ANY(fields);

            WHEN 'series' THEN
				--Is unauthorized, i.e., 4xx on an auth record?
                SELECT INTO unauthorized_entry *
                FROM metabib.browse_series_entry_simple_heading_map mbeshm
                INNER JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                INNER JOIN authority.control_set_authority_field acsaf ON ( acsaf.id = ash.atag AND acsaf.tag like '4__')
                WHERE mbeshm.entry = rec.id;
                
                -- Gather aggregate data based on the MBE row we're looking at now, authority axis
                -- Gather aggregate data based on the MBE row we're looking at now, authority axis
               IF (unauthorized_entry.record IS NOT NULL) THEN
                        --Do unauthorized procedure, use the authorized term's auth record and it's bibs
                        SELECT INTO all_arecords, result_row.sees, afields
                                ARRAY_AGG(DISTINCT abl.bib),
                                STRING_AGG(DISTINCT abl.authority::TEXT, $$,$$),
                                ARRAY_AGG(DISTINCT map.metabib_field)
                        FROM authority.bib_linking abl
                        INNER JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                                map.authority_field = unauthorized_entry.atag
                                AND map.metabib_field = ANY(fields)
                        )
                        WHERE abl.authority = unauthorized_entry.record;
               ELSE
						SELECT INTO all_arecords, result_row.sees, afields
								ARRAY_AGG(DISTINCT abl.bib), -- bibs to check for visibility
								ARRAY_TO_STRING(ARRAY_AGG(DISTINCT aal.source), $$,$$), -- authority record ids
								ARRAY_AGG(DISTINCT map.metabib_field) -- authority-tag-linked CMF rows
						FROM  metabib.browse_series_entry_simple_heading_map mbeshm
						JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
						JOIN authority.authority_linking aal ON ( ash.record = aal.source )
						JOIN authority.bib_linking abl ON ( aal.target = abl.authority )
						JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                        ash.atag = map.authority_field
                        AND map.metabib_field = ANY(fields)
							)
						WHERE mbeshm.entry = rec.id;
				END IF;
				
                -- Gather aggregate data based on the MBE row we're looking at now, bib axis
                SELECT INTO all_brecords, result_row.authorities, bfields
                    ARRAY_AGG(DISTINCT source),
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT authority), $$,$$),
                    ARRAY_AGG(DISTINCT def)
                FROM  metabib.browse_series_entry_def_map
                WHERE entry = rec.id
                    AND def = ANY(fields);

            WHEN 'call_number' THEN
                -- Gather aggregate data based on the MBE row we're looking at now, bib axis
                SELECT INTO all_brecords, result_row.authorities, bfields
                    ARRAY_AGG(DISTINCT source),
                    ARRAY_TO_STRING(ARRAY_AGG(DISTINCT authority), $$,$$),
                    ARRAY_AGG(DISTINCT def)
                FROM  metabib.browse_call_number_entry_def_map
                WHERE entry = rec.id
                    AND def = ANY(fields);

            ELSE

        END CASE;

        

        SELECT INTO result_row.fields ARRAY_TO_STRING(ARRAY_AGG(DISTINCT x), $$,$$) FROM UNNEST(afields || bfields) x;

        result_row.sources := 0;
        result_row.asources := 0;

        -- Bib-linked vis checking
        IF ARRAY_UPPER(all_brecords,1) IS NOT NULL THEN

            full_end := ARRAY_LENGTH(all_brecords, 1);
            superpage_size := COALESCE(browse_superpage_size, full_end);
            slice_start := 1;
            slice_end := superpage_size;

            WHILE result_row.sources = 0 AND slice_start <= full_end LOOP
                superpage_of_records := all_brecords[slice_start:slice_end];
                qpfts_query :=
                    'SELECT NULL::BIGINT AS id, ARRAY[r] AS records, ' ||
                    '1::INT AS rel FROM (SELECT UNNEST(' ||
                    quote_literal(superpage_of_records) || '::BIGINT[]) AS r) rr';

                -- We use search.query_parser_fts() for visibility testing.
                -- We're calling it once per browse-superpage worth of records
                -- out of the set of records related to a given mbe, until we've
                -- either exhausted that set of records or found at least 1
                -- visible record.

                SELECT INTO result_row.sources visible
                    FROM search.query_parser_fts(
                        context_org, NULL, qpfts_query, NULL,
                        context_locations, 0, NULL, NULL, FALSE, staff, FALSE
                    ) qpfts
                    WHERE qpfts.rel IS NULL;

                slice_start := slice_start + superpage_size;
                slice_end := slice_end + superpage_size;
            END LOOP;

            -- Accurate?  Well, probably.
            result_row.accurate := browse_superpage_size IS NULL OR
                browse_superpage_size >= full_end;

        END IF;

        -- Authority-linked vis checking
        IF ARRAY_UPPER(all_arecords,1) IS NOT NULL THEN

            full_end := ARRAY_LENGTH(all_arecords, 1);
            superpage_size := COALESCE(browse_superpage_size, full_end);
            slice_start := 1;
            slice_end := superpage_size;

            WHILE result_row.asources = 0 AND slice_start <= full_end LOOP
                superpage_of_records := all_arecords[slice_start:slice_end];
                qpfts_query :=
                    'SELECT NULL::BIGINT AS id, ARRAY[r] AS records, ' ||
                    '1::INT AS rel FROM (SELECT UNNEST(' ||
                    quote_literal(superpage_of_records) || '::BIGINT[]) AS r) rr';

                -- We use search.query_parser_fts() for visibility testing.
                -- We're calling it once per browse-superpage worth of records
                -- out of the set of records related to a given mbe, via
                -- authority until we've either exhausted that set of records
                -- or found at least 1 visible record.

                SELECT INTO result_row.asources visible
                    FROM search.query_parser_fts(
                        context_org, NULL, qpfts_query, NULL,
                        context_locations, 0, NULL, NULL, FALSE, staff, FALSE
                    ) qpfts
                    WHERE qpfts.rel IS NULL;

                slice_start := slice_start + superpage_size;
                slice_end := slice_end + superpage_size;
            END LOOP;


            -- Accurate?  Well, probably.
            result_row.aaccurate := browse_superpage_size IS NULL OR
                browse_superpage_size >= full_end;

        END IF;

        IF result_row.sources > 0 OR result_row.asources > 0 THEN

            -- The function that calls this function needs row_number in order
            -- to correctly order results from two different runs of this
            -- functions.
            result_row.row_number := row_number;

            -- Now, if row_counter is still less than limit, return a row.  If
            -- not, but it is less than next_pivot_pos, continue on without
            -- returning actual result rows until we find
            -- that next pivot, and return it.

            IF row_counter < result_limit THEN
                result_row.browse_entry := rec.id;
                result_row.value := rec.value;

                RETURN NEXT result_row;
            ELSE
                result_row.browse_entry := NULL;
                result_row.authorities := NULL;
                result_row.fields := NULL;
                result_row.value := NULL;
                result_row.sources := NULL;
                result_row.sees := NULL;
                result_row.accurate := NULL;
                result_row.aaccurate := NULL;
                result_row.pivot_point := rec.id;

                IF row_counter >= next_pivot_pos THEN
                    RETURN NEXT result_row;
                    RETURN;
                END IF;
            END IF;

            IF count_up_from_zero THEN
                row_number := row_number + 1;
            ELSE
                row_number := row_number - 1;
            END IF;

            -- row_counter is different from row_number.
            -- It simply counts up from zero so that we know when
            -- we've reached our limit.
            row_counter := row_counter + 1;
        END IF;
    END LOOP;
END;
$_$;


ALTER FUNCTION metabib.staged_browse(query text, fields integer[], context_org integer, context_locations integer[], staff boolean, browse_superpage_size integer, count_up_from_zero boolean, result_limit integer, next_pivot_pos integer, search_class text) OWNER TO evergreen;

--
-- Name: suggest_browse_entries(text, text, text, integer, integer, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) RETURNS TABLE(value text, field integer, buoyant_and_class_match boolean, field_match boolean, field_weight integer, rank real, buoyant boolean, match text)
    LANGUAGE plpgsql
    AS $_$
DECLARE
    prepared_query_texts    TEXT[];
    query                   TSQUERY;
    plain_query             TSQUERY;
    opac_visibility_join    TEXT;
    search_class_join       TEXT;
    r_fields                RECORD;
BEGIN
    prepared_query_texts := metabib.autosuggest_prepare_tsquery(raw_query_text);

    query := TO_TSQUERY('keyword', prepared_query_texts[1]);
    plain_query := TO_TSQUERY('keyword', prepared_query_texts[2]);

    visibility_org := NULLIF(visibility_org,-1);
    IF visibility_org IS NOT NULL THEN
        opac_visibility_join := '
    JOIN asset.opac_visible_copies aovc ON (
        aovc.record = x.source AND
        aovc.circ_lib IN (SELECT id FROM actor.org_unit_descendants($4))
    )';
    ELSE
        opac_visibility_join := '';
    END IF;

    -- The following determines whether we only provide suggestsons matching
    -- the user's selected search_class, or whether we show other suggestions
    -- too. The reason for MIN() is that for search_classes like
    -- 'title|proper|uniform' you would otherwise get multiple rows.  The
    -- implication is that if title as a class doesn't have restrict,
    -- nor does the proper field, but the uniform field does, you're going
    -- to get 'false' for your overall evaluation of 'should we restrict?'
    -- To invert that, change from MIN() to MAX().

    SELECT
        INTO r_fields
            MIN(cmc.restrict::INT) AS restrict_class,
            MIN(cmf.restrict::INT) AS restrict_field
        FROM metabib.search_class_to_registered_components(search_class)
            AS _registered (field_class TEXT, field INT)
        JOIN
            config.metabib_class cmc ON (cmc.name = _registered.field_class)
        LEFT JOIN
            config.metabib_field cmf ON (cmf.id = _registered.field);

    -- evaluate 'should we restrict?'
    IF r_fields.restrict_field::BOOL OR r_fields.restrict_class::BOOL THEN
        search_class_join := '
    JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            (_registered.field IS NULL AND
                _registered.field_class = cmf.field_class) OR
            (_registered.field = cmf.id)
        )
    ';
    ELSE
        search_class_join := '
    LEFT JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            _registered.field_class = cmc.name
        )
    ';
    END IF;

    RETURN QUERY EXECUTE '
SELECT  DISTINCT
        x.value,
        x.id,
        x.push,
        x.restrict,
        x.weight,
        x.ts_rank_cd,
        x.buoyant,
        TS_HEADLINE(value, $7, $3)
  FROM  (SELECT DISTINCT
                mbe.value,
                cmf.id,
                cmc.buoyant AND _registered.field_class IS NOT NULL AS push,
                _registered.field = cmf.id AS restrict,
                cmf.weight,
                TS_RANK_CD(mbe.index_vector, $1, $6),
                cmc.buoyant,
                mbedm.source
          FROM  metabib.browse_entry_def_map mbedm
                JOIN (SELECT * FROM metabib.browse_entry WHERE index_vector @@ $1 LIMIT 10000) mbe ON (mbe.id = mbedm.entry)
                JOIN config.metabib_field cmf ON (cmf.id = mbedm.def)
                JOIN config.metabib_class cmc ON (cmf.field_class = cmc.name)
                '  || search_class_join || '
          ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
          LIMIT 1000) AS x
        ' || opac_visibility_join || '
  ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
  LIMIT $5
'   -- sic, repeat the order by clause in the outer select too
    USING
        query, search_class, headline_opts,
        visibility_org, query_limit, normalization, plain_query
        ;

    -- sort order:
    --  buoyant AND chosen class = match class
    --  chosen field = match field
    --  field weight
    --  rank
    --  buoyancy
    --  value itself

END;
$_$;


ALTER FUNCTION metabib.suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_auth_id(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION triggered_reingest_for_auth_id(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   UPDATE authority.record_entry SET id = id WHERE id = auth_id;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_bib_id(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION triggered_reingest_for_bib_id(bib_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
   reingest_count	BIGINT;
BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   reingest_count = 0;
   
   UPDATE biblio.record_entry SET id = id WHERE id = bib_id;
   reingest_count = reingest_count + 1;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

   RETURN reingest_count;
END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_bib_id(bib_id bigint) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_bib_set(bigint, bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION triggered_reingest_for_bib_set(start_id bigint, stop_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
   record_id		BIGINT;
   reingest_count	BIGINT;
BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   reingest_count = 0;
   FOR record_id IN (SELECT id FROM biblio.record_entry WHERE id >= start_id AND id <= stop_id AND NOT deleted ORDER BY id) LOOP

       UPDATE biblio.record_entry SET id = id WHERE id = record_id;
       reingest_count = reingest_count + 1;

   END LOOP;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

   RETURN reingest_count;
END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_bib_set(start_id bigint, stop_id bigint) OWNER TO evergreen;

--
-- Name: update_combined_index_vectors(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION update_combined_index_vectors(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM metabib.combined_keyword_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_title_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_author_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_subject_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_series_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_identifier_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id;

END;
$$;


ALTER FUNCTION metabib.update_combined_index_vectors(bib_id bigint) OWNER TO evergreen;

SET search_path = migration_tools, pg_catalog;

--
-- Name: add_codabar_checkdigit(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION add_codabar_checkdigit(text) RETURNS text
    LANGUAGE plperl STABLE STRICT
    AS $_X$
    my $barcode = shift;

    return $barcode if $barcode !~ /^\d{13,14}$/;
    $barcode = substr($barcode, 0, 13); # ignore 14th digit
    my @digits = split //, $barcode;
    my $total = 0;
    $total += $digits[$_] foreach (1, 3, 5, 7, 9, 11);
    $total += (2 * $digits[$_] >= 10) ? (2 * $digits[$_] - 9) : (2 * $digits[$_]) foreach (0, 2, 4, 6, 8, 10, 12);
    my $remainder = $total % 10;
    my $checkdigit = ($remainder == 0) ? $remainder : 10 - $remainder;
    return $barcode . $checkdigit; 
$_X$;


ALTER FUNCTION migration_tools.add_codabar_checkdigit(text) OWNER TO evergreen;

--
-- Name: address_parse_out_citystatezip(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION address_parse_out_citystatezip(text) RETURNS text[]
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        city_state_zip TEXT := $1;
        city TEXT := '';
        state TEXT := '';
        zip TEXT := '';
    BEGIN
        zip := CASE WHEN city_state_zip ~ E'\\d\\d\\d\\d\\d' THEN REGEXP_REPLACE( city_state_zip, E'^.*(\\d\\d\\d\\d\\d-?\\d*).*$', E'\\1' ) ELSE '' END;
        city_state_zip := REGEXP_REPLACE( city_state_zip, E'^(.*)\\d\\d\\d\\d\\d-?\\d*(.*)$', E'\\1\\2');
        IF city_state_zip ~ ',' THEN
            state := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\2');
            city := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\1');
        ELSE
            IF city_state_zip ~ E'\\s+[A-Z][A-Z]\\s*' THEN
                state := REGEXP_REPLACE( city_state_zip, E'^.*,?\\s+([A-Z][A-Z])\\s*.*$', E'\\1' );
                city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s+[A-Z][A-Z](\\s*.*)$', E'\\1\\2' );
            ELSE
                IF city_state_zip ~ E'^\\S+$'  THEN
                    city := city_state_zip;
                    state := 'N/A';
                ELSE
                    state := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\2');
                    city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\1');
                END IF;
            END IF;
        END IF;
        RETURN ARRAY[ TRIM(BOTH ' ' FROM city), TRIM(BOTH ' ' FROM state), TRIM(BOTH ' ' FROM zip) ];
    END;
$_$;


ALTER FUNCTION migration_tools.address_parse_out_citystatezip(text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION apply_circ_matrix(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      duration_rule,
      recurring_fine_rule,
      max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recurring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recurring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recurring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix(tablename text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix_after_20(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION apply_circ_matrix_after_20(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      (matchpoint).duration_rule,
      (matchpoint).recurring_fine_rule,
      (matchpoint).max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recurring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recurring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recurring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix_after_20(tablename text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix_before_20(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION apply_circ_matrix_before_20(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      duration_rule,
      recuring_fine_rule,
      max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recuring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recuring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recuring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix_before_20(tablename text) OWNER TO evergreen;

--
-- Name: assign_standing_penalties(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION assign_standing_penalties() RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Once circulation data has been loaded, and group penalty thresholds have been set up, run this.
--        This will assign standing penalties as needed.

DECLARE
  org_unit  INT;
  usr       INT;

BEGIN

  FOR org_unit IN EXECUTE ('SELECT DISTINCT org_unit FROM permission.grp_penalty_threshold;') LOOP

    FOR usr IN EXECUTE ('SELECT id FROM actor.usr WHERE NOT deleted;') LOOP
  
      EXECUTE('SELECT actor.calculate_system_penalties(' || usr || ', ' || org_unit || ');');

    END LOOP;

  END LOOP;

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.assign_standing_penalties() OWNER TO evergreen;

--
-- Name: attempt_cast(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION attempt_cast(text, text, text) RETURNS record
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        datatype ALIAS FOR $2;
        fail_value ALIAS FOR $3;
        output RECORD;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::' || datatype || ' AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::' || datatype || ' AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_cast(text, text, text) OWNER TO evergreen;

--
-- Name: attempt_date(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION attempt_date(text, text) RETURNS date
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output DATE;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::date AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::date AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_date(text, text) OWNER TO evergreen;

--
-- Name: attempt_money(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION attempt_money(text, text) RETURNS numeric
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output NUMERIC(8,2);
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::NUMERIC(8,2) AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::NUMERIC(8,2) AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_money(text, text) OWNER TO evergreen;

--
-- Name: attempt_phone(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION attempt_phone(text, text) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
  DECLARE
    phone TEXT := $1;
    areacode TEXT := $2;
    temp TEXT := '';
    output TEXT := '';
    n_digits INTEGER := 0;
  BEGIN
    temp := phone;
    temp := REGEXP_REPLACE(temp, '^1*[^0-9]*(?=[0-9])', '');
    temp := REGEXP_REPLACE(temp, '[^0-9]*([0-9]{3})[^0-9]*([0-9]{3})[^0-9]*([0-9]{4})', E'\\1-\\2-\\3');
    n_digits := LENGTH(REGEXP_REPLACE(REGEXP_REPLACE(temp, '(.*)?[a-zA-Z].*', E'\\1') , '[^0-9]', '', 'g'));
    IF n_digits = 7 AND areacode <> '' THEN
      temp := REGEXP_REPLACE(temp, '[^0-9]*([0-9]{3})[^0-9]*([0-9]{4})', E'\\1-\\2');
      output := (areacode || '-' || temp);
    ELSE
      output := temp;
    END IF;
    RETURN output;
  END;

$_$;


ALTER FUNCTION migration_tools.attempt_phone(text, text) OWNER TO evergreen;

--
-- Name: attempt_timestamptz(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION attempt_timestamptz(text, text) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output TIMESTAMPTZ;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::TIMESTAMPTZ AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::TIMESTAMPTZ AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_timestamptz(text, text) OWNER TO evergreen;

--
-- Name: base_circ_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION base_circ_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_circ_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_circ_field_map(text) OWNER TO evergreen;

--
-- Name: base_copy_location_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION base_copy_location_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_copy_location_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_copy_location_map(text) OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION base_item_dynamic_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_item_dynamic_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_item_dynamic_field_map(text) OWNER TO evergreen;

--
-- Name: base_profile_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION base_profile_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_profile_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_profile_map(text) OWNER TO evergreen;

--
-- Name: build(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION build(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables TEXT[];
    BEGIN
        --RAISE INFO 'In migration_tools.build(%)', migration_schema;
        SELECT migration_tools.production_tables(migration_schema) INTO STRICT production_tables;
        PERFORM migration_tools.build_base_staging_tables(migration_schema,production_tables);
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_patron_barcode_key ON ' || migration_schema || '.actor_card ( barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_patron_usrname_key ON ' || migration_schema || '.actor_usr ( usrname );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_copy_barcode_key ON ' || migration_schema || '.asset_copy ( barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_copy_id_key ON ' || migration_schema || '.asset_copy ( id );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_callnum_record_idx ON ' || migration_schema || '.asset_call_number ( record );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_callnum_upper_label_id_lib_idx ON ' || migration_schema || '.asset_call_number ( UPPER(label),id,owning_lib );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_callnum_label_once_per_lib ON ' || migration_schema || '.asset_call_number ( record,owning_lib,label );' );
    END;
$_$;


ALTER FUNCTION migration_tools.build(text) OWNER TO evergreen;

--
-- Name: build_base_staging_tables(text, text[]); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION build_base_staging_tables(text, text[]) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables ALIAS FOR $2;
    BEGIN
        --RAISE INFO 'In migration_tools.build_base_staging_tables(%,%)', migration_schema, production_tables;
        FOR i IN array_lower(production_tables,1) .. array_upper(production_tables,1) LOOP
            PERFORM migration_tools.build_specific_base_staging_table(migration_schema,production_tables[i]);
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.build_base_staging_tables(text, text[]) OWNER TO evergreen;

--
-- Name: build_specific_base_staging_table(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION build_specific_base_staging_table(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_table ALIAS FOR $2;
        base_staging_table TEXT;
        columns RECORD;
    BEGIN
        base_staging_table = REPLACE( production_table, '.', '_' );
        --RAISE INFO 'In migration_tools.build_specific_base_staging_table(%,%) -> %', migration_schema, production_table, base_staging_table;
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.' || base_staging_table || ' ( LIKE ' || production_table || ' INCLUDING DEFAULTS EXCLUDING CONSTRAINTS );' );
        PERFORM migration_tools.exec( $1, '
            INSERT INTO ' || migration_schema || '.fields_requiring_mapping
                SELECT table_schema, table_name, column_name, data_type
                FROM information_schema.columns 
                WHERE table_schema = ''' || migration_schema || ''' AND table_name = ''' || base_staging_table || ''' AND is_nullable = ''NO'' AND column_default IS NULL;
        ' );
        FOR columns IN 
            SELECT table_schema, table_name, column_name, data_type
            FROM information_schema.columns 
            WHERE table_schema = migration_schema AND table_name = base_staging_table AND is_nullable = 'NO' AND column_default IS NULL
        LOOP
            PERFORM migration_tools.exec( $1, 'ALTER TABLE ' || columns.table_schema || '.' || columns.table_name || ' ALTER COLUMN ' || columns.column_name || ' DROP NOT NULL;' );
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.build_specific_base_staging_table(text, text) OWNER TO evergreen;

--
-- Name: change_call_number(bigint, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION change_call_number(copy_id bigint, new_label text) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  old_volume   BIGINT;
  new_volume   BIGINT;
  bib          BIGINT;
  owner        INTEGER;
  old_label    TEXT;
  remainder    BIGINT;

BEGIN

  -- Bail out if asked to change the label to ##URI##
  IF new_label = '##URI##' THEN
    RETURN;
  END IF;

  -- Gather information
  SELECT call_number INTO old_volume FROM asset.copy WHERE id = copy_id;
  SELECT record INTO bib FROM asset.call_number WHERE id = old_volume;
  SELECT owning_lib, label INTO owner, old_label FROM asset.call_number WHERE id = old_volume;

  -- Bail out if the label already is ##URI##
  IF old_label = '##URI##' THEN
    RETURN;
  END IF;

  -- Bail out if the call number label is already correct
  IF new_volume = old_volume THEN
    RETURN;
  END IF;

  -- Check whether we already have a destination volume available
  SELECT id INTO new_volume FROM asset.call_number 
    WHERE 
      record = bib AND
      owning_lib = owner AND
      label = new_label AND
      NOT deleted;

  -- Create destination volume if needed
  IF NOT FOUND THEN
    INSERT INTO asset.call_number (creator, editor, record, owning_lib, label) 
      VALUES (1, 1, bib, owner, new_label);
    SELECT id INTO new_volume FROM asset.call_number
      WHERE 
        record = bib AND
        owning_lib = owner AND
        label = new_label AND
        NOT deleted;
  END IF;

  -- Move copy to destination
  UPDATE asset.copy SET call_number = new_volume WHERE id = copy_id;

  -- Delete source volume if it is now empty
  SELECT id INTO remainder FROM asset.copy WHERE call_number = old_volume AND NOT deleted;
  IF NOT FOUND THEN
    DELETE FROM asset.call_number WHERE id = old_volume;
  END IF;

END;

$$;


ALTER FUNCTION migration_tools.change_call_number(copy_id bigint, new_label text) OWNER TO evergreen;

--
-- Name: change_owning_lib(bigint, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION change_owning_lib(copy_id bigint, new_owning_lib integer) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  old_volume     BIGINT;
  new_volume     BIGINT;
  bib            BIGINT;
  old_owning_lib INTEGER;
	old_label      TEXT;
  remainder      BIGINT;

BEGIN

  -- Gather information
  SELECT call_number INTO old_volume FROM asset.copy WHERE id = copy_id;
  SELECT record INTO bib FROM asset.call_number WHERE id = old_volume;
  SELECT owning_lib, label INTO old_owning_lib, old_label FROM asset.call_number WHERE id = old_volume;

	-- Bail out if the new_owning_lib is not the ID of an org_unit
	IF new_owning_lib NOT IN (SELECT id FROM actor.org_unit) THEN
		RAISE WARNING 
			'% is not a valid actor.org_unit ID; no change made.', 
				new_owning_lib;
		RETURN;
	END IF;

  -- Bail out discreetly if the owning_lib is already correct
  IF new_owning_lib = old_owning_lib THEN
    RETURN;
  END IF;

  -- Check whether we already have a destination volume available
  SELECT id INTO new_volume FROM asset.call_number 
    WHERE 
      record = bib AND
      owning_lib = new_owning_lib AND
      label = old_label AND
      NOT deleted;

  -- Create destination volume if needed
  IF NOT FOUND THEN
    INSERT INTO asset.call_number (creator, editor, record, owning_lib, label) 
      VALUES (1, 1, bib, new_owning_lib, old_label);
    SELECT id INTO new_volume FROM asset.call_number
      WHERE 
        record = bib AND
        owning_lib = new_owning_lib AND
        label = old_label AND
        NOT deleted;
  END IF;

  -- Move copy to destination
  UPDATE asset.copy SET call_number = new_volume WHERE id = copy_id;

  -- Delete source volume if it is now empty
  SELECT id INTO remainder FROM asset.copy WHERE call_number = old_volume AND NOT deleted;
  IF NOT FOUND THEN
    DELETE FROM asset.call_number WHERE id = old_volume;
  END IF;

END;

$$;


ALTER FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owning_lib integer) OWNER TO evergreen;

--
-- Name: change_owning_lib(bigint, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION change_owning_lib(copy_id bigint, new_owner text) RETURNS void
    LANGUAGE plpgsql
    AS $_$

-- You can use shortnames with this function, which looks up the org unit ID and passes it to change_owning_lib(BIGINT,INTEGER).

DECLARE
	new_owning_lib	INTEGER;

BEGIN

	-- Parse the new_owner as an org unit ID or shortname
	IF new_owner IN (SELECT shortname FROM actor.org_unit) THEN
		SELECT id INTO new_owning_lib FROM actor.org_unit WHERE shortname = new_owner;
		PERFORM migration_tools.change_owning_lib(copy_id, new_owning_lib);
	ELSIF new_owner ~ E'^[0-9]+$' THEN
		IF new_owner::INTEGER IN (SELECT id FROM actor.org_unit) THEN
			RAISE INFO 
				'%',
				E'You don\'t need to put the actor.org_unit ID in quotes; '
					|| E'if you put it in quotes, I\'m going to try to parse it as a shortname first.';
			new_owning_lib := new_owner::INTEGER;
		PERFORM migration_tools.change_owning_lib(copy_id, new_owning_lib);
		END IF;
	ELSE
		RAISE WARNING 
			'% is not a valid actor.org_unit shortname or ID; no change made.', 
			new_owning_lib;
		RETURN;
	END IF;

END;

$_$;


ALTER FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owner text) OWNER TO evergreen;

--
-- Name: check_ou_depth(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION check_ou_depth() RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  ou  INT;
	org_unit_depth INT;
	ou_parent INT;
	parent_depth INT;
  errors_found BOOLEAN;
	ou_shortname TEXT;
	parent_shortname TEXT;
	ou_type_name TEXT;
	parent_type TEXT;
	type_id INT;
	type_depth INT;
	type_parent INT;
	type_parent_depth INT;
	proper_parent TEXT;

BEGIN

	errors_found := FALSE;

-- Checking actor.org_unit_type

	FOR type_id IN EXECUTE ('SELECT id FROM actor.org_unit_type ORDER BY id;') LOOP

		SELECT depth FROM actor.org_unit_type WHERE id = type_id INTO type_depth;
		SELECT parent FROM actor.org_unit_type WHERE id = type_id INTO type_parent;

		IF type_parent IS NOT NULL THEN

			SELECT depth FROM actor.org_unit_type WHERE id = type_parent INTO type_parent_depth;

			IF type_depth - type_parent_depth <> 1 THEN
				SELECT name FROM actor.org_unit_type WHERE id = type_id INTO ou_type_name;
				SELECT name FROM actor.org_unit_type WHERE id = type_parent INTO parent_type;
				RAISE INFO 'The % org unit type has a depth of %, but its parent org unit type, %, has a depth of %.',
					ou_type_name, type_depth, parent_type, type_parent_depth;
				errors_found := TRUE;

			END IF;

		END IF;

	END LOOP;

-- Checking actor.org_unit

  FOR ou IN EXECUTE ('SELECT id FROM actor.org_unit ORDER BY shortname;') LOOP

		SELECT parent_ou FROM actor.org_unit WHERE id = ou INTO ou_parent;
		SELECT t.depth FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou INTO org_unit_depth;
		SELECT t.depth FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou_parent INTO parent_depth;
		SELECT shortname FROM actor.org_unit WHERE id = ou INTO ou_shortname;
		SELECT shortname FROM actor.org_unit WHERE id = ou_parent INTO parent_shortname;
		SELECT t.name FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou INTO ou_type_name;
		SELECT t.name FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou_parent INTO parent_type;

		IF ou_parent IS NOT NULL THEN

			IF	(org_unit_depth - parent_depth <> 1) OR (
				(SELECT parent FROM actor.org_unit_type WHERE name = ou_type_name) <> (SELECT id FROM actor.org_unit_type WHERE name = parent_type)
			) THEN
				RAISE INFO '% (org unit %) is a % (depth %) but its parent, % (org unit %), is a % (depth %).', 
					ou_shortname, ou, ou_type_name, org_unit_depth, parent_shortname, ou_parent, parent_type, parent_depth;
				errors_found := TRUE;
			END IF;

		END IF;

  END LOOP;

	IF NOT errors_found THEN
		RAISE INFO 'No errors found.';
	END IF;

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.check_ou_depth() OWNER TO evergreen;

--
-- Name: country_code(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION country_code(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value FROM ' || migration_schema || '.config WHERE key = ''country_code'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.country_code(text) OWNER TO evergreen;

--
-- Name: create_cards(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION create_cards(schemaname text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Make sure the patrons are staged in schemaname.actor_usr_legacy and have 'usrname' assigned.
--        Then SELECT migration_tools.create_cards('m_foo');

DECLARE
	u                    TEXT := schemaname || '.actor_usr_legacy';
	c                    TEXT := schemaname || '.actor_card';
  
BEGIN

	EXECUTE ('DELETE FROM ' || c || ';');
	EXECUTE ('INSERT INTO ' || c || ' (usr, barcode) SELECT id, usrname FROM ' || u || ';');
	EXECUTE ('UPDATE ' || u || ' u SET card = c.id FROM ' || c || ' c WHERE c.usr = u.id;');

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.create_cards(schemaname text) OWNER TO evergreen;

--
-- Name: debug_exec(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION debug_exec(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows INTEGER;
    BEGIN
        EXECUTE 'UPDATE ' || migration_schema || '.sql_current SET sql = ' || quote_literal(sql) || ';';
        RAISE INFO 'debug_exec sql = %', sql;
        EXECUTE sql;
        GET DIAGNOSTICS nrows = ROW_COUNT;
        PERFORM migration_tools.log(migration_schema,sql,nrows);
    EXCEPTION
        WHEN OTHERS THEN 
            RAISE EXCEPTION '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
    END;
$_$;


ALTER FUNCTION migration_tools.debug_exec(text, text) OWNER TO evergreen;

--
-- Name: exec(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION exec(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows INTEGER;
    BEGIN
        EXECUTE 'UPDATE ' || migration_schema || '.sql_current SET sql = ' || quote_literal(sql) || ';';
        --RAISE INFO '%', sql;
        EXECUTE sql;
        GET DIAGNOSTICS nrows = ROW_COUNT;
        PERFORM migration_tools.log(migration_schema,sql,nrows);
    EXCEPTION
        WHEN OTHERS THEN 
            RAISE EXCEPTION '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
    END;
$_$;


ALTER FUNCTION migration_tools.exec(text, text) OWNER TO evergreen;

--
-- Name: expand_barcode(text, text, integer, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION expand_barcode(text, text, integer, text, text) RETURNS text
    LANGUAGE plperl STABLE
    AS $_$
    my ($barcode, $prefix, $maxlen, $pad, $suffix) = @_;

    # default case
    return unless defined $barcode;

    $prefix     = '' unless defined $prefix;
    $maxlen ||= 14;
    $pad        = '0' unless defined $pad;
    $suffix     = '' unless defined $suffix;

    # bail out if adding prefix and suffix would bring new barcode over max length
    return $barcode if (length($prefix) + length($barcode) + length($suffix)) > $maxlen;

    my $new_barcode = $barcode;
    if ($pad ne '') {
        my $pad_length = $maxlen - length($prefix) - length($suffix);
        if (length($barcode) < $pad_length) {
            # assuming we always want padding on the left
            # also assuming that it is possible to have the pad string be longer than 1 character
            $new_barcode = substr($pad x ($pad_length - length($barcode)), 0, $pad_length - length($barcode)) . $new_barcode;
        }
    }

    # bail out if adding prefix and suffix would bring new barcode over max length
    return $barcode if (length($prefix) + length($new_barcode) + length($suffix)) > $maxlen;

    return "$prefix$new_barcode$suffix";
$_$;


ALTER FUNCTION migration_tools.expand_barcode(text, text, integer, text, text) OWNER TO evergreen;

--
-- Name: init(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION init(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql TEXT;
    BEGIN
        EXECUTE 'DROP TABLE IF EXISTS ' || migration_schema || '.sql_current;';
        EXECUTE 'CREATE TABLE ' || migration_schema || '.sql_current ( sql TEXT);';
        EXECUTE 'INSERT INTO ' || migration_schema || '.sql_current ( sql ) VALUES ( '''' );';
        BEGIN
            SELECT 'CREATE TABLE ' || migration_schema || '.sql_log ( time TIMESTAMP NOT NULL DEFAULT NOW(), row_count INTEGER, sql TEXT );' INTO STRICT sql;
            EXECUTE sql;
        EXCEPTION
            WHEN OTHERS THEN 
                RAISE INFO '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
        END;
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.config;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.config ( key TEXT UNIQUE, value TEXT);' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''production_tables'', ''asset.call_number,asset.copy_location,asset.copy,asset.stat_cat,asset.stat_cat_entry,asset.stat_cat_entry_copy_map,asset.copy_note,actor.usr,actor.card,actor.usr_address,actor.stat_cat,actor.stat_cat_entry,actor.stat_cat_entry_usr_map,actor.usr_note,action.circulation,action.hold_request,action.hold_notification,money.grocery,money.billing,money.cash_payment,money.forgive_payment'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''country_code'', ''USA'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.fields_requiring_mapping;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.fields_requiring_mapping( table_schema TEXT, table_name TEXT, column_name TEXT, data_type TEXT);' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_profile_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_profile_map ( 
            id SERIAL,
            perm_grp_id INTEGER,
            transcribed_perm_group TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_profile_map'', ''base_profile_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_item_dynamic_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_item_dynamic_field_map ( 
            id SERIAL,
            evergreen_field TEXT,
            evergreen_value TEXT,
            evergreen_datatype TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf1_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf2_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf3_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_item_dynamic_field_map'', ''base_item_dynamic_field_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_copy_location_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_copy_location_map ( 
            id SERIAL,
            location INTEGER,
            holdable BOOLEAN NOT NULL DEFAULT TRUE,
            hold_verify BOOLEAN NOT NULL DEFAULT FALSE,
            opac_visible BOOLEAN NOT NULL DEFAULT TRUE,
            circulate BOOLEAN NOT NULL DEFAULT TRUE,
            transcribed_location TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf1_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf2_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf3_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_loc_idx ON ' || migration_schema || '.base_copy_location_map (transcribed_location);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_copy_location_map'', ''base_copy_location_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_circ_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_circ_field_map ( 
            id SERIAL,
            circulate BOOLEAN,
            loan_period TEXT,
            max_renewals TEXT,
            max_out TEXT,
            fine_amount TEXT,
            fine_interval TEXT,
            max_fine TEXT,
            item_field1 TEXT,
            item_value1 TEXT,
            item_field2 TEXT,
            item_value2 TEXT,
            patron_field1 TEXT,
            patron_value1 TEXT,
            patron_field2 TEXT,
            patron_value2 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf1_idx ON ' || migration_schema || '.base_circ_field_map (item_field1,item_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf2_idx ON ' || migration_schema || '.base_circ_field_map (item_field2,item_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf3_idx ON ' || migration_schema || '.base_circ_field_map (patron_field1,patron_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf4_idx ON ' || migration_schema || '.base_circ_field_map (patron_field2,patron_value2);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_circ_field_map'', ''base_circ_field_map'' );' );

        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_init'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_init'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.init(text) OWNER TO evergreen;

--
-- Name: insert_856_9(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_856_9(text, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$

  ## USAGE: UPDATE biblio.record_entry SET marc = migration_tools.insert_856_9(marc, 'ABC') WHERE [...];

  my ($marcxml, $shortname) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;

  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');

    foreach my $field ( $marc->field('856') ) {
      if ( scalar(grep( /(contentreserve|netlibrary|overdrive)\.com/i, $field->subfield('u'))) > 0 &&
           ! ( $field->as_string('9') =~ m/$shortname/ ) ) {
        $field->add_subfields( '9' => $shortname );
				$field->update( ind2 => '0');
      }
    }

    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };

  return $xml;

$_$;


ALTER FUNCTION migration_tools.insert_856_9(text, text) OWNER TO evergreen;

--
-- Name: insert_base_into_production(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_base_into_production(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables TEXT[];
    BEGIN
        --RAISE INFO 'In migration_tools.insert_into_production(%)', migration_schema;
        SELECT migration_tools.production_tables(migration_schema) INTO STRICT production_tables;
        FOR i IN array_lower(production_tables,1) .. array_upper(production_tables,1) LOOP
            PERFORM migration_tools.insert_into_production(migration_schema,production_tables[i]);
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.insert_base_into_production(text) OWNER TO evergreen;

--
-- Name: insert_into_production(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_into_production(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_table ALIAS FOR $2;
        base_staging_table TEXT;
        columns RECORD;
    BEGIN
        base_staging_table = REPLACE( production_table, '.', '_' );
        --RAISE INFO 'In migration_tools.insert_into_production(%,%) -> %', migration_schema, production_table, base_staging_table;
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || production_table || ' SELECT * FROM ' || migration_schema || '.' || base_staging_table || ';' );
    END;
$_$;


ALTER FUNCTION migration_tools.insert_into_production(text, text) OWNER TO evergreen;

--
-- Name: insert_metarecords_for_incumbent_database(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_metarecords_for_incumbent_database() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
  INSERT INTO metabib.metarecord (fingerprint, master_record)
    SELECT  DISTINCT ON (b.fingerprint) b.fingerprint, b.id
      FROM  biblio.record_entry b
      WHERE NOT b.deleted
        AND b.id IN (SELECT r.id FROM biblio.record_entry r LEFT JOIN metabib.metarecord_source_map k ON (k.source = r.id) WHERE k.id IS NULL AND r.fingerprint IS NOT NULL)
        AND NOT EXISTS ( SELECT 1 FROM metabib.metarecord WHERE fingerprint = b.fingerprint )
      ORDER BY b.fingerprint, b.quality DESC;
  INSERT INTO metabib.metarecord_source_map (metarecord, source)
    SELECT  m.id, r.id
      FROM  biblio.record_entry r
        JOIN metabib.metarecord m USING (fingerprint)
      WHERE NOT r.deleted
        AND r.id IN (SELECT b.id FROM biblio.record_entry b LEFT JOIN metabib.metarecord_source_map k ON (k.source = b.id) WHERE k.id IS NULL);
END;
    
$$;


ALTER FUNCTION migration_tools.insert_metarecords_for_incumbent_database() OWNER TO evergreen;

--
-- Name: insert_metarecords_for_pristine_database(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_metarecords_for_pristine_database() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
  INSERT INTO metabib.metarecord (fingerprint, master_record)
    SELECT  DISTINCT ON (b.fingerprint) b.fingerprint, b.id
      FROM  biblio.record_entry b
      WHERE NOT b.deleted
        AND b.id IN (SELECT r.id FROM biblio.record_entry r LEFT JOIN metabib.metarecord_source_map k ON (k.source = r.id) WHERE k.id IS NULL AND r.fingerprint IS NOT NULL)
        AND NOT EXISTS ( SELECT 1 FROM metabib.metarecord WHERE fingerprint = b.fingerprint )
      ORDER BY b.fingerprint, b.quality DESC;
  INSERT INTO metabib.metarecord_source_map (metarecord, source)
    SELECT  m.id, r.id
      FROM  biblio.record_entry r
      JOIN  metabib.metarecord m USING (fingerprint)
     WHERE  NOT r.deleted;
END;
  
$$;


ALTER FUNCTION migration_tools.insert_metarecords_for_pristine_database() OWNER TO evergreen;

--
-- Name: insert_tags(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION insert_tags(text, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_X$

  my ($marcxml, $tags) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;

  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $to_insert = MARC::Record->new_from_xml("<record>$tags</record>", 'UTF-8');

    my @incumbents = ();

    foreach my $field ( $marc->fields() ) {
      push @incumbents, $field->as_formatted();
    }

    foreach $field ( $to_insert->fields() ) {
      if (!grep {$_ eq $field->as_formatted()} @incumbents) {
        $marc->insert_fields_ordered( ($field) );
      }
    }

    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };

  return $xml;

$_X$;


ALTER FUNCTION migration_tools.insert_tags(text, text) OWNER TO evergreen;

--
-- Name: is_blank(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION is_blank(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  BEGIN
    RETURN CASE WHEN $1 = '' THEN TRUE ELSE FALSE END;
  END;
$_$;


ALTER FUNCTION migration_tools.is_blank(text) OWNER TO evergreen;

--
-- Name: is_staff_profile(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION is_staff_profile(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    profile ALIAS FOR $1;
  BEGIN
    RETURN CASE WHEN 'Staff' IN (select (permission.grp_ancestors(profile)).name) THEN TRUE ELSE FALSE END;
  END;
$_$;


ALTER FUNCTION migration_tools.is_staff_profile(integer) OWNER TO evergreen;

--
-- Name: keyword(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION keyword(breid integer) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- And now the indexing data
    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( breid ) LOOP
        IF ind_data.field < 0 THEN
            ind_vector = '';
            ind_data.field = -1 * ind_data.field;
        ELSE
            ind_vector = NULL;
        END IF;

        EXECUTE $$
            INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value, index_vector)
                VALUES ($$ ||
                    quote_literal(ind_data.field) || $$, $$ ||
                    quote_literal(ind_data.source) || $$, $$ ||
                    quote_literal(ind_data.value) || $$, $$ ||
                    COALESCE(quote_literal(ind_vector),'NULL'::TEXT) ||
                $$);$$;
    END LOOP;

END;
$_X$;


ALTER FUNCTION migration_tools.keyword(breid integer) OWNER TO evergreen;

--
-- Name: log(text, text, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION log(text, text, integer) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows ALIAS FOR $3;
    BEGIN
        EXECUTE 'INSERT INTO ' || migration_schema || '.sql_log ( sql, row_count ) VALUES ( ' || quote_literal(sql) || ', ' || nrows || ' );';
    END;
$_$;


ALTER FUNCTION migration_tools.log(text, text, integer) OWNER TO evergreen;

--
-- Name: map_base_circ_table_dynamic(text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_base_circ_table_dynamic(text, text, text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        circ_table ALIAS FOR $2;
        item_table ALIAS FOR $3;
        patron_table ALIAS FOR $4;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        sql_where4 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_circ_field_map(migration_schema) INTO STRICT field_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || circ_table || ' AS c SET duration = ' || quote_literal(output.loan_period) || '::INTERVAL, renewal_remaining = ' || quote_literal(output.max_renewals) || '::INTEGER, recuring_fine = ' || quote_literal(output.fine_amount) || '::NUMERIC(6,2), fine_interval = ' || quote_literal(output.fine_interval) || '::INTERVAL, max_fine = ' || quote_literal(output.max_fine) || '::NUMERIC(6,2) FROM ' || field_map || ' AS m, ' || item_table || ' AS i, ' || patron_table || ' AS u WHERE c.usr = u.id AND c.target_copy = i.id AND ';
            sql_where1 := NULLIF(output.item_field1,'') || ' = ' || quote_literal( output.item_value1 ) || ' AND item_field1 = ' || quote_literal(output.item_field1) || ' AND item_value1 = ' || quote_literal(output.item_value1);
            sql_where2 := NULLIF(output.item_field2,'') || ' = ' || quote_literal( output.item_value2 ) || ' AND item_field2 = ' || quote_literal(output.item_field2) || ' AND item_value2 = ' || quote_literal(output.item_value2);
            sql_where3 := NULLIF(output.patron_field1,'') || ' = ' || quote_literal( output.patron_value1 ) || ' AND patron_field1 = ' || quote_literal(output.patron_field1) || ' AND patron_value1 = ' || quote_literal(output.patron_value1);
            sql_where4 := NULLIF(output.patron_field2,'') || ' = ' || quote_literal( output.patron_value2 ) || ' AND patron_field2 = ' || quote_literal(output.patron_field2) || ' AND patron_value2 = ' || quote_literal(output.patron_value2);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || CASE WHEN sql_where3 <> '' AND sql_where4 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where4,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_circ_field_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_circ_field_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_circ_table_dynamic(text, text, text, text) OWNER TO evergreen;

--
-- Name: map_base_item_table_dynamic(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_base_item_table_dynamic(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        item_table ALIAS FOR $2;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_item_dynamic_field_map(migration_schema) INTO STRICT field_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET ' || output.evergreen_field || E' = ' || quote_literal(output.evergreen_value) || '::' || output.evergreen_datatype || E' FROM ' || field_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_item_mapping_dynamic'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_item_mapping_dynamic'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_item_table_dynamic(text, text) OWNER TO evergreen;

--
-- Name: map_base_item_table_locations(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_base_item_table_locations(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        base_copy_location_map TEXT;
        item_table ALIAS FOR $2;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_copy_location_map(migration_schema) INTO STRICT base_copy_location_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || base_copy_location_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET location = m.location FROM ' || base_copy_location_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_item_mapping_locations'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_item_mapping_locations'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_item_table_locations(text, text) OWNER TO evergreen;

--
-- Name: map_base_patron_profile(text, text, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_base_patron_profile(text, text, integer) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        profile_map TEXT;
        patron_table ALIAS FOR $2;
        default_patron_profile ALIAS FOR $3;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_profile_map(migration_schema) INTO STRICT profile_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || profile_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || patron_table || ' AS u SET profile = perm_grp_id FROM ' || profile_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        PERFORM migration_tools.exec( $1, 'UPDATE ' || patron_table || ' AS u SET profile = ' || quote_literal(default_patron_profile) || ' WHERE profile IS NULL;'  );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_patron_mapping_profile'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_patron_mapping_profile'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_patron_profile(text, text, integer) OWNER TO evergreen;

--
-- Name: map_subfield(bigint, text, text, text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_subfield(bibid bigint, old_marc text, source_tag text, source_sf text, dest_tag text, dest_sf text, map text DEFAULT ''::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
        sf_value        TEXT;
        new_marc        TEXT;
BEGIN
        -- NOTE!!! This will strip the ENTIRE destination tag ... you are warned.
        sf_value := extract_marc_field('biblio.record_entry', bibid, '//*[@tag="' || source_tag || '"][1]/*[@code="' || source_sf || '"][1]');
        -- RAISE NOTICE '%', sf_value;
        sf_value := generic_map_normalizer(sf_value, map);
        -- RAISE NOTICE '%', sf_value;
        -- make sure it's gone
        new_marc := vandelay.strip_field( old_marc, dest_tag);
        -- RAISE NOTICE '%', new_marc;
        new_marc := migration_tools.insert_tags( new_marc, '<datafield tag="'||dest_tag||'"><subfield code="'||dest_sf||'">'||sf_value||'</subfield></datafield>');
        -- RAISE NOTICE '%', new_marc;
        -- UPDATE biblio.record_entry SET marc = new_marc WHERE id = bibid;
        RETURN new_marc;
END;
$$;


ALTER FUNCTION migration_tools.map_subfield(bibid bigint, old_marc text, source_tag text, source_sf text, dest_tag text, dest_sf text, map text) OWNER TO evergreen;

--
-- Name: map_unicorn_circulation(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_circulation(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                usr = p.usr FROM ' || migration_schema || E'.actor_card p WHERE p.barcode = l_user_id
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                circ_lib = m.org_id FROM ' || org_map || E' m WHERE l_library = l_charging_lib
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                circ_staff = m.default_circ_staff FROM ' || org_map || E' m WHERE l_library = l_charging_lib
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                target_copy = i.id FROM ' || migration_schema || E'.asset_copy i WHERE i.barcode = l_item_id
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn AS c SET
                renewal_remaining = 5,
                xact_start = l_date_charged::TIMESTAMP,
                due_date = COALESCE( NULLIF(l_date_due,''NEVER''), ''2030-01-01'' )::TIMESTAMP,
                duration = COALESCE( NULLIF(l_date_due,''NEVER''), ''2030-01-01'' )::TIMESTAMP - l_date_charged::TIMESTAMP,
                recurring_fine = 0.00,
                max_fine = 10.00,
                stop_fines = CASE WHEN l_date_claim_returned <> '''' THEN ''CLAIMSRETURNED'' ELSE NULL END,
                stop_fines_time = CASE WHEN l_date_claim_returned <> '''' THEN l_date_claim_returned::TIMESTAMP ELSE NULL END,
                duration_rule = ' || quote_literal(migration_schema) || E',
                recurring_fine_rule = ' || quote_literal(migration_schema) || E',
                max_fine_rule = ' || quote_literal(migration_schema) || E' 

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_circulation_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_circulation_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_circulation(text) OWNER TO evergreen;

--
-- Name: map_unicorn_holds(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_holds(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        user_key_barcode_map TEXT;
        item_key_barcode_map TEXT;
        default_selection_depth INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_user_key_barcode_map(migration_schema) INTO STRICT user_key_barcode_map;
        SELECT migration_tools.unicorn_item_key_barcode_map(migration_schema) INTO STRICT item_key_barcode_map;
        SELECT migration_tools.unicorn_default_selection_depth(migration_schema) INTO STRICT default_selection_depth;
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _item_barcode = BTRIM(im.barcode)
            FROM
                ' || migration_schema || '.item_key_barcode_map im
            WHERE
                h.l_cat_key::TEXT = im.key1 AND
                h.l_call_key::TEXT = im.key2 AND
                h.l_item_key::TEXT = im.key3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _user_barcode = BTRIM(um.barcode)
            FROM
                ' || migration_schema || '.user_key_barcode_map um
            WHERE
                h.l_user_key::TEXT = um.key;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                _bib_id = ( SELECT DISTINCT i._final_eg_bibid FROM ' || item_table || E' AS i WHERE barcode = _item_barcode ),
                current_copy = ( SELECT DISTINCT i.id FROM ' || item_table || E' AS i WHERE barcode = _item_barcode ),
                usr = ( SELECT DISTINCT p.id FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                request_time = l_hold_date::TIMESTAMP,
                capture_time = CASE
                    WHEN l_item_available = ''Y'' THEN l_hold_date::TIMESTAMP
                    ELSE NULL
                END,
                selection_depth = ' || quote_literal(default_selection_depth) || E',
                selection_ou = ( SELECT DISTINCT p.home_ou FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                hold_type = CASE -- Let us not trust the Unicorn values
                    WHEN l_hold_type = ''C'' THEN ''C''
                    ELSE ''T''
                END,
                phone_notify = ( SELECT DISTINCT COALESCE(NULLIF(day_phone,''''),NULLIF(evening_phone,''''),NULLIF(other_phone,'''')) FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                target = CASE
                    WHEN l_hold_type = ''C'' THEN current_copy
                    ELSE _bib_id
                END,
                requestor = usr,
                request_lib = selection_ou,
                pickup_lib = selection_ou;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_hold_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_hold_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_holds(text) OWNER TO evergreen;

--
-- Name: map_unicorn_holds_with_pickup_location(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_holds_with_pickup_location(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        user_key_barcode_map TEXT;
        item_key_barcode_map TEXT;
        default_selection_depth INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_user_key_barcode_map(migration_schema) INTO STRICT user_key_barcode_map;
        SELECT migration_tools.unicorn_item_key_barcode_map(migration_schema) INTO STRICT item_key_barcode_map;
        SELECT migration_tools.unicorn_default_selection_depth(migration_schema) INTO STRICT default_selection_depth;
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _item_barcode = BTRIM(im.barcode)
            FROM
                ' || migration_schema || '.item_key_barcode_map im
            WHERE
                h.l_cat_key::TEXT = im.key1 AND
                h.l_call_key::TEXT = im.key2 AND
                h.l_item_key::TEXT = im.key3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _user_barcode = BTRIM(um.barcode)
            FROM
                ' || migration_schema || '.user_key_barcode_map um
            WHERE
                h.l_user_key::TEXT = um.key;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE 
                ' || migration_schema || E'.action_hold_request_unicorn h
            SET
                _bib_id = i._final_eg_bibid
            FROM
                ' || item_table || ' i
            WHERE
                i.barcode = h._item_barcode;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE 
                ' || migration_schema || E'.action_hold_request_unicorn h
            SET
                current_copy = i.id
            FROM
                ' || item_table || ' i
            WHERE
                i.barcode = h._item_barcode;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                usr = ( SELECT DISTINCT p.id FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                request_time = l_hold_date::TIMESTAMP,
                capture_time = CASE
                    WHEN l_item_available = ''Y'' THEN l_hold_date::TIMESTAMP
                    ELSE NULL
                END,
                selection_depth = ' || quote_literal(default_selection_depth) || E',
                selection_ou = ( SELECT DISTINCT p.home_ou FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                pickup_lib = ( SELECT DISTINCT id FROM actor.org_unit ou WHERE ou.shortname = l_pickup_lib ),
                hold_type = CASE -- Let us not trust the Unicorn values
                    WHEN l_hold_type = ''C'' THEN ''C''
                    ELSE ''T''
                END,
                phone_notify = ( SELECT DISTINCT COALESCE(NULLIF(day_phone,''''),NULLIF(evening_phone,''''),NULLIF(other_phone,'''')) FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                target = CASE
                    WHEN l_hold_type = ''C'' THEN current_copy
                    ELSE _bib_id
                END,
                requestor = usr,
                request_lib = selection_ou;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_hold_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_hold_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_holds_with_pickup_location(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_base(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_item_table_base(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        default_item_status INTEGER;
        default_item_holdable_flag BOOLEAN;
        default_item_circulate_flag BOOLEAN;
        default_item_creator INTEGER;
        default_item_editor INTEGER;
        default_item_loan_duration INTEGER;
        default_item_fine_level INTEGER;
        default_item_age_protect INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_default_item_status(migration_schema) INTO STRICT default_item_status;
        SELECT migration_tools.unicorn_default_item_holdable_flag(migration_schema) INTO STRICT default_item_holdable_flag;
        SELECT migration_tools.unicorn_default_item_circulate_flag(migration_schema) INTO STRICT default_item_circulate_flag;
        SELECT migration_tools.unicorn_default_item_creator(migration_schema) INTO STRICT default_item_creator;
        SELECT migration_tools.unicorn_default_item_editor(migration_schema) INTO STRICT default_item_editor;
        SELECT migration_tools.unicorn_default_item_loan_duration(migration_schema) INTO STRICT default_item_loan_duration;
        SELECT migration_tools.unicorn_default_item_fine_level(migration_schema) INTO STRICT default_item_fine_level;
        SELECT migration_tools.unicorn_default_item_age_protect(migration_schema) INTO STRICT default_item_age_protect;
        SELECT '

            UPDATE ' || item_table || E' AS i SET 

                barcode = migration_tools.rebarcode( l_barcode, (SELECT item_rebarcode_offset FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library) ),
                price = CASE
                    WHEN length(l_price) >= 11 THEN 999999.99
                    WHEN l_price !~ E''^\\\\$?\\\\d*\\\\.\\\\d\\\\d$'' THEN 0.00
                    ELSE COALESCE( NULLIF( REPLACE(REPLACE(l_price,'' '',''''),''$'',''''), '''' ), ''0.00'' )::NUMERIC(8,2)
                END,
                create_date = NULLIF(l_acq_date,'''')::TIMESTAMP,
                edit_date = NULLIF(l_acq_date,'''')::TIMESTAMP,
                status = ' || quote_literal(default_item_status) || E',
                creator = ' || quote_literal(default_item_creator) || E',
                editor = ' || quote_literal(default_item_editor) || E',
                loan_duration = ' || quote_literal(default_item_loan_duration) || E',
                fine_level = ' || quote_literal(default_item_fine_level) || E',
                age_protect = ' || CASE WHEN default_item_age_protect IS NULL THEN 'NULL' ELSE quote_literal(default_item_age_protect) END || E',
                holdable = ' || CASE WHEN default_item_holdable_flag THEN 'TRUE' ELSE 'FALSE' END || E',
                circulate = CASE
                    WHEN l_circ_flag = ''Y'' THEN TRUE
                    WHEN l_circ_flag = ''N'' THEN FALSE
                    ELSE ' || CASE WHEN default_item_circulate_flag THEN 'TRUE' ELSE 'FALSE' END || E'
                END,
                circ_lib = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library)

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_base'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_base'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_base(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_dynamic(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_item_table_dynamic(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        item_table TEXT;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_item_dynamic_field_map(migration_schema) INTO STRICT field_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET ' || output.evergreen_field || E' = ' || quote_literal(output.evergreen_value) || '::' || output.evergreen_datatype || E' FROM ' || field_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_dynamic'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_dynamic'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_dynamic(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_locations(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_item_table_locations(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        home_location_map TEXT;
        item_table TEXT;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_home_location_map(migration_schema) INTO STRICT home_location_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || home_location_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET location = m.location FROM ' || home_location_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_locations'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_locations'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_locations(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_volumes(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_item_table_volumes(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        default_item_creator INTEGER;
        default_item_editor INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_default_item_creator(migration_schema) INTO STRICT default_item_creator;
        SELECT migration_tools.unicorn_default_item_editor(migration_schema) INTO STRICT default_item_editor;
        SELECT '

            INSERT INTO ' || migration_schema || E'.asset_call_number ( label, record, owning_lib, creator, editor ) SELECT DISTINCT
                BTRIM(l_call_number),
                _final_eg_bibid,
                (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library),
                ' || quote_literal(default_item_creator) || E'::INTEGER,
                ' || quote_literal(default_item_editor) || E'::INTEGER
            FROM ' || item_table || E' AS i WHERE _final_eg_bibid <> -1 ORDER BY 1,2,3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || item_table || E' AS i SET call_number = COALESCE(

                (SELECT c.id FROM ' || migration_schema || E'.asset_call_number AS c WHERE label = BTRIM(l_call_number) AND record = _final_eg_bibid AND owning_lib = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library)),

                -1 -- Precat

            );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_volumes'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_volumes'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_volumes(text) OWNER TO evergreen;

--
-- Name: map_unicorn_money(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_money(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.money_grocery_unicorn AS g SET

                usr = ( SELECT p.id FROM ' || patron_table || E' AS p WHERE p.l_user_id = g.l_user_id ),
                xact_start = l_bill_date::TIMESTAMP,
                note = ' || quote_literal(migration_schema) || E',
                billing_location = (SELECT org_id FROM ' || org_map || E' AS m WHERE l_library = l_billing_lib);

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            INSERT INTO ' || migration_schema || E'.money_billing ( xact, amount, billing_type, note) SELECT
                id,
                CASE
                    WHEN l_bill_amt !~ E''^\\\\$?\\\\d*\\\\.\\\\d\\\\d$'' THEN 0.00
                    ELSE COALESCE( NULLIF( REPLACE(REPLACE(l_bill_amt,'' '',''''),''$'',''''), '''' ), ''0.00'' )::NUMERIC(6,2)
                END,
                ''Legacy '' || l_bill_reason,
                COALESCE(''Item: '' || NULLIF(l_item_id,''''), '''')
            FROM ' || migration_schema || E'.money_grocery_unicorn;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_money_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_money_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_money(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_profile(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_patron_profile(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        profile_map TEXT;
        patron_table TEXT;
        default_patron_profile INTEGER;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_profile_map(migration_schema) INTO STRICT profile_map;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_default_patron_profile(migration_schema) INTO STRICT default_patron_profile;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || profile_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || patron_table || ' AS u SET profile = perm_grp_id FROM ' || profile_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        PERFORM migration_tools.exec( $1, 'UPDATE ' || patron_table || ' AS u SET profile = ' || quote_literal(default_patron_profile) || ' WHERE profile IS NULL;'  );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_profile'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_profile'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_profile(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_addresses(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_patron_table_addresses(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        patron_table TEXT;
    BEGIN
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address1 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr1_std_line1, l_addr1_std_line2, l_addr1_care_of,  l_addr1_std_city, l_addr1_std_state, l_addr1_std_zip, ''Legacy Address #1'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address2 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr2_std_line1, l_addr2_std_line2, l_addr2_care_of,  l_addr2_std_city, l_addr2_std_state, l_addr2_std_zip, ''Legacy Address #2'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address3 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr3_std_line1, l_addr3_std_line2, l_addr3_care_of,  l_addr3_std_city, l_addr3_std_state, l_addr3_std_zip, ''Legacy Address #3'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                mailing_address = CASE
                    WHEN l_user_mailingaddr = ''1'' THEN _address1
                    WHEN l_user_mailingaddr = ''2'' THEN _address2
                    WHEN l_user_mailingaddr = ''3'' THEN _address3
                    ELSE COALESCE( _address1, _address2, _address3 )
                END;

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET billing_address = mailing_address;

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_addresses'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_addresses'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_addresses(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_base(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_patron_table_base(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        patron_table TEXT;
        default_net_access_level INTEGER;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_default_net_access_level(migration_schema) INTO STRICT default_net_access_level;
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                passwd = l_user_pin,
                family_name = BTRIM( l_last_name ),
                first_given_name = BTRIM( l_first_name ),
                second_given_name = BTRIM( l_middle_name ),
                suffix = BTRIM( l_suffix_name ),
                prefix = BTRIM( l_prefix_name ),
                dob = NULLIF( NULLIF(l_birthdate, ''''), ''NEVER'' )::TIMESTAMP,
                create_date = COALESCE( NULLIF( NULLIF(l_user_priv_granted, ''''), ''NEVER'' ), now()::DATE::TEXT )::TIMESTAMP,
                expire_date = COALESCE( NULLIF( NULLIF(l_user_priv_expires, ''''), ''NEVER'' ), ''2030-01-01'' )::TIMESTAMP,
                day_phone = BTRIM(
                    COALESCE( NULLIF(l_addr1_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_dayphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_dayphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_dayphone,'''') || '' '', '''' ) 
                ),
                evening_phone = BTRIM(
                    COALESCE( NULLIF(l_addr1_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_homephone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_homephone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_homephone,'''') || '' '', '''' ) 
                ),
                other_phone = BTRIM(
                    COALESCE( NULLIF(l_addr2_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_cellphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_cellphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_cellphone,'''') || '' '', '''' )
                ),
                email = BTRIM(
                    COALESCE(
                        NULLIF(l_addr1_email,''''),
                        NULLIF(l_addr2_email,''''),
                        NULLIF(l_addr3_email,''''),
                        ''''
                    )
                ),
                ident_type = 3,
                ident_value = BTRIM(
                    COALESCE(
                        NULLIF(l_license,''''),
                        NULLIF(l_user_id,''''),
                        ''''
                    )
                ),
                ident_type2 = CASE WHEN l_ssn <> '''' THEN 2 ELSE 3 END,
                ident_value2 = BTRIM(
                    COALESCE(
                        NULLIF(l_ssn,''''),
                        NULLIF(l_guardian,''''),
                        NULLIF(l_user_altid,''''),
                        ''''
                    )
                ),
                home_ou = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = u.l_user_library),
                usrname = migration_tools.rebarcode( l_user_id, (SELECT patron_rebarcode_offset FROM ' || org_map || E' AS m WHERE m.l_library = u.l_user_library) ),
                alert_message = NULLIF(
                    BTRIM(
                        CASE WHEN l_user_profile = ''LOSTCARD'' THEN ''Legacy LOSTCARD user.  Check for duplicate account.  '' ELSE '''' END
                        || COALESCE( ''Legacy Comment: '' || NULLIF(l_comment,'''') || ''  '', '''' )
                        || COALESCE( ''Legacy Note: '' || NULLIF(l_note,'''') || ''  '', '''' )
                        -- || COALESCE( ''Legacy Staff Note: '' || NULLIF(l_staff_note,'''') || ''  '', '''' )
                        || COALESCE( ''Legacy WebCatPref Note: '' || NULLIF(l_webcatpref,'''') || ''  '', '''' )
                    ),
                    ''''
                ),
                net_access_level = ' || quote_literal(default_net_access_level) || E',
                active = COALESCE( NULLIF(l_user_profile,''''), '''' ) != ''LOSTCARD'';

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_base'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_base'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_base(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_cards(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION map_unicorn_patron_table_cards(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        patron_table TEXT;
    BEGIN
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',id,l_user_id,l_userid_active <> ''f'')
            FROM ' || patron_table || ';

        ' );
        PERFORM migration_tools.exec( $1, '

						DROP TABLE IF EXISTS ' || migration_schema || '.barcodes_to_add;

        ' );
        PERFORM migration_tools.exec( $1, '

            CREATE TABLE ' || migration_schema || '.barcodes_to_add ( barcode TEXT );

        ' );
        PERFORM migration_tools.exec( $1, '

						CREATE INDEX ' || migration_schema || '_barcodes_to_add_idx ON ' || migration_schema || '.barcodes_to_add ( barcode );

        ' );
        PERFORM migration_tools.exec( $1, '

            INSERT INTO ' || migration_schema || '.barcodes_to_add 
                SELECT l_inactive_barcode1 FROM ' || patron_table || ' WHERE l_inactive_barcode1 <> '''' ORDER BY 1;

        ' );
        PERFORM migration_tools.exec( $1, '

            DELETE FROM ' || migration_schema || '.barcodes_to_add WHERE barcode IN (
                SELECT barcode FROM ' || migration_schema || '.actor_card);

        ' );
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',u.id,u.l_inactive_barcode1,false)
            FROM ' || patron_table || ' u,
                 ' || migration_schema || '.barcodes_to_add ok
            WHERE u.l_inactive_barcode1 = ok.barcode;                  

        ' );
        PERFORM migration_tools.exec( $1, '

						DROP TABLE IF EXISTS ' || migration_schema || '.barcodes_to_add;

        ' );
        PERFORM migration_tools.exec( $1, '

            CREATE TABLE ' || migration_schema || '.barcodes_to_add ( barcode TEXT );

        ' );
        PERFORM migration_tools.exec( $1, '

						CREATE INDEX ' || migration_schema || '_barcodes_to_add_idx ON ' || migration_schema || '.barcodes_to_add ( barcode );

        ' );
        PERFORM migration_tools.exec( $1, '

            INSERT INTO ' || migration_schema || '.barcodes_to_add 
                SELECT l_inactive_barcode2 FROM ' || patron_table || ' WHERE l_inactive_barcode2 <> '''' ORDER BY 1;

        ' );
        PERFORM migration_tools.exec( $1, '

            DELETE FROM ' || migration_schema || '.barcodes_to_add WHERE barcode IN (
                SELECT barcode FROM ' || migration_schema || '.actor_card);

        ' );
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',u.id,u.l_inactive_barcode2,false)
            FROM ' || patron_table || ' u,
                 ' || migration_schema || '.barcodes_to_add ok
            WHERE u.l_inactive_barcode2 = ok.barcode;                  

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                card = (SELECT MIN(c.id) FROM ' || migration_schema || E'.actor_card AS c WHERE usr = u.id);

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_cards'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_cards'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_cards(text) OWNER TO evergreen;

--
-- Name: name_parse_out_last_comma_prefix_first_middle_suffix(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION name_parse_out_last_comma_prefix_first_middle_suffix(text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
    DECLARE
        full_name TEXT := $1;
        temp TEXT;
        family_name TEXT := '';
        first_given_name TEXT := '';
        second_given_name TEXT := '';
        suffix TEXT := '';
        prefix TEXT := '';
    BEGIN
        temp := full_name;
        -- Use values, not structure, for prefix/suffix, unless we come up with a better idea
        IF temp ilike '%MR.%' THEN
            prefix := 'Mr.';
            temp := REGEXP_REPLACE( temp, E'MR\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%MRS.%' THEN
            prefix := 'Mrs.';
            temp := REGEXP_REPLACE( temp, E'MRS\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%MS.%' THEN
            prefix := 'Ms.';
            temp := REGEXP_REPLACE( temp, E'MS\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%DR.%' THEN
            prefix := 'Dr.';
            temp := REGEXP_REPLACE( temp, E'DR\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%JR%' THEN
            suffix := 'Jr.';
            temp := REGEXP_REPLACE( temp, E'JR\.?\\s*', '', 'i' );
        END IF;
        IF temp ilike '%JR,%' THEN
            suffix := 'Jr.';
            temp := REGEXP_REPLACE( temp, E'JR,\\s*', ',', 'i' );
        END IF;
        IF temp ilike '%SR%' THEN
            suffix := 'Sr.';
            temp := REGEXP_REPLACE( temp, E'SR\.?\\s*', '', 'i' );
        END IF;
        IF temp ilike '%SR,%' THEN
            suffix := 'Sr.';
            temp := REGEXP_REPLACE( temp, E'SR,\\s*', ',', 'i' );
        END IF;
        IF temp ~ E'\\sII$' THEN
            suffix := 'II';
            temp := REGEXP_REPLACE( temp, E'II$', '', 'i' );
        END IF;
        IF temp ~ E'\\sIII$' THEN
            suffix := 'III';
            temp := REGEXP_REPLACE( temp, E'III$', '', 'i' );
        END IF;
        IF temp ~ E'\\sIV$' THEN
            suffix := 'IV';
            temp := REGEXP_REPLACE( temp, E'IV$', '', 'i' );
        END IF;

        family_name := BTRIM( REGEXP_REPLACE(temp,E'^([^,]*)\\s*,.*$',E'\\1') );
        first_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*([^,\\s]*)\\s*.*$',E'\\1') ELSE 'N/A' END );
        second_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*[^,\\s]*\\s*(.*)$',E'\\1') ELSE ''  END );

        RETURN ARRAY[ family_name, prefix, first_given_name, second_given_name, suffix ];
    END;
$_$;


ALTER FUNCTION migration_tools.name_parse_out_last_comma_prefix_first_middle_suffix(text) OWNER TO evergreen;

--
-- Name: pop_rfr(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION pop_rfr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- Shove the flattened MARC in
    INSERT INTO metabib.full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM biblio.flatten_marc( NEW.id );

    RETURN NEW;

END;
$$;


ALTER FUNCTION migration_tools.pop_rfr() OWNER TO evergreen;

--
-- Name: production_tables(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION production_tables(text) RETURNS text[]
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output  RECORD;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT string_to_array(value,'','') AS tables FROM ' || migration_schema || '.config WHERE key = ''production_tables'';'
        LOOP
            RETURN output.tables;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.production_tables(text) OWNER TO evergreen;

--
-- Name: rebarcode(text, bigint); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION rebarcode(o text, t bigint) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
    DECLARE
        n TEXT := o;
    BEGIN
        IF o ~ E'^\\d+$' AND o !~ E'^0' AND length(o) < 19 THEN -- for reference, the max value for a bigint is 9223372036854775807.  May also want to consider the case where folks want to add prefixes to non-numeric barcodes
            IF o::BIGINT < t THEN
                n = o::BIGINT + t;
            END IF;
        END IF;

        RETURN n;
    END;
$_$;


ALTER FUNCTION migration_tools.rebarcode(o text, t bigint) OWNER TO evergreen;

--
-- Name: rec_descriptor(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION rec_descriptor(breid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- Then, the rec_descriptor
    INSERT INTO metabib.rec_descriptor (record, item_type, item_form, bib_level, control_type, enc_level, audience, lit_form, type_mat, cat_form, pub_status, item_lang, vr_format, date1, date2)
        SELECT  breid,
                biblio.marc21_extract_fixed_field( breid, 'Type' ),
                biblio.marc21_extract_fixed_field( breid, 'Form' ),
                biblio.marc21_extract_fixed_field( breid, 'BLvl' ),
                biblio.marc21_extract_fixed_field( breid, 'Ctrl' ),
                biblio.marc21_extract_fixed_field( breid, 'ELvl' ),
                biblio.marc21_extract_fixed_field( breid, 'Audn' ),
                biblio.marc21_extract_fixed_field( breid, 'LitF' ),
                biblio.marc21_extract_fixed_field( breid, 'TMat' ),
                biblio.marc21_extract_fixed_field( breid, 'Desc' ),
                biblio.marc21_extract_fixed_field( breid, 'DtSt' ),
                biblio.marc21_extract_fixed_field( breid, 'Lang' ),
                (   SELECT  v.value
                      FROM  biblio.marc21_physical_characteristics( breid) p
                            JOIN config.marc21_physical_characteristic_subfield_map s ON (s.id = p.subfield)
                            JOIN config.marc21_physical_characteristic_value_map v ON (v.id = p.value)
                      WHERE p.ptype = 'v' AND s.subfield = 'e'    ),
                biblio.marc21_extract_fixed_field( breid, 'Date1'),
                biblio.marc21_extract_fixed_field( breid, 'Date2');

 

END;
$$;


ALTER FUNCTION migration_tools.rec_descriptor(breid integer) OWNER TO evergreen;

--
-- Name: refresh_opac_visible_copies(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION refresh_opac_visible_copies() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN	

	DELETE FROM asset.opac_visible_copies;

	INSERT INTO asset.opac_visible_copies (id, circ_lib, record)
		SELECT DISTINCT
			cp.id, cp.circ_lib, cn.record
		FROM
			asset.copy cp
			JOIN asset.call_number cn ON (cn.id = cp.call_number)
			JOIN actor.org_unit a ON (cp.circ_lib = a.id)
			JOIN asset.copy_location cl ON (cp.location = cl.id)
			JOIN config.copy_status cs ON (cp.status = cs.id)
			JOIN biblio.record_entry b ON (cn.record = b.id)
		WHERE 
			NOT cp.deleted AND
			NOT cn.deleted AND
			NOT b.deleted AND
			cs.opac_visible AND
			cl.opac_visible AND
			cp.opac_visible AND
			a.opac_visible AND
			cp.id NOT IN (SELECT id FROM asset.opac_visible_copies);

END;

$$;


ALTER FUNCTION migration_tools.refresh_opac_visible_copies() OWNER TO evergreen;

--
-- Name: restore_index(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION restore_index(_table_schema text, _table_name text, _index_name text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    restore TEXT;
BEGIN
    SELECT restore_command INTO restore
        FROM migration_tools.db_object_stash
        WHERE schema_name = _table_schema
        AND   table_name = _table_name
        AND   object_name = _index_name
        AND   object_type = 'index';
    EXECUTE restore;
    DELETE FROM migration_tools.db_object_stash
        WHERE schema_name = _table_schema
        AND   table_name = _table_name
        AND   object_name = _index_name
        AND   object_type = 'index';
END;
$$;


ALTER FUNCTION migration_tools.restore_index(_table_schema text, _table_name text, _index_name text) OWNER TO evergreen;

--
-- Name: set_008(text, integer, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION set_008(text, integer, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml, $pos, $value) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $f008 = $marc->field('008');

    if ($f008) {
       my $field = $f008->data();
       substr($field, $pos, 1) = $value;
       $f008->update($field);
       $xml = $marc->as_xml_record;
       $xml =~ s/^<\?.+?\?>$//mo;
       $xml =~ s/\n//sgo;
       $xml =~ s/>\s+</></sgo;
    }
  };
  return $xml;
$_$;


ALTER FUNCTION migration_tools.set_008(text, integer, text) OWNER TO evergreen;

--
-- Name: set_leader(text, integer, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION set_leader(text, integer, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml, $pos, $value) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $leader = $marc->leader();
    substr($leader, $pos, 1) = $value;
    $marc->leader($leader);
    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };
  return $xml;
$_$;


ALTER FUNCTION migration_tools.set_leader(text, integer, text) OWNER TO evergreen;

--
-- Name: stage_not_applicable_asset_stat_cats(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION stage_not_applicable_asset_stat_cats(schemaname text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Make sure the stat_cat and stat_cat_entry tables are populated, including exactly one 'Not Applicable' entry per stat cat.
--        Then SELECT migration_tools.stage_not_applicable_asset_stat_cats('m_foo');

-- TODO: Make a variant that will go directly to production tables -- which would be useful for retrofixing the absence of N/A cats.
-- TODO: Add a similar tool for actor stat cats, which behave differently.

DECLARE
	c                    TEXT := schemaname || '.asset_copy_legacy';
	sc									 TEXT := schemaname || '.asset_stat_cat';
	sce									 TEXT := schemaname || '.asset_stat_cat_entry';
	scecm								 TEXT := schemaname || '.asset_stat_cat_entry_copy_map';
	stat_cat						 INT;
  stat_cat_entry       INT;
  
BEGIN

  FOR stat_cat IN EXECUTE ('SELECT id FROM ' || sc) LOOP

		EXECUTE ('SELECT id FROM ' || sce || ' WHERE stat_cat = ' || stat_cat || E' AND value = \'Not Applicable\';') INTO stat_cat_entry;

		EXECUTE ('INSERT INTO ' || scecm || ' (owning_copy, stat_cat, stat_cat_entry)
							SELECT c.id, ' || stat_cat || ', ' || stat_cat_entry || ' FROM ' || c || ' c WHERE c.id NOT IN
							(SELECT owning_copy FROM ' || scecm || ' WHERE stat_cat = ' || stat_cat || ');');

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.stage_not_applicable_asset_stat_cats(schemaname text) OWNER TO evergreen;

--
-- Name: stash_index(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION stash_index(_table_schema text, _table_name text, _index_name text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    restore TEXT;
BEGIN
    SELECT indexdef INTO restore
        FROM pg_indexes
        WHERE schemaname = _table_schema
        AND   tablename = _table_name
        AND   indexname = _index_name;
    IF restore IS NULL
    THEN
       RAISE EXCEPTION 'no restore command for %', _index_name;
    END IF;
    INSERT INTO migration_tools.db_object_stash (schema_name, table_name, object_name, object_type, restore_command)
        VALUES(_table_schema, _table_name, _index_name, 'index', restore);
    EXECUTE 'DROP INDEX ' || _table_schema || '.' || _index_name;
END;
$$;


ALTER FUNCTION migration_tools.stash_index(_table_schema text, _table_name text, _index_name text) OWNER TO evergreen;

--
-- Name: unaccent_string(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plperl
    AS $_$
my ($input_string) = @_;
$input_string =~ s/[]/a/g;
$input_string =~ s/[]/A/g;
$input_string =~ s/[]/e/g;
$input_string =~ s/[]/E/g;
$input_string =~ s/[]/i/g;
$input_string =~ s/[]/I/g;
$input_string =~ s/[]/o/g;
$input_string =~ s/[]/O/g;
$input_string =~ s/[]/u/g;
$input_string =~ s/[]/U/g;
return $input_string;
$_$;


ALTER FUNCTION migration_tools.unaccent_string(text) OWNER TO evergreen;

--
-- Name: unicorn_actor_stat_cat_entry_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_actor_stat_cat_entry_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''actor_stat_cat_entry_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_actor_stat_cat_entry_map(text) OWNER TO evergreen;

--
-- Name: unicorn_actor_stat_cat_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_actor_stat_cat_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''actor_stat_cat_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_actor_stat_cat_map(text) OWNER TO evergreen;

--
-- Name: unicorn_card_collisions_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_card_collisions_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''card_collisions'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_card_collisions_table(text) OWNER TO evergreen;

--
-- Name: unicorn_circ_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_circ_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''circ_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_circ_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_circ_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_create_circ_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.action_circulation_unicorn (
            l_form TEXT NOT NULL CHECK ( l_form = ''LDCHARGE'' ),
            l_user_id TEXT,
            l_item_id TEXT,
            l_charging_lib TEXT,
            l_date_charged TEXT,
            l_date_due TEXT,
            l_date_claim_returned TEXT
        ) INHERITS ( ' || migration_schema || '.action_circulation);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_circ_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_hold_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_create_hold_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
				PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.action_hold_request_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.action_hold_request_unicorn (
            _bib_id BIGINT,
            _item_barcode TEXT,
            _user_barcode TEXT,
            l_cat_key integer, 
            l_call_key integer, 
            l_item_key integer, 
            l_hold_key integer, 
            l_user_key integer, 
            l_hold_type text, 
            l_item_available text, 
            l_hold_date text,
						l_pickup_lib text 
        ) INHERITS ( ' || migration_schema || '.action_hold_request);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_hold_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_item_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_create_item_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.asset_copy_unicorn (
            _orig_eg_bibid BIGINT,
            _final_eg_bibid BIGINT,
            l_library TEXT,
            l_barcode TEXT,
            l_location_current TEXT,
            l_location_home TEXT,
            l_call_number TEXT,
            l_item_type TEXT,
            l_acq_date TEXT,
            l_price TEXT,
            l_circ_flag TEXT,
            l_total_charges TEXT,
            l_cat1 TEXT,
            l_cat2 TEXT
        ) INHERITS ( ' || migration_schema || '.asset_copy);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_orig_eg_bibid ON ' || migration_schema || '.asset_copy_unicorn ( _orig_eg_bibid );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_final_eg_bibid ON ' || migration_schema || '.asset_copy_unicorn ( _final_eg_bibid );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_barcode ON ' || migration_schema || '.asset_copy_unicorn ( l_barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_location_home ON ' || migration_schema || '.asset_copy_unicorn ( l_location_home );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_location_current ON ' || migration_schema || '.asset_copy_unicorn ( l_location_current );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_library ON ' || migration_schema || '.asset_copy_unicorn ( l_library );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_item_type ON ' || migration_schema || '.asset_copy_unicorn ( l_item_type );' );
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_item_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_money_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_create_money_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.money_grocery_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.money_grocery_unicorn (
            l_form TEXT NOT NULL CHECK ( l_form = ''LDBILL'' ),
            l_user_id TEXT,
            l_item_id TEXT,
            l_billing_lib TEXT,
            l_bill_date TEXT,
            l_bill_amt TEXT,
            l_bill_reason TEXT
        ) INHERITS ( ' || migration_schema || '.money_grocery);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_money_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_patron_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_create_patron_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_usr_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_usr_unicorn (
            l_user_id TEXT,
            l_user_altid TEXT,
            l_user_pin TEXT,
            l_user_profile TEXT,
            l_user_status TEXT,
            l_user_library TEXT,
            l_user_priv_granted TEXT,
            l_user_priv_expires TEXT,
            l_user_mailingaddr TEXT,
            l_birthdate TEXT,
            l_prefix_name TEXT,
            l_last_name TEXT,
            l_first_name TEXT,
            l_middle_name TEXT,
            l_suffix_name TEXT,
            l_note TEXT,
            l_note1 TEXT,
            l_patron TEXT,
            l_comment TEXT,
            l_staff TEXT,
            l_webcatpref TEXT,
            l_user_category1 TEXT,
            l_user_category2 TEXT,
            l_user_category3 TEXT,
            l_user_category4 TEXT,
            l_dept TEXT,
            l_guardian TEXT,
            l_license TEXT,
            l_ssn TEXT,
            l_misc TEXT,
            l_aup TEXT,
            l_photo TEXT,
            l_notify_via TEXT,
            l_user_claims_ret TEXT,
            l_user_environment TEXT,
            l_user_department TEXT,
            l_ums_id TEXT,
            l_user_last_activity TEXT,
            l_placcard TEXT,
            l_user_email TEXT,
            l_addr1_std_line1 TEXT,
            l_addr1_std_line2 TEXT,
            l_addr1_std_city TEXT,
            l_addr1_std_state TEXT,
            l_addr1_std_zip TEXT,
            l_addr1_country TEXT,
            l_addr1_county TEXT,
            l_addr1_township TEXT,
            l_addr1_room TEXT,
            l_addr1_company TEXT,
            l_addr1_office TEXT,
            l_addr1_phone TEXT,
            l_addr1_dayphone TEXT,
            l_addr1_homephone TEXT,
            l_addr1_workphone TEXT,
            l_addr1_cellphone TEXT,
            l_addr1_fax TEXT,
            l_addr1_email TEXT,
            l_addr1_location TEXT,
            l_addr1_usefor TEXT,
            l_addr1_care_of TEXT,
            l_addr1_known_bad TEXT,
            l_addr1_ums_addrid TEXT,
            l_addr2_std_line1 TEXT,
            l_addr2_std_line2 TEXT,
            l_addr2_std_city TEXT,
            l_addr2_std_state TEXT,
            l_addr2_std_zip TEXT,
            l_addr2_country TEXT,
            l_addr2_county TEXT,
            l_addr2_township TEXT,
            l_addr2_room TEXT,
            l_addr2_company TEXT,
            l_addr2_office TEXT,
            l_addr2_phone TEXT,
            l_addr2_dayphone TEXT,
            l_addr2_homephone TEXT,
            l_addr2_workphone TEXT,
            l_addr2_cellphone TEXT,
            l_addr2_fax TEXT,
            l_addr2_email TEXT,
            l_addr2_location TEXT,
            l_addr2_usefor TEXT,
            l_addr2_care_of TEXT,
            l_addr2_known_bad TEXT,
            l_addr2_ums_addrid TEXT,
            l_addr3_std_line1 TEXT,
            l_addr3_std_line2 TEXT,
            l_addr3_std_city TEXT,
            l_addr3_std_state TEXT,
            l_addr3_std_zip TEXT,
            l_addr3_country TEXT,
            l_addr3_county TEXT,
            l_addr3_township TEXT,
            l_addr3_room TEXT,
            l_addr3_company TEXT,
            l_addr3_office TEXT,
            l_addr3_phone TEXT,
            l_addr3_dayphone TEXT,
            l_addr3_homephone TEXT,
            l_addr3_workphone TEXT,
            l_addr3_cellphone TEXT,
            l_addr3_fax TEXT,
            l_addr3_email TEXT,
            l_addr3_location TEXT,
            l_addr3_usefor TEXT,
            l_addr3_care_of TEXT,
            l_addr3_known_bad TEXT,
            l_addr3_ums_addrid TEXT,
            l_identific TEXT,
            l_noempl TEXT,
            l_profession TEXT,
            l_program TEXT,
            l_represent TEXT,
            l_userid_active TEXT,
            l_inactive_barcode1 TEXT,
            l_inactive_barcode2 TEXT,
            _address1 INTEGER,
            _address2 INTEGER,
            _address3 INTEGER
        ) INHERITS ( ' || migration_schema || '.actor_usr);' ); 
        -- watch out for MARC8 with these files
        -- \COPY foo.actor_usr_unicorn ( l_user_id, l_user_altid, l_user_pin, l_user_profile, l_user_status, l_user_library, l_user_priv_granted, l_user_priv_expires, l_user_mailingaddr, l_birthdate, l_last_name, l_first_name, l_middle_name, l_suffix_name, l_note, l_note1, l_patron, l_comment, l_staff, l_webcatpref, l_user_category1, l_user_category2, l_user_category3, l_user_category4, l_dept, l_guardian, l_license, l_ssn, l_misc, l_aup, l_photo, l_notify_via, l_user_claims_ret, l_user_environment, l_user_department, l_ums_id, l_user_last_activity, l_placcard, l_user_email, l_addr1_std_line1, l_addr1_std_line2, l_addr1_std_city, l_addr1_std_state, l_addr1_std_zip, l_addr1_country, l_addr1_township, l_addr1_room, l_addr1_company, l_addr1_office, l_addr1_phone, l_addr1_dayphone, l_addr1_homephone, l_addr1_workphone, l_addr1_cellphone, l_addr1_email, l_addr1_location, l_addr1_usefor, l_addr1_care_of, l_addr1_known_bad, l_addr1_ums_addrid, l_addr2_std_line1, l_addr2_std_line2, l_addr2_std_city, l_addr2_std_state, l_addr2_std_zip, l_addr2_country, l_addr2_township, l_addr2_room, l_addr2_company, l_addr2_office, l_addr2_phone, l_addr2_dayphone, l_addr2_homephone, l_addr2_workphone, l_addr2_cellphone, l_addr2_email, l_addr2_location, l_addr2_usefor, l_addr2_care_of, l_addr2_known_bad, l_addr2_ums_addrid, l_addr3_std_line1, l_addr3_std_line2, l_addr3_std_city, l_addr3_std_state, l_addr3_std_zip, l_addr3_country, l_addr3_township, l_addr3_room, l_addr3_company, l_addr3_office, l_addr3_phone, l_addr3_dayphone, l_addr3_homephone, l_addr3_workphone, l_addr3_cellphone, l_addr3_email, l_addr3_location, l_addr3_usefor, l_addr3_care_of, l_addr3_known_bad, l_addr3_ums_addrid, l_identific, l_noempl, l_profession, l_program, l_represent, l_userid_active, l_inactive_barcode1, l_inactive_barcode2 ) FROM 'users.tabbed.txt'
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_patron_table(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_age_protect(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_age_protect(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_age_protect'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_age_protect(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_circulate_flag(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_circulate_flag(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output BOOLEAN;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value = ''t'' FROM ' || migration_schema || '.config WHERE key = ''default_item_circulate_flag'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_circulate_flag(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_creator(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_creator(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_creator'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_creator(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_editor(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_editor(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_editor'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_editor(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_fine_level(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_fine_level(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_fine_level'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_fine_level(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_holdable_flag(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_holdable_flag(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output BOOLEAN;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value = ''t'' FROM ' || migration_schema || '.config WHERE key = ''default_item_holdable_flag'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_holdable_flag(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_loan_duration(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_loan_duration(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_loan_duration'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_loan_duration(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_status(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_item_status(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_status'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_status(text) OWNER TO evergreen;

--
-- Name: unicorn_default_net_access_level(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_net_access_level(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_net_access_level'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_net_access_level(text) OWNER TO evergreen;

--
-- Name: unicorn_default_patron_profile(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_patron_profile(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_patron_profile'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_patron_profile(text) OWNER TO evergreen;

--
-- Name: unicorn_default_selection_depth(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_default_selection_depth(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_selection_depth'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_selection_depth(text) OWNER TO evergreen;

--
-- Name: unicorn_hold_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_hold_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''hold_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_hold_table(text) OWNER TO evergreen;

--
-- Name: unicorn_home_location_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_home_location_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''home_location_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_home_location_map(text) OWNER TO evergreen;

--
-- Name: unicorn_init(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_init(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DELETE FROM ' || migration_schema || '.config WHERE key IN ( ''ils_type'', ''item_table'', ''patron_table'', ''circ_table'', ''hold_table'', ''money_table'', ''org_map'', ''profile_map'', ''item_dynamic_field_map'', ''default_patron_profile'', ''default_net_access_level'', ''actor_stat_cat_map'', ''actor_stat_cat_entry_map'', ''default_item_status'', ''default_item_holdable_flag'', ''default_item_circulate_flag'', ''default_item_creator'', ''default_item_editor'', ''default_item_loan_duration'', ''default_item_fine_level'', ''default_item_age_protect'', ''default_selection_depth'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''ils_type'', ''Unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_table'', ''asset_copy_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''patron_table'', ''actor_usr_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''circ_table'', ''action_circulation_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''hold_table'', ''action_hold_request_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''money_table'', ''money_grocery_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_patron_profile'', ''1'' );' ); -- Users
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_net_access_level'', ''2'' );' ); -- Unrestricted
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_status'', ''0'' );' ); -- Available
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_holdable_flag'', ''t'' );' ); -- true
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_circulate_flag'', ''t'' );' ); -- true
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_creator'', ''1'' );' ); -- Admin
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_editor'', ''1'' );' ); -- Admin
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_fine_level'', ''1'' );' ); -- Normal
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_loan_duration'', ''1'' );' ); -- Normal
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_age_protect'', NULL );' ); -- none
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_selection_depth'', ''0'' );' ); -- Consortium
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.org_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.org_map ( 
            id SERIAL,
            org_id INTEGER, 
            transcribed_shortname TEXT,
            l_library TEXT UNIQUE NOT NULL, 
            patron_rebarcode_offset BIGINT NOT NULL DEFAULT 0, 
            item_rebarcode_offset BIGINT NOT NULL DEFAULT 0,
            default_circ_staff INTEGER NOT NULL DEFAULT 1 
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''org_map'', ''org_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.profile_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.profile_map ( 
            id SERIAL,
            perm_grp_id INTEGER,
            transcribed_perm_group TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''profile_map'', ''profile_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.home_location_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.home_location_map ( 
            id SERIAL,
            location INTEGER,
            holdable BOOLEAN NOT NULL DEFAULT TRUE,
            hold_verify BOOLEAN NOT NULL DEFAULT FALSE,
            opac_visible BOOLEAN NOT NULL DEFAULT TRUE,
            circulate BOOLEAN NOT NULL DEFAULT TRUE,
            transcribed_location TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf1_idx ON ' || migration_schema || '.home_location_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf2_idx ON ' || migration_schema || '.home_location_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf3_idx ON ' || migration_schema || '.home_location_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_loc_idx ON ' || migration_schema || '.home_location_map (transcribed_location);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''home_location_map'', ''home_location_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.item_dynamic_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.item_dynamic_field_map ( 
            id SERIAL,
            evergreen_field TEXT,
            evergreen_value TEXT,
            evergreen_datatype TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf1_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf2_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf3_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_dynamic_field_map'', ''item_dynamic_field_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.card_collisions;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.card_collisions ( 
            id SERIAL,
            reason TEXT,
            usr INTEGER,
            barcode TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''card_collisions'', ''card_collisions'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_stat_cat_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_stat_cat_map ( 
            id SERIAL,
            stat_cat INTEGER,
            org_id INTEGER,
            l_library TEXT,
            name TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''actor_stat_cat_map'', ''actor_stat_cat_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_stat_cat_entry_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_stat_cat_entry_map ( 
            id SERIAL,
            stat_cat INTEGER,
            stat_cat_entry INTEGER,
            org_id INTEGER,
            l_library TEXT,
            name TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            entry TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''actor_stat_cat_entry_map'', ''actor_stat_cat_entry_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.item_key_barcode_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.item_key_barcode_map ( 
            key1 text,
            key2 text,
            key3 text,
            barcode text
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_key_barcode_map_idx ON ' || migration_schema || '.item_key_barcode_map (key1,key2,key3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_key_barcode_map'', ''item_key_barcode_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.user_key_barcode_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.user_key_barcode_map ( 
            key text,
            barcode text
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_user_key_barcode_map_idx ON ' || migration_schema || '.user_key_barcode_map (key);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''user_key_barcode_map'', ''user_key_barcode_map'' );' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_init'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_init'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_init(text) OWNER TO evergreen;

--
-- Name: unicorn_item_dynamic_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_item_dynamic_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_dynamic_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_dynamic_field_map(text) OWNER TO evergreen;

--
-- Name: unicorn_item_key_barcode_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_item_key_barcode_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_key_barcode_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_key_barcode_map(text) OWNER TO evergreen;

--
-- Name: unicorn_item_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_item_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_table(text) OWNER TO evergreen;

--
-- Name: unicorn_make_address(text, integer, text, text, text, text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_make_address(text, integer, text, text, text, text, text, text, text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        au_id ALIAS FOR $2;
        line1 ALIAS FOR $3;
        line2 ALIAS FOR $4;
        care_of ALIAS FOR $5;
        city ALIAS FOR $6;
        state ALIAS FOR $7;
        zip ALIAS FOR $8;
        label ALIAS FOR $9;
        _street1 TEXT := ''; _street2 TEXT := ''; _city TEXT := ''; _county TEXT := ''; _state TEXT := ''; _country TEXT := ''; _post_code TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.country_code(migration_schema) INTO _country;
        _street1 := BTRIM(line1);
        _street2 := BTRIM(line2) || CASE WHEN line2 <> '' AND care_of <> '' THEN ' ' ELSE '' END || CASE WHEN care_of <> '' THEN 'Care Of: ' || BTRIM(care_of) ELSE '' END;
        _city := BTRIM(city);
        _state := BTRIM(state);
        _post_code := BTRIM(zip);
        IF _street1 = '' AND _street2 = '' AND _city = '' AND _state = '' AND _post_code = '' THEN
            RETURN NULL;
        END IF;
        PERFORM migration_tools.exec($1, '
            INSERT INTO ' || migration_schema || E'.actor_usr_address ( address_type, usr, street1, street2, city, county, state, country, post_code ) VALUES ( 
                COALESCE( NULLIF(' || quote_literal(label) || E',''''),''Legacy Address''), 
                ' || quote_literal(au_id) || E', 
                ' || quote_literal(_street1) || E', 
                ' || quote_literal(_street2) || E', 
                ' || quote_literal(_city) || E', 
                ' || quote_literal(_county) || E', 
                ' || quote_literal(_state) || E', 
                ' || quote_literal(_country) || E', 
                ' || quote_literal(_post_code) || E' 
            );
        ');
        EXECUTE 'SELECT max(id) AS a FROM ' || migration_schema || E'.actor_usr_address;' INTO output;
        RETURN output.a;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_make_address(text, integer, text, text, text, text, text, text, text) OWNER TO evergreen;

--
-- Name: unicorn_make_card(text, integer, text, boolean); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_make_card(text, integer, text, boolean) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        au_id ALIAS FOR $2;
        barcode ALIAS FOR $3;
        barcode_valid ALIAS FOR $4;
        card_collisions_table TEXT;
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_card_collisions_table(migration_schema) INTO STRICT card_collisions_table;
        IF barcode = '' THEN
            RETURN NULL;
        END IF;
        IF LENGTH(barcode) <> 0 THEN
            EXECUTE 'SELECT id FROM ' || migration_schema || E'.actor_card WHERE barcode = ' || quote_literal(barcode) || ';' INTO output;
            IF output.id IS NULL THEN

                EXECUTE 'SELECT id FROM actor.card WHERE barcode = ' || quote_literal(barcode) || ';' INTO output;
                IF output.id IS NULL THEN
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                            ' || (au_id) || E',
                            ' || quote_literal(barcode) || E',
                            ' || CASE WHEN barcode_valid THEN 'true' ELSE 'false' END || E'
                        );
                    ');
                ELSE
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || card_collisions_table || E' ( reason, usr, barcode ) VALUES (
                            ''collision with incumbent barcode'',
                            ' || quote_literal(au_id) || E',
                            ' || quote_literal(barcode) || E'
                        );
                    ');
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                            ' || (au_id) || E',
                            ' || quote_literal('coll1_usr_id_'||au_id) || E',
                            ' || CASE WHEN barcode_valid THEN 'true' ELSE 'false' END || E'
                        );
                    ');
                END IF;

            ELSE
                PERFORM migration_tools.exec($1, '
                    INSERT INTO ' || card_collisions_table || E' ( reason, usr, barcode ) VALUES (
                        ''collision with another barcode in same dataset'',
                        ' || quote_literal(au_id) || E',
                        ' || quote_literal(barcode) || E'
                    );
                ');
                PERFORM migration_tools.exec($1, '
                    INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                        ' || (au_id) || E',
                        ' || quote_literal('coll2_usr_id_'||au_id) || E',
                        false
                    );
                ');
            END IF;
        END IF;
        EXECUTE 'SELECT MIN(id) AS a FROM ' || migration_schema || '.actor_card WHERE usr = ' || quote_literal(au_id) || ';' INTO output;
        RETURN output.a;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_make_card(text, integer, text, boolean) OWNER TO evergreen;

--
-- Name: unicorn_money_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_money_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''money_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_money_table(text) OWNER TO evergreen;

--
-- Name: unicorn_org_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_org_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''org_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_org_map(text) OWNER TO evergreen;

--
-- Name: unicorn_patron_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_patron_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''patron_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_patron_table(text) OWNER TO evergreen;

--
-- Name: unicorn_profile_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_profile_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''profile_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_profile_map(text) OWNER TO evergreen;

--
-- Name: unicorn_user_key_barcode_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION unicorn_user_key_barcode_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''user_key_barcode_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_user_key_barcode_map(text) OWNER TO evergreen;

--
-- Name: zip_to_city_state_county(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION zip_to_city_state_county(text) RETURNS text[]
    LANGUAGE plperlu STABLE
    AS $_X$

	my $input = $_[0];
	my %zipdata;

	open (FH, '<', '/openils/var/data/zips.txt') or return ('No File Found', 'No File Found', 'No File Found');

	while (<FH>) {
		chomp;
		my ($junk, $state, $city, $zip, $foo, $bar, $county, $baz, $morejunk) = split(/\|/);
		$zipdata{$zip} = [$city, $state, $county];
	}

	if (defined $zipdata{$input}) {
		my ($city, $state, $county) = @{$zipdata{$input}};
		return [$city, $state, $county];
	} elsif (defined $zipdata{substr $input, 0, 5}) {
		my ($city, $state, $county) = @{$zipdata{substr $input, 0, 5}};
		return [$city, $state, $county];
	} else {
		return ['ZIP not found', 'ZIP not found', 'ZIP not found'];
	}
  
$_X$;


ALTER FUNCTION migration_tools.zip_to_city_state_county(text) OWNER TO evergreen;

SET search_path = money, pg_catalog;

--
-- Name: mat_summary_create(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION mat_summary_create() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	INSERT INTO money.materialized_billable_xact_summary (id, usr, xact_start, xact_finish, total_paid, total_owed, balance_owed, xact_type)
		VALUES ( NEW.id, NEW.usr, NEW.xact_start, NEW.xact_finish, 0.0, 0.0, 0.0, TG_ARGV[0]);
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_create() OWNER TO evergreen;

--
-- Name: mat_summary_delete(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION mat_summary_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	DELETE FROM money.materialized_billable_xact_summary WHERE id = OLD.id;
	RETURN OLD;
END;
$$;


ALTER FUNCTION money.mat_summary_delete() OWNER TO evergreen;

--
-- Name: mat_summary_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION mat_summary_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE	money.materialized_billable_xact_summary
	  SET	usr = NEW.usr,
		xact_start = NEW.xact_start,
		xact_finish = NEW.xact_finish
	  WHERE	id = NEW.id;
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_update() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_add(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_billing_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = COALESCE(total_owed, 0.0::numeric) + NEW.amount,
			last_billing_ts = NEW.billing_ts,
			last_billing_note = NEW.note,
			last_billing_type = NEW.billing_type,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_add() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_del(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_billing_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	prev_billing	money.billing%ROWTYPE;
	old_billing	money.billing%ROWTYPE;
BEGIN
	SELECT * INTO prev_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1 OFFSET 1;
	SELECT * INTO old_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;

	IF OLD.id = old_billing.id THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	last_billing_ts = prev_billing.billing_ts,
			last_billing_note = prev_billing.note,
			last_billing_type = prev_billing.billing_type
		  WHERE	id = OLD.xact;
	END IF;

	IF NOT OLD.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - OLD.amount,
			balance_owed = balance_owed + OLD.amount
		  WHERE	id = OLD.xact;
	END IF;

	RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_del() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_billing_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_billing	money.billing%ROWTYPE;
	old_voided	money.billing%ROWTYPE;
BEGIN

	SELECT * INTO old_billing FROM money.billing WHERE xact = NEW.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.billing WHERE xact = NEW.xact ORDER BY billing_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_billing.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed + NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - (OLD.amount - NEW.amount),
			balance_owed = balance_owed - (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_update() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_add(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_payment_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = COALESCE(total_paid, 0.0::numeric) + NEW.amount,
			last_payment_ts = NEW.payment_ts,
			last_payment_note = NEW.note,
			last_payment_type = TG_ARGV[0],
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_add() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_del(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_payment_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	prev_payment	money.payment_view%ROWTYPE;
	old_payment	money.payment_view%ROWTYPE;
BEGIN
	SELECT * INTO prev_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1 OFFSET 1;
	SELECT * INTO old_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;

	IF OLD.id = old_payment.id THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	last_payment_ts = prev_payment.payment_ts,
			last_payment_note = prev_payment.note,
			last_payment_type = prev_payment.payment_type
		  WHERE	id = OLD.xact;
	END IF;

	IF NOT OLD.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - OLD.amount,
			balance_owed = balance_owed + OLD.amount
		  WHERE	id = OLD.xact;
	END IF;

	RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_del() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION materialized_summary_payment_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_payment	money.payment_view%ROWTYPE;
	old_voided	money.payment_view%ROWTYPE;
BEGIN

	SELECT * INTO old_payment FROM money.payment_view WHERE xact = NEW.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.payment_view WHERE xact = NEW.xact ORDER BY payment_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_payment.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid + NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - (OLD.amount - NEW.amount),
			balance_owed = balance_owed + (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_update() OWNER TO evergreen;

SET search_path = permission, pg_catalog;

--
-- Name: grp_tree; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE grp_tree (
    id integer NOT NULL,
    name text NOT NULL,
    parent integer,
    usergroup boolean DEFAULT true NOT NULL,
    perm_interval interval DEFAULT '3 years'::interval NOT NULL,
    description text,
    application_perm text,
    hold_priority integer DEFAULT 0 NOT NULL
);


ALTER TABLE permission.grp_tree OWNER TO evergreen;

--
-- Name: grp_ancestors(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION grp_ancestors(integer) RETURNS SETOF grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	a.*
	FROM	connectby('permission.grp_tree'::text,'parent'::text,'id'::text,'name'::text,$1::text,100,'.'::text)
			AS t(keyid text, parent_keyid text, level int, branch text,pos int)
		JOIN permission.grp_tree a ON a.id::text = t.keyid::text
	ORDER BY
		CASE WHEN a.parent IS NULL
			THEN 0
			ELSE 1
		END, a.name;
$_$;


ALTER FUNCTION permission.grp_ancestors(integer) OWNER TO evergreen;

--
-- Name: grp_ancestors_distance(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION grp_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.parent, gad.distance+1
            FROM permission.grp_tree pgt JOIN grp_ancestors_distance gad ON pgt.id = gad.id
            WHERE pgt.parent IS NOT NULL
    )
    SELECT * FROM grp_ancestors_distance;
$_$;


ALTER FUNCTION permission.grp_ancestors_distance(integer) OWNER TO evergreen;

--
-- Name: grp_descendants_distance(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION grp_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.id, gdd.distance+1
            FROM permission.grp_tree pgt JOIN grp_descendants_distance gdd ON pgt.parent = gdd.id
    )
    SELECT * FROM grp_descendants_distance;
$_$;


ALTER FUNCTION permission.grp_descendants_distance(integer) OWNER TO evergreen;

--
-- Name: usr_can_grant_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_can_grant_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	(l.code = tperm AND p.grantable IS TRUE)
		LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_can_grant_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_home_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_home_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1 LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_home_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_object_perm(integer, text, text, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_object_perm(integer, text, text, text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT permission.usr_has_object_perm( $1, $2, $3, $4, -1 );
$_$;


ALTER FUNCTION permission.usr_has_object_perm(integer, text, text, text) OWNER TO evergreen;

--
-- Name: usr_has_object_perm(integer, text, text, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	res     BOOL;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	SELECT TRUE INTO res FROM permission.usr_object_perm_map WHERE usr = r_usr.id AND object_type = obj_type AND object_id = obj_id;

	IF FOUND THEN
		RETURN TRUE;
	END IF;

	IF target_ou > -1 THEN
		RETURN permission.usr_has_perm( iuser, tperm, target_ou);
	END IF;

	RETURN FALSE;

END;
$$;


ALTER FUNCTION permission.usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_perm(integer, text, integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
	SELECT	CASE
			WHEN permission.usr_has_home_perm( $1, $2, $3 ) THEN TRUE
			WHEN permission.usr_has_work_perm( $1, $2, $3 ) THEN TRUE
			ELSE FALSE
		END;
$_$;


ALTER FUNCTION permission.usr_has_perm(integer, text, integer) OWNER TO evergreen;

--
-- Name: usr_has_perm_at(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_perm_at(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_all(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_perm_at_all(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_all_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at_all(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_all_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_perm_at_all_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted either directly or through inheritance from a parent
-- org unit.
--
-- The permissions apply to a minimum depth of the org unit hierarchy, and
-- to the subordinates of those org units, for the org unit(s) to which the
-- user is assigned.
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- assigns users to org units.  I.e. we ignore the home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	n_head_ou     INTEGER;
	n_child_ou    INTEGER;
BEGIN
	FOR n_head_ou IN
		SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( user_id, perm_code )
	LOOP
		--
		-- The permission applies only at a depth greater than the work org unit.
		-- Use connectby() to find all dependent org units at the specified depth.
		--
		FOR n_child_ou IN
			SELECT ou::INTEGER
			FROM connectby( 
					'actor.org_unit',   -- table name
					'id',               -- key column
					'parent_ou',        -- recursive foreign key
					n_head_ou::TEXT,    -- id of starting point
					0                   -- no limit on search depth
				)
				AS t(
					ou text,            -- dependent org unit
					parent_ou text,     -- (ignore)
					level int           -- (ignore)
				)
		LOOP
			RETURN NEXT n_child_ou;
		END LOOP;
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_all_nd(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_perm_at_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted directly (not through inheritance from a parent
-- org unit).
--
-- The permissions apply to a minimum depth of the org unit hierarchy,
-- for the org unit(s) to which the user is assigned.  (They also apply
-- to the subordinates of those org units, but we don't report the
-- subordinates here.)
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- defines which users belong to which org units.  I.e. we ignore the
-- home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	b_super       BOOLEAN;
	n_perm        INTEGER;
	n_min_depth   INTEGER; 
	n_work_ou     INTEGER;
	n_curr_ou     INTEGER;
	n_depth       INTEGER;
	n_curr_depth  INTEGER;
BEGIN
	--
	-- Check for superuser
	--
	SELECT INTO b_super
		super_user
	FROM
		actor.usr
	WHERE
		id = user_id;
	--
	IF NOT FOUND THEN
		return;				-- No user?  No permissions.
	ELSIF b_super THEN
		--
		-- Super user has all permissions everywhere
		--
		FOR n_work_ou IN
			SELECT
				id
			FROM
				actor.org_unit
			WHERE
				parent_ou IS NULL
		LOOP
			RETURN NEXT n_work_ou; 
		END LOOP;
		RETURN;
	END IF;
	--
	-- Translate the permission name
	-- to a numeric permission id
	--
	SELECT INTO n_perm
		id
	FROM
		permission.perm_list
	WHERE
		code = perm_code;
	--
	IF NOT FOUND THEN
		RETURN;               -- No such permission
	END IF;
	--
	-- Find the highest-level org unit (i.e. the minimum depth)
	-- to which the permission is applied for this user
	--
	-- This query is modified from the one in permission.usr_perms().
	--
	SELECT INTO n_min_depth
		min( depth )
	FROM	(
		SELECT depth 
		  FROM permission.usr_perm_map upm
		 WHERE upm.usr = user_id 
		   AND (upm.perm = n_perm OR upm.perm = -1)
       				UNION
		SELECT	gpm.depth
		  FROM	permission.grp_perm_map gpm
		  WHERE	(gpm.perm = n_perm OR gpm.perm = -1)
	        AND gpm.grp IN (
	 		   SELECT	(permission.grp_ancestors(
					(SELECT profile FROM actor.usr WHERE id = user_id)
				)).id
			)
       				UNION
		SELECT	p.depth
		  FROM	permission.grp_perm_map p 
		  WHERE (p.perm = n_perm OR p.perm = -1)
		    AND p.grp IN (
		  		SELECT (permission.grp_ancestors(m.grp)).id 
				FROM   permission.usr_grp_map m
				WHERE  m.usr = user_id
			)
	) AS x;
	--
	IF NOT FOUND THEN
		RETURN;                -- No such permission for this user
	END IF;
	--
	-- Identify the org units to which the user is assigned.  Note that
	-- we pay no attention to the home_ou column in actor.usr.
	--
	FOR n_work_ou IN
		SELECT
			work_ou
		FROM
			permission.usr_work_ou_map
		WHERE
			usr = user_id
	LOOP            -- For each org unit to which the user is assigned
		--
		-- Determine the level of the org unit by a lookup in actor.org_unit_type.
		-- We take it on faith that this depth agrees with the actual hierarchy
		-- defined in actor.org_unit.
		--
		SELECT INTO n_depth
		    type.depth
		FROM
		    actor.org_unit_type type
		        INNER JOIN actor.org_unit ou
		            ON ( ou.ou_type = type.id )
		WHERE
		    ou.id = n_work_ou;
		--
		IF NOT FOUND THEN
			CONTINUE;        -- Maybe raise exception?
		END IF;
		--
		-- Compare the depth of the work org unit to the
		-- minimum depth, and branch accordingly
		--
		IF n_depth = n_min_depth THEN
			--
			-- The org unit is at the right depth, so return it.
			--
			RETURN NEXT n_work_ou;
		ELSIF n_depth > n_min_depth THEN
			--
			-- Traverse the org unit tree toward the root,
			-- until you reach the minimum depth determined above
			--
			n_curr_depth := n_depth;
			n_curr_ou := n_work_ou;
			WHILE n_curr_depth > n_min_depth LOOP
				SELECT INTO n_curr_ou
					parent_ou
				FROM
					actor.org_unit
				WHERE
					id = n_curr_ou;
				--
				IF FOUND THEN
					n_curr_depth := n_curr_depth - 1;
				ELSE
					--
					-- This can happen only if the hierarchy defined in
					-- actor.org_unit is corrupted, or out of sync with
					-- the depths defined in actor.org_unit_type.
					-- Maybe we should raise an exception here, instead
					-- of silently ignoring the problem.
					--
					n_curr_ou = NULL;
					EXIT;
				END IF;
			END LOOP;
			--
			IF n_curr_ou IS NOT NULL THEN
				RETURN NEXT n_curr_ou;
			END IF;
		ELSE
			--
			-- The permission applies only at a depth greater than the work org unit.
			-- Use connectby() to find all dependent org units at the specified depth.
			--
			FOR n_curr_ou IN
				SELECT ou::INTEGER
				FROM connectby( 
						'actor.org_unit',         -- table name
						'id',                     -- key column
						'parent_ou',              -- recursive foreign key
						n_work_ou::TEXT,          -- id of starting point
						(n_min_depth - n_depth)   -- max depth to search, relative
					)                             --   to starting point
					AS t(
						ou text,            -- dependent org unit
						parent_ou text,     -- (ignore)
						level int           -- depth relative to starting point
					)
				WHERE
					level = n_min_depth - n_depth
			LOOP
				RETURN NEXT n_curr_ou;
			END LOOP;
		END IF;
		--
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_nd(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_work_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_has_work_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_woum	permission.usr_work_ou_map%ROWTYPE;
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1
		LOOP

		FOR r_woum IN	SELECT	*
				  FROM	permission.usr_work_ou_map
				  WHERE	usr = iuser
			LOOP

			PERFORM	*
			  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
			  WHERE	id = r_woum.work_ou;

			IF FOUND THEN
				RETURN TRUE;
			END IF;

		END LOOP;

	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_work_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_perm_map; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_perm_map OWNER TO evergreen;

--
-- Name: usr_perms(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION usr_perms(integer) RETURNS SETOF usr_perm_map
    LANGUAGE sql STABLE ROWS 10
    AS $_$
	SELECT	DISTINCT ON (usr,perm) *
	  FROM	(
			(SELECT * FROM permission.usr_perm_map WHERE usr = $1)
        				UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p
			  WHERE	p.grp IN (
			  	SELECT	(permission.grp_ancestors(
						(SELECT profile FROM actor.usr WHERE id = $1)
					)).id
				)
			)
        				UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p 
			  WHERE	p.grp IN (SELECT (permission.grp_ancestors(m.grp)).id FROM permission.usr_grp_map m WHERE usr = $1))
		) AS x
	  ORDER BY 2, 3, 1 DESC, 5 DESC ;
$_$;


ALTER FUNCTION permission.usr_perms(integer) OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: akeys(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION akeys(hstore) RETURNS text[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_akeys';


ALTER FUNCTION public.akeys(hstore) OWNER TO evergreen;

--
-- Name: approximate_date(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION approximate_date(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'\\D', $2, 'g' );
$_$;


ALTER FUNCTION public.approximate_date(text, text) OWNER TO evergreen;

--
-- Name: approximate_high_date(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION approximate_high_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '9');
$_$;


ALTER FUNCTION public.approximate_high_date(text) OWNER TO evergreen;

--
-- Name: approximate_low_date(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION approximate_low_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '0');
$_$;


ALTER FUNCTION public.approximate_low_date(text) OWNER TO evergreen;

--
-- Name: auth_n_bib_generator(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION auth_n_bib_generator(auth_heading text) RETURNS auth_n_bib
    LANGUAGE plpgsql
    AS $_$
DECLARE
    auth_n_bib_data	auth_n_bib;
    temp_bibs		BIGINT[] := '{}';
    temp_afr		authority.full_rec%ROWTYPE;
    sub_tag		TEXT;
BEGIN
    -- ver 0.3

    -- Add % to end to take into consideration additonal characters like '.' and date ($d).
    -- This may get us more bibs then wanted but will a little more is better than missing some.
    auth_heading := auth_heading || '%';

    -- Get the auth record full rec for the given auth heading
    SELECT * INTO temp_afr FROM authority.full_rec WHERE value ILIKE auth_heading AND tag LIKE '1__' AND subfield LIKE 'a';

    --------- PRIMARY AUTH RECORD ---------
    -- Set the primary auth record id
    auth_n_bib_data.primary_auth := temp_afr.record;

    -- Get all bib record id's associated with the primary auth record
    SELECT * INTO auth_n_bib_data.bibs FROM public.generate_bibs_associated_to_auth_heading(temp_afr.tag, auth_heading);

    --------- LINKED AUTH RECORDS ---------
    -- Loop for getting all linked auth record id's and their associated bib record id's
    FOR temp_afr IN SELECT afr2.* FROM authority.full_rec AS afr1 JOIN authority.full_rec AS afr2 ON afr1.record = afr2.record WHERE afr1.value ILIKE auth_heading AND afr1.tag LIKE '5__' AND afr2.tag LIKE '1__' AND afr2.subfield LIKE 'a' LOOP
        -- Add auth record id to the list
        auth_n_bib_data.auths := array_append(auth_n_bib_data.auths, temp_afr.record);

        -- Add linked bib id's to the list
        SELECT * INTO temp_bibs FROM public.generate_bibs_associated_to_auth_heading(temp_afr.tag, temp_afr.value);
        SELECT INTO auth_n_bib_data.bibs ARRAY( SELECT unnest(auth_n_bib_data.bibs) AS e UNION SELECT unnest(temp_bibs) AS e ORDER BY e);
    END LOOP;

    RETURN auth_n_bib_data;
END;
$_$;


ALTER FUNCTION public.auth_n_bib_generator(auth_heading text) OWNER TO evergreen;

--
-- Name: avals(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION avals(hstore) RETURNS text[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_avals';


ALTER FUNCTION public.avals(hstore) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, ean13) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, isbn13) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, ismn13) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, issn13) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, isbn) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, ismn) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, issn) OWNER TO evergreen;

--
-- Name: btean13cmp(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btean13cmp(ean13, upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(ean13, upc) OWNER TO evergreen;

--
-- Name: btisbn13cmp(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbn13cmp(isbn13, isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: btisbn13cmp(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbn13cmp(isbn13, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(isbn13, ean13) OWNER TO evergreen;

--
-- Name: btisbn13cmp(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbn13cmp(isbn13, isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(isbn13, isbn) OWNER TO evergreen;

--
-- Name: btisbncmp(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbncmp(isbn, isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(isbn, isbn) OWNER TO evergreen;

--
-- Name: btisbncmp(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbncmp(isbn, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(isbn, ean13) OWNER TO evergreen;

--
-- Name: btisbncmp(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btisbncmp(isbn, isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(isbn, isbn13) OWNER TO evergreen;

--
-- Name: btismn13cmp(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismn13cmp(ismn13, ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: btismn13cmp(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismn13cmp(ismn13, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(ismn13, ean13) OWNER TO evergreen;

--
-- Name: btismn13cmp(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismn13cmp(ismn13, ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(ismn13, ismn) OWNER TO evergreen;

--
-- Name: btismncmp(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismncmp(ismn, ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(ismn, ismn) OWNER TO evergreen;

--
-- Name: btismncmp(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismncmp(ismn, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(ismn, ean13) OWNER TO evergreen;

--
-- Name: btismncmp(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btismncmp(ismn, ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(ismn, ismn13) OWNER TO evergreen;

--
-- Name: btissn13cmp(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissn13cmp(issn13, issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(issn13, issn13) OWNER TO evergreen;

--
-- Name: btissn13cmp(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissn13cmp(issn13, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(issn13, ean13) OWNER TO evergreen;

--
-- Name: btissn13cmp(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissn13cmp(issn13, issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(issn13, issn) OWNER TO evergreen;

--
-- Name: btissncmp(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissncmp(issn, issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(issn, issn) OWNER TO evergreen;

--
-- Name: btissncmp(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissncmp(issn, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(issn, ean13) OWNER TO evergreen;

--
-- Name: btissncmp(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btissncmp(issn, issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(issn, issn13) OWNER TO evergreen;

--
-- Name: btupccmp(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btupccmp(upc, upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btupccmp(upc, upc) OWNER TO evergreen;

--
-- Name: btupccmp(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION btupccmp(upc, ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btupccmp(upc, ean13) OWNER TO evergreen;

--
-- Name: call_number_dewey(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION call_number_dewey(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
	my $txt = shift;
	$txt =~ s/^\s+//o;
	$txt =~ s/[\[\]\{\}\(\)`'"#<>\*\?\-\+\$\\]+//og;
	$txt =~ s/\s+$//o;
	if ($txt =~ /(\d{3}(?:\.\d+)?)/o) {
		return $1;
	} else {
		return (split /\s+/, $txt)[0];
	}
$_$;


ALTER FUNCTION public.call_number_dewey(text) OWNER TO evergreen;

--
-- Name: call_number_dewey(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION call_number_dewey(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT SUBSTRING(call_number_dewey($1) FROM 1 FOR $2);
$_$;


ALTER FUNCTION public.call_number_dewey(text, integer) OWNER TO evergreen;

--
-- Name: cleanup_acq_marc(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION cleanup_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		DELETE FROM acq.lineitem_attr
	    		WHERE lineitem = OLD.id AND attr_type IN ('lineitem_provider_attr_definition', 'lineitem_marc_attr_definition','lineitem_generated_attr_definition');
		RETURN NEW;
	ELSE
		DELETE FROM acq.lineitem_attr WHERE lineitem = OLD.id;
		RETURN OLD;
	END IF;
END;
$$;


ALTER FUNCTION public.cleanup_acq_marc() OWNER TO evergreen;

--
-- Name: connectby(text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: content_or_null(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION content_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\s*$' THEN NULL ELSE $1 END
$_$;


ALTER FUNCTION public.content_or_null(text) OWNER TO evergreen;

--
-- Name: crosstab(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text) OWNER TO postgres;

--
-- Name: crosstab(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text, integer) OWNER TO postgres;

--
-- Name: crosstab(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab_hash';


ALTER FUNCTION public.crosstab(text, text) OWNER TO postgres;

--
-- Name: crosstab2(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab2(text) RETURNS SETOF tablefunc_crosstab_2
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab2(text) OWNER TO postgres;

--
-- Name: crosstab3(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab3(text) RETURNS SETOF tablefunc_crosstab_3
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab3(text) OWNER TO postgres;

--
-- Name: crosstab4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab4(text) RETURNS SETOF tablefunc_crosstab_4
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab4(text) OWNER TO postgres;

--
-- Name: defined(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION defined(hstore, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_defined';


ALTER FUNCTION public.defined(hstore, text) OWNER TO evergreen;

--
-- Name: delete(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION delete(hstore, text) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_delete';


ALTER FUNCTION public.delete(hstore, text) OWNER TO evergreen;

--
-- Name: delete(hstore, text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION delete(hstore, text[]) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_delete_array';


ALTER FUNCTION public.delete(hstore, text[]) OWNER TO evergreen;

--
-- Name: delete(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION delete(hstore, hstore) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_delete_hstore';


ALTER FUNCTION public.delete(hstore, hstore) OWNER TO evergreen;

--
-- Name: each(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION each(hs hstore, OUT key text, OUT value text) RETURNS SETOF record
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_each';


ALTER FUNCTION public.each(hs hstore, OUT key text, OUT value text) OWNER TO evergreen;

--
-- Name: entityize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION entityize(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFC(shift);
    $x =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;
    return $x;

$_$;


ALTER FUNCTION public.entityize(text) OWNER TO evergreen;

--
-- Name: exist(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION exist(hstore, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_exists';


ALTER FUNCTION public.exist(hstore, text) OWNER TO evergreen;

--
-- Name: exists_all(hstore, text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION exists_all(hstore, text[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_exists_all';


ALTER FUNCTION public.exists_all(hstore, text[]) OWNER TO evergreen;

--
-- Name: exists_any(hstore, text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION exists_any(hstore, text[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_exists_any';


ALTER FUNCTION public.exists_any(hstore, text[]) OWNER TO evergreen;

--
-- Name: explode_array(anyarray); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION explode_array(anyarray) RETURNS SETOF anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT ($1)[s] FROM generate_series(1, array_upper($1, 1)) AS s;
$_$;


ALTER FUNCTION public.explode_array(anyarray) OWNER TO evergreen;

--
-- Name: export_generate_ids(date, date); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_generate_ids(start_date date, end_date date) RETURNS SETOF bigint
    LANGUAGE sql STABLE
    AS $$
-- Generates a list of ids for exporting based on the following criteria
-- For a record to be exported it MUST MEET ALL of the following conditions
-- 1.The record must have at least one LDR field and byte 05 of every instance of that field must not be d.
-- AND
-- 2. The record must have at least one 001 field and at least one of those fields should contain oc
--        OR has at least one 035 field with "WaOLN" in subfield "a"
-- AND
-- 3. The record must have at least one of the following fields 086 or 092 or 099 and every instance of each of these fields must not contain ON ORDER
-- AND
-- 4. The record must have items attached OR the record must have at least one 998 field with subfield d that has one of the following values d or t or v or w or x or y or 1
-- AND
-- 5. The records Cat Date must fall between two dates supplied by the user.


     SELECT id
     FROM biblio.record_entry
     WHERE public.export_ids_cat_date(id, start_date, end_date) AND public.export_ids_LDR(id) AND public.export_ids_001(id) 
     AND public.export_ids_086_092_099(id) AND public.export_ids_998(id);
    
     
$$;


ALTER FUNCTION public.export_generate_ids(start_date date, end_date date) OWNER TO evergreen;

--
-- Name: export_ids_001(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_001(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if the record has at least one 001 field and at least one of those fields should contain oc
-- OR has at least one 035 field with "WaOLN" in subfield "a"
DECLARE
  v_row_count BIGINT;
BEGIN

  SELECT count(*) INTO v_row_count
  FROM metabib.real_full_rec
  WHERE ((tag = '001' AND (value ILIKE 'oc%' OR value ILIKE 'on%' OR value ILIKE 'wln%')) 
        OR (tag = '035' AND subfield ILIKE 'a' AND value ILIKE '%WaOLN%'))
        AND record = record_to_check;

  IF v_row_count > 0 THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
    
END $$;


ALTER FUNCTION public.export_ids_001(record_to_check bigint) OWNER TO evergreen;

--
-- Name: export_ids_086_092_099(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_086_092_099(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has at least one of the following fields 086 or 092 or 099 and every instance 
-- of each of these fields must not contain ON ORDER
DECLARE
  v_row_count BIGINT;
BEGIN

  SELECT count(*) INTO v_row_count
  FROM metabib.real_full_rec
  WHERE (tag = '086' OR tag = '092' OR tag = '099') AND value ILIKE '%on order%' AND record = record_to_check;

  IF v_row_count > 0 THEN
     RETURN FALSE;
  END IF;
  
  SELECT count(*) INTO v_row_count
  FROM metabib.real_full_rec
  WHERE (tag = '086' OR tag = '092' OR tag = '099') AND value NOT ILIKE '%on order%' AND record = record_to_check;

  IF v_row_count > 0 THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
    
END $$;


ALTER FUNCTION public.export_ids_086_092_099(record_to_check bigint) OWNER TO evergreen;

--
-- Name: export_ids_998(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_998(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has items attached OR the record must have at least one 998 field with subfield d that has 
-- one of the following values d or t or v or w or x or y or 1
DECLARE
  v_row_count BIGINT;
BEGIN

  SELECT count(*) INTO v_row_count
  FROM metabib.real_full_rec
  WHERE tag = '998' 
    AND subfield = 'd' 
    AND value IN ('d','t','v','w','x','y','1') 
    AND record = record_to_check;

  IF v_row_count > 0 OR public.export_ids_has_copy(record_to_check) THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
    
END $$;


ALTER FUNCTION public.export_ids_998(record_to_check bigint) OWNER TO evergreen;

--
-- Name: export_ids_cat_date(bigint, date, date); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_cat_date(record_to_check bigint, start_date date, end_date date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has a Cat Date that falls between start_date and end_date inclusive.
DECLARE
  v_cat_date TIMESTAMP WITH TIME ZONE;
BEGIN

  IF start_date IS NULL OR end_date IS NULL THEN
    RETURN TRUE;
  ELSE
    SELECT cataloging_date INTO v_cat_date
    FROM biblio.record_entry
    WHERE id = record_to_check;

    IF  v_cat_date >= start_date AND v_cat_date <= end_date THEN
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END IF;  
END $$;


ALTER FUNCTION public.export_ids_cat_date(record_to_check bigint, start_date date, end_date date) OWNER TO evergreen;

--
-- Name: export_ids_has_copy(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_has_copy(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has a copy attached
DECLARE
  v_row_count BIGINT;
BEGIN

  SELECT count(acp.id) INTO v_row_count
  FROM biblio.record_entry AS bre
  JOIN asset.call_number AS acn
  ON bre.id = acn.record
  JOIN asset.copy AS acp
  ON acn.id = acp.call_number
  WHERE bre.id = record_to_check;
  
  IF v_row_count > 0 THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
    
END $$;


ALTER FUNCTION public.export_ids_has_copy(record_to_check bigint) OWNER TO evergreen;

--
-- Name: export_ids_ldr(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION export_ids_ldr(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has an 'f' in deleted field of biblio.record_entry
DECLARE
  export_bib BOOLEAN;
BEGIN

  SELECT deleted into export_bib
  FROM biblio.record_entry
  WHERE id = record_to_check;

  IF export_bib  = 'f' THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
     
END $$;


ALTER FUNCTION public.export_ids_ldr(record_to_check bigint) OWNER TO evergreen;

--
-- Name: extract_acq_marc_field(bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION extract_acq_marc_field(bigint, text, text) RETURNS text
    LANGUAGE sql
    AS $_$    
    SELECT extract_marc_field('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field(bigint, text, text) OWNER TO evergreen;

--
-- Name: extract_acq_marc_field_set(bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION extract_acq_marc_field_set(bigint, text, text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
	SELECT extract_marc_field_set('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field_set(bigint, text, text) OWNER TO evergreen;

--
-- Name: extract_marc_field(text, bigint, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION extract_marc_field(text, bigint, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT extract_marc_field($1,$2,$3,'');
$_$;


ALTER FUNCTION public.extract_marc_field(text, bigint, text) OWNER TO evergreen;

--
-- Name: extract_marc_field(text, bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION extract_marc_field(text, bigint, text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    query := $q$
        SELECT  regexp_replace(
                    oils_xpath_string(
                        $q$ || quote_literal($3) || $q$,
                        marc,
                        ' '
                    ),
                    $q$ || quote_literal($4) || $q$,
                    '',
                    'g')
          FROM  $q$ || $1 || $q$
          WHERE id = $q$ || $2;

    EXECUTE query INTO output;

    -- RAISE NOTICE 'query: %, output; %', query, output;

    RETURN output;
END;
$_$;


ALTER FUNCTION public.extract_marc_field(text, bigint, text, text) OWNER TO evergreen;

--
-- Name: fetchval(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION fetchval(hstore, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_fetchval';


ALTER FUNCTION public.fetchval(hstore, text) OWNER TO evergreen;

--
-- Name: first5(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION first5(text) RETURNS text
    LANGUAGE sql
    AS $_$
	SELECT SUBSTRING( $1, 1, 5);
$_$;


ALTER FUNCTION public.first5(text) OWNER TO evergreen;

--
-- Name: first_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION first_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT CASE WHEN $1 IS NULL THEN $2 ELSE $1 END;
$_$;


ALTER FUNCTION public.first_agg(anyelement, anyelement) OWNER TO evergreen;

--
-- Name: first_word(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION first_word(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_X$
        SELECT COALESCE(SUBSTRING( $1 FROM $_$^\S+$_$), '');
$_X$;


ALTER FUNCTION public.first_word(text) OWNER TO evergreen;

--
-- Name: force_to_isbn13(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION force_to_isbn13(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # Find the first ISBN, force it to ISBN13 and return it

    my $input = shift;

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, force it to ISBN13 and return it
        return $isbn->as_isbn13->isbn if ($isbn && $isbn->is_valid());
    }
    return undef;
$_$;


ALTER FUNCTION public.force_to_isbn13(text) OWNER TO evergreen;

--
-- Name: FUNCTION force_to_isbn13(text); Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON FUNCTION force_to_isbn13(text) IS '
/*
 * Copyright (C) 2011 Equinox Software
 * Mike Rylander <mrylander@gmail.com>
 *
 * Inspired by translate_isbn1013
 *
 * The force_to_isbn13 function takes an input ISBN and returns the ISBN13
 * version without hypens and with a repaired checksum if the checksum was bad
 */
';


--
-- Name: generate_bibs_associated_to_auth_heading(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION generate_bibs_associated_to_auth_heading(field text, auth_heading text) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    temp_bibs		BIGINT[] := '{}';
BEGIN
    -- ver 0.1

    -- Add % to end to take into consideration additonal characters like '.' and date ($d).
    -- This may get us more bibs then wanted but will a little more is better than missing some.
    auth_heading := auth_heading || '%';

    -- Get all bib record id's associated with the primary auth record
    CASE field
        WHEN '100' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('100', '600', '700', '800');
        WHEN '110' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('110', '610', '710', '810');
        WHEN '111' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('111', '611', '711', '811');
        WHEN '130' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('130', '630', '730', '830');
        WHEN '150' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '650';
        WHEN '151' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '651';
        WHEN '155' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '655';
        ELSE
    END CASE;

    RETURN temp_bibs;
END;
$_$;


ALTER FUNCTION public.generate_bibs_associated_to_auth_heading(field text, auth_heading text) OWNER TO evergreen;

--
-- Name: get_ind(bigint, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION get_ind(source bigint, field integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    ind TEXT := NULL;
    ind_record RECORD;
BEGIN  
    IF field = 6 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '245' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 3 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '240' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 5 THEN
	SELECT ind1 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '130' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 216 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '222' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 227 THEN
	SELECT ind1 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '730' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    END IF;

    return ind;
END;
$$;


ALTER FUNCTION public.get_ind(source bigint, field integer) OWNER TO evergreen;

--
-- Name: ghstore_compress(internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_compress';


ALTER FUNCTION public.ghstore_compress(internal) OWNER TO evergreen;

--
-- Name: ghstore_consistent(internal, internal, integer, oid, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_consistent(internal, internal, integer, oid, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_consistent';


ALTER FUNCTION public.ghstore_consistent(internal, internal, integer, oid, internal) OWNER TO evergreen;

--
-- Name: ghstore_decompress(internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_decompress';


ALTER FUNCTION public.ghstore_decompress(internal) OWNER TO evergreen;

--
-- Name: ghstore_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_penalty';


ALTER FUNCTION public.ghstore_penalty(internal, internal, internal) OWNER TO evergreen;

--
-- Name: ghstore_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_picksplit';


ALTER FUNCTION public.ghstore_picksplit(internal, internal) OWNER TO evergreen;

--
-- Name: ghstore_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_same';


ALTER FUNCTION public.ghstore_same(internal, internal, internal) OWNER TO evergreen;

--
-- Name: ghstore_union(internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ghstore_union(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'ghstore_union';


ALTER FUNCTION public.ghstore_union(internal, internal) OWNER TO evergreen;

--
-- Name: gin_consistent_hstore(internal, smallint, internal, integer, internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION gin_consistent_hstore(internal, smallint, internal, integer, internal, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'gin_consistent_hstore';


ALTER FUNCTION public.gin_consistent_hstore(internal, smallint, internal, integer, internal, internal) OWNER TO evergreen;

--
-- Name: gin_extract_hstore(internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION gin_extract_hstore(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'gin_extract_hstore';


ALTER FUNCTION public.gin_extract_hstore(internal, internal) OWNER TO evergreen;

--
-- Name: gin_extract_hstore_query(internal, internal, smallint, internal, internal); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION gin_extract_hstore_query(internal, internal, smallint, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'gin_extract_hstore_query';


ALTER FUNCTION public.gin_extract_hstore_query(internal, internal, smallint, internal, internal) OWNER TO evergreen;

--
-- Name: hashean13(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashean13(ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashean13(ean13) OWNER TO evergreen;

--
-- Name: hashisbn(isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashisbn(isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashisbn(isbn) OWNER TO evergreen;

--
-- Name: hashisbn13(isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashisbn13(isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashisbn13(isbn13) OWNER TO evergreen;

--
-- Name: hashismn(ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashismn(ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashismn(ismn) OWNER TO evergreen;

--
-- Name: hashismn13(ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashismn13(ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashismn13(ismn13) OWNER TO evergreen;

--
-- Name: hashissn(issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashissn(issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashissn(issn) OWNER TO evergreen;

--
-- Name: hashissn13(issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashissn13(issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashissn13(issn13) OWNER TO evergreen;

--
-- Name: hashupc(upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hashupc(upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashupc(upc) OWNER TO evergreen;

--
-- Name: hs_concat(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hs_concat(hstore, hstore) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_concat';


ALTER FUNCTION public.hs_concat(hstore, hstore) OWNER TO evergreen;

--
-- Name: hs_contained(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hs_contained(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_contained';


ALTER FUNCTION public.hs_contained(hstore, hstore) OWNER TO evergreen;

--
-- Name: hs_contains(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hs_contains(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_contains';


ALTER FUNCTION public.hs_contains(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore(text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore(text[]) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_from_array';


ALTER FUNCTION public.hstore(text[]) OWNER TO evergreen;

--
-- Name: hstore(record); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore(record) RETURNS hstore
    LANGUAGE c IMMUTABLE
    AS '$libdir/hstore', 'hstore_from_record';


ALTER FUNCTION public.hstore(record) OWNER TO evergreen;

--
-- Name: hstore(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore(text, text) RETURNS hstore
    LANGUAGE c IMMUTABLE
    AS '$libdir/hstore', 'hstore_from_text';


ALTER FUNCTION public.hstore(text, text) OWNER TO evergreen;

--
-- Name: hstore(text[], text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore(text[], text[]) RETURNS hstore
    LANGUAGE c IMMUTABLE
    AS '$libdir/hstore', 'hstore_from_arrays';


ALTER FUNCTION public.hstore(text[], text[]) OWNER TO evergreen;

--
-- Name: hstore_cmp(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_cmp(hstore, hstore) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_cmp';


ALTER FUNCTION public.hstore_cmp(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_eq(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_eq(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_eq';


ALTER FUNCTION public.hstore_eq(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_ge(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_ge(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_ge';


ALTER FUNCTION public.hstore_ge(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_gt(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_gt(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_gt';


ALTER FUNCTION public.hstore_gt(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_hash(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_hash(hstore) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_hash';


ALTER FUNCTION public.hstore_hash(hstore) OWNER TO evergreen;

--
-- Name: hstore_le(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_le(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_le';


ALTER FUNCTION public.hstore_le(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_lt(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_lt(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_lt';


ALTER FUNCTION public.hstore_lt(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_ne(hstore, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_ne(hstore, hstore) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_ne';


ALTER FUNCTION public.hstore_ne(hstore, hstore) OWNER TO evergreen;

--
-- Name: hstore_to_array(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_to_array(hstore) RETURNS text[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_to_array';


ALTER FUNCTION public.hstore_to_array(hstore) OWNER TO evergreen;

--
-- Name: hstore_to_matrix(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_to_matrix(hstore) RETURNS text[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_to_matrix';


ALTER FUNCTION public.hstore_to_matrix(hstore) OWNER TO evergreen;

--
-- Name: hstore_version_diag(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION hstore_version_diag(hstore) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_version_diag';


ALTER FUNCTION public.hstore_version_diag(hstore) OWNER TO evergreen;

--
-- Name: ingest_acq_marc(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ingest_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
	value		TEXT;
	atype		TEXT;
	prov		INT;
	pos 		INT;
	adef		RECORD;
	xpath_string	TEXT;
BEGIN
	FOR adef IN SELECT *,tableoid FROM acq.lineitem_attr_definition LOOP

		SELECT relname::TEXT INTO atype FROM pg_class WHERE oid = adef.tableoid;

		IF (atype NOT IN ('lineitem_usr_attr_definition','lineitem_local_attr_definition')) THEN
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT provider INTO prov FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
				CONTINUE WHEN NEW.provider IS NULL OR prov <> NEW.provider;
			END IF;
			
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_marc_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_marc_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_generated_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_generated_attr_definition WHERE id = adef.id;
			END IF;

            xpath_string := REGEXP_REPLACE(xpath_string,$re$//?text\(\)$$re$,'');

            IF (adef.code = 'title' OR adef.code = 'author') THEN
                -- title and author should not be split
                -- FIXME: once oils_xpath can grok XPATH 2.0 functions, we can use
                -- string-join in the xpath and remove this special case
    			SELECT extract_acq_marc_field(id, xpath_string, adef.remove) INTO value FROM acq.lineitem WHERE id = NEW.id;
    			IF (value IS NOT NULL AND value <> '') THEN
				    INSERT INTO acq.lineitem_attr (lineitem, definition, attr_type, attr_name, attr_value)
	     			    VALUES (NEW.id, adef.id, atype, adef.code, value);
                END IF;
            ELSE
                pos := 1;
                LOOP
                    -- each application of the regex may produce multiple values
                    FOR value IN
                        SELECT * FROM extract_acq_marc_field_set(
                            NEW.id, xpath_string || '[' || pos || ']', adef.remove)
                        LOOP

                        IF (value IS NOT NULL AND value <> '') THEN
                            INSERT INTO acq.lineitem_attr
                                (lineitem, definition, attr_type, attr_name, attr_value)
                                VALUES (NEW.id, adef.id, atype, adef.code, value);
                        ELSE
                            EXIT;
                        END IF;
                    END LOOP;
                    IF NOT FOUND THEN
                        EXIT;
                    END IF;
                    pos := pos + 1;
               END LOOP;
            END IF;

		END IF;

	END LOOP;

	RETURN NULL;
END;
$_$;


ALTER FUNCTION public.ingest_acq_marc() OWNER TO evergreen;

--
-- Name: integer_or_null(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION integer_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\d+$' THEN $1 ELSE NULL END
$_$;


ALTER FUNCTION public.integer_or_null(text) OWNER TO evergreen;

--
-- Name: is_valid(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(ean13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(ean13) OWNER TO evergreen;

--
-- Name: is_valid(isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(isbn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(isbn13) OWNER TO evergreen;

--
-- Name: is_valid(ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(ismn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(ismn13) OWNER TO evergreen;

--
-- Name: is_valid(issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(issn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(issn13) OWNER TO evergreen;

--
-- Name: is_valid(isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(isbn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(isbn) OWNER TO evergreen;

--
-- Name: is_valid(ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(ismn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(ismn) OWNER TO evergreen;

--
-- Name: is_valid(issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(issn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(issn) OWNER TO evergreen;

--
-- Name: is_valid(upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION is_valid(upc) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(upc) OWNER TO evergreen;

--
-- Name: isbn(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isbn(ean13) RETURNS isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_cast_from_ean13';


ALTER FUNCTION public.isbn(ean13) OWNER TO evergreen;

--
-- Name: isbn13(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isbn13(ean13) RETURNS isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_cast_from_ean13';


ALTER FUNCTION public.isbn13(ean13) OWNER TO evergreen;

--
-- Name: isdefined(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isdefined(hstore, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_defined';


ALTER FUNCTION public.isdefined(hstore, text) OWNER TO evergreen;

--
-- Name: isexists(hstore, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isexists(hstore, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_exists';


ALTER FUNCTION public.isexists(hstore, text) OWNER TO evergreen;

--
-- Name: ismn(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ismn(ean13) RETURNS ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_cast_from_ean13';


ALTER FUNCTION public.ismn(ean13) OWNER TO evergreen;

--
-- Name: ismn13(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION ismn13(ean13) RETURNS ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_cast_from_ean13';


ALTER FUNCTION public.ismn13(ean13) OWNER TO evergreen;

--
-- Name: isn_weak(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_weak() RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'weak_input_status';


ALTER FUNCTION public.isn_weak() OWNER TO evergreen;

--
-- Name: isn_weak(boolean); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isn_weak(boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'accept_weak_input';


ALTER FUNCTION public.isn_weak(boolean) OWNER TO evergreen;

--
-- Name: isneq(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, ean13) OWNER TO evergreen;

--
-- Name: isneq(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isneq(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isneq(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, issn13) OWNER TO evergreen;

--
-- Name: isneq(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, isbn) OWNER TO evergreen;

--
-- Name: isneq(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, ismn) OWNER TO evergreen;

--
-- Name: isneq(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, issn) OWNER TO evergreen;

--
-- Name: isneq(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ean13, upc) OWNER TO evergreen;

--
-- Name: isneq(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isneq(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isneq(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isneq(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn, isbn) OWNER TO evergreen;

--
-- Name: isneq(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isneq(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(isbn, ean13) OWNER TO evergreen;

--
-- Name: isneq(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isneq(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isneq(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isneq(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn, ismn) OWNER TO evergreen;

--
-- Name: isneq(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isneq(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(ismn, ean13) OWNER TO evergreen;

--
-- Name: isneq(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn13, issn13) OWNER TO evergreen;

--
-- Name: isneq(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn13, issn) OWNER TO evergreen;

--
-- Name: isneq(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn13, ean13) OWNER TO evergreen;

--
-- Name: isneq(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn, issn) OWNER TO evergreen;

--
-- Name: isneq(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn, issn13) OWNER TO evergreen;

--
-- Name: isneq(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(issn, ean13) OWNER TO evergreen;

--
-- Name: isneq(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(upc, upc) OWNER TO evergreen;

--
-- Name: isneq(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isneq(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(upc, ean13) OWNER TO evergreen;

--
-- Name: isnge(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, ean13) OWNER TO evergreen;

--
-- Name: isnge(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isnge(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isnge(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, issn13) OWNER TO evergreen;

--
-- Name: isnge(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, isbn) OWNER TO evergreen;

--
-- Name: isnge(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, ismn) OWNER TO evergreen;

--
-- Name: isnge(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, issn) OWNER TO evergreen;

--
-- Name: isnge(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ean13, upc) OWNER TO evergreen;

--
-- Name: isnge(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isnge(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isnge(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isnge(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn, isbn) OWNER TO evergreen;

--
-- Name: isnge(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isnge(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(isbn, ean13) OWNER TO evergreen;

--
-- Name: isnge(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isnge(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isnge(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isnge(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn, ismn) OWNER TO evergreen;

--
-- Name: isnge(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isnge(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(ismn, ean13) OWNER TO evergreen;

--
-- Name: isnge(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn13, issn13) OWNER TO evergreen;

--
-- Name: isnge(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn13, issn) OWNER TO evergreen;

--
-- Name: isnge(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn13, ean13) OWNER TO evergreen;

--
-- Name: isnge(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn, issn) OWNER TO evergreen;

--
-- Name: isnge(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn, issn13) OWNER TO evergreen;

--
-- Name: isnge(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(issn, ean13) OWNER TO evergreen;

--
-- Name: isnge(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(upc, upc) OWNER TO evergreen;

--
-- Name: isnge(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnge(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(upc, ean13) OWNER TO evergreen;

--
-- Name: isngt(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, ean13) OWNER TO evergreen;

--
-- Name: isngt(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isngt(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isngt(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, issn13) OWNER TO evergreen;

--
-- Name: isngt(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, isbn) OWNER TO evergreen;

--
-- Name: isngt(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, ismn) OWNER TO evergreen;

--
-- Name: isngt(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, issn) OWNER TO evergreen;

--
-- Name: isngt(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ean13, upc) OWNER TO evergreen;

--
-- Name: isngt(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isngt(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isngt(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isngt(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn, isbn) OWNER TO evergreen;

--
-- Name: isngt(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isngt(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(isbn, ean13) OWNER TO evergreen;

--
-- Name: isngt(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isngt(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isngt(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isngt(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn, ismn) OWNER TO evergreen;

--
-- Name: isngt(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isngt(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(ismn, ean13) OWNER TO evergreen;

--
-- Name: isngt(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn13, issn13) OWNER TO evergreen;

--
-- Name: isngt(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn13, issn) OWNER TO evergreen;

--
-- Name: isngt(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn13, ean13) OWNER TO evergreen;

--
-- Name: isngt(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn, issn) OWNER TO evergreen;

--
-- Name: isngt(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn, issn13) OWNER TO evergreen;

--
-- Name: isngt(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(issn, ean13) OWNER TO evergreen;

--
-- Name: isngt(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(upc, upc) OWNER TO evergreen;

--
-- Name: isngt(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isngt(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(upc, ean13) OWNER TO evergreen;

--
-- Name: isnle(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, ean13) OWNER TO evergreen;

--
-- Name: isnle(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isnle(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isnle(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, issn13) OWNER TO evergreen;

--
-- Name: isnle(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, isbn) OWNER TO evergreen;

--
-- Name: isnle(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, ismn) OWNER TO evergreen;

--
-- Name: isnle(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, issn) OWNER TO evergreen;

--
-- Name: isnle(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ean13, upc) OWNER TO evergreen;

--
-- Name: isnle(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isnle(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isnle(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isnle(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn, isbn) OWNER TO evergreen;

--
-- Name: isnle(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isnle(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(isbn, ean13) OWNER TO evergreen;

--
-- Name: isnle(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isnle(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isnle(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isnle(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn, ismn) OWNER TO evergreen;

--
-- Name: isnle(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isnle(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(ismn, ean13) OWNER TO evergreen;

--
-- Name: isnle(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn13, issn13) OWNER TO evergreen;

--
-- Name: isnle(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn13, issn) OWNER TO evergreen;

--
-- Name: isnle(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn13, ean13) OWNER TO evergreen;

--
-- Name: isnle(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn, issn) OWNER TO evergreen;

--
-- Name: isnle(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn, issn13) OWNER TO evergreen;

--
-- Name: isnle(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(issn, ean13) OWNER TO evergreen;

--
-- Name: isnle(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(upc, upc) OWNER TO evergreen;

--
-- Name: isnle(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnle(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(upc, ean13) OWNER TO evergreen;

--
-- Name: isnlt(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, ean13) OWNER TO evergreen;

--
-- Name: isnlt(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isnlt(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isnlt(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, issn13) OWNER TO evergreen;

--
-- Name: isnlt(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, isbn) OWNER TO evergreen;

--
-- Name: isnlt(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, ismn) OWNER TO evergreen;

--
-- Name: isnlt(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, issn) OWNER TO evergreen;

--
-- Name: isnlt(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ean13, upc) OWNER TO evergreen;

--
-- Name: isnlt(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isnlt(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isnlt(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isnlt(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn, isbn) OWNER TO evergreen;

--
-- Name: isnlt(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isnlt(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(isbn, ean13) OWNER TO evergreen;

--
-- Name: isnlt(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isnlt(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isnlt(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isnlt(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn, ismn) OWNER TO evergreen;

--
-- Name: isnlt(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isnlt(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(ismn, ean13) OWNER TO evergreen;

--
-- Name: isnlt(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn13, issn13) OWNER TO evergreen;

--
-- Name: isnlt(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn13, issn) OWNER TO evergreen;

--
-- Name: isnlt(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn13, ean13) OWNER TO evergreen;

--
-- Name: isnlt(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn, issn) OWNER TO evergreen;

--
-- Name: isnlt(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn, issn13) OWNER TO evergreen;

--
-- Name: isnlt(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(issn, ean13) OWNER TO evergreen;

--
-- Name: isnlt(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(upc, upc) OWNER TO evergreen;

--
-- Name: isnlt(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnlt(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(upc, ean13) OWNER TO evergreen;

--
-- Name: isnne(ean13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, ean13) OWNER TO evergreen;

--
-- Name: isnne(ean13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, isbn13) OWNER TO evergreen;

--
-- Name: isnne(ean13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, ismn13) OWNER TO evergreen;

--
-- Name: isnne(ean13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, issn13) OWNER TO evergreen;

--
-- Name: isnne(ean13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, isbn) OWNER TO evergreen;

--
-- Name: isnne(ean13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, ismn) OWNER TO evergreen;

--
-- Name: isnne(ean13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, issn) OWNER TO evergreen;

--
-- Name: isnne(ean13, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ean13, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ean13, upc) OWNER TO evergreen;

--
-- Name: isnne(isbn13, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn13, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn13, isbn13) OWNER TO evergreen;

--
-- Name: isnne(isbn13, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn13, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn13, isbn) OWNER TO evergreen;

--
-- Name: isnne(isbn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn13, ean13) OWNER TO evergreen;

--
-- Name: isnne(isbn, isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn, isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn, isbn) OWNER TO evergreen;

--
-- Name: isnne(isbn, isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn, isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn, isbn13) OWNER TO evergreen;

--
-- Name: isnne(isbn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(isbn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(isbn, ean13) OWNER TO evergreen;

--
-- Name: isnne(ismn13, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn13, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn13, ismn13) OWNER TO evergreen;

--
-- Name: isnne(ismn13, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn13, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn13, ismn) OWNER TO evergreen;

--
-- Name: isnne(ismn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn13, ean13) OWNER TO evergreen;

--
-- Name: isnne(ismn, ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn, ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn, ismn) OWNER TO evergreen;

--
-- Name: isnne(ismn, ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn, ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn, ismn13) OWNER TO evergreen;

--
-- Name: isnne(ismn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(ismn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(ismn, ean13) OWNER TO evergreen;

--
-- Name: isnne(issn13, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn13, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn13, issn13) OWNER TO evergreen;

--
-- Name: isnne(issn13, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn13, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn13, issn) OWNER TO evergreen;

--
-- Name: isnne(issn13, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn13, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn13, ean13) OWNER TO evergreen;

--
-- Name: isnne(issn, issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn, issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn, issn) OWNER TO evergreen;

--
-- Name: isnne(issn, issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn, issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn, issn13) OWNER TO evergreen;

--
-- Name: isnne(issn, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(issn, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(issn, ean13) OWNER TO evergreen;

--
-- Name: isnne(upc, upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(upc, upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(upc, upc) OWNER TO evergreen;

--
-- Name: isnne(upc, ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION isnne(upc, ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(upc, ean13) OWNER TO evergreen;

--
-- Name: issn(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION issn(ean13) RETURNS issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_cast_from_ean13';


ALTER FUNCTION public.issn(ean13) OWNER TO evergreen;

--
-- Name: issn13(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION issn13(ean13) RETURNS issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_cast_from_ean13';


ALTER FUNCTION public.issn13(ean13) OWNER TO evergreen;

--
-- Name: last_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION last_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT $2;
$_$;


ALTER FUNCTION public.last_agg(anyelement, anyelement) OWNER TO evergreen;

--
-- Name: left_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION left_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,$2);
$_$;


ALTER FUNCTION public.left_trunc(text, integer) OWNER TO evergreen;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION public.lowercase(text) OWNER TO evergreen;

--
-- Name: maintain_control_numbers(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION maintain_control_numbers() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use Encode;
use Unicode::Normalize;

my $record = MARC::Record->new_from_xml($_TD->{new}{marc});
my $schema = $_TD->{table_schema};
my $rec_id = $_TD->{new}{id};

# Short-circuit if maintaining control numbers per MARC21 spec is not enabled
my $enable = spi_exec_query("SELECT enabled FROM config.global_flag WHERE name = 'cat.maintain_control_numbers'");
if (!($enable->{processed}) or $enable->{rows}[0]->{enabled} eq 'f') {
    return;
}

# Get the control number identifier from an OU setting based on $_TD->{new}{owner}
my $ou_cni = 'EVRGRN';

my $owner;
if ($schema eq 'serial') {
    $owner = $_TD->{new}{owning_lib};
} else {
    # are.owner and bre.owner can be null, so fall back to the consortial setting
    $owner = $_TD->{new}{owner} || 1;
}

my $ous_rv = spi_exec_query("SELECT value FROM actor.org_unit_ancestor_setting('cat.marc_control_number_identifier', $owner)");
if ($ous_rv->{processed}) {
    $ou_cni = $ous_rv->{rows}[0]->{value};
    $ou_cni =~ s/"//g; # Stupid VIM syntax highlighting"
} else {
    # Fall back to the shortname of the OU if there was no OU setting
    $ous_rv = spi_exec_query("SELECT shortname FROM actor.org_unit WHERE id = $owner");
    if ($ous_rv->{processed}) {
        $ou_cni = $ous_rv->{rows}[0]->{shortname};
    }
}

my ($create, $munge) = (0, 0);

my @scns = $record->field('035');

foreach my $id_field ('001', '003') {
    my $spec_value;
    my @controls = $record->field($id_field);

    if ($id_field eq '001') {
        $spec_value = $rec_id;
    } else {
        $spec_value = $ou_cni;
    }

    # Create the 001/003 if none exist
    if (scalar(@controls) == 1) {
        # Only one field; check to see if we need to munge it
        unless (grep $_->data() eq $spec_value, @controls) {
            $munge = 1;
        }
    } else {
        # Delete the other fields, as with more than 1 001/003 we do not know which 003/001 to match
        foreach my $control (@controls) {
            unless ($control->data() eq $spec_value) {
                $record->delete_field($control);
            }
        }
        $record->insert_fields_ordered(MARC::Field->new($id_field, $spec_value));
        $create = 1;
    }
}

# Now, if we need to munge the 001, we will first push the existing 001/003
# into the 035; but if the record did not have one (and one only) 001 and 003
# to begin with, skip this process
if ($munge and not $create) {
    my $scn = "(" . $record->field('003')->data() . ")" . $record->field('001')->data();

    # Do not create duplicate 035 fields
    unless (grep $_->subfield('a') eq $scn, @scns) {
        $record->insert_fields_ordered(MARC::Field->new('035', '', '', 'a' => $scn));
    }
}

# Set the 001/003 and update the MARC
if ($create or $munge) {
    $record->field('001')->data($rec_id);
    $record->field('003')->data($ou_cni);

    my $xml = $record->as_xml_record();
    $xml =~ s/\n//sgo;
    $xml =~ s/^<\?xml.+\?\s*>//go;
    $xml =~ s/>\s+</></go;
    $xml =~ s/\p{Cc}//go;

    # Embed a version of OpenILS::Application::AppUtils->entityize()
    # to avoid having to set PERL5LIB for PostgreSQL as well

    # If we are going to convert non-ASCII characters to XML entities,
    # we had better be dealing with a UTF8 string to begin with
    $xml = decode_utf8($xml);

    $xml = NFC($xml);

    # Convert raw ampersands to entities
    $xml =~ s/&(?!\S+;)/&amp;/gso;

    # Convert Unicode characters to entities
    $xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

    $xml =~ s/[\x00-\x1f]//go;
    $_TD->{new}{marc} = $xml;

    return "MODIFY";
}

return;
$_X$;


ALTER FUNCTION public.maintain_control_numbers() OWNER TO evergreen;

--
-- Name: make_valid(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(ean13) RETURNS ean13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(ean13) OWNER TO evergreen;

--
-- Name: make_valid(isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(isbn13) RETURNS isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(isbn13) OWNER TO evergreen;

--
-- Name: make_valid(ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(ismn13) RETURNS ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(ismn13) OWNER TO evergreen;

--
-- Name: make_valid(issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(issn13) RETURNS issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(issn13) OWNER TO evergreen;

--
-- Name: make_valid(isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(isbn) RETURNS isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(isbn) OWNER TO evergreen;

--
-- Name: make_valid(ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(ismn) RETURNS ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(ismn) OWNER TO evergreen;

--
-- Name: make_valid(issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(issn) RETURNS issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(issn) OWNER TO evergreen;

--
-- Name: make_valid(upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION make_valid(upc) RETURNS upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(upc) OWNER TO evergreen;

--
-- Name: naco_normalize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION naco_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.naco_normalize($1,'');
$_$;


ALTER FUNCTION public.naco_normalize(text) OWNER TO evergreen;

--
-- Name: naco_normalize(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION naco_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # http://www.loc.gov/catdir/pcc/naco/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett () and certain ligatures (?, ?, ?, etc.) will be handled correctly.
    # If there are any bugs in Perl`s implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}]['/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

	#Catalyst IT Services
	#Jeffrey Bond
	#05 - 24 - 2012
	#Modified if statement, was to bulky, only required checking if $sf was true and removing the first comma.
	#sf represents an optional argument for author to keep the first comma in the string.
	if ($sf) {$str =~ s/,/\x{009F}/;}

	#Catalyst IT Services
	#Jeffrey Bond
	#05 - 24 - 2012
	#Added 3 lines to eliminate apostrophes commas and hyphens and adhere to standard NACO rules.
    $str =~ s/\'//g;
    $str =~ s/\,//g;
    $str =~ s/\'//g;
    # since we`ve stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that`s fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

	$str =~ s/\x{009F}/,/; #Put comma back
    return lc $str;
$_$;


ALTER FUNCTION public.naco_normalize(text, text) OWNER TO evergreen;

--
-- Name: naco_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION naco_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.naco_normalize($1,'a');
$_$;


ALTER FUNCTION public.naco_normalize_keep_comma(text) OWNER TO evergreen;

--
-- Name: naco_normalize_keep_decimal(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION naco_normalize_keep_decimal(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Altered version of the naco_normalize function

    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}]['/DDOLl/d;
     # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

    if ($sf) {$str =~ s/,/\x{009F}/;}

    $str =~ s/\'//g;
    $str =~ s/\,//g;
    $str =~ s/\'//g;
    # since we`ve stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;

    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that`s fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

	$str =~ s/\x{009F}/,/; #Put comma back

    return lc $str;
$_$;


ALTER FUNCTION public.naco_normalize_keep_decimal(text, text) OWNER TO evergreen;

--
-- Name: non_filing_normalize(text, "char"); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION non_filing_normalize(text, "char") RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT  SUBSTRING(
                        REGEXP_REPLACE(
                                REGEXP_REPLACE(
                                        $1,
                                        E'\W*$',
					''
				),
                                '  ',
                                ' '
                        ),
                        CASE
				WHEN $2::INT NOT BETWEEN 48 AND 57 THEN 1
				ELSE $2::TEXT::INT + 1
			END
		);
$_$;


ALTER FUNCTION public.non_filing_normalize(text, "char") OWNER TO evergreen;

--
-- Name: normal_rand(integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION normal_rand(integer, double precision, double precision) RETURNS SETOF double precision
    LANGUAGE c STRICT
    AS '$libdir/tablefunc', 'normal_rand';


ALTER FUNCTION public.normal_rand(integer, double precision, double precision) OWNER TO postgres;

--
-- Name: normalize_space(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION normalize_space(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(regexp_replace(regexp_replace($1, E'\\n', ' ', 'g'), E'(?:^\\s+)|(\\s+$)', '', 'g'), E'\\s+', ' ', 'g');
$_$;


ALTER FUNCTION public.normalize_space(text) OWNER TO evergreen;

--
-- Name: oils_i18n_code_tracking(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_code_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.code::TEXT, NEW.code::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.oils_i18n_code_tracking() OWNER TO evergreen;

--
-- Name: oils_i18n_gettext(integer, text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_gettext(integer, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION public.oils_i18n_gettext(integer, text, text, text) OWNER TO evergreen;

--
-- Name: oils_i18n_gettext(text, text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_gettext(text, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION public.oils_i18n_gettext(text, text, text, text) OWNER TO evergreen;

--
-- Name: oils_i18n_id_tracking(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_id_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.id::TEXT, NEW.id::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.oils_i18n_id_tracking() OWNER TO evergreen;

--
-- Name: oils_i18n_update_apply(text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_update_apply(old_ident text, new_ident text, hint text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN

    EXECUTE $$
        UPDATE  config.i18n_core
          SET   identity_value = $$ || quote_literal( new_ident ) || $$ 
          WHERE fq_field LIKE '$$ || hint || $$.%' 
                AND identity_value = $$ || quote_literal( old_ident ) || $$;$$;

    RETURN;

END;
$_$;


ALTER FUNCTION public.oils_i18n_update_apply(old_ident text, new_ident text, hint text) OWNER TO evergreen;

--
-- Name: oils_i18n_xlate(text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    locale      TEXT := REGEXP_REPLACE( REGEXP_REPLACE( raw_locale, E'[;, ].+$', '' ), E'_', '-', 'g' );
    language    TEXT := REGEXP_REPLACE( locale, E'-.+$', '' );
    result      config.i18n_core%ROWTYPE;
    fallback    TEXT;
    keyfield    TEXT := keyclass || '.' || keycol;
BEGIN

    -- Try the full locale
    SELECT  * INTO result
      FROM  config.i18n_core
      WHERE fq_field = keyfield
            AND identity_value = keyvalue
            AND translation = locale;

    -- Try just the language
    IF NOT FOUND THEN
        SELECT  * INTO result
          FROM  config.i18n_core
          WHERE fq_field = keyfield
                AND identity_value = keyvalue
                AND translation = language;
    END IF;

    -- Fall back to the string we passed in in the first place
    IF NOT FOUND THEN
	EXECUTE
            'SELECT ' ||
                keycol ||
            ' FROM ' || keytable ||
            ' WHERE ' || identcol || ' = ' || quote_literal(keyvalue)
                INTO fallback;
        RETURN fallback;
    END IF;

    RETURN result.string;
END;
$_$;


ALTER FUNCTION public.oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) OWNER TO evergreen;

--
-- Name: oils_json_to_text(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_json_to_text(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;                    
    my $json = shift();
    my $txt;
    eval { $txt = JSON::XS->new->allow_nonref->decode( $json ) };   
    return undef if ($@);
    return $txt
$_$;


ALTER FUNCTION public.oils_json_to_text(text) OWNER TO evergreen;

--
-- Name: oils_text_as_bytea(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_text_as_bytea(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT CAST(REGEXP_REPLACE(UPPER($1), $$\\$$, $$\\\\$$, 'g') AS BYTEA);
$_$;


ALTER FUNCTION public.oils_text_as_bytea(text) OWNER TO evergreen;

--
-- Name: oils_tsearch2(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_tsearch2() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    normalizer      RECORD;
    value           TEXT := '';
    temp_vector     TEXT := '';
    ts_rec          RECORD;
    cur_weight      "char";
BEGIN

    value := NEW.value;
    NEW.index_vector = ''::tsvector;

    IF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos < 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;

        NEW.value = value;

        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos >= 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;
   END IF;

    IF TG_TABLE_NAME::TEXT ~ 'browse_entry$' THEN
        value :=  ARRAY_TO_STRING(
            evergreen.regexp_split_to_array(value, E'\\W+'), ' '
        );
        value := public.search_normalize(value);
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);
    ELSIF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR ts_rec IN
            SELECT ts_config, index_weight
            FROM config.metabib_class_ts_map
            WHERE field_class = TG_ARGV[0]
                AND index_lang IS NULL OR EXISTS (SELECT 1 FROM metabib.record_attr WHERE id = NEW.source AND index_lang IN(attrs->'item_lang',attrs->'language'))
                AND always OR NOT EXISTS (SELECT 1 FROM config.metabib_field_ts_map WHERE metabib_field = NEW.field)
            UNION
            SELECT ts_config, index_weight
            FROM config.metabib_field_ts_map
            WHERE metabib_field = NEW.field
               AND index_lang IS NULL OR EXISTS (SELECT 1 FROM metabib.record_attr WHERE id = NEW.source AND index_lang IN(attrs->'item_lang',attrs->'language'))
            ORDER BY index_weight ASC
        LOOP
            IF cur_weight IS NOT NULL AND cur_weight != ts_rec.index_weight THEN
                NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
                temp_vector = '';
            END IF;
            cur_weight = ts_rec.index_weight;
            SELECT INTO temp_vector temp_vector || ' ' || to_tsvector(ts_rec.ts_config::regconfig, value)::TEXT;
        END LOOP;
        NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
    ELSE
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION public.oils_tsearch2() OWNER TO evergreen;

--
-- Name: oils_xpath(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath(text, text) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT XPATH( $1, $2::XML )::TEXT[];$_$;


ALTER FUNCTION public.oils_xpath(text, text) OWNER TO evergreen;

--
-- Name: oils_xpath(text, text, anyarray); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath(text, text, anyarray) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT XPATH( $1, $2::XML, $3 )::TEXT[];$_$;


ALTER FUNCTION public.oils_xpath(text, text, anyarray) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath_string(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '{}'::TEXT[] );
$_$;


ALTER FUNCTION public.oils_xpath_string(text, text) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath_string(text, text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, $3, '{}'::TEXT[] );
$_$;


ALTER FUNCTION public.oils_xpath_string(text, text, text) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, anyarray); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath_string(text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '', $3 );
$_$;


ALTER FUNCTION public.oils_xpath_string(text, text, anyarray) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, text, anyarray); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath_string(text, text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  ARRAY_TO_STRING(
                oils_xpath(
                    $1 ||
                        CASE WHEN $1 ~ $re$/[^/[]*@[^]]+$$re$ OR $1 ~ $re$text\(\)$$re$ THEN '' ELSE '//text()' END,
                    $2,
                    $4
                ),
                $3
            );
$_$;


ALTER FUNCTION public.oils_xpath_string(text, text, text, anyarray) OWNER TO evergreen;

--
-- Name: oils_xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) RETURNS SETOF record
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    xpath_list  TEXT[];
    select_list TEXT[];
    where_list  TEXT[];
    q           TEXT;
    out_record  RECORD;
    empty_test  RECORD;
BEGIN
    xpath_list := STRING_TO_ARRAY( xpaths, '|' );

    select_list := ARRAY_APPEND( select_list, key || '::INT AS key' );

    FOR i IN 1 .. ARRAY_UPPER(xpath_list,1) LOOP
        IF xpath_list[i] = 'null()' THEN
            select_list := ARRAY_APPEND( select_list, 'NULL::TEXT AS c_' || i );
        ELSE
            select_list := ARRAY_APPEND(
                select_list,
                $sel$
                EXPLODE_ARRAY(
                    COALESCE(
                        NULLIF(
                            oils_xpath(
                                $sel$ ||
                                    quote_literal(
                                        CASE
                                            WHEN xpath_list[i] ~ $re$/[^/[]*@[^/]+$$re$ OR xpath_list[i] ~ $re$text\(\)$$re$ THEN xpath_list[i]
                                            ELSE xpath_list[i] || '//text()'
                                        END
                                    ) ||
                                $sel$,
                                $sel$ || document_field || $sel$
                            ),
                           '{}'::TEXT[]
                        ),
                        '{NULL}'::TEXT[]
                    )
                ) AS c_$sel$ || i
            );
            where_list := ARRAY_APPEND(
                where_list,
                'c_' || i || ' IS NOT NULL'
            );
        END IF;
    END LOOP;

    q := $q$
SELECT * FROM (
    SELECT $q$ || ARRAY_TO_STRING( select_list, ', ' ) || $q$ FROM $q$ || relation_name || $q$ WHERE ($q$ || criteria || $q$)
)x WHERE $q$ || ARRAY_TO_STRING( where_list, ' OR ' );
    -- RAISE NOTICE 'query: %', q;

    FOR out_record IN EXECUTE q LOOP
        RETURN NEXT out_record;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION public.oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) OWNER TO evergreen;

--
-- Name: oils_xslt_process(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION oils_xslt_process(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
  use strict;

  use XML::LibXSLT;
  use XML::LibXML;

  my $doc = shift;
  my $xslt = shift;

  # The following approach uses the older XML::LibXML 1.69 / XML::LibXSLT 1.68
  # methods of parsing XML documents and stylesheets, in the hopes of broader
  # compatibility with distributions
  my $parser = $_SHARED{'_xslt_process'}{parsers}{xml} || XML::LibXML->new();

  # Cache the XML parser, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xml} = $parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xml});

  my $xslt_parser = $_SHARED{'_xslt_process'}{parsers}{xslt} || XML::LibXSLT->new();

  # Cache the XSLT processor, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xslt} = $xslt_parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xslt});

  my $stylesheet = $_SHARED{'_xslt_process'}{stylesheets}{$xslt} ||
    $xslt_parser->parse_stylesheet( $parser->parse_string($xslt) );

  $_SHARED{'_xslt_process'}{stylesheets}{$xslt} = $stylesheet
    unless ($_SHARED{'_xslt_process'}{stylesheets}{$xslt});

  return $stylesheet->output_string(
    $stylesheet->transform(
      $parser->parse_string($doc)
    )
  );

$_X$;


ALTER FUNCTION public.oils_xslt_process(text, text) OWNER TO evergreen;

--
-- Name: populate_record(anyelement, hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION populate_record(anyelement, hstore) RETURNS anyelement
    LANGUAGE c IMMUTABLE
    AS '$libdir/hstore', 'hstore_populate_record';


ALTER FUNCTION public.populate_record(anyelement, hstore) OWNER TO evergreen;

--
-- Name: remove_commas(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION remove_commas(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, ',', '', 'g');
$_$;


ALTER FUNCTION public.remove_commas(text) OWNER TO evergreen;

--
-- Name: remove_diacritics(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION remove_diacritics(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFD(shift);
    $x =~ s/\pM+//go;
    return $x;

$_$;


ALTER FUNCTION public.remove_diacritics(text) OWNER TO evergreen;

--
-- Name: remove_insignificants(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION remove_insignificants(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
	my $str = shift;
	my @char_array = split ('', $str);
	
		if($char_array[2] eq ' ' && $char_array[1] eq 'n' && $char_array[0] eq 'a'){
			$str =~ s/^an //;
		}elsif($char_array[1] eq ' ' && $char_array[0] eq 'a'){
			$str =~ s/^a //;
		}elsif($char_array[3] eq ' ' && $char_array[2] eq 'e' && $char_array[1] eq 'h' && $char_array[0] eq 't'){
			$str =~ s/^the //;
		}
		
	return $str;
		
$_$;


ALTER FUNCTION public.remove_insignificants(text) OWNER TO evergreen;

--
-- Name: remove_paren_substring(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION remove_paren_substring(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, $$\([^)]+\)$$, '', 'g');
$_$;


ALTER FUNCTION public.remove_paren_substring(text) OWNER TO evergreen;

--
-- Name: remove_whitespace(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION remove_whitespace(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(normalize_space($1), E'\\s+', '', 'g');
$_$;


ALTER FUNCTION public.remove_whitespace(text) OWNER TO evergreen;

--
-- Name: replace_ampersand(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION replace_ampersand(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, '&amp|&', 'and', 'g' );
$_$;


ALTER FUNCTION public.replace_ampersand(text) OWNER TO evergreen;

--
-- Name: right_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION right_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,1,$2);
$_$;


ALTER FUNCTION public.right_trunc(text, integer) OWNER TO evergreen;

--
-- Name: search_normalize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION search_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.search_normalize($1,'');
$_$;


ALTER FUNCTION public.search_normalize(text) OWNER TO evergreen;

--
-- Name: search_normalize(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION search_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # http://www.loc.gov/catdir/pcc/naco/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett () and certain ligatures (?, ?, ?, etc.) will be handled correctly.
    # If there are any bugs in Perl`s implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}][/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

	#Jeffrey Bond
	#05 - 24 - 2012
	#Modified if statement, was to bulky, only required checking if $sf was true and removing the first comma.
	#sf represents an optional argument for author to keep the first comma in the string.
	if ($sf) {$str =~ s/,/\x{009F}/;}

	#Catalyst IT Services
	#Jeffrey Bond
	#05 - 23 - 2012
	#Added 3 lines to eliminate apostrophes and commas, hyphens are converted to spaces, and adhere to standard NACO rules.
    $str =~ s/\'//g;
    $str =~ s/\,//g;
    $str =~ s/\'//g;
    # since we've stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that`s fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;
    
    # Return first comma, if it existed
    $str =~ s/\x{009F}/,/g;

    return lc $str;
$_$;


ALTER FUNCTION public.search_normalize(text, text) OWNER TO evergreen;

--
-- Name: search_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION search_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.search_normalize($1,'a');
$_$;


ALTER FUNCTION public.search_normalize_keep_comma(text) OWNER TO evergreen;

--
-- Name: short_title(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION short_title(text, integer) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    my $str = shift;
    my $num = shift;

    $str =~ s/[;\/:, ]+$//;
    my @tokens = split /\s+/, $str;
    if (@tokens <= $num) {
        return $str;
    } else {
        return '';
    }

$_$;


ALTER FUNCTION public.short_title(text, integer) OWNER TO evergreen;

--
-- Name: skeys(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION skeys(hstore) RETURNS SETOF text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_skeys';


ALTER FUNCTION public.skeys(hstore) OWNER TO evergreen;

--
-- Name: slice(hstore, text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION slice(hstore, text[]) RETURNS hstore
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_slice_to_hstore';


ALTER FUNCTION public.slice(hstore, text[]) OWNER TO evergreen;

--
-- Name: slice_array(hstore, text[]); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION slice_array(hstore, text[]) RETURNS text[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_slice_to_array';


ALTER FUNCTION public.slice_array(hstore, text[]) OWNER TO evergreen;

--
-- Name: split_date_range(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION split_date_range(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'(\\d{4})-(\\d{4})', E'\\1 \\2', 'g' );
$_$;


ALTER FUNCTION public.split_date_range(text) OWNER TO evergreen;

--
-- Name: svals(hstore); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION svals(hstore) RETURNS SETOF text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/hstore', 'hstore_svals';


ALTER FUNCTION public.svals(hstore) OWNER TO evergreen;

--
-- Name: tableoid2name(oid); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION tableoid2name(oid) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		RETURN $1::regclass;
	END;
$_$;


ALTER FUNCTION public.tableoid2name(oid) OWNER TO evergreen;

--
-- Name: tconvert(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION tconvert(text, text) RETURNS hstore
    LANGUAGE c IMMUTABLE
    AS '$libdir/hstore', 'hstore_from_text';


ALTER FUNCTION public.tconvert(text, text) OWNER TO evergreen;

--
-- Name: temp_update_holds(bigint, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION temp_update_holds(arg bigint, arg2 text) RETURNS integer
    LANGUAGE plpgsql COST 500
    AS $$
BEGIN

	UPDATE action.hold_count AS "main"
	SET holds_count = (SELECT  count("ahr".id ) AS "count" 
										FROM action.hold_request AS "ahr"  
										WHERE ( 
												( 
													( 
														( "ahr".target IN (SELECT  "acp".id AS "id" 
															FROM asset.copy AS "acp"  
															INNER JOIN asset.call_number AS "acn" 
															ON ( "acn".id = "acp".call_number )   
															INNER JOIN biblio.record_entry AS "bre" 
															ON ( "bre".id = "acn".record AND  "bre".id = "main".record_entry_id ) ) 
															AND "ahr".hold_type IN ('C') 
														) 
													) 
													OR 	(
															( "ahr".target IN (SELECT  "acn".id AS "id" 
																FROM asset.call_number AS "acn"  
																INNER JOIN biblio.record_entry AS "bre" 
																ON ( "bre".id = "acn".record AND  "bre".id = "main".record_entry_id ) ) 
																AND "ahr".hold_type = 'V' 
															) 
														) 
													OR  (
															( "ahr".target = "main".record_entry_id AND "ahr".hold_type = 'T' ) 
														) 
												) 
												AND "ahr".cancel_time IS NULL 
												AND "ahr".fulfillment_time IS NULL 
											))
	WHERE 
			-- For hold type T (title)
			(("main".record_entry_id = arg) AND (arg2 = 'T'))
		OR 
			-- For hold type C (copy)
			(("main".record_entry_id = (SELECT "acn".record 
														FROM asset.copy AS "acp"
														INNER JOIN asset.call_number AS "acn" 
														ON ( "acn".id = "acp".call_number ) 
														WHERE "acp".id = new.target)) AND (arg2 = 'C'))
		OR
			-- For hold type V (volume)
			(("main".record_entry_id = (SELECT "acn".record
														FROM asset.call_number AS "acn"
														WHERE "acn".id = arg) AND (arg2 = 'V'))
	);
	RETURN 1;
END
$$;


ALTER FUNCTION public.temp_update_holds(arg bigint, arg2 text) OWNER TO evergreen;

--
-- Name: text_concat(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION text_concat(text, text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
SELECT
	CASE	WHEN $1 IS NULL
			THEN $2
		WHEN $2 IS NULL
			THEN $1
		ELSE $1 || ' ' || $2
	END;
$_$;


ALTER FUNCTION public.text_concat(text, text) OWNER TO evergreen;

--
-- Name: translate_isbn1013(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION translate_isbn1013(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # For each ISBN found in a single string containing a set of ISBNs:
    #   * Normalize an incoming ISBN to have the correct checksum and no hyphens
    #   * Convert an incoming ISBN10 or ISBN13 to its counterpart and return

    my $input = shift;
    my $output = '';

    if ($input =~ m/^(on\d{10})|(on\d{13})$/i) {
	return $input;
    }

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $output .= $isbn->isbn() . " ";
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, convert it to its counterpart ISBN10/ISBN13
        # and add the normalized original ISBN to the output
        if ($isbn && $isbn->is_valid()) {
            my $isbn_xlated = ($isbn->type eq "ISBN13") ? $isbn->as_isbn10 : $isbn->as_isbn13;
            $output .= $isbn->isbn . " ";

            # If we successfully converted the ISBN to its counterpart, add the
            # converted ISBN to the output as well
            $output .= ($isbn_xlated->isbn . " ") if ($isbn_xlated);
        }
    }
    return $output if $output;

    # If there were no valid ISBNs, just return the raw input
    return $input;
$_$;


ALTER FUNCTION public.translate_isbn1013(text) OWNER TO evergreen;

--
-- Name: FUNCTION translate_isbn1013(text); Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON FUNCTION translate_isbn1013(text) IS '

/*
 * Copyright (C) 2010 Merrimack Valley Library Consortium
 * Jason Stephenson <jstephenson@mvlc.org>
 * Copyright (C) 2010 Laurentian University
 * Dan Scott <dscott@laurentian.ca>
 *
 * The translate_isbn1013 function takes an input ISBN and returns the
 * following in a single space-delimited string if the input ISBN is valid:
 *   - The normalized input ISBN (hyphens stripped)
 *   - The normalized input ISBN with a fixed checksum if the checksum was bad
 *   - The ISBN converted to its ISBN10 or ISBN13 counterpart, if possible
 */
';


--
-- Name: tsvector_concat(tsvector, tsvector); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION tsvector_concat(tsvector, tsvector) RETURNS tsvector
    LANGUAGE sql STABLE
    AS $_$
SELECT
	CASE	WHEN $1 IS NULL
			THEN $2
		WHEN $2 IS NULL
			THEN $1
		ELSE $1 || ' ' || $2
	END;
$_$;


ALTER FUNCTION public.tsvector_concat(tsvector, tsvector) OWNER TO evergreen;

--
-- Name: upc(ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION upc(ean13) RETURNS upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'upc_cast_from_ean13';


ALTER FUNCTION public.upc(ean13) OWNER TO evergreen;

--
-- Name: uppercase(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION uppercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return uc(shift);
$$;


ALTER FUNCTION public.uppercase(text) OWNER TO evergreen;

--
-- Name: xml_encode_special_chars(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xml_encode_special_chars(text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_encode_special_chars';


ALTER FUNCTION public.xml_encode_special_chars(text) OWNER TO postgres;

--
-- Name: xml_is_well_formed(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xml_is_well_formed(text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_is_well_formed';


ALTER FUNCTION public.xml_is_well_formed(text) OWNER TO postgres;

--
-- Name: xml_valid(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xml_valid(text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_is_well_formed';


ALTER FUNCTION public.xml_valid(text) OWNER TO postgres;

--
-- Name: xpath_bool(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_bool(text, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_bool';


ALTER FUNCTION public.xpath_bool(text, text) OWNER TO postgres;

--
-- Name: xpath_list(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_list(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_list($1,$2,',')$_$;


ALTER FUNCTION public.xpath_list(text, text) OWNER TO postgres;

--
-- Name: xpath_list(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_list(text, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_list';


ALTER FUNCTION public.xpath_list(text, text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_nodeset(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_nodeset($1,$2,'','')$_$;


ALTER FUNCTION public.xpath_nodeset(text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_nodeset(text, text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_nodeset($1,$2,'',$3)$_$;


ALTER FUNCTION public.xpath_nodeset(text, text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_nodeset(text, text, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_nodeset';


ALTER FUNCTION public.xpath_nodeset(text, text, text, text) OWNER TO postgres;

--
-- Name: xpath_number(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_number(text, text) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_number';


ALTER FUNCTION public.xpath_number(text, text) OWNER TO postgres;

--
-- Name: xpath_string(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_string(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_string';


ALTER FUNCTION public.xpath_string(text, text) OWNER TO postgres;

--
-- Name: xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xpath_table(text, text, text, text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/pgxml', 'xpath_table';


ALTER FUNCTION public.xpath_table(text, text, text, text, text) OWNER TO postgres;

--
-- Name: xslt_process(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xslt_process(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xslt_process';


ALTER FUNCTION public.xslt_process(text, text) OWNER TO postgres;

--
-- Name: xslt_process(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xslt_process(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/pgxml', 'xslt_process';


ALTER FUNCTION public.xslt_process(text, text, text) OWNER TO postgres;

SET search_path = reporter, pg_catalog;

--
-- Name: disable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION disable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$
    DROP TRIGGER IF EXISTS bbb_simple_rec_trigger ON biblio.record_entry;
$$;


ALTER FUNCTION reporter.disable_materialized_simple_record_trigger() OWNER TO evergreen;

--
-- Name: enable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION enable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$

    DELETE FROM reporter.materialized_simple_record;

    INSERT INTO reporter.materialized_simple_record
        (id,fingerprint,quality,tcn_source,tcn_value,title,author,publisher,pubdate,isbn,issn)
        SELECT DISTINCT ON (id) * FROM reporter.old_super_simple_record;

    CREATE TRIGGER bbb_simple_rec_trigger
        AFTER INSERT OR UPDATE OR DELETE ON biblio.record_entry
        FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();

$$;


ALTER FUNCTION reporter.enable_materialized_simple_record_trigger() OWNER TO evergreen;

--
-- Name: refresh_materialized_simple_record(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION refresh_materialized_simple_record() RETURNS void
    LANGUAGE sql
    AS $$
    SELECT reporter.disable_materialized_simple_record_trigger();
    SELECT reporter.enable_materialized_simple_record_trigger();
$$;


ALTER FUNCTION reporter.refresh_materialized_simple_record() OWNER TO evergreen;

--
-- Name: simple_rec_delete(bigint); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION simple_rec_delete(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, TRUE);
$_$;


ALTER FUNCTION reporter.simple_rec_delete(r_id bigint) OWNER TO evergreen;

--
-- Name: simple_rec_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION simple_rec_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM reporter.simple_rec_delete(NEW.id);
    ELSE
        PERFORM reporter.simple_rec_update(NEW.id);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION reporter.simple_rec_trigger() OWNER TO evergreen;

--
-- Name: simple_rec_update(bigint); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION simple_rec_update(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, FALSE);
$_$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint) OWNER TO evergreen;

--
-- Name: simple_rec_update(bigint, boolean); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION simple_rec_update(r_id bigint, deleted boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

    DELETE FROM reporter.materialized_simple_record WHERE id = r_id;

    IF NOT deleted THEN
        INSERT INTO reporter.materialized_simple_record SELECT DISTINCT ON (id) * FROM reporter.old_super_simple_record WHERE id = r_id;
    END IF;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint, deleted boolean) OWNER TO evergreen;

SET search_path = search, pg_catalog;

--
-- Name: query_parser_fts(integer, integer, text, integer[], integer[], integer, integer, integer, boolean, boolean, integer); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, param_pref_ou integer DEFAULT NULL::integer) RETURNS SETOF search_result
    LANGUAGE plpgsql
    AS $$
DECLARE

    current_res         search.search_result%ROWTYPE;
    search_org_list     INT[];
    luri_org_list       INT[];
    tmp_int_list        INT[];

    check_limit         INT;
    core_limit          INT;
    core_offset         INT;
    tmp_int             INT;

    core_result         RECORD;
    core_cursor         REFCURSOR;
    core_rel_query      TEXT;

    total_count         INT := 0;
    check_count         INT := 0;
    deleted_count       INT := 0;
    visible_count       INT := 0;
    excluded_count      INT := 0;

BEGIN

    check_limit := COALESCE( param_check, 1000 );
    core_limit  := COALESCE( param_limit, 25000 );
    core_offset := COALESCE( param_offset, 0 );

    -- core_skip_chk := COALESCE( param_skip_chk, 1 );

    IF param_search_ou > 0 THEN
        IF param_depth IS NOT NULL THEN
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou, param_depth );
        ELSE
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou );
        END IF;

        SELECT array_accum(distinct id) INTO luri_org_list FROM actor.org_unit_ancestors( param_search_ou );

    ELSIF param_search_ou < 0 THEN
        SELECT array_accum(distinct org_unit) INTO search_org_list FROM actor.org_lasso_map WHERE lasso = -param_search_ou;

        FOR tmp_int IN SELECT * FROM UNNEST(search_org_list) LOOP
            SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors( tmp_int );
            luri_org_list := luri_org_list || tmp_int_list;
        END LOOP;

        SELECT array_accum(DISTINCT x.id) INTO luri_org_list FROM UNNEST(luri_org_list) x(id);

    ELSIF param_search_ou = 0 THEN
        -- reserved for user lassos (ou_buckets/type='lasso') with ID passed in depth ... hack? sure.
    END IF;

    IF param_pref_ou IS NOT NULL THEN
        SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors(param_pref_ou);
        luri_org_list := luri_org_list || tmp_int_list;
    END IF;

    OPEN core_cursor FOR EXECUTE param_query;

    LOOP

        FETCH core_cursor INTO core_result;
        EXIT WHEN NOT FOUND;
        EXIT WHEN total_count >= core_limit;

        total_count := total_count + 1;

        CONTINUE WHEN total_count NOT BETWEEN  core_offset + 1 AND check_limit + core_offset;

        check_count := check_count + 1;

        PERFORM 1 FROM biblio.record_entry b WHERE NOT b.deleted AND b.id IN ( SELECT * FROM unnest( core_result.records ) );
        IF NOT FOUND THEN
            -- RAISE NOTICE ' % were all deleted ... ', core_result.records;
            deleted_count := deleted_count + 1;
            CONTINUE;
        END IF;

        PERFORM 1
          FROM  biblio.record_entry b
                JOIN config.bib_source s ON (b.source = s.id)
          WHERE s.transcendant
                AND b.id IN ( SELECT * FROM unnest( core_result.records ) );

        IF FOUND THEN
            -- RAISE NOTICE ' % were all transcendant ... ', core_result.records;
            visible_count := visible_count + 1;

            current_res.id = core_result.id;
            current_res.rel = core_result.rel;

            tmp_int := 1;
            IF metarecord THEN
                SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
            END IF;

            IF tmp_int = 1 THEN
                current_res.record = core_result.records[1];
            ELSE
                current_res.record = NULL;
            END IF;

            RETURN NEXT current_res;

            CONTINUE;
        END IF;

        PERFORM 1
          FROM  asset.call_number cn
                JOIN asset.uri_call_number_map map ON (map.call_number = cn.id)
                JOIN asset.uri uri ON (map.uri = uri.id)
          WHERE NOT cn.deleted
                AND cn.label = '##URI##'
                AND uri.active
                AND ( param_locations IS NULL OR array_upper(param_locations, 1) IS NULL )
                AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                AND cn.owning_lib IN ( SELECT * FROM unnest( luri_org_list ) )
          LIMIT 1;

        IF FOUND THEN
            -- RAISE NOTICE ' % have at least one URI ... ', core_result.records;
            visible_count := visible_count + 1;

            current_res.id = core_result.id;
            current_res.rel = core_result.rel;

            tmp_int := 1;
            IF metarecord THEN
                SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
            END IF;

            IF tmp_int = 1 THEN
                current_res.record = core_result.records[1];
            ELSE
                current_res.record = NULL;
            END IF;

            RETURN NEXT current_res;

            CONTINUE;
        END IF;

        IF param_statuses IS NOT NULL AND array_upper(param_statuses, 1) > 0 THEN

            PERFORM 1
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cp.call_number = cn.id)
              WHERE NOT cn.deleted
                    AND NOT cp.deleted
                    AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                    AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                    AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
              LIMIT 1;

            IF NOT FOUND THEN
                PERFORM 1
                  FROM  biblio.peer_bib_copy_map pr
                        JOIN asset.copy cp ON (cp.id = pr.target_copy)
                  WHERE NOT cp.deleted
                        AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                        AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                -- RAISE NOTICE ' % and multi-home linked records were all status-excluded ... ', core_result.records;
                    excluded_count := excluded_count + 1;
                    CONTINUE;
                END IF;
            END IF;

        END IF;

        IF param_locations IS NOT NULL AND array_upper(param_locations, 1) > 0 THEN

            PERFORM 1
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cp.call_number = cn.id)
              WHERE NOT cn.deleted
                    AND NOT cp.deleted
                    AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                    AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                    AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
              LIMIT 1;

            IF NOT FOUND THEN
                PERFORM 1
                  FROM  biblio.peer_bib_copy_map pr
                        JOIN asset.copy cp ON (cp.id = pr.target_copy)
                  WHERE NOT cp.deleted
                        AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                        AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    -- RAISE NOTICE ' % and multi-home linked records were all copy_location-excluded ... ', core_result.records;
                    excluded_count := excluded_count + 1;
                    CONTINUE;
                END IF;
            END IF;

        END IF;

        IF staff IS NULL OR NOT staff THEN

            PERFORM 1
              FROM  asset.opac_visible_copies
              WHERE circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                    AND record IN ( SELECT * FROM unnest( core_result.records ) )
              LIMIT 1;

            IF NOT FOUND THEN
                PERFORM 1
                  FROM  biblio.peer_bib_copy_map pr
                        JOIN asset.opac_visible_copies cp ON (cp.copy_id = pr.target_copy)
                  WHERE cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN

                    -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                    excluded_count := excluded_count + 1;
                    CONTINUE;
                END IF;
            END IF;

        ELSE

            PERFORM 1
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cp.call_number = cn.id)
              WHERE NOT cn.deleted
                    AND NOT cp.deleted
                    AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                    AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
              LIMIT 1;

            IF NOT FOUND THEN

                PERFORM 1
                  FROM  biblio.peer_bib_copy_map pr
                        JOIN asset.copy cp ON (cp.id = pr.target_copy)
                  WHERE NOT cp.deleted
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN

                    PERFORM 1
                      FROM  asset.call_number cn
                            JOIN asset.copy cp ON (cp.call_number = cn.id)
                      WHERE cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                            AND NOT cp.deleted
                      LIMIT 1;

                    IF FOUND THEN
                        -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            END IF;

        END IF;

        visible_count := visible_count + 1;

        current_res.id = core_result.id;
        current_res.rel = core_result.rel;

        tmp_int := 1;
        IF metarecord THEN
            SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
        END IF;

        IF tmp_int = 1 THEN
            current_res.record = core_result.records[1];
        ELSE
            current_res.record = NULL;
        END IF;

        RETURN NEXT current_res;

        IF visible_count % 1000 = 0 THEN
            -- RAISE NOTICE ' % visible so far ... ', visible_count;
        END IF;

    END LOOP;

    current_res.id = NULL;
    current_res.rel = NULL;
    current_res.record = NULL;
    current_res.total = total_count;
    current_res.checked = check_count;
    current_res.deleted = deleted_count;
    current_res.visible = visible_count;
    current_res.excluded = excluded_count;

    CLOSE core_cursor;

    RETURN NEXT current_res;

END;
$$;


ALTER FUNCTION search.query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, param_pref_ou integer) OWNER TO evergreen;

--
-- Name: query_parser_fts(integer, integer, text, integer[], integer[], integer, integer, integer, boolean, boolean, boolean, integer); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, deleted_search boolean, param_pref_ou integer DEFAULT NULL::integer) RETURNS SETOF search_result
    LANGUAGE plpgsql
    AS $$
DECLARE

    current_res         search.search_result%ROWTYPE;
    search_org_list     INT[];
    luri_org_list       INT[];
    tmp_int_list        INT[];

    check_limit         INT;
    core_limit          INT;
    core_offset         INT;
    tmp_int             INT;

    core_result         RECORD;
    core_cursor         REFCURSOR;
    core_rel_query      TEXT;

    total_count         INT := 0;
    check_count         INT := 0;
    deleted_count       INT := 0;
    visible_count       INT := 0;
    excluded_count      INT := 0;

BEGIN

    check_limit := COALESCE( param_check, 1000 );
    core_limit  := COALESCE( param_limit, 25000 );
    core_offset := COALESCE( param_offset, 0 );

    -- core_skip_chk := COALESCE( param_skip_chk, 1 );

    IF param_search_ou > 0 THEN
        IF param_depth IS NOT NULL THEN
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou, param_depth );
        ELSE
            SELECT array_accum(distinct id) INTO search_org_list FROM actor.org_unit_descendants( param_search_ou );
        END IF;

        SELECT array_accum(distinct id) INTO luri_org_list FROM actor.org_unit_ancestors( param_search_ou );

    ELSIF param_search_ou < 0 THEN
        SELECT array_accum(distinct org_unit) INTO search_org_list FROM actor.org_lasso_map WHERE lasso = -param_search_ou;

        FOR tmp_int IN SELECT * FROM UNNEST(search_org_list) LOOP
            SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors( tmp_int );
            luri_org_list := luri_org_list || tmp_int_list;
        END LOOP;

        SELECT array_accum(DISTINCT x.id) INTO luri_org_list FROM UNNEST(luri_org_list) x(id);

    ELSIF param_search_ou = 0 THEN
        -- reserved for user lassos (ou_buckets/type='lasso') with ID passed in depth ... hack? sure.
    END IF;

    IF param_pref_ou IS NOT NULL THEN
        SELECT array_accum(distinct id) INTO tmp_int_list FROM actor.org_unit_ancestors(param_pref_ou);
        luri_org_list := luri_org_list || tmp_int_list;
    END IF;

    OPEN core_cursor FOR EXECUTE param_query;

    LOOP

        FETCH core_cursor INTO core_result;
        EXIT WHEN NOT FOUND;
        EXIT WHEN total_count >= core_limit;

        total_count := total_count + 1;

        CONTINUE WHEN total_count NOT BETWEEN  core_offset + 1 AND check_limit + core_offset;

        check_count := check_count + 1;

        IF NOT deleted_search THEN

            PERFORM 1 FROM biblio.record_entry b WHERE NOT b.deleted AND b.id IN ( SELECT * FROM unnest( core_result.records ) );
            IF NOT FOUND THEN
                -- RAISE NOTICE ' % were all deleted ... ', core_result.records;
                deleted_count := deleted_count + 1;
                CONTINUE;
            END IF;

            PERFORM 1
              FROM  biblio.record_entry b
                    JOIN config.bib_source s ON (b.source = s.id)
              WHERE s.transcendant
                    AND b.id IN ( SELECT * FROM unnest( core_result.records ) );

            IF FOUND THEN
                -- RAISE NOTICE ' % were all transcendant ... ', core_result.records;
                visible_count := visible_count + 1;

                current_res.id = core_result.id;
                current_res.rel = core_result.rel;

                tmp_int := 1;
                IF metarecord THEN
                    SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
                END IF;

                IF tmp_int = 1 THEN
                    current_res.record = core_result.records[1];
                ELSE
                    current_res.record = NULL;
                END IF;

                RETURN NEXT current_res;

                CONTINUE;
            END IF;

            PERFORM 1
              FROM  asset.call_number cn
                    JOIN asset.uri_call_number_map map ON (map.call_number = cn.id)
                    JOIN asset.uri uri ON (map.uri = uri.id)
              WHERE NOT cn.deleted
                    AND cn.label = '##URI##'
                    AND uri.active
                    AND ( param_locations IS NULL OR array_upper(param_locations, 1) IS NULL )
                    AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                    AND cn.owning_lib IN ( SELECT * FROM unnest( luri_org_list ) )
              LIMIT 1;

            IF FOUND THEN
                -- RAISE NOTICE ' % have at least one URI ... ', core_result.records;
                visible_count := visible_count + 1;

                current_res.id = core_result.id;
                current_res.rel = core_result.rel;

                tmp_int := 1;
                IF metarecord THEN
                    SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
                END IF;

                IF tmp_int = 1 THEN
                    current_res.record = core_result.records[1];
                ELSE
                    current_res.record = NULL;
                END IF;

                RETURN NEXT current_res;

                CONTINUE;
            END IF;

            IF param_statuses IS NOT NULL AND array_upper(param_statuses, 1) > 0 THEN

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.status IN ( SELECT * FROM unnest( param_statuses ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                      LIMIT 1;

                    IF NOT FOUND THEN
                    -- RAISE NOTICE ' % and multi-home linked records were all status-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            END IF;

            IF param_locations IS NOT NULL AND array_upper(param_locations, 1) > 0 THEN

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.location IN ( SELECT * FROM unnest( param_locations ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                      LIMIT 1;

                    IF NOT FOUND THEN
                        -- RAISE NOTICE ' % and multi-home linked records were all copy_location-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            END IF;

            IF staff IS NULL OR NOT staff THEN

                PERFORM 1
                  FROM  asset.opac_visible_copies
                  WHERE circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN
                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.opac_visible_copies cp ON (cp.copy_id = pr.target_copy)
                      WHERE cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                      LIMIT 1;

                    IF NOT FOUND THEN

                        -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                        excluded_count := excluded_count + 1;
                        CONTINUE;
                    END IF;
                END IF;

            ELSE

                PERFORM 1
                  FROM  asset.call_number cn
                        JOIN asset.copy cp ON (cp.call_number = cn.id)
                  WHERE NOT cn.deleted
                        AND NOT cp.deleted
                        AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                        AND cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                  LIMIT 1;

                IF NOT FOUND THEN

                    PERFORM 1
                      FROM  biblio.peer_bib_copy_map pr
                            JOIN asset.copy cp ON (cp.id = pr.target_copy)
                      WHERE NOT cp.deleted
                            AND cp.circ_lib IN ( SELECT * FROM unnest( search_org_list ) )
                            AND pr.peer_record IN ( SELECT * FROM unnest( core_result.records ) )
                      LIMIT 1;

                    IF NOT FOUND THEN

                        PERFORM 1
                          FROM  asset.call_number cn
                                JOIN asset.copy cp ON (cp.call_number = cn.id)
                          WHERE cn.record IN ( SELECT * FROM unnest( core_result.records ) )
                                AND NOT cp.deleted
                          LIMIT 1;

                        IF FOUND THEN
                            -- RAISE NOTICE ' % and multi-home linked records were all visibility-excluded ... ', core_result.records;
                            excluded_count := excluded_count + 1;
                            CONTINUE;
                        END IF;
                    END IF;

                END IF;

            END IF;

        END IF;

        visible_count := visible_count + 1;

        current_res.id = core_result.id;
        current_res.rel = core_result.rel;

        tmp_int := 1;
        IF metarecord THEN
            SELECT COUNT(DISTINCT s.source) INTO tmp_int FROM metabib.metarecord_source_map s WHERE s.metarecord = core_result.id;
        END IF;

        IF tmp_int = 1 THEN
            current_res.record = core_result.records[1];
        ELSE
            current_res.record = NULL;
        END IF;

        RETURN NEXT current_res;

        IF visible_count % 1000 = 0 THEN
            -- RAISE NOTICE ' % visible so far ... ', visible_count;
        END IF;

    END LOOP;

    current_res.id = NULL;
    current_res.rel = NULL;
    current_res.record = NULL;
    current_res.total = total_count;
    current_res.checked = check_count;
    current_res.deleted = deleted_count;
    current_res.visible = visible_count;
    current_res.excluded = excluded_count;

    CLOSE core_cursor;

    RETURN NEXT current_res;

END;
$$;


ALTER FUNCTION search.query_parser_fts(param_search_ou integer, param_depth integer, param_query text, param_statuses integer[], param_locations integer[], param_offset integer, param_check integer, param_limit integer, metarecord boolean, staff boolean, deleted_search boolean, param_pref_ou integer) OWNER TO evergreen;

SET search_path = serial, pg_catalog;

--
-- Name: materialize_holding_code(); Type: FUNCTION; Schema: serial; Owner: evergreen
--

CREATE FUNCTION materialize_holding_code() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$ 
use strict;

use MARC::Field;
use JSON::XS;

if (not defined $_TD->{new}{holding_code}) {
    elog(WARNING, 'NULL in "holding_code" column of serial.issuance allowed for now, but may not be useful');
    return;
}

# Do nothing if holding_code has not changed...

if ($_TD->{new}{holding_code} eq $_TD->{old}{holding_code}) {
    # ... unless the following internal flag is set.

    my $flag_rv = spi_exec_query(q{
        SELECT * FROM config.internal_flag
        WHERE name = 'serial.rematerialize_on_same_holding_code' AND enabled
    }, 1);
    return unless $flag_rv->{processed};
}


my $holding_code = (new JSON::XS)->decode($_TD->{new}{holding_code});

my $field = new MARC::Field('999', @$holding_code); # tag doesnt matter

my $dstmt = spi_prepare(
    'DELETE FROM serial.materialized_holding_code WHERE issuance = $1',
    'INT'
);
spi_exec_prepared($dstmt, $_TD->{new}{id});

my $istmt = spi_prepare(
    q{
        INSERT INTO serial.materialized_holding_code (
            issuance, subfield, value
        ) VALUES ($1, $2, $3)
    }, qw{INT CHAR TEXT}
);

foreach ($field->subfields) {
    spi_exec_prepared(
        $istmt,
        $_TD->{new}{id},
        $_->[0],
        $_->[1]
    );
}

return;

$_X$;


ALTER FUNCTION serial.materialize_holding_code() OWNER TO evergreen;

SET search_path = unapi, pg_catalog;

--
-- Name: acl(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name location,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible,
                    label_prefix AS prefix,
                    label_suffix AS suffix
                ),
                name
            )
      FROM  asset.copy_location
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acn(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name volume,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acn/' || acn.id AS id,
                        acn.id AS vol_id, o.shortname AS lib,
                        o.opac_visible AS opac_visible,
                        deleted, label, label_sortkey, label_class, record
                    ),
                    unapi.aou( owning_lib, $2, 'owning_lib', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            CASE WHEN $6 IS NOT NULL THEN
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp_status(cp.status) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5), $6) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            ELSE
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp_status(cp.status) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5) ) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            END
                        ELSE NULL
                    END,
                    XMLELEMENT(
                        name uris,
                        (SELECT XMLAGG(auri) FROM (SELECT unapi.auri(uri,'xml','uri', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE call_number = acn.id)x)
                    ),
                    unapi.acnp( acn.prefix, 'marcxml', 'prefix', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                    unapi.acns( acn.suffix, 'marcxml', 'suffix', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE),
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( acn.record, 'marcxml', 'record', evergreen.array_remove_item_by_value($4,'acn'), $5, $6, $7, $8, FALSE) ELSE NULL END
                ) AS x
          FROM  asset.call_number acn
                JOIN actor.org_unit o ON (o.id = acn.owning_lib)
          WHERE acn.id = $1
              AND acn.deleted IS FALSE
          GROUP BY acn.id, o.shortname, o.opac_visible, deleted, label, label_sortkey, label_class, owning_lib, record, acn.prefix, acn.suffix;
$_$;


ALTER FUNCTION unapi.acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acnp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_prefix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_prefix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acns(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_suffix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_suffix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect
                    ),
                    unapi.ccs( status, $2, 'status', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('acpn' = ANY ($4)) THEN
                            XMLELEMENT( name copy_notes,
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('ascecm' = ANY ($4)) THEN
                            XMLELEMENT( name statcats,
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE
                        WHEN ('bre' = ANY ($4)) THEN
                            XMLELEMENT( name foreign_records,
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)

                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  asset.copy cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, deposit, ref, holdable,
              deleted, deposit_amount, price, barcode, circ_modifier,
              circ_as_type, opac_visible, age_protect;
$_$;


ALTER FUNCTION unapi.acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acpn(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy_note,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        create_date AS date,
                        title
                    ),
                    value
                )
          FROM  asset.copy_note
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: aou(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    output XML;
BEGIN
    IF ename = 'circlib' THEN
        SELECT  XMLELEMENT(
                    name circlib,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        id AS ident
                    ),
                    name
                ) INTO output
          FROM  actor.org_unit aou
          WHERE id = obj_id;
    ELSE
        EXECUTE $$SELECT  XMLELEMENT(
                    name $$ || ename || $$,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        'tag:open-ils.org:U2@aou/' || id AS id,
                        shortname, name, opac_visible
                    )
                )
          FROM  actor.org_unit aou
         WHERE id = $1 $$ INTO output USING obj_id;
    END IF;

    RETURN output;

END;
$_$;


ALTER FUNCTION unapi.aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: ascecm(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name statcat,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        sc.name,
                        sc.opac_visible
                    ),
                    asce.value
                )
          FROM  asset.stat_cat_entry asce
                JOIN asset.stat_cat sc ON (sc.id = asce.stat_cat)
          WHERE asce.id = $1;
$_$;


ALTER FUNCTION unapi.ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: auri(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name uri,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@auri/' || uri.id AS id,
                        use_restriction,
                        href,
                        label
                    ),
                    CASE 
                        WHEN ('acn' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acn) FROM (SELECT unapi.acn( call_number, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'auri'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE uri = uri.id)x)
                            )
                        ELSE NULL
                    END
                ) AS x
          FROM  asset.uri uri
          WHERE uri.id = $1
          GROUP BY uri.id, use_restriction, href, label;
$_$;


ALTER FUNCTION unapi.auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: biblio_record_entry_feed(bigint[], text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, text, text, text, text, text, xml); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, title text DEFAULT NULL::text, description text DEFAULT NULL::text, creator text DEFAULT NULL::text, update_ts text DEFAULT NULL::text, unapi_url text DEFAULT NULL::text, header_xml xml DEFAULT NULL::xml) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    layout          unapi.bre_output_layout%ROWTYPE;
    transform       config.xml_transform%ROWTYPE;
    item_format     TEXT;
    tmp_xml         TEXT;
    xmlns_uri       TEXT := 'http://open-ils.org/spec/feed-xml/v1';
    ouid            INT;
    element_list    TEXT[];
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;
    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO transform FROM config.xml_transform WHERE name = layout.transform;
    xmlns_uri := COALESCE(transform.namespace_uri,xmlns_uri);

    -- Gather the bib xml
    SELECT XMLAGG( unapi.bre(i, format, '', includes, org, depth, slimit, soffset, include_xmlns)) INTO tmp_xml FROM UNNEST( id_list ) i;

    IF layout.title_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.title_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, title;
    END IF;

    IF layout.description_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.description_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, description;
    END IF;

    IF layout.creator_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.creator_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, creator;
    END IF;

    IF layout.update_ts_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.update_ts_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, update_ts;
    END IF;

    IF unapi_url IS NOT NULL THEN
        EXECUTE $$SELECT XMLCONCAT( XMLELEMENT( name link, XMLATTRIBUTES( 'http://www.w3.org/1999/xhtml' AS xmlns, 'unapi-server' AS rel, $1 AS href, 'unapi' AS title)), $2)$$ INTO tmp_xml USING unapi_url, tmp_xml::XML;
    END IF;

    IF header_xml IS NOT NULL THEN tmp_xml := XMLCONCAT(header_xml,tmp_xml::XML); END IF;

    element_list := regexp_split_to_array(layout.feed_top,E'\\.');
    FOR i IN REVERSE ARRAY_UPPER(element_list, 1) .. 1 LOOP
        EXECUTE 'SELECT XMLELEMENT( name '|| quote_ident(element_list[i]) ||', XMLATTRIBUTES( $1 AS xmlns), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML;
    END LOOP;

    RETURN tmp_xml::XML;
END;
$_$;


ALTER FUNCTION unapi.biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, title text, description text, creator text, update_ts text, unapi_url text, header_xml xml) OWNER TO evergreen;

--
-- Name: bmp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name monograph_part,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@bmp/' || id AS id,
                        id AS ident,
                        label,
                        label_sortkey,
                        'tag:open-ils.org:U2@bre/' || record AS record
                    ),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acp) FROM (
                                    SELECT  unapi.acp( cp.id, 'xml', 'copy', evergreen.array_remove_item_by_value($4,'bmp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy cp
                                            JOIN asset.copy_part_map cpm ON (cpm.target_copy = cp.id)
                                      WHERE cpm.part = $1
                                          AND cp.deleted IS FALSE
                                      ORDER BY COALESCE(cp.copy_number,0), cp.barcode
                                      LIMIT ($7 -> 'acp')::INT
                                      OFFSET ($8 -> 'acp')::INT

                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( record, 'marcxml', 'record', evergreen.array_remove_item_by_value($4,'bmp'), $5, $6, $7, $8, FALSE) ELSE NULL END
                )
          FROM  biblio.monograph_part
          WHERE id = $1
          GROUP BY id, label, label_sortkey, record;
$_$;


ALTER FUNCTION unapi.bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: bre(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    me      biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    tmp_xml TEXT;
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;

    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.holdings_xml( obj_id, ouid, org, depth, includes, slimit, soffset, include_xmlns);
        RETURN output;
    END IF;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

    SELECT * INTO me FROM biblio.record_entry WHERE id = obj_id;

    -- grab SVF if we need them
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mra(obj_id,NULL,NULL,NULL,NULL);
    ELSE
        axml := NULL::XML;
    END IF;

    -- grab holdings if we need them
    IF ('holdings_xml' = ANY (includes)) THEN 
        hxml := unapi.holdings_xml(obj_id, ouid, org, depth, evergreen.array_remove_item_by_value(includes,'holdings_xml'), slimit, soffset, include_xmlns, pref_lib);
    ELSE
        hxml := NULL::XML;
    END IF;


    -- generate our item node


    IF format = 'marcxml' THEN
        tmp_xml := me.marc;
        IF tmp_xml !~ E'<marc:' THEN -- If we're not using the prefixed namespace in this record, then remove all declarations of it
           tmp_xml := REGEXP_REPLACE(tmp_xml, ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        tmp_xml := oils_xslt_process(me.marc, xfrm.xslt)::XML;
    END IF;

    top_el := REGEXP_REPLACE(tmp_xml, E'^.*?<((?:\\S+:)?' || layout.holdings_element || ').*$', E'\\1');

    IF axml IS NOT NULL THEN 
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN -- XXX how do we configure the holdings position?
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

    IF ('bre.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@bre/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: bre_profiling(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION bre_profiling(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    me      biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    tmp_xml TEXT;
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
diff    interval;
current     timestamp with time zone;
BEGIN
current = clock_timestamp();
RAISE NOTICE 'PROFILING: Function start %', current;
    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 1 % DIFF: %', current, diff;

    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.holdings_xml( obj_id, ouid, org, depth, includes, slimit, soffset, include_xmlns);
        RETURN output;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 2 % DIFF: %', current, diff;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 3 % DIFF: %', current, diff;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 4 % DIFF: %', current, diff;

    SELECT * INTO me FROM biblio.record_entry WHERE id = obj_id;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 5 % DIFF: %', current, diff;

    -- grab SVF if we need them
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mra(obj_id,NULL,NULL,NULL,NULL);
    ELSE
        axml := NULL::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 6 % DIFF: %', current, diff;

    -- grab holdings if we need them
    IF ('holdings_xml' = ANY (includes)) THEN 
        hxml := unapi.holdings_xml(obj_id, ouid, org, depth, evergreen.array_remove_item_by_value(includes,'holdings_xml'), slimit, soffset, include_xmlns, pref_lib);
    ELSE
        hxml := NULL::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 7 % DIFF: %', current, diff;


    -- generate our item node


    IF format = 'marcxml' THEN
        tmp_xml := me.marc;
        IF tmp_xml !~ E'<marc:' THEN -- If we're not using the prefixed namespace in this record, then remove all declarations of it
           tmp_xml := REGEXP_REPLACE(tmp_xml, ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        tmp_xml := oils_xslt_process(me.marc, xfrm.xslt)::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 8 % DIFF: %', current, diff;

    top_el := REGEXP_REPLACE(tmp_xml, E'^.*?<((?:\\S+:)?' || layout.holdings_element || ').*$', E'\\1');

    IF axml IS NOT NULL THEN 
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN -- XXX how do we configure the holdings position?
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 9 % DIFF: %', current, diff;

    IF ('bre.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@bre/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 10 % DIFF: %', current, diff;

    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: END: % DIFF: %', current, diff;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.bre_profiling(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO postgres;

--
-- Name: ccs(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name status,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible
                ),
                name
            )
      FROM  config.copy_status
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: circ(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION circ(obj_id bigint, format text, ename text, includes text[], org text DEFAULT '-'::text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT XMLELEMENT(
        name circ,
        XMLATTRIBUTES(
            CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
            'tag:open-ils.org:U2@circ/' || id AS id,
            xact_start,
            due_date
        ),
        CASE WHEN ('aou' = ANY ($4)) THEN unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END,
        CASE WHEN ('acp' = ANY ($4)) THEN unapi.acp( circ_lib, $2, 'target_copy', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END
    )
    FROM action.circulation
    WHERE id = $1;
$_$;


ALTER FUNCTION unapi.circ(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: holdings_xml(bigint, integer, text, integer, text[], evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION holdings_xml(bid bigint, ouid integer, org text, depth integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[], slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
     SELECT  XMLELEMENT(
                 name holdings,
                 XMLATTRIBUTES(
                    CASE WHEN $8 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    CASE WHEN ('bre' = ANY ($5)) THEN 'tag:open-ils.org:U2@bre/' || $1 || '/' || $3 ELSE NULL END AS id,
                    (SELECT record_has_holdable_copy FROM asset.record_has_holdable_copy($1)) AS has_holdable
                 ),
                 XMLELEMENT(
                     name counts,
                     (SELECT  XMLAGG(XMLELEMENT::XML) FROM (
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('public' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($2,  $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('staff' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.staff_ou_record_copy_count($2, $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('pref_lib' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($9,  $1)
                                     ORDER BY 1
                     )x)
                 ),
                 CASE 
                     WHEN ('bmp' = ANY ($5)) THEN
                        XMLELEMENT(
                            name monograph_parts,
                            (SELECT XMLAGG(bmp) FROM (
                                SELECT  unapi.bmp( id, 'xml', 'monograph_part', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'bre'), 'holdings_xml'), $3, $4, $6, $7, FALSE)
                                  FROM  biblio.monograph_part
                                  WHERE record = $1
                            )x)
                        )
                     ELSE NULL
                 END,
                 XMLELEMENT(
                     name volumes,
                     (SELECT XMLAGG(acn ORDER BY rank, name, label_sortkey) FROM (
                        -- Physical copies
                        SELECT  unapi.acn(y.id,'xml','volume',evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), y.rank, name, label_sortkey
                        FROM evergreen.ranked_volumes($1, $2, $4, $6, $7, $9, $5) AS y
                        UNION ALL
                        -- Located URIs
                        SELECT unapi.acn(uris.id,'xml','volume',evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), 0, name, label_sortkey
                        FROM evergreen.located_uris($1, $2, $9) AS uris
                     )x)
                 ),
                 CASE WHEN ('ssub' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name subscriptions,
                         (SELECT XMLAGG(ssub) FROM (
                            SELECT  unapi.ssub(id,'xml','subscription','{}'::TEXT[], $3, $4, $6, $7, FALSE)
                              FROM  serial.subscription
                              WHERE record_entry = $1
                        )x)
                     )
                 ELSE NULL END,
                 CASE WHEN ('acp' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name foreign_copies,
                         (SELECT XMLAGG(acp) FROM (
                            SELECT  unapi.acp(p.target_copy,'xml','copy',evergreen.array_remove_item_by_value($5,'acp'), $3, $4, $6, $7, FALSE)
                              FROM  biblio.peer_bib_copy_map p
                                    JOIN asset.copy c ON (p.target_copy = c.id)
                              WHERE NOT c.deleted AND p.peer_record = $1
                            LIMIT ($6 -> 'acp')::INT
                            OFFSET ($7 -> 'acp')::INT
                        )x)
                     )
                 ELSE NULL END
             );
$_$;


ALTER FUNCTION unapi.holdings_xml(bid bigint, ouid integer, org text, depth integer, includes text[], slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: memoize(text, bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    key     TEXT;
    output  XML;
BEGIN
    key :=
        'id'        || COALESCE(obj_id::TEXT,'') ||
        'format'    || COALESCE(format::TEXT,'') ||
        'ename'     || COALESCE(ename::TEXT,'') ||
        'includes'  || COALESCE(includes::TEXT,'{}'::TEXT[]::TEXT) ||
        'org'       || COALESCE(org::TEXT,'') ||
        'depth'     || COALESCE(depth::TEXT,'') ||
        'slimit'    || COALESCE(slimit::TEXT,'') ||
        'soffset'   || COALESCE(soffset::TEXT,'') ||
        'include_xmlns'   || COALESCE(include_xmlns::TEXT,'');
    -- RAISE NOTICE 'memoize key: %', key;

    key := MD5(key);
    -- RAISE NOTICE 'memoize hash: %', key;

    -- XXX cache logic ... memcached? table?

    EXECUTE $$SELECT unapi.$$ || classname || $$( $1, $2, $3, $4, $5, $6, $7, $8, $9);$$ INTO output USING obj_id, format, ename, includes, org, depth, slimit, soffset, include_xmlns;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: mra(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name attributes,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/indexing/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@mra/' || mra.id AS id,
                        'tag:open-ils.org:U2@bre/' || mra.id AS record
                    ),
                    (SELECT XMLAGG(foo.y)
                      FROM (SELECT XMLELEMENT(
                                name field,
                                XMLATTRIBUTES(
                                    key AS name,
                                    cvm.value AS "coded-value",
                                    rad.filter,
                                    rad.sorter
                                ),
                                x.value
                            )
                           FROM EACH(mra.attrs) AS x
                                JOIN config.record_attr_definition rad ON (x.key = rad.name)
                                LEFT JOIN config.coded_value_map cvm ON (cvm.ctype = x.key AND code = x.value)
                        )foo(y)
                    )
                )
          FROM  metabib.record_attr mra
          WHERE mra.id = $1;
$_$;


ALTER FUNCTION unapi.mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sbsum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sbsum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.basic_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sdist(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name distribution,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sdist/' || id AS id,
            			'tag:open-ils.org:U2@acn/' || receive_call_number AS receive_call_number,
			            'tag:open-ils.org:U2@acn/' || bind_call_number AS bind_call_number,
                        unit_label_prefix, label, unit_label_suffix, summary_method
                    ),
                    unapi.aou( holding_lib, $2, 'holding_lib', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8),
                    CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('sstr' = ANY ($4)) THEN
                            XMLELEMENT( name streams,
                                (SELECT XMLAGG(sstr) FROM (
                                    SELECT  unapi.sstr( id, 'xml', 'stream', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.stream
                                      WHERE distribution = sdist.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    XMLELEMENT( name summaries,
                        CASE 
                            WHEN ('sbsum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sbsum) FROM (
                                    SELECT  unapi.sbsum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.basic_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sisum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sisum) FROM (
                                    SELECT  unapi.sisum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.index_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sssum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sssum) FROM (
                                    SELECT  unapi.sssum( id, 'xml', 'serial_summary', evergreen.array_remove_item_by_value($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.supplement_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END
                    )
                )
          FROM  serial.distribution sdist
          WHERE id = $1
          GROUP BY id, label, unit_label_prefix, unit_label_suffix, holding_lib, summary_method, subscription, receive_call_number, bind_call_number;
$_$;


ALTER FUNCTION unapi.sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: siss(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name issuance,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@siss/' || id AS id,
                    create_date, edit_date, label, date_published,
                    holding_code, holding_type, holding_link_id
                ),
                CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', evergreen.array_remove_item_by_value($4,'siss'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', evergreen.array_remove_item_by_value($4,'siss'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE issuance = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.issuance sstr
      WHERE id = $1
      GROUP BY id, create_date, edit_date, label, date_published, holding_code, holding_type, holding_link_id, subscription;
$_$;


ALTER FUNCTION unapi.siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sisum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sisum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.index_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sitem(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_item,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sitem/' || id AS id,
                        'tag:open-ils.org:U2@siss/' || issuance AS issuance,
                        date_expected, date_received
                    ),
                    CASE WHEN issuance IS NOT NULL AND ('siss' = ANY ($4)) THEN unapi.siss( issuance, $2, 'issuance', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN stream IS NOT NULL AND ('sstr' = ANY ($4)) THEN unapi.sstr( stream, $2, 'stream', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN unit IS NOT NULL AND ('sunit' = ANY ($4)) THEN unapi.sunit( unit, $2, 'serial_unit', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN uri IS NOT NULL AND ('auri' = ANY ($4)) THEN unapi.auri( uri, $2, 'uri', evergreen.array_remove_item_by_value($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END
--                    XMLELEMENT( name notes,
--                        CASE 
--                            WHEN ('acpn' = ANY ($4)) THEN
--                                (SELECT XMLAGG(acpn) FROM (
--                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8)
--                                      FROM  asset.copy_note
--                                      WHERE owning_copy = cp.id AND pub
--                                )x)
--                            ELSE NULL
--                        END
--                    )
                )
          FROM  serial.item sitem
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sssum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sssum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.supplement_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sstr(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name stream,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sstr/' || id AS id,
                    routing_label
                ),
                CASE WHEN distribution IS NOT NULL AND ('sdist' = ANY ($4)) THEN unapi.sssum( distribution, 'xml', 'distribtion', evergreen.array_remove_item_by_value($4,'sstr'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', evergreen.array_remove_item_by_value($4,'sstr'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE stream = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.stream sstr
      WHERE id = $1
      GROUP BY id, routing_label, distribution;
$_$;


ALTER FUNCTION unapi.sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: ssub(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name subscription,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@ssub/' || id AS id,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        start_date AS start, end_date AS end, expected_date_offset
                    ),
                    CASE 
                        WHEN ('sdist' = ANY ($4)) THEN
                            XMLELEMENT( name distributions,
                                (SELECT XMLAGG(sdist) FROM (
                                    SELECT  unapi.sdist( id, 'xml', 'distribution', evergreen.array_remove_item_by_value($4,'ssub'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.distribution
                                      WHERE subscription = ssub.id
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.subscription ssub
          WHERE id = $1
          GROUP BY id, start_date, end_date, expected_date_offset, owning_lib;
$_$;


ALTER FUNCTION unapi.ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sunit(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_unit,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect,
                        status_changed_time, floating, mint_condition,
                        detailed_contents, sort_key, summary_contents, cost 
                    ),
                    unapi.ccs( status, $2, 'status', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    XMLELEMENT( name copy_notes,
                        CASE 
                            WHEN ('acpn' = ANY ($4)) THEN
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', evergreen.array_remove_item_by_value( evergreen.array_remove_item_by_value($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name statcats,
                        CASE 
                            WHEN ('ascecm' = ANY ($4)) THEN
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name foreign_records,
                        CASE
                            WHEN ('bre' = ANY ($4)) THEN
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', evergreen.array_remove_item_by_value($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', evergreen.array_remove_item_by_value($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.unit cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, floating, mint_condition,
              deposit, ref, holdable, deleted, deposit_amount, price,
              barcode, circ_modifier, circ_as_type, opac_visible,
              status_changed_time, detailed_contents, sort_key,
              summary_contents, cost, age_protect;
$_$;


ALTER FUNCTION unapi.sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

SET search_path = url_verify, pg_catalog;

--
-- Name: extract_urls(integer, integer); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION extract_urls(session_id integer, item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    last_seen_tag TEXT;
    current_tag TEXT;
    current_sf TEXT;
    current_url TEXT;
    current_ord INT;
    current_url_pos INT;
    current_selector url_verify.url_selector%ROWTYPE;
BEGIN
    current_ord := 1;

    FOR current_selector IN SELECT * FROM url_verify.url_selector s WHERE s.session = session_id LOOP
        current_url_pos := 1;
        LOOP
            SELECT  (XPATH(current_selector.xpath || '/text()', b.marc::XML))[current_url_pos]::TEXT INTO current_url
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            EXIT WHEN current_url IS NULL;

            SELECT  (XPATH(current_selector.xpath || '/../@tag', b.marc::XML))[current_url_pos]::TEXT INTO current_tag
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            IF current_tag IS NULL THEN
                current_tag := last_seen_tag;
            ELSE
                last_seen_tag := current_tag;
            END IF;

            SELECT  (XPATH(current_selector.xpath || '/@code', b.marc::XML))[current_url_pos]::TEXT INTO current_sf
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            INSERT INTO url_verify.url (session, item, url_selector, tag, subfield, ord, full_url)
              VALUES ( session_id, item_id, current_selector.id, current_tag, current_sf, current_ord, current_url);

            current_url_pos := current_url_pos + 1;
            current_ord := current_ord + 1;
        END LOOP;
    END LOOP;

    RETURN current_ord - 1;
END;
$$;


ALTER FUNCTION url_verify.extract_urls(session_id integer, item_id integer) OWNER TO evergreen;

--
-- Name: ingest_url(); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION ingest_url() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_row url_verify.url%ROWTYPE;
BEGIN
    SELECT * INTO tmp_row FROM url_verify.parse_url(NEW.full_url);

    NEW.scheme          := tmp_row.scheme;
    NEW.username        := tmp_row.username;
    NEW.password        := tmp_row.password;
    NEW.host            := tmp_row.host;
    NEW.domain          := tmp_row.domain;
    NEW.tld             := tmp_row.tld;
    NEW.port            := tmp_row.port;
    NEW.path            := tmp_row.path;
    NEW.page            := tmp_row.page;
    NEW.query           := tmp_row.query;
    NEW.fragment        := tmp_row.fragment;

    RETURN NEW;
END;
$$;


ALTER FUNCTION url_verify.ingest_url() OWNER TO evergreen;

--
-- Name: url; Type: TABLE; Schema: url_verify; Owner: evergreen; Tablespace: 
--

CREATE TABLE url (
    id integer NOT NULL,
    redirect_from integer,
    item integer,
    url_selector integer,
    session integer,
    tag text,
    subfield text,
    ord integer,
    full_url text NOT NULL,
    scheme text,
    username text,
    password text,
    host text,
    domain text,
    tld text,
    port text,
    path text,
    page text,
    query text,
    fragment text,
    CONSTRAINT redirect_or_from_item CHECK (((redirect_from IS NOT NULL) OR (((((item IS NOT NULL) AND (url_selector IS NOT NULL)) AND (tag IS NOT NULL)) AND (subfield IS NOT NULL)) AND (ord IS NOT NULL))))
);


ALTER TABLE url_verify.url OWNER TO evergreen;

--
-- Name: parse_url(text); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION parse_url(url_in text) RETURNS url
    LANGUAGE plperlu
    AS $_X$

use Rose::URI;

my $url_in = shift;
my $url = Rose::URI->new($url_in);

my %parts = map { $_ => $url->$_ } qw/scheme username password host port path query fragment/;

$parts{full_url} = $url_in;
($parts{domain} = $parts{host}) =~ s/^[^.]+\.//;
($parts{tld} = $parts{domain}) =~ s/(?:[^.]+\.)+//;
($parts{page} = $parts{path}) =~ s#(?:[^/]*/)+##;

return \%parts;

$_X$;


ALTER FUNCTION url_verify.parse_url(url_in text) OWNER TO evergreen;

SET search_path = vandelay, pg_catalog;

--
-- Name: match_set_point; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE match_set_point (
    id integer NOT NULL,
    match_set integer,
    parent integer,
    bool_op text,
    svf text,
    tag text,
    subfield text,
    negate boolean DEFAULT false,
    quality integer DEFAULT 1 NOT NULL,
    CONSTRAINT match_set_point_bool_op_check CHECK (((bool_op IS NULL) OR (bool_op = ANY (ARRAY['AND'::text, 'OR'::text, 'NOT'::text])))),
    CONSTRAINT vmsp_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsp_need_a_tag_or_a_ff_or_a_bo CHECK ((((((tag IS NOT NULL) AND (svf IS NULL)) AND (bool_op IS NULL)) OR (((tag IS NULL) AND (svf IS NOT NULL)) AND (bool_op IS NULL))) OR (((tag IS NULL) AND (svf IS NULL)) AND (bool_op IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_point OWNER TO evergreen;

--
-- Name: _get_expr_push_jrow(match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _get_expr_push_jrow(node match_set_point, tags_rstore evergreen.hstore) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jrow        TEXT;
    my_alias    TEXT;
    op          TEXT;
    tagkey      TEXT;
    caseless    BOOL;
    jrow_count  INT;
    my_using    TEXT;
    my_join     TEXT;
BEGIN
    -- remember $1 is tags_rstore, and $2 is svf_rstore

    caseless := FALSE;
    SELECT COUNT(*) INTO jrow_count FROM _vandelay_tmp_jrows;
    IF jrow_count > 0 THEN
        my_using := ' USING (record)';
        my_join := 'FULL OUTER JOIN';
    ELSE
        my_using := '';
        my_join := 'FROM';
    END IF;

    IF node.tag IS NOT NULL THEN
        caseless := (node.tag IN ('020', '022', '024'));
        tagkey := node.tag;
        IF node.subfield IS NOT NULL THEN
            tagkey := tagkey || node.subfield;
        END IF;
    END IF;

    IF node.negate THEN
        IF caseless THEN
            op := 'NOT LIKE';
        ELSE
            op := '<>';
        END IF;
    ELSE
        IF caseless THEN
            op := 'LIKE';
        ELSE
            op := '=';
        END IF;
    END IF;

    my_alias := 'n' || node.id::TEXT;

    jrow := my_join || ' (SELECT *, ';
    IF node.tag IS NOT NULL THEN
        jrow := jrow  || node.quality ||
            ' AS quality FROM metabib.full_rec mfr WHERE mfr.tag = ''' ||
            node.tag || '''';
        IF node.subfield IS NOT NULL THEN
            jrow := jrow || ' AND mfr.subfield = ''' ||
                node.subfield || '''';
        END IF;
        jrow := jrow || ' AND (';
        jrow := jrow || vandelay._node_tag_comparisons(caseless, op, tags_rstore, tagkey);
        jrow := jrow || ')) ' || my_alias || my_using || E'\n';
    ELSE    -- svf
        jrow := jrow || 'id AS record, ' || node.quality ||
            ' AS quality FROM metabib.record_attr mra WHERE mra.attrs->''' ||
            node.svf || ''' ' || op || ' $2->''' || node.svf || ''') ' ||
            my_alias || my_using || E'\n';
    END IF;
    INSERT INTO _vandelay_tmp_jrows (j) VALUES (jrow);
END;
$_$;


ALTER FUNCTION vandelay._get_expr_push_jrow(node match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: _get_expr_push_jrow_auth(match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _get_expr_push_jrow_auth(node match_set_point, tags_rstore evergreen.hstore) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jrow        TEXT;
    my_alias    TEXT;
    op          TEXT;
    tagkey      TEXT;
    caseless    BOOL;
    jrow_count  INT;
    my_using    TEXT;
    my_join     TEXT;
BEGIN
    --ver1.0
    -- remember $1 is tags_rstore, and $2 is svf_rstore

    caseless := FALSE;
    SELECT COUNT(*) INTO jrow_count FROM _vandelay_tmp_jrows_auth;
    IF jrow_count > 0 THEN
        my_using := ' USING (record)';
        my_join := 'FULL OUTER JOIN';
    ELSE
        my_using := '';
        my_join := 'FROM';
    END IF;

    IF node.tag IS NOT NULL THEN
        caseless := (node.tag IN ('020', '022', '024'));
        tagkey := node.tag;
        IF node.subfield IS NOT NULL THEN
            tagkey := tagkey || node.subfield;
        END IF;
    END IF;

    IF node.negate THEN
        IF caseless THEN
            op := 'NOT LIKE';
        ELSE
            op := '<>';
        END IF;
    ELSE
        IF caseless THEN
            op := 'LIKE';
        ELSE
            op := '=';
        END IF;
    END IF;

    my_alias := 'n' || node.id::TEXT;

    jrow := my_join || ' (SELECT *, ';
    IF node.tag IS NOT NULL THEN
        jrow := jrow  || node.quality ||
            ' AS quality FROM authority.full_rec mfr WHERE mfr.tag = ''' ||
            node.tag || '''';
        IF node.subfield IS NOT NULL THEN
            jrow := jrow || ' AND mfr.subfield = ''' ||
                node.subfield || '''';
        END IF;
        jrow := jrow || ' AND (';
        jrow := jrow || vandelay._node_tag_comparisons(caseless, op, tags_rstore, tagkey);
        jrow := jrow || ')) ' || my_alias || my_using || E'\n';
    ELSE    -- svf
        jrow := jrow || 'id AS record, ' || node.quality ||
            ' AS quality FROM metabib.record_attr mra WHERE mra.attrs->''' ||
            node.svf || ''' ' || op || ' $2->''' || node.svf || ''') ' ||
            my_alias || my_using || E'\n';
    END IF;
    INSERT INTO _vandelay_tmp_jrows_auth (j) VALUES (jrow);
END;
$_$;


ALTER FUNCTION vandelay._get_expr_push_jrow_auth(node match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: _get_expr_push_qrow(match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _get_expr_push_qrow(node match_set_point) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    INSERT INTO _vandelay_tmp_qrows (q) VALUES (node.id);
END;
$$;


ALTER FUNCTION vandelay._get_expr_push_qrow(node match_set_point) OWNER TO evergreen;

--
-- Name: _get_expr_push_qrow_auth(match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _get_expr_push_qrow_auth(node match_set_point) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    --ver1.0
    INSERT INTO _vandelay_tmp_qrows_auth (q) VALUES (node.id);
END;
$$;


ALTER FUNCTION vandelay._get_expr_push_qrow_auth(node match_set_point) OWNER TO evergreen;

--
-- Name: _get_expr_render_one(match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _get_expr_render_one(node match_set_point) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    s           TEXT;
BEGIN
    IF node.bool_op IS NOT NULL THEN
        RETURN node.bool_op;
    ELSE
        RETURN '(n' || node.id::TEXT || '.id IS NOT NULL)';
    END IF;
END;
$$;


ALTER FUNCTION vandelay._get_expr_render_one(node match_set_point) OWNER TO evergreen;

--
-- Name: _node_tag_comparisons(boolean, text, evergreen.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION _node_tag_comparisons(caseless boolean, op text, tags_rstore evergreen.hstore, tagkey text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    result  TEXT;
    i       INT;
    vals    TEXT[];
BEGIN
    i := 1;
    vals := tags_rstore->tagkey;
    result := '';

    WHILE TRUE LOOP
        IF i > 1 THEN
            IF vals[i] IS NULL THEN
                EXIT;
            ELSE
                result := result || ' OR ';
            END IF;
        END IF;

        IF caseless THEN
            result := result || 'LOWER(mfr.value) ' || op;
        ELSE
            result := result || 'mfr.value ' || op;
        END IF;

        result := result || ' ' || COALESCE('''' || vals[i] || '''', 'NULL');

        IF vals[i] IS NULL THEN
            EXIT;
        END IF;
        i := i + 1;
    END LOOP;

    RETURN result;

END;
$$;


ALTER FUNCTION vandelay._node_tag_comparisons(caseless boolean, op text, tags_rstore evergreen.hstore, tagkey text) OWNER TO evergreen;

--
-- Name: add_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION add_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.add_field( $1, $2, $3, 0 );
$_$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text) OWNER TO evergreen;

--
-- Name: add_field(text, text, text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION add_field(target_xml text, source_xml text, field text, force_add integer) RETURNS text
    LANGUAGE plperlu
    AS $_X$
    #ver1.0
    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $target_xml = shift;
    my $source_xml = shift;
    my $field_spec = shift;
    my $force_add = shift || 0;

    my $target_r = MARC::Record->new_from_xml( $target_xml );
    my $source_r = MARC::Record->new_from_xml( $source_xml );

    return $target_xml unless ($target_r && $source_r);

    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    for my $f ( keys %fields) {
        if ( @{$fields{$f}{sf}} ) {
            for my $from_field ($source_r->field( $f )) {
                my @tos = $target_r->field( $f );
                if (!@tos) {
                    next if (exists($fields{$f}{match}) and !$force_add);
                    my @new_fields = map { $_->clone } $source_r->field( $f );
                    $target_r->insert_fields_ordered( @new_fields );
                } else {
                    for my $to_field (@tos) {
                        if (exists($fields{$f}{match})) {
                            next unless (grep { $_ =~ $fields{$f}{match}{re} } $to_field->subfield($fields{$f}{match}{sf}));
                        }
                        for my $old_sf ($from_field->subfields) {
                            $to_field->add_subfields( @$old_sf ) if grep(/$$old_sf[0]/,@{$fields{$f}{sf}});
                        }
                    }
                }
            }
        } else {
            my @new_fields = map { $_->clone } $source_r->field( $f );
            $target_r->insert_fields_ordered( @new_fields );
        }
    }

    $target_xml = $target_r->as_xml_record;
    $target_xml =~ s/^<\?.+?\?>$//mo;
    $target_xml =~ s/\n//sgo;
    $target_xml =~ s/>\s+</></sgo;

    return $target_xml;

$_X$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text, force_add integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_authority_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_authority_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_authority_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_authority_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_authority_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_authority_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN
    SELECT COUNT(*) INTO match_count FROM vandelay.authority_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.authority_match m
      WHERE m.queued_record = import_id
      LIMIT 1;

    IF eg_id IS NULL THEN
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_authority_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_record(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_record_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_authority_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    lwm_ratio_value NUMERIC;
BEGIN
    --ver1.0
    lwm_ratio_value := COALESCE(lwm_ratio_value_p, 0.0);

    PERFORM * FROM vandelay.queued_authority_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        RAISE NOTICE 'already imported, cannot auto-overlay';
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.authority_match m
            JOIN vandelay.queued_authority_record qr ON (m.queued_record = qr.id)
            JOIN vandelay.authority_queue q ON (qr.queue = q.id)
            JOIN authority.record_entry r ON (r.id = m.eg_record)
      WHERE m.queued_record = import_id
            AND qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC >= lwm_ratio_value
      ORDER BY  m.match_score DESC, -- required match score
                qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC DESC, -- quality tie breaker
                m.id -- when in doubt, use the first match
      LIMIT 1;

    IF eg_id IS NULL THEN
        RAISE NOTICE 'incoming record is not of high enough quality';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_authority_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_bib_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT vandelay.auto_overlay_bib_queue_with_best( $1, $2, p.lwm_ratio ) FROM vandelay.merge_profile p WHERE id = $2;
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record_with_best( queued_record.id, merge_profile_id, lwm_ratio_value ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;
    
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT COUNT(*) INTO match_count FROM vandelay.bib_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    -- Check that the one match is on the first 901c
    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.queued_bib_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id)
      WHERE q.id = import_id
            AND m.eg_record = oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]',marc)::BIGINT;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'not a 901c match';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_record_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    lwm_ratio_value NUMERIC;
BEGIN

    lwm_ratio_value := COALESCE(lwm_ratio_value_p, 0.0);

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.bib_match m
            JOIN vandelay.queued_bib_record qr ON (m.queued_record = qr.id)
            JOIN vandelay.bib_queue q ON (qr.queue = q.id)
            JOIN biblio.record_entry r ON (r.id = m.eg_record)
      WHERE m.queued_record = import_id
            AND qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC >= lwm_ratio_value
      ORDER BY  m.match_score DESC, -- required match score
                qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC DESC, -- quality tie breaker
                m.id -- when in doubt, use the first match
      LIMIT 1;

    IF eg_id IS NULL THEN
        -- RAISE NOTICE 'incoming record is not of high enough quality';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO evergreen;

--
-- Name: cleanup_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION cleanup_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_authority_record_attr WHERE record = OLD.id;
    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_authority_marc() OWNER TO evergreen;

--
-- Name: cleanup_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION cleanup_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_bib_record_attr WHERE record = OLD.id;
    DELETE FROM vandelay.import_item WHERE record = OLD.id;

    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_bib_marc() OWNER TO evergreen;

--
-- Name: compile_profile(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION compile_profile(incoming_xml text) RETURNS compile_profile
    LANGUAGE plpgsql
    AS $$
DECLARE
    output              vandelay.compile_profile%ROWTYPE;
    profile             vandelay.merge_profile%ROWTYPE;
    profile_tmpl        TEXT;
    profile_tmpl_owner  TEXT;
    add_rule            TEXT := '';
    strip_rule          TEXT := '';
    replace_rule        TEXT := '';
    preserve_rule       TEXT := '';

BEGIN

    profile_tmpl := (oils_xpath('//*[@tag="905"]/*[@code="t"]/text()',incoming_xml))[1];
    profile_tmpl_owner := (oils_xpath('//*[@tag="905"]/*[@code="o"]/text()',incoming_xml))[1];

    IF profile_tmpl IS NOT NULL AND profile_tmpl <> '' AND profile_tmpl_owner IS NOT NULL AND profile_tmpl_owner <> '' THEN
        SELECT  p.* INTO profile
          FROM  vandelay.merge_profile p
                JOIN actor.org_unit u ON (u.id = p.owner)
          WHERE p.name = profile_tmpl
                AND u.shortname = profile_tmpl_owner;

        IF profile.id IS NOT NULL THEN
            add_rule := COALESCE(profile.add_spec,'');
            strip_rule := COALESCE(profile.strip_spec,'');
            replace_rule := COALESCE(profile.replace_spec,'');
            preserve_rule := COALESCE(profile.preserve_spec,'');
        END IF;
    END IF;

    add_rule := add_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="a"]/text()',incoming_xml),','),'');
    strip_rule := strip_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="d"]/text()',incoming_xml),','),'');
    replace_rule := replace_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="r"]/text()',incoming_xml),','),'');
    preserve_rule := preserve_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="p"]/text()',incoming_xml),','),'');

    output.add_rule := BTRIM(add_rule,',');
    output.replace_rule := BTRIM(replace_rule,',');
    output.strip_rule := BTRIM(strip_rule,',');
    output.preserve_rule := BTRIM(preserve_rule,',');

    RETURN output;
END;
$$;


ALTER FUNCTION vandelay.compile_profile(incoming_xml text) OWNER TO evergreen;

--
-- Name: extract_rec_attrs(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION extract_rec_attrs(xml text) RETURNS evergreen.hstore
    LANGUAGE sql
    AS $_$
    SELECT vandelay.extract_rec_attrs( $1, (SELECT ARRAY_ACCUM(name) FROM config.record_attr_definition));
$_$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text) OWNER TO evergreen;

--
-- Name: extract_rec_attrs(text, text[]); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION extract_rec_attrs(xml text, attr_defs text[]) RETURNS evergreen.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_value      TEXT;
    new_attrs       HSTORE := ''::HSTORE;
    attr_def        config.record_attr_definition%ROWTYPE;
BEGIN
    --ver1.0
    FOR attr_def IN SELECT * FROM config.record_attr_definition WHERE name IN (SELECT * FROM UNNEST(attr_defs)) ORDER BY format LOOP

        IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
            SELECT  ARRAY_TO_STRING(ARRAY_ACCUM(x.value), COALESCE(attr_def.joiner,' ')) INTO attr_value
              FROM  vandelay.flatten_marc(xml) AS x
              WHERE x.tag LIKE attr_def.tag
                    AND CASE
                        WHEN attr_def.sf_list IS NOT NULL
                            THEN POSITION(x.subfield IN attr_def.sf_list) > 0
                        ELSE TRUE
                        END
              GROUP BY x.tag
              ORDER BY x.tag
              LIMIT 1;

        ELSIF attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
            attr_value := vandelay.marc21_extract_fixed_field(xml, attr_def.fixed_field);

        ELSIF attr_def.xpath IS NOT NULL THEN -- and xpath expression

            SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;

            -- See if we can skip the XSLT ... it's expensive
            IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                -- Can't skip the transform
                IF xfrm.xslt <> '---' THEN
                    transformed_xml := oils_xslt_process(xml,xfrm.xslt);
                ELSE
                    transformed_xml := xml;
                END IF;

                prev_xfrm := xfrm.name;
            END IF;

            IF xfrm.name IS NULL THEN
                -- just grab the marcxml (empty) transform
                SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                prev_xfrm := xfrm.name;
            END IF;

            attr_value := oils_xpath_string(attr_def.xpath, transformed_xml, COALESCE(attr_def.joiner,' '), ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]);

        ELSIF attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
            SELECT  m.value::TEXT INTO attr_value
              FROM  vandelay.marc21_physical_characteristics(xml) v
                    JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
              WHERE v.subfield = attr_def.phys_char_sf
              LIMIT 1; -- Just in case ...

        END IF;

        -- apply index normalizers to attr_value
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
              WHERE attr = attr_def.name
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_nullable( attr_value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO attr_value;

        END LOOP;

        -- Add the new value to the hstore
        new_attrs := new_attrs || hstore( attr_def.name, attr_value );

    END LOOP;

    RETURN new_attrs;
END;
$$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text, attr_defs text[]) OWNER TO evergreen;

--
-- Name: find_bib_tcn_data(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION find_bib_tcn_data(xml text) RETURNS SETOF tcn_data
    LANGUAGE plpgsql
    AS $_$
DECLARE
    eg_tcn          TEXT;
    eg_tcn_source   TEXT;
    output          vandelay.tcn_data%ROWTYPE;
BEGIN

    -- 001/003
    eg_tcn := BTRIM((oils_xpath('//*[@tag="001"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="003"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 901 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 039 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 020 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="020"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISBN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 022 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="022"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISSN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 010 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="010"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'LCCN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 035 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="035"]/*[@code="a"]/text()',xml))[1], $re$^.*?(\w+)$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'System Legacy';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    RETURN;
END;
$_$;


ALTER FUNCTION vandelay.find_bib_tcn_data(xml text) OWNER TO evergreen;

--
-- Name: flatten_marc(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION flatten_marc(marc text) RETURNS SETOF flat_marc
    LANGUAGE plpgsql
    AS $$
DECLARE
    output  vandelay.flat_marc%ROWTYPE;
    field   RECORD;
BEGIN
    FOR field IN SELECT * FROM vandelay.flay_marc( marc ) LOOP
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        IF field.subfield IS NOT NULL AND field.tag NOT IN ('020','022','024') THEN -- exclude standard numbers and control fields
            output.value := naco_normalize(field.value, field.subfield);
        ELSE
            output.value := field.value;
        END IF;

        CONTINUE WHEN output.value IS NULL;

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION vandelay.flatten_marc(marc text) OWNER TO evergreen;

--
-- Name: flatten_marc_hstore(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION flatten_marc_hstore(record_xml text) RETURNS evergreen.hstore
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN (SELECT
        HSTORE(
            ARRAY_ACCUM(tag || (COALESCE(subfield, ''))),
            ARRAY_ACCUM(value)
        )
        FROM (
            SELECT  tag, subfield, ARRAY_ACCUM(value)::TEXT AS value
              FROM  (SELECT tag,
                            subfield,
                            CASE WHEN tag = '020' THEN -- caseless -- isbn
                                LOWER((REGEXP_MATCHES(value,$$^(\S{10,17})$$))[1] || '%')
                            WHEN tag = '022' THEN -- caseless -- issn
                                LOWER((REGEXP_MATCHES(value,$$^(\S{4}[- ]?\S{4})$$))[1] || '%')
                            WHEN tag = '024' THEN -- caseless -- upc (other)
                                LOWER(value || '%')
                            ELSE
                                value
                            END AS value
                      FROM  vandelay.flatten_marc(record_xml)) x
                GROUP BY tag, subfield ORDER BY tag, subfield
        ) subquery
    );
END;
$_$;


ALTER FUNCTION vandelay.flatten_marc_hstore(record_xml text) OWNER TO evergreen;

--
-- Name: flay_marc(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION flay_marc(text) RETURNS SETOF flat_marc
    LANGUAGE plperlu
    AS $_$

use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use strict;

MARC::Charset->assume_unicode(1);

my $xml = shift;
my $r = MARC::Record->new_from_xml( $xml );

return_next( { tag => 'LDR', value => $r->leader } );

for my $f ( $r->fields ) {
    if ($f->is_control_field) {
        return_next({ tag => $f->tag, value => $f->data });
    } else {
        for my $s ($f->subfields) {
            return_next({
                tag      => $f->tag,
                ind1     => $f->indicator(1),
                ind2     => $f->indicator(2),
                subfield => $s->[0],
                value    => $s->[1]
            });

            if ( $f->tag eq '245' and $s->[0] eq 'a' ) {
                my $trim = $f->indicator(2) || 0;
                return_next({
                    tag      => 'tnf',
                    ind1     => $f->indicator(1),
                    ind2     => $f->indicator(2),
                    subfield => 'a',
                    value    => substr( $s->[1], $trim )
                });
            }
        }
    }
}

return undef;

$_$;


ALTER FUNCTION vandelay.flay_marc(text) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set(integer, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    root    vandelay.match_set_point;
BEGIN
    SELECT * INTO root FROM vandelay.match_set_point
        WHERE parent IS NULL AND match_set = match_set_id;

    RETURN vandelay.get_expr_from_match_set_point(root, tags_rstore);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_auth(integer, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION get_expr_from_match_set_auth(match_set_id integer, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    root    vandelay.match_set_point;
BEGIN
    --ver1.0
    SELECT * INTO root FROM vandelay.match_set_point
        WHERE parent IS NULL AND match_set = match_set_id;

    RETURN vandelay.get_expr_from_match_set_point_auth(root, tags_rstore);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_auth(match_set_id integer, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_point(match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION get_expr_from_match_set_point(node match_set_point, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    q           TEXT;
    i           INTEGER;
    this_op     TEXT;
    children    INTEGER[];
    child       vandelay.match_set_point;
BEGIN
    SELECT ARRAY_ACCUM(id) INTO children FROM vandelay.match_set_point
        WHERE parent = node.id;

    IF ARRAY_LENGTH(children, 1) > 0 THEN
        this_op := vandelay._get_expr_render_one(node);
        q := '(';
        i := 1;
        WHILE children[i] IS NOT NULL LOOP
            SELECT * INTO child FROM vandelay.match_set_point
                WHERE id = children[i];
            IF i > 1 THEN
                q := q || ' ' || this_op || ' ';
            END IF;
            i := i + 1;
            q := q || vandelay.get_expr_from_match_set_point(child, tags_rstore);
        END LOOP;
        q := q || ')';
        RETURN q;
    ELSIF node.bool_op IS NULL THEN
        PERFORM vandelay._get_expr_push_qrow(node);
        PERFORM vandelay._get_expr_push_jrow(node, tags_rstore);
        RETURN vandelay._get_expr_render_one(node);
    ELSE
        RETURN '';
    END IF;
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_point(node match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_point_auth(match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION get_expr_from_match_set_point_auth(node match_set_point, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    q           TEXT;
    i           INTEGER;
    this_op     TEXT;
    children    INTEGER[];
    child       vandelay.match_set_point;
BEGIN
    --ver1.0
    SELECT ARRAY_ACCUM(id) INTO children FROM vandelay.match_set_point
        WHERE parent = node.id;

    IF ARRAY_LENGTH(children, 1) > 0 THEN
        this_op := vandelay._get_expr_render_one(node);
        q := '(';
        i := 1;
        WHILE children[i] IS NOT NULL LOOP
            SELECT * INTO child FROM vandelay.match_set_point
                WHERE id = children[i];
            IF i > 1 THEN
                q := q || ' ' || this_op || ' ';
            END IF;
            i := i + 1;
            q := q || vandelay.get_expr_from_match_set_point_auth(child, tags_rstore);
        END LOOP;
        q := q || ')';
        RETURN q;
    ELSIF node.bool_op IS NULL THEN
        PERFORM vandelay._get_expr_push_qrow_auth(node);
        PERFORM vandelay._get_expr_push_jrow_auth(node, tags_rstore);
        RETURN vandelay._get_expr_render_one(node);
    ELSE
        RETURN '';
    END IF;
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_point_auth(node match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_matched_records(bigint, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION get_matched_records(queued_bib bigint, bib_type text) RETURNS SETOF evergreen.matched_records
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	m_record matched_records;
BEGIN
        --ver1.0
		IF bib_type = 'bib' THEN
				FOR m_record IN
					SELECT create_date, creator, edit_date, bre.id, vqbr.quality, source, tcn_source, tcn_value,
					'null' as _id, vbm.match_score, vbm.quality as match_quality
					FROM biblio.record_entry bre
					INNER JOIN vandelay.bib_match vbm
					ON vbm.eg_record = bre.id
					INNER JOIN vandelay.queued_bib_record vqbr
					ON vqbr.id = vbm.queued_record
					WHERE vqbr.id = queued_bib
					ORDER BY bre.id DESC
				LOOP
				RETURN NEXT m_record;
				END LOOP;
		ELSE
				FOR m_record IN
					SELECT create_date, creator, edit_date, are.id, vqar.quality, source, '' as tcn_source, '' as tcn_value,
					'null' as _id, vam.match_score, vam.quality as match_quality
					FROM authority.record_entry are
					INNER JOIN vandelay.authority_match vam
					ON vam.eg_record = are.id
					INNER JOIN vandelay.queued_authority_record  vqar
					ON vqar.id = vam.queued_record
					WHERE vqar.id = queued_bib
					ORDER BY are.id DESC
				LOOP
				RETURN NEXT m_record;
				END LOOP;
		END IF;
	RETURN;
END;
$$;


ALTER FUNCTION vandelay.get_matched_records(queued_bib bigint, bib_type text) OWNER TO evergreen;

--
-- Name: ingest_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION ingest_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.authority_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_authority_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_authority_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_authority_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_authority_marc() OWNER TO evergreen;

--
-- Name: ingest_bib_items(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION ingest_bib_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    attr_def    BIGINT;
    item_data   vandelay.import_item%ROWTYPE;
BEGIN

    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    SELECT item_attr_def INTO attr_def FROM vandelay.bib_queue WHERE id = NEW.queue;

    FOR item_data IN SELECT * FROM vandelay.ingest_items( NEW.id::BIGINT, attr_def ) LOOP
        INSERT INTO vandelay.import_item (
            record,
            definition,
            owning_lib,
            circ_lib,
            call_number,
            copy_number,
            status,
            location,
            circulate,
            deposit,
            deposit_amount,
            ref,
            holdable,
            price,
            barcode,
            circ_modifier,
            circ_as_type,
            alert_message,
            pub_note,
            priv_note,
            internal_id,
            opac_visible,
            import_error,
            error_detail
        ) VALUES (
            NEW.id,
            item_data.definition,
            item_data.owning_lib,
            item_data.circ_lib,
            item_data.call_number,
            item_data.copy_number,
            item_data.status,
            item_data.location,
            item_data.circulate,
            item_data.deposit,
            item_data.deposit_amount,
            item_data.ref,
            item_data.holdable,
            item_data.price,
            item_data.barcode,
            item_data.circ_modifier,
            item_data.circ_as_type,
            item_data.alert_message,
            item_data.pub_note,
            item_data.priv_note,
            item_data.internal_id,
            item_data.opac_visible,
            item_data.import_error,
            item_data.error_detail
        );
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_items() OWNER TO evergreen;

--
-- Name: ingest_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION ingest_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.bib_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_bib_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_bib_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_bib_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_marc() OWNER TO evergreen;

--
-- Name: import_item; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE import_item (
    id bigint NOT NULL,
    record bigint NOT NULL,
    definition bigint NOT NULL,
    owning_lib integer,
    circ_lib integer,
    call_number text,
    copy_number integer,
    status integer,
    location integer,
    circulate boolean,
    deposit boolean,
    deposit_amount numeric(8,2),
    ref boolean,
    holdable boolean,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    pub_note text,
    priv_note text,
    opac_visible boolean,
    import_error text,
    error_detail text,
    imported_as bigint,
    import_time timestamp with time zone,
    internal_id bigint
);


ALTER TABLE vandelay.import_item OWNER TO evergreen;

--
-- Name: ingest_items(bigint, bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION ingest_items(import_id bigint, attr_def_id bigint) RETURNS SETOF import_item
    LANGUAGE plpgsql
    AS $$
DECLARE

    owning_lib      TEXT;
    circ_lib        TEXT;
    call_number     TEXT;
    copy_number     TEXT;
    status          TEXT;
    location        TEXT;
    circulate       TEXT;
    deposit         TEXT;
    deposit_amount  TEXT;
    ref             TEXT;
    holdable        TEXT;
    price           TEXT;
    barcode         TEXT;
    circ_modifier   TEXT;
    circ_as_type    TEXT;
    alert_message   TEXT;
    opac_visible    TEXT;
    pub_note        TEXT;
    priv_note       TEXT;
    internal_id     TEXT;

    attr_def        RECORD;
    tmp_attr_set    RECORD;
    attr_set        vandelay.import_item%ROWTYPE;

    xpath           TEXT;
    tmp_str         TEXT;

BEGIN

    SELECT * INTO attr_def FROM vandelay.import_item_attr_definition WHERE id = attr_def_id;

    IF FOUND THEN

        attr_set.definition := attr_def.id;

        -- Build the combined XPath

        owning_lib :=
            CASE
                WHEN attr_def.owning_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.owning_lib ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.owning_lib || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.owning_lib
            END;

        circ_lib :=
            CASE
                WHEN attr_def.circ_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_lib ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_lib || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_lib
            END;

        call_number :=
            CASE
                WHEN attr_def.call_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.call_number ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.call_number || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.call_number
            END;

        copy_number :=
            CASE
                WHEN attr_def.copy_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.copy_number ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.copy_number || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.copy_number
            END;

        status :=
            CASE
                WHEN attr_def.status IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.status ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.status || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.status
            END;

        location :=
            CASE
                WHEN attr_def.location IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.location ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.location || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.location
            END;

        circulate :=
            CASE
                WHEN attr_def.circulate IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circulate ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circulate || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circulate
            END;

        deposit :=
            CASE
                WHEN attr_def.deposit IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.deposit || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.deposit
            END;

        deposit_amount :=
            CASE
                WHEN attr_def.deposit_amount IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit_amount ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.deposit_amount || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.deposit_amount
            END;

        ref :=
            CASE
                WHEN attr_def.ref IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.ref ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.ref || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.ref
            END;

        holdable :=
            CASE
                WHEN attr_def.holdable IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.holdable ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.holdable || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.holdable
            END;

        price :=
            CASE
                WHEN attr_def.price IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.price ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.price || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.price
            END;

        barcode :=
            CASE
                WHEN attr_def.barcode IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.barcode ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.barcode || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.barcode
            END;

        circ_modifier :=
            CASE
                WHEN attr_def.circ_modifier IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_modifier ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_modifier || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_modifier
            END;

        circ_as_type :=
            CASE
                WHEN attr_def.circ_as_type IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_as_type ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.circ_as_type || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.circ_as_type
            END;

        alert_message :=
            CASE
                WHEN attr_def.alert_message IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.alert_message ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.alert_message || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.alert_message
            END;

        opac_visible :=
            CASE
                WHEN attr_def.opac_visible IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.opac_visible ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.opac_visible || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.opac_visible
            END;

        pub_note :=
            CASE
                WHEN attr_def.pub_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.pub_note ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.pub_note || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.pub_note
            END;
        priv_note :=
            CASE
                WHEN attr_def.priv_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.priv_note ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.priv_note || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.priv_note
            END;

        internal_id :=
            CASE
                WHEN attr_def.internal_id IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.internal_id ) = 1 THEN '//*[@tag="' || attr_def.tag || '"]/*[@code="' || attr_def.internal_id || '"]'
                ELSE '//*[@tag="' || attr_def.tag || '"]/*' || attr_def.internal_id
            END;



        xpath :=
            owning_lib      || '|' ||
            circ_lib        || '|' ||
            call_number     || '|' ||
            copy_number     || '|' ||
            status          || '|' ||
            location        || '|' ||
            circulate       || '|' ||
            deposit         || '|' ||
            deposit_amount  || '|' ||
            ref             || '|' ||
            holdable        || '|' ||
            price           || '|' ||
            barcode         || '|' ||
            circ_modifier   || '|' ||
            circ_as_type    || '|' ||
            alert_message   || '|' ||
            pub_note        || '|' ||
            priv_note       || '|' ||
            internal_id     || '|' ||
            opac_visible;

        FOR tmp_attr_set IN
                SELECT  *
                  FROM  oils_xpath_table( 'id', 'marc', 'vandelay.queued_bib_record', xpath, 'id = ' || import_id )
                            AS t( id INT, ol TEXT, clib TEXT, cn TEXT, cnum TEXT, cs TEXT, cl TEXT, circ TEXT,
                                  dep TEXT, dep_amount TEXT, r TEXT, hold TEXT, pr TEXT, bc TEXT, circ_mod TEXT,
                                  circ_as TEXT, amessage TEXT, note TEXT, pnote TEXT, internal_id TEXT, opac_vis TEXT )
        LOOP

            attr_set.import_error := NULL;
            attr_set.error_detail := NULL;
            attr_set.deposit_amount := NULL;
            attr_set.copy_number := NULL;
            attr_set.price := NULL;

            IF tmp_attr_set.pr != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.pr, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.price';
                    attr_set.error_detail := tmp_attr_set.pr; -- original value
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.price := tmp_str::NUMERIC(8,2); 
            END IF;

            IF tmp_attr_set.dep_amount != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.dep_amount, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.deposit_amount';
                    attr_set.error_detail := tmp_attr_set.dep_amount; 
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.deposit_amount := tmp_str::NUMERIC(8,2); 
            END IF;

            IF tmp_attr_set.cnum != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.cnum, E'[^0-9]', '', 'g');
                IF tmp_str = '' THEN 
                    attr_set.import_error := 'import.item.invalid.copy_number';
                    attr_set.error_detail := tmp_attr_set.cnum; 
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
                attr_set.copy_number := tmp_str::INT; 
            END IF;

            IF tmp_attr_set.ol != '' THEN
                SELECT id INTO attr_set.owning_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.ol); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.owning_lib';
                    attr_set.error_detail := tmp_attr_set.ol;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.clib != '' THEN
                SELECT id INTO attr_set.circ_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.clib); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_lib';
                    attr_set.error_detail := tmp_attr_set.clib;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.cs != '' THEN
                SELECT id INTO attr_set.status FROM config.copy_status WHERE LOWER(name) = LOWER(tmp_attr_set.cs); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.status';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.circ_mod != '' THEN
                SELECT code INTO attr_set.circ_modifier FROM config.circ_modifier WHERE code = tmp_attr_set.circ_mod;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_modifier';
                    attr_set.error_detail := tmp_attr_set.circ_mod;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.circ_as != '' THEN
                SELECT code INTO attr_set.circ_as_type FROM config.coded_value_map WHERE ctype = 'item_type' AND code = tmp_attr_set.circ_as;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_as_type';
                    attr_set.error_detail := tmp_attr_set.circ_as;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            IF tmp_attr_set.cl != '' THEN

                -- search up the org unit tree for a matching copy location
                WITH RECURSIVE anscestor_depth AS (
                    SELECT  ou.id,
                        out.depth AS depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                    WHERE ou.id = COALESCE(attr_set.owning_lib, attr_set.circ_lib)
                        UNION ALL
                    SELECT  ou.id,
                        out.depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                        JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
                ) SELECT  cpl.id INTO attr_set.location
                    FROM  anscestor_depth a
                        JOIN asset.copy_location cpl ON (cpl.owning_lib = a.id)
                    WHERE LOWER(cpl.name) = LOWER(tmp_attr_set.cl)
                    ORDER BY a.depth DESC
                    LIMIT 1; 

                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.location';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE; 
                END IF;
            END IF;

            attr_set.circulate      :=
                LOWER( SUBSTRING( tmp_attr_set.circ, 1, 1)) IN ('t','y','1')
                OR LOWER(tmp_attr_set.circ) = 'circulating'; -- BOOL

            attr_set.deposit        :=
                LOWER( SUBSTRING( tmp_attr_set.dep, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.dep) = 'deposit'; -- BOOL

            attr_set.holdable       :=
                LOWER( SUBSTRING( tmp_attr_set.hold, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.hold) = 'holdable'; -- BOOL

            attr_set.opac_visible   :=
                LOWER( SUBSTRING( tmp_attr_set.opac_vis, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.opac_vis) = 'visible'; -- BOOL

            attr_set.ref            :=
                LOWER( SUBSTRING( tmp_attr_set.r, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.r) = 'reference'; -- BOOL

            attr_set.call_number    := tmp_attr_set.cn; -- TEXT
            attr_set.barcode        := tmp_attr_set.bc; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.pub_note       := tmp_attr_set.note; -- TEXT,
            attr_set.priv_note      := tmp_attr_set.pnote; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.internal_id    := tmp_attr_set.internal_id::BIGINT;

            RETURN NEXT attr_set;

        END LOOP;

    END IF;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.ingest_items(import_id bigint, attr_def_id bigint) OWNER TO evergreen;

--
-- Name: marc21_extract_all_fixed_fields(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION marc21_extract_all_fixed_fields(marc text) RETURNS SETOF biblio.record_ff_map
    LANGUAGE plpgsql
    AS $$
DECLARE
    tag_data    TEXT;
    rtype       TEXT;
    ff_pos      RECORD;
    output      biblio.record_ff_map%ROWTYPE;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;

    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE rec_type = rtype ORDER BY tag DESC LOOP
        output.ff_name  := ff_pos.fixed_field;
        output.ff_value := NULL;

        IF ff_pos.tag = 'ldr' THEN
            output.ff_value := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF output.ff_value IS NOT NULL THEN
                output.ff_value := SUBSTRING( output.ff_value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN NEXT output;
                output.ff_value := NULL;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                output.ff_value := SUBSTRING( tag_data, ff_pos.start_pos + 1, ff_pos.length );
                IF output.ff_value IS NULL THEN output.ff_value := REPEAT( ff_pos.default_val, ff_pos.length ); END IF;
                RETURN NEXT output;
                output.ff_value := NULL;
            END LOOP;
        END IF;
    
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_all_fixed_fields(marc text) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field(text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION marc21_extract_fixed_field(marc text, ff text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    rtype       TEXT;
    ff_pos      RECORD;
    tag_data    RECORD;
    val         TEXT;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;
    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = ff AND rec_type = rtype ORDER BY tag DESC LOOP
        IF ff_pos.tag = 'ldr' THEN
            val := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF val IS NOT NULL THEN
                val := SUBSTRING( val, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                val := SUBSTRING( tag_data.value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END LOOP;
        END IF;
        val := REPEAT( ff_pos.default_val, ff_pos.length );
        RETURN val;
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_fixed_field(marc text, ff text) OWNER TO evergreen;

--
-- Name: marc21_physical_characteristics(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION marc21_physical_characteristics(marc text) RETURNS SETOF biblio.marc21_physical_characteristics
    LANGUAGE plpgsql
    AS $$
DECLARE
    rowid   INT := 0;
    _007    TEXT;
    ptype   config.marc21_physical_characteristic_type_map%ROWTYPE;
    psf     config.marc21_physical_characteristic_subfield_map%ROWTYPE;
    pval    config.marc21_physical_characteristic_value_map%ROWTYPE;
    retval  biblio.marc21_physical_characteristics%ROWTYPE;
BEGIN

    _007 := oils_xpath_string( '//*[@tag="007"]', marc );

    IF _007 IS NOT NULL AND _007 <> '' THEN
        SELECT * INTO ptype FROM config.marc21_physical_characteristic_type_map WHERE ptype_key = SUBSTRING( _007, 1, 1 );

        IF ptype.ptype_key IS NOT NULL THEN
            FOR psf IN SELECT * FROM config.marc21_physical_characteristic_subfield_map WHERE ptype_key = ptype.ptype_key LOOP
                SELECT * INTO pval FROM config.marc21_physical_characteristic_value_map WHERE ptype_subfield = psf.id AND value = SUBSTRING( _007, psf.start_pos + 1, psf.length );

                IF pval.id IS NOT NULL THEN
                    rowid := rowid + 1;
                    retval.id := rowid;
                    retval.ptype := ptype.ptype_key;
                    retval.subfield := psf.id;
                    retval.value := pval.id;
                    RETURN NEXT retval;
                END IF;

            END LOOP;
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_physical_characteristics(marc text) OWNER TO evergreen;

--
-- Name: marc21_record_type(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION marc21_record_type(marc text) RETURNS config.marc21_rec_type_map
    LANGUAGE plpgsql
    AS $$
DECLARE
    ldr         TEXT;
    tval        TEXT;
    tval_rec    RECORD;
    bval        TEXT;
    bval_rec    RECORD;
    retval      config.marc21_rec_type_map%ROWTYPE;
BEGIN
    ldr := oils_xpath_string( '//*[local-name()="leader"]', marc );

    IF ldr IS NULL OR ldr = '' THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
        RETURN retval;
    END IF;

    SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
    SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


    tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
    bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

    -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

    SELECT * INTO retval FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';


    IF retval.code IS NULL THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
    END IF;

    RETURN retval;
END;
$$;


ALTER FUNCTION vandelay.marc21_record_type(marc text) OWNER TO evergreen;

--
-- Name: match_auth_record(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION match_auth_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
BEGIN
    --ver1.0
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.authority_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.authority_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM authority.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.authority_match (queued_record, eg_record, match_score, quality)
                SELECT
                    NEW.id,
                    b.id,
                    9999,
                    vandelay.measure_record_quality( b.marc, match_set )
                FROM authority.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_marcxml_auth(match_set, NEW.marc) LOOP

        INSERT INTO vandelay.authority_match ( queued_record, eg_record, match_score, quality )
            SELECT
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_record_quality( b.marc, match_set )
	        FROM  authority.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_auth_record() OWNER TO evergreen;

--
-- Name: match_bib_record(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION match_bib_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.bib_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.bib_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM biblio.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.bib_match (queued_record, eg_record, match_score, quality) 
                SELECT
                    NEW.id, 
                    b.id,
                    9999,
                    -- note: no match_set means quality==0
                    vandelay.measure_record_quality( b.marc, match_set )
                FROM biblio.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_marcxml(match_set, NEW.marc) LOOP

        INSERT INTO vandelay.bib_match ( queued_record, eg_record, match_score, quality )
            SELECT  
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_record_quality( b.marc, match_set )
	        FROM  biblio.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_bib_record() OWNER TO evergreen;

--
-- Name: match_set_test_marcxml(integer, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION match_set_test_marcxml(match_set_id integer, record_xml text) RETURNS SETOF match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    svf_rstore  HSTORE;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);
    svf_rstore := vandelay.extract_rec_attrs(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set(match_set_id, tags_rstore);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT ARRAY_TO_STRING(
        ARRAY_ACCUM('COALESCE(n' || q::TEXT || '.quality, 0)'), ' + '
    ) INTO coal FROM _vandelay_tmp_qrows;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT ARRAY_TO_STRING(ARRAY_ACCUM(j), E'\n') INTO joins
        FROM _vandelay_tmp_jrows;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n' || 'JOIN biblio.record_entry bre ON (bre.id = record) ' || 'WHERE ' || wq || ' AND not bre.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore, svf_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows;
    DROP TABLE _vandelay_tmp_jrows;
    RETURN;
END;

$$;


ALTER FUNCTION vandelay.match_set_test_marcxml(match_set_id integer, record_xml text) OWNER TO evergreen;

--
-- Name: match_set_test_marcxml_auth(integer, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION match_set_test_marcxml_auth(match_set_id integer, record_xml text) RETURNS SETOF match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    svf_rstore  HSTORE;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    --ver1.0
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);
    svf_rstore := vandelay.extract_rec_attrs(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows_auth (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows_auth (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set_auth(match_set_id, tags_rstore);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT ARRAY_TO_STRING(
        ARRAY_ACCUM('COALESCE(n' || q::TEXT || '.quality, 0)'), ' + '
    ) INTO coal FROM _vandelay_tmp_qrows_auth;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT ARRAY_TO_STRING(ARRAY_ACCUM(j), E'\n') INTO joins
        FROM _vandelay_tmp_jrows_auth;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n' || 'JOIN authority.record_entry bre ON (bre.id = record) ' || 'WHERE ' || wq || ' AND not bre.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore, svf_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows_auth;
    DROP TABLE _vandelay_tmp_jrows_auth;
    RETURN;
END;

$$;


ALTER FUNCTION vandelay.match_set_test_marcxml_auth(match_set_id integer, record_xml text) OWNER TO evergreen;

--
-- Name: measure_record_quality(text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION measure_record_quality(xml text, match_set_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    out_q   INT := 0;
    rvalue  TEXT;
    test    vandelay.match_set_quality%ROWTYPE;
BEGIN

    FOR test IN SELECT * FROM vandelay.match_set_quality WHERE match_set = match_set_id LOOP
        IF test.tag IS NOT NULL THEN
            FOR rvalue IN SELECT value FROM vandelay.flatten_marc( xml ) WHERE tag = test.tag AND subfield = test.subfield LOOP
                IF test.value = rvalue THEN
                    out_q := out_q + test.quality;
                END IF;
            END LOOP;
        ELSE
            IF test.value = vandelay.extract_rec_attrs(xml, ARRAY[test.svf]) -> test.svf THEN
                out_q := out_q + test.quality;
            END IF;
        END IF;
    END LOOP;

    RETURN out_q;
END;
$$;


ALTER FUNCTION vandelay.measure_record_quality(xml text, match_set_id integer) OWNER TO evergreen;

--
-- Name: merge_record_xml(text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION merge_record_xml(target_marc text, template_marc text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    replace_rule    TEXT;
    tmp_marc        TEXT;
    trgt_marc        TEXT;
    tmpl_marc        TEXT;
    match_count     INT;
BEGIN

    IF target_marc IS NULL OR template_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for target or template record';
        RETURN NULL;
    END IF;

    dyn_profile := vandelay.compile_profile( template_marc );

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN NULL;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' THEN
        --Since we have nothing to do, just return what we were given.
        RETURN target_marc;
    ELSIF dyn_profile.replace_rule <> '' THEN
        trgt_marc = target_marc;
        tmpl_marc = template_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        tmp_marc = target_marc;
        trgt_marc = template_marc;
        tmpl_marc = tmp_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    RETURN vandelay.merge_record_xml( trgt_marc, tmpl_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule );

END;
$$;


ALTER FUNCTION vandelay.merge_record_xml(target_marc text, template_marc text) OWNER TO evergreen;

--
-- Name: merge_record_xml(text, text, text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.replace_field( vandelay.add_field( vandelay.strip_field( $1, $5) , $2, $3 ), $2, $4);
$_$;


ALTER FUNCTION vandelay.merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) OWNER TO evergreen;

--
-- Name: overlay_authority_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    v_marc          TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    SELECT  b.marc INTO eg_marc
      FROM  authority.record_entry b
            JOIN vandelay.authority_match m ON (m.eg_record = b.id AND m.queued_record = import_id)
      LIMIT 1;

    SELECT  q.marc INTO v_marc
      FROM  vandelay.queued_record q
            JOIN vandelay.authority_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or authority record';
        RETURN FALSE;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  authority.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule )
      WHERE id = eg_id;

    IF FOUND THEN
        UPDATE  vandelay.queued_authority_record
          SET   imported_as = eg_id,
                import_time = NOW()
          WHERE id = import_id;
        RETURN TRUE;
    END IF;

    -- RAISE NOTICE 'update of authority.record_entry failed';

    RETURN FALSE;

END;
$$;


ALTER FUNCTION vandelay.overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: overlay_bib_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    editor_id       INT;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    v_marc          TEXT;
    replace_rule    TEXT;
BEGIN

    SELECT  q.marc INTO v_marc
      FROM  vandelay.queued_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    IF v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or bib record';
        RETURN FALSE;
    END IF;

    IF vandelay.template_overlay_bib_record( v_marc, eg_id, merge_profile_id) THEN
        UPDATE  vandelay.queued_bib_record
          SET   imported_as = eg_id,
                import_time = NOW()
          WHERE id = import_id;

        editor_string := (oils_xpath('//*[@tag="905"]/*[@code="u"]/text()',v_marc))[1];

        IF editor_string IS NOT NULL AND editor_string <> '' THEN
            SELECT usr INTO editor_id FROM actor.card WHERE barcode = editor_string;

            IF editor_id IS NULL THEN
                SELECT id INTO editor_id FROM actor.usr WHERE usrname = editor_string;
            END IF;

            IF editor_id IS NOT NULL THEN
                UPDATE biblio.record_entry SET editor = editor_id, edit_date = NOW() WHERE id = eg_id;
            END IF;
        ELSE
            UPDATE biblio.record_entry SET edit_date = NOW() WHERE id = eg_id;
        END IF;

        RETURN TRUE;
    END IF;

    -- RAISE NOTICE 'update of biblio.record_entry failed';

    RETURN FALSE;

END;
$$;


ALTER FUNCTION vandelay.overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: replace_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION replace_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    xml_output TEXT;
    parsed_target TEXT;
    curr_field TEXT;
BEGIN

    parsed_target := vandelay.strip_field( target_xml, ''); -- this dance normalizes the format of the xml for the IF below
    xml_output := parsed_target; -- if there are no replace rules, just return the input

    FOR curr_field IN SELECT UNNEST( STRING_TO_ARRAY(field, ',') ) LOOP -- naive split, but it's the same we use in the perl

        xml_output := vandelay.strip_field( parsed_target, curr_field);

        IF xml_output <> parsed_target  AND curr_field ~ E'~' THEN
            -- we removed something, and there was a regexp restriction in the curr_field definition, so proceed
            xml_output := vandelay.add_field( xml_output, source_xml, curr_field, 1 );
        ELSIF curr_field !~ E'~' THEN
            -- No regexp restriction, add the curr_field
            xml_output := vandelay.add_field( xml_output, source_xml, curr_field, 0 );
        END IF;

        parsed_target := xml_output; -- in prep for any following loop iterations

    END LOOP;

    RETURN xml_output;
END;
$$;


ALTER FUNCTION vandelay.replace_field(target_xml text, source_xml text, field text) OWNER TO evergreen;

--
-- Name: strip_field(text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION strip_field(xml text, field text) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $xml = shift;
    my $r = MARC::Record->new_from_xml( $xml );

    return $xml unless ($r);

    my $field_spec = shift;
    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    for my $f ( keys %fields) {
        for my $to_field ($r->field( $f )) {
            if (exists($fields{$f}{match})) {
                next unless (grep { $_ =~ $fields{$f}{match}{re} } $to_field->subfield($fields{$f}{match}{sf}));
            }

            if ( @{$fields{$f}{sf}} ) {
                $to_field->delete_subfield(code => $fields{$f}{sf});
            } else {
                $r->delete_field( $to_field );
            }
        }
    }

    $xml = $r->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;

    return $xml;

$_X$;


ALTER FUNCTION vandelay.strip_field(xml text, field text) OWNER TO evergreen;

--
-- Name: template_overlay_bib_record(text, bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION template_overlay_bib_record(v_marc text, eg_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT vandelay.template_overlay_bib_record( $1, $2, NULL);
$_$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint) OWNER TO evergreen;

--
-- Name: template_overlay_bib_record(text, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    editor_id       INT;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    SELECT  b.marc INTO eg_marc
      FROM  biblio.record_entry b
      WHERE b.id = eg_id
      LIMIT 1;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for template or bib record';
        RETURN FALSE;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  biblio.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule )
      WHERE id = eg_id;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'update of biblio.record_entry failed';
        RETURN FALSE;
    END IF;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: agg_text(text); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE agg_text(text) (
    SFUNC = text_concat,
    STYPE = text
);


ALTER AGGREGATE public.agg_text(text) OWNER TO evergreen;

--
-- Name: agg_tsvector(tsvector); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE agg_tsvector(tsvector) (
    SFUNC = tsvector_concat,
    STYPE = tsvector
);


ALTER AGGREGATE public.agg_tsvector(tsvector) OWNER TO evergreen;

--
-- Name: array_accum(anyelement); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE array_accum(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE public.array_accum(anyelement) OWNER TO evergreen;

--
-- Name: first(anyelement); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE first(anyelement) (
    SFUNC = first_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.first(anyelement) OWNER TO evergreen;

--
-- Name: last(anyelement); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE last(anyelement) (
    SFUNC = last_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.last(anyelement) OWNER TO evergreen;

--
-- Name: #<#; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR #<# (
    PROCEDURE = hstore_lt,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = #>#,
    NEGATOR = #>=#,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.#<# (hstore, hstore) OWNER TO evergreen;

--
-- Name: #<=#; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR #<=# (
    PROCEDURE = hstore_le,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = #>=#,
    NEGATOR = #>#,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.#<=# (hstore, hstore) OWNER TO evergreen;

--
-- Name: #=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR #= (
    PROCEDURE = populate_record,
    LEFTARG = anyelement,
    RIGHTARG = hstore
);


ALTER OPERATOR public.#= (anyelement, hstore) OWNER TO evergreen;

--
-- Name: #>#; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR #># (
    PROCEDURE = hstore_gt,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = #<#,
    NEGATOR = #<=#,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.#># (hstore, hstore) OWNER TO evergreen;

--
-- Name: #>=#; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR #>=# (
    PROCEDURE = hstore_ge,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = #<=#,
    NEGATOR = #<#,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.#>=# (hstore, hstore) OWNER TO evergreen;

--
-- Name: %#; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR %# (
    PROCEDURE = hstore_to_matrix,
    RIGHTARG = hstore
);


ALTER OPERATOR public.%# (NONE, hstore) OWNER TO evergreen;

--
-- Name: %%; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR %% (
    PROCEDURE = hstore_to_array,
    RIGHTARG = hstore
);


ALTER OPERATOR public.%% (NONE, hstore) OWNER TO evergreen;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR - (
    PROCEDURE = delete,
    LEFTARG = hstore,
    RIGHTARG = text
);


ALTER OPERATOR public.- (hstore, text) OWNER TO evergreen;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR - (
    PROCEDURE = delete,
    LEFTARG = hstore,
    RIGHTARG = text[]
);


ALTER OPERATOR public.- (hstore, text[]) OWNER TO evergreen;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR - (
    PROCEDURE = delete,
    LEFTARG = hstore,
    RIGHTARG = hstore
);


ALTER OPERATOR public.- (hstore, hstore) OWNER TO evergreen;

--
-- Name: ->; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR -> (
    PROCEDURE = fetchval,
    LEFTARG = hstore,
    RIGHTARG = text
);


ALTER OPERATOR public.-> (hstore, text) OWNER TO evergreen;

--
-- Name: ->; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR -> (
    PROCEDURE = slice_array,
    LEFTARG = hstore,
    RIGHTARG = text[]
);


ALTER OPERATOR public.-> (hstore, text[]) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn13, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn13, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn13, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ean13, upc) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (upc, ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn13, isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn, isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (isbn, isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn13, ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn, ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ismn, ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn13, issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn13, issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn, issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (issn, issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR < (
    PROCEDURE = isnlt,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (upc, upc) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn13, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn13, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn13, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ean13, upc) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (upc, ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn13, isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn, isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (isbn, isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn13, ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn, ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ismn, ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn13, issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn13, issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn, issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (issn, issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <= (
    PROCEDURE = isnle,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (upc, upc) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn13, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn13, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn13, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ean13, upc) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (upc, ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn13, isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn, isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (isbn, isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn13, ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn, ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ismn, ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn13, issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn13, issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn, issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (issn, issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = isnne,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (upc, upc) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <> (
    PROCEDURE = hstore_ne,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (hstore, hstore) OWNER TO evergreen;

--
-- Name: <@; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR <@ (
    PROCEDURE = hs_contained,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = @>,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<@ (hstore, hstore) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn13, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn13, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn13, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (upc, ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ean13, upc) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn, isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn13, isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (isbn, isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn, ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn13, ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ismn, ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn13, issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn, issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn13, issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (issn, issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = isneq,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (upc, upc) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR = (
    PROCEDURE = hstore_eq,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (hstore, hstore) OWNER TO evergreen;

--
-- Name: =>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR => (
    PROCEDURE = hstore,
    LEFTARG = text,
    RIGHTARG = text
);


ALTER OPERATOR public.=> (text, text) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn13, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn13, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn13, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (upc, ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ean13, upc) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn, isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn13, isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (isbn, isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn, ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn13, ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ismn, ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn13, issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn, issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn13, issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (issn, issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR > (
    PROCEDURE = isngt,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (upc, upc) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = isbn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn13,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn13, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = ismn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn13,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn13, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = issn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn13,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn13, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = isbn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = ismn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = issn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ean13,
    RIGHTARG = upc,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ean13, upc) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = upc,
    RIGHTARG = ean13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (upc, ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn13,
    RIGHTARG = isbn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn13, isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn13,
    RIGHTARG = isbn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn13, isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn,
    RIGHTARG = isbn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn, isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = isbn,
    RIGHTARG = isbn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (isbn, isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn13,
    RIGHTARG = ismn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn13, ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn13,
    RIGHTARG = ismn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn13, ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn,
    RIGHTARG = ismn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn, ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = ismn,
    RIGHTARG = ismn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ismn, ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn13,
    RIGHTARG = issn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn13, issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn13,
    RIGHTARG = issn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn13, issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn,
    RIGHTARG = issn13,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn, issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = issn,
    RIGHTARG = issn,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (issn, issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR >= (
    PROCEDURE = isnge,
    LEFTARG = upc,
    RIGHTARG = upc,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (upc, upc) OWNER TO evergreen;

--
-- Name: ?; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR ? (
    PROCEDURE = exist,
    LEFTARG = hstore,
    RIGHTARG = text,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.? (hstore, text) OWNER TO evergreen;

--
-- Name: ?&; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR ?& (
    PROCEDURE = exists_all,
    LEFTARG = hstore,
    RIGHTARG = text[],
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.?& (hstore, text[]) OWNER TO evergreen;

--
-- Name: ?|; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR ?| (
    PROCEDURE = exists_any,
    LEFTARG = hstore,
    RIGHTARG = text[],
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.?| (hstore, text[]) OWNER TO evergreen;

--
-- Name: @; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR @ (
    PROCEDURE = hs_contains,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (hstore, hstore) OWNER TO evergreen;

--
-- Name: @>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR @> (
    PROCEDURE = hs_contains,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = <@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@> (hstore, hstore) OWNER TO evergreen;

--
-- Name: ||; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR || (
    PROCEDURE = hs_concat,
    LEFTARG = hstore,
    RIGHTARG = hstore
);


ALTER OPERATOR public.|| (hstore, hstore) OWNER TO evergreen;

--
-- Name: ~; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR ~ (
    PROCEDURE = hs_contained,
    LEFTARG = hstore,
    RIGHTARG = hstore,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (hstore, hstore) OWNER TO evergreen;

--
-- Name: btree_hstore_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY btree_hstore_ops USING btree;


ALTER OPERATOR FAMILY public.btree_hstore_ops USING btree OWNER TO postgres;

--
-- Name: btree_hstore_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS btree_hstore_ops
    DEFAULT FOR TYPE hstore USING btree AS
    OPERATOR 1 #<#(hstore,hstore) ,
    OPERATOR 2 #<=#(hstore,hstore) ,
    OPERATOR 3 =(hstore,hstore) ,
    OPERATOR 4 #>=#(hstore,hstore) ,
    OPERATOR 5 #>#(hstore,hstore) ,
    FUNCTION 1 (hstore, hstore) hstore_cmp(hstore,hstore);


ALTER OPERATOR CLASS public.btree_hstore_ops USING btree OWNER TO evergreen;

--
-- Name: isn_ops; Type: OPERATOR FAMILY; Schema: public; Owner: evergreen
--

CREATE OPERATOR FAMILY isn_ops USING btree;
ALTER OPERATOR FAMILY isn_ops USING btree ADD
    OPERATOR 1 <(ismn,ismn13) ,
    OPERATOR 1 <(ean13,isbn13) ,
    OPERATOR 1 <(upc,ean13) ,
    OPERATOR 1 <(issn13,issn) ,
    OPERATOR 1 <(issn13,ean13) ,
    OPERATOR 1 <(ean13,issn13) ,
    OPERATOR 1 <(ean13,isbn) ,
    OPERATOR 1 <(ean13,ismn) ,
    OPERATOR 1 <(ean13,issn) ,
    OPERATOR 1 <(ean13,upc) ,
    OPERATOR 1 <(isbn13,ean13) ,
    OPERATOR 1 <(ean13,ismn13) ,
    OPERATOR 1 <(isbn13,isbn) ,
    OPERATOR 1 <(issn,issn13) ,
    OPERATOR 1 <(issn,ean13) ,
    OPERATOR 1 <(isbn,ean13) ,
    OPERATOR 1 <(isbn,isbn13) ,
    OPERATOR 1 <(ismn13,ean13) ,
    OPERATOR 1 <(ismn13,ismn) ,
    OPERATOR 1 <(ismn,ean13) ,
    OPERATOR 2 <=(ean13,ismn13) ,
    OPERATOR 2 <=(issn,ean13) ,
    OPERATOR 2 <=(upc,ean13) ,
    OPERATOR 2 <=(issn,issn13) ,
    OPERATOR 2 <=(issn13,issn) ,
    OPERATOR 2 <=(issn13,ean13) ,
    OPERATOR 2 <=(ismn,ismn13) ,
    OPERATOR 2 <=(ismn,ean13) ,
    OPERATOR 2 <=(ismn13,ismn) ,
    OPERATOR 2 <=(ismn13,ean13) ,
    OPERATOR 2 <=(ean13,isbn13) ,
    OPERATOR 2 <=(isbn,isbn13) ,
    OPERATOR 2 <=(isbn,ean13) ,
    OPERATOR 2 <=(isbn13,isbn) ,
    OPERATOR 2 <=(isbn13,ean13) ,
    OPERATOR 2 <=(ean13,upc) ,
    OPERATOR 2 <=(ean13,issn) ,
    OPERATOR 2 <=(ean13,ismn) ,
    OPERATOR 2 <=(ean13,isbn) ,
    OPERATOR 2 <=(ean13,issn13) ,
    OPERATOR 3 =(isbn,isbn13) ,
    OPERATOR 3 =(isbn13,isbn) ,
    OPERATOR 3 =(ismn13,ean13) ,
    OPERATOR 3 =(issn13,issn) ,
    OPERATOR 3 =(ean13,ismn13) ,
    OPERATOR 3 =(ismn,ismn13) ,
    OPERATOR 3 =(ismn,ean13) ,
    OPERATOR 3 =(ean13,isbn13) ,
    OPERATOR 3 =(issn,issn13) ,
    OPERATOR 3 =(issn13,ean13) ,
    OPERATOR 3 =(isbn,ean13) ,
    OPERATOR 3 =(ean13,upc) ,
    OPERATOR 3 =(ean13,issn) ,
    OPERATOR 3 =(ean13,ismn) ,
    OPERATOR 3 =(ean13,isbn) ,
    OPERATOR 3 =(issn,ean13) ,
    OPERATOR 3 =(ean13,issn13) ,
    OPERATOR 3 =(ismn13,ismn) ,
    OPERATOR 3 =(upc,ean13) ,
    OPERATOR 3 =(isbn13,ean13) ,
    OPERATOR 4 >=(ismn13,ean13) ,
    OPERATOR 4 >=(isbn,isbn13) ,
    OPERATOR 4 >=(issn,ean13) ,
    OPERATOR 4 >=(issn,issn13) ,
    OPERATOR 4 >=(issn13,ean13) ,
    OPERATOR 4 >=(issn13,issn) ,
    OPERATOR 4 >=(isbn,ean13) ,
    OPERATOR 4 >=(isbn13,isbn) ,
    OPERATOR 4 >=(isbn13,ean13) ,
    OPERATOR 4 >=(upc,ean13) ,
    OPERATOR 4 >=(ean13,upc) ,
    OPERATOR 4 >=(ean13,issn) ,
    OPERATOR 4 >=(ean13,ismn) ,
    OPERATOR 4 >=(ean13,isbn) ,
    OPERATOR 4 >=(ean13,issn13) ,
    OPERATOR 4 >=(ean13,ismn13) ,
    OPERATOR 4 >=(ean13,isbn13) ,
    OPERATOR 4 >=(ismn,ismn13) ,
    OPERATOR 4 >=(ismn,ean13) ,
    OPERATOR 4 >=(ismn13,ismn) ,
    OPERATOR 5 >(ismn13,ismn) ,
    OPERATOR 5 >(ean13,ismn) ,
    OPERATOR 5 >(ean13,issn) ,
    OPERATOR 5 >(ean13,upc) ,
    OPERATOR 5 >(upc,ean13) ,
    OPERATOR 5 >(isbn13,ean13) ,
    OPERATOR 5 >(ismn,ismn13) ,
    OPERATOR 5 >(ismn,ean13) ,
    OPERATOR 5 >(ismn13,ean13) ,
    OPERATOR 5 >(isbn,isbn13) ,
    OPERATOR 5 >(ean13,issn13) ,
    OPERATOR 5 >(ean13,ismn13) ,
    OPERATOR 5 >(ean13,isbn13) ,
    OPERATOR 5 >(isbn13,isbn) ,
    OPERATOR 5 >(issn13,issn) ,
    OPERATOR 5 >(issn13,ean13) ,
    OPERATOR 5 >(issn,issn13) ,
    OPERATOR 5 >(issn,ean13) ,
    OPERATOR 5 >(isbn,ean13) ,
    OPERATOR 5 >(ean13,isbn) ,
    FUNCTION 1 (ean13, isbn13) btean13cmp(ean13,isbn13) ,
    FUNCTION 1 (ean13, ismn13) btean13cmp(ean13,ismn13) ,
    FUNCTION 1 (ean13, issn13) btean13cmp(ean13,issn13) ,
    FUNCTION 1 (ean13, isbn) btean13cmp(ean13,isbn) ,
    FUNCTION 1 (ean13, ismn) btean13cmp(ean13,ismn) ,
    FUNCTION 1 (ean13, issn) btean13cmp(ean13,issn) ,
    FUNCTION 1 (ean13, upc) btean13cmp(ean13,upc) ,
    FUNCTION 1 (isbn13, ean13) btisbn13cmp(isbn13,ean13) ,
    FUNCTION 1 (isbn13, isbn) btisbn13cmp(isbn13,isbn) ,
    FUNCTION 1 (isbn, ean13) btisbncmp(isbn,ean13) ,
    FUNCTION 1 (isbn, isbn13) btisbncmp(isbn,isbn13) ,
    FUNCTION 1 (ismn13, ean13) btismn13cmp(ismn13,ean13) ,
    FUNCTION 1 (ismn13, ismn) btismn13cmp(ismn13,ismn) ,
    FUNCTION 1 (ismn, ean13) btismncmp(ismn,ean13) ,
    FUNCTION 1 (ismn, ismn13) btismncmp(ismn,ismn13) ,
    FUNCTION 1 (issn13, ean13) btissn13cmp(issn13,ean13) ,
    FUNCTION 1 (issn13, issn) btissn13cmp(issn13,issn) ,
    FUNCTION 1 (issn, ean13) btissncmp(issn,ean13) ,
    FUNCTION 1 (issn, issn13) btissncmp(issn,issn13) ,
    FUNCTION 1 (upc, ean13) btupccmp(upc,ean13);


ALTER OPERATOR FAMILY public.isn_ops USING btree OWNER TO evergreen;

--
-- Name: ean13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ean13_ops
    DEFAULT FOR TYPE ean13 USING btree FAMILY isn_ops AS
    OPERATOR 1 <(ean13,ean13) ,
    OPERATOR 2 <=(ean13,ean13) ,
    OPERATOR 3 =(ean13,ean13) ,
    OPERATOR 4 >=(ean13,ean13) ,
    OPERATOR 5 >(ean13,ean13) ,
    FUNCTION 1 (ean13, ean13) btean13cmp(ean13,ean13);


ALTER OPERATOR CLASS public.ean13_ops USING btree OWNER TO evergreen;

--
-- Name: isn_ops; Type: OPERATOR FAMILY; Schema: public; Owner: evergreen
--

CREATE OPERATOR FAMILY isn_ops USING hash;
ALTER OPERATOR FAMILY isn_ops USING hash ADD
    OPERATOR 1 =(ean13,isbn13) ,
    OPERATOR 1 =(ean13,ismn13) ,
    OPERATOR 1 =(ean13,issn13) ,
    OPERATOR 1 =(ean13,isbn) ,
    OPERATOR 1 =(ean13,ismn) ,
    OPERATOR 1 =(ean13,issn) ,
    OPERATOR 1 =(ean13,upc) ,
    OPERATOR 1 =(isbn13,ean13) ,
    OPERATOR 1 =(isbn13,isbn) ,
    OPERATOR 1 =(isbn,ean13) ,
    OPERATOR 1 =(isbn,isbn13) ,
    OPERATOR 1 =(ismn13,ean13) ,
    OPERATOR 1 =(ismn13,ismn) ,
    OPERATOR 1 =(ismn,ean13) ,
    OPERATOR 1 =(ismn,ismn13) ,
    OPERATOR 1 =(issn13,ean13) ,
    OPERATOR 1 =(issn13,issn) ,
    OPERATOR 1 =(issn,ean13) ,
    OPERATOR 1 =(issn,issn13) ,
    OPERATOR 1 =(upc,ean13);


ALTER OPERATOR FAMILY public.isn_ops USING hash OWNER TO evergreen;

--
-- Name: ean13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ean13_ops
    DEFAULT FOR TYPE ean13 USING hash FAMILY isn_ops AS
    OPERATOR 1 =(ean13,ean13) ,
    FUNCTION 1 (ean13, ean13) hashean13(ean13);


ALTER OPERATOR CLASS public.ean13_ops USING hash OWNER TO evergreen;

--
-- Name: gin_hstore_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gin_hstore_ops USING gin;


ALTER OPERATOR FAMILY public.gin_hstore_ops USING gin OWNER TO postgres;

--
-- Name: gin_hstore_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS gin_hstore_ops
    DEFAULT FOR TYPE hstore USING gin AS
    STORAGE text ,
    OPERATOR 7 @>(hstore,hstore) ,
    OPERATOR 9 ?(hstore,text) ,
    OPERATOR 10 ?|(hstore,text[]) ,
    OPERATOR 11 ?&(hstore,text[]) ,
    FUNCTION 1 (hstore, hstore) bttextcmp(text,text) ,
    FUNCTION 2 (hstore, hstore) gin_extract_hstore(internal,internal) ,
    FUNCTION 3 (hstore, hstore) gin_extract_hstore_query(internal,internal,smallint,internal,internal) ,
    FUNCTION 4 (hstore, hstore) gin_consistent_hstore(internal,smallint,internal,integer,internal,internal);


ALTER OPERATOR CLASS public.gin_hstore_ops USING gin OWNER TO evergreen;

--
-- Name: gist_hstore_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_hstore_ops USING gist;


ALTER OPERATOR FAMILY public.gist_hstore_ops USING gist OWNER TO postgres;

--
-- Name: gist_hstore_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS gist_hstore_ops
    DEFAULT FOR TYPE hstore USING gist AS
    STORAGE ghstore ,
    OPERATOR 7 @>(hstore,hstore) ,
    OPERATOR 9 ?(hstore,text) ,
    OPERATOR 10 ?|(hstore,text[]) ,
    OPERATOR 11 ?&(hstore,text[]) ,
    OPERATOR 13 @(hstore,hstore) ,
    FUNCTION 1 (hstore, hstore) ghstore_consistent(internal,internal,integer,oid,internal) ,
    FUNCTION 2 (hstore, hstore) ghstore_union(internal,internal) ,
    FUNCTION 3 (hstore, hstore) ghstore_compress(internal) ,
    FUNCTION 4 (hstore, hstore) ghstore_decompress(internal) ,
    FUNCTION 5 (hstore, hstore) ghstore_penalty(internal,internal,internal) ,
    FUNCTION 6 (hstore, hstore) ghstore_picksplit(internal,internal) ,
    FUNCTION 7 (hstore, hstore) ghstore_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_hstore_ops USING gist OWNER TO evergreen;

--
-- Name: hash_hstore_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY hash_hstore_ops USING hash;


ALTER OPERATOR FAMILY public.hash_hstore_ops USING hash OWNER TO postgres;

--
-- Name: hash_hstore_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS hash_hstore_ops
    DEFAULT FOR TYPE hstore USING hash AS
    OPERATOR 1 =(hstore,hstore) ,
    FUNCTION 1 (hstore, hstore) hstore_hash(hstore);


ALTER OPERATOR CLASS public.hash_hstore_ops USING hash OWNER TO evergreen;

--
-- Name: isbn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS isbn13_ops
    DEFAULT FOR TYPE isbn13 USING btree FAMILY isn_ops AS
    OPERATOR 1 <(isbn13,isbn13) ,
    OPERATOR 2 <=(isbn13,isbn13) ,
    OPERATOR 3 =(isbn13,isbn13) ,
    OPERATOR 4 >=(isbn13,isbn13) ,
    OPERATOR 5 >(isbn13,isbn13) ,
    FUNCTION 1 (isbn13, isbn13) btisbn13cmp(isbn13,isbn13);


ALTER OPERATOR CLASS public.isbn13_ops USING btree OWNER TO evergreen;

--
-- Name: isbn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS isbn13_ops
    DEFAULT FOR TYPE isbn13 USING hash FAMILY isn_ops AS
    OPERATOR 1 =(isbn13,isbn13) ,
    FUNCTION 1 (isbn13, isbn13) hashisbn13(isbn13);


ALTER OPERATOR CLASS public.isbn13_ops USING hash OWNER TO evergreen;

--
-- Name: isbn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS isbn_ops
    DEFAULT FOR TYPE isbn USING btree FAMILY isn_ops AS
    OPERATOR 1 <(isbn,isbn) ,
    OPERATOR 2 <=(isbn,isbn) ,
    OPERATOR 3 =(isbn,isbn) ,
    OPERATOR 4 >=(isbn,isbn) ,
    OPERATOR 5 >(isbn,isbn) ,
    FUNCTION 1 (isbn, isbn) btisbncmp(isbn,isbn);


ALTER OPERATOR CLASS public.isbn_ops USING btree OWNER TO evergreen;

--
-- Name: isbn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS isbn_ops
    DEFAULT FOR TYPE isbn USING hash FAMILY isn_ops AS
    OPERATOR 1 =(isbn,isbn) ,
    FUNCTION 1 (isbn, isbn) hashisbn(isbn);


ALTER OPERATOR CLASS public.isbn_ops USING hash OWNER TO evergreen;

--
-- Name: ismn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ismn13_ops
    DEFAULT FOR TYPE ismn13 USING btree FAMILY isn_ops AS
    OPERATOR 1 <(ismn13,ismn13) ,
    OPERATOR 2 <=(ismn13,ismn13) ,
    OPERATOR 3 =(ismn13,ismn13) ,
    OPERATOR 4 >=(ismn13,ismn13) ,
    OPERATOR 5 >(ismn13,ismn13) ,
    FUNCTION 1 (ismn13, ismn13) btismn13cmp(ismn13,ismn13);


ALTER OPERATOR CLASS public.ismn13_ops USING btree OWNER TO evergreen;

--
-- Name: ismn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ismn13_ops
    DEFAULT FOR TYPE ismn13 USING hash FAMILY isn_ops AS
    OPERATOR 1 =(ismn13,ismn13) ,
    FUNCTION 1 (ismn13, ismn13) hashismn13(ismn13);


ALTER OPERATOR CLASS public.ismn13_ops USING hash OWNER TO evergreen;

--
-- Name: ismn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ismn_ops
    DEFAULT FOR TYPE ismn USING btree FAMILY isn_ops AS
    OPERATOR 1 <(ismn,ismn) ,
    OPERATOR 2 <=(ismn,ismn) ,
    OPERATOR 3 =(ismn,ismn) ,
    OPERATOR 4 >=(ismn,ismn) ,
    OPERATOR 5 >(ismn,ismn) ,
    FUNCTION 1 (ismn, ismn) btismncmp(ismn,ismn);


ALTER OPERATOR CLASS public.ismn_ops USING btree OWNER TO evergreen;

--
-- Name: ismn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS ismn_ops
    DEFAULT FOR TYPE ismn USING hash FAMILY isn_ops AS
    OPERATOR 1 =(ismn,ismn) ,
    FUNCTION 1 (ismn, ismn) hashismn(ismn);


ALTER OPERATOR CLASS public.ismn_ops USING hash OWNER TO evergreen;

--
-- Name: issn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS issn13_ops
    DEFAULT FOR TYPE issn13 USING btree FAMILY isn_ops AS
    OPERATOR 1 <(issn13,issn13) ,
    OPERATOR 2 <=(issn13,issn13) ,
    OPERATOR 3 =(issn13,issn13) ,
    OPERATOR 4 >=(issn13,issn13) ,
    OPERATOR 5 >(issn13,issn13) ,
    FUNCTION 1 (issn13, issn13) btissn13cmp(issn13,issn13);


ALTER OPERATOR CLASS public.issn13_ops USING btree OWNER TO evergreen;

--
-- Name: issn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS issn13_ops
    DEFAULT FOR TYPE issn13 USING hash FAMILY isn_ops AS
    OPERATOR 1 =(issn13,issn13) ,
    FUNCTION 1 (issn13, issn13) hashissn13(issn13);


ALTER OPERATOR CLASS public.issn13_ops USING hash OWNER TO evergreen;

--
-- Name: issn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS issn_ops
    DEFAULT FOR TYPE issn USING btree FAMILY isn_ops AS
    OPERATOR 1 <(issn,issn) ,
    OPERATOR 2 <=(issn,issn) ,
    OPERATOR 3 =(issn,issn) ,
    OPERATOR 4 >=(issn,issn) ,
    OPERATOR 5 >(issn,issn) ,
    FUNCTION 1 (issn, issn) btissncmp(issn,issn);


ALTER OPERATOR CLASS public.issn_ops USING btree OWNER TO evergreen;

--
-- Name: issn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS issn_ops
    DEFAULT FOR TYPE issn USING hash FAMILY isn_ops AS
    OPERATOR 1 =(issn,issn) ,
    FUNCTION 1 (issn, issn) hashissn(issn);


ALTER OPERATOR CLASS public.issn_ops USING hash OWNER TO evergreen;

--
-- Name: upc_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS upc_ops
    DEFAULT FOR TYPE upc USING btree FAMILY isn_ops AS
    OPERATOR 1 <(upc,upc) ,
    OPERATOR 2 <=(upc,upc) ,
    OPERATOR 3 =(upc,upc) ,
    OPERATOR 4 >=(upc,upc) ,
    OPERATOR 5 >(upc,upc) ,
    FUNCTION 1 (upc, upc) btupccmp(upc,upc);


ALTER OPERATOR CLASS public.upc_ops USING btree OWNER TO evergreen;

--
-- Name: upc_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS upc_ops
    DEFAULT FOR TYPE upc USING hash FAMILY isn_ops AS
    OPERATOR 1 =(upc,upc) ,
    FUNCTION 1 (upc, upc) hashupc(upc);


ALTER OPERATOR CLASS public.upc_ops USING hash OWNER TO evergreen;

SET search_path = pg_catalog;

--
-- Name: CAST (text[] AS public.hstore); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text[] AS public.hstore) WITH FUNCTION public.hstore(text[]);


--
-- Name: CAST (public.ean13 AS public.isbn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.isbn) WITH FUNCTION public.isbn(public.ean13);


--
-- Name: CAST (public.ean13 AS public.isbn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.isbn13) WITH FUNCTION public.isbn13(public.ean13);


--
-- Name: CAST (public.ean13 AS public.ismn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.ismn) WITH FUNCTION public.ismn(public.ean13);


--
-- Name: CAST (public.ean13 AS public.ismn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.ismn13) WITH FUNCTION public.ismn13(public.ean13);


--
-- Name: CAST (public.ean13 AS public.issn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.issn) WITH FUNCTION public.issn(public.ean13);


--
-- Name: CAST (public.ean13 AS public.issn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.issn13) WITH FUNCTION public.issn13(public.ean13);


--
-- Name: CAST (public.ean13 AS public.upc); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ean13 AS public.upc) WITH FUNCTION public.upc(public.ean13);


--
-- Name: CAST (public.isbn AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.isbn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn AS public.isbn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.isbn AS public.isbn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn13 AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.isbn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn13 AS public.isbn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.isbn13 AS public.isbn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ismn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn AS public.ismn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ismn AS public.ismn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn13 AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ismn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn13 AS public.ismn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ismn13 AS public.ismn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.issn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn AS public.issn13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.issn AS public.issn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn13 AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.issn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn13 AS public.issn); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.issn13 AS public.issn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.upc AS public.ean13); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.upc AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


SET search_path = public, pg_catalog;

--
-- Name: danish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY danish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'danish' );


ALTER TEXT SEARCH DICTIONARY public.danish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY danish_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY danish_nostop IS 'danish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: dutch_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY dutch_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'dutch' );


ALTER TEXT SEARCH DICTIONARY public.dutch_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY dutch_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY dutch_nostop IS 'dutch snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: english_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY english_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'english' );


ALTER TEXT SEARCH DICTIONARY public.english_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY english_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY english_nostop IS 'english snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: finnish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY finnish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'finnish' );


ALTER TEXT SEARCH DICTIONARY public.finnish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY finnish_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY finnish_nostop IS 'finnish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: french_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY french_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'french' );


ALTER TEXT SEARCH DICTIONARY public.french_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY french_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY french_nostop IS 'french snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: german_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY german_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'german' );


ALTER TEXT SEARCH DICTIONARY public.german_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY german_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY german_nostop IS 'german snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: hungarian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY hungarian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'hungarian' );


ALTER TEXT SEARCH DICTIONARY public.hungarian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY hungarian_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY hungarian_nostop IS 'hungarian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: italian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY italian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'italian' );


ALTER TEXT SEARCH DICTIONARY public.italian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY italian_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY italian_nostop IS 'italian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: norwegian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY norwegian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'norwegian' );


ALTER TEXT SEARCH DICTIONARY public.norwegian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY norwegian_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY norwegian_nostop IS 'norwegian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: portuguese_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY portuguese_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'portuguese' );


ALTER TEXT SEARCH DICTIONARY public.portuguese_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY portuguese_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY portuguese_nostop IS 'portuguese snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: romanian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY romanian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'romanian' );


ALTER TEXT SEARCH DICTIONARY public.romanian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY romanian_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY romanian_nostop IS 'romanian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: russian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY russian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'russian' );


ALTER TEXT SEARCH DICTIONARY public.russian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY russian_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY russian_nostop IS 'russian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: spanish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY spanish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'spanish' );


ALTER TEXT SEARCH DICTIONARY public.spanish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY spanish_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY spanish_nostop IS 'spanish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: swedish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY swedish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'swedish' );


ALTER TEXT SEARCH DICTIONARY public.swedish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY swedish_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY swedish_nostop IS 'swedish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: turkish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY turkish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'turkish' );


ALTER TEXT SEARCH DICTIONARY public.turkish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY turkish_nostop; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY turkish_nostop IS 'turkish snowball stemmer with no stopwords for ASCII words only.';


SET search_path = evergreen, pg_catalog;

--
-- Name: author; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION author (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.author OWNER TO evergreen;

--
-- Name: identifier; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION identifier (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION identifier
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.identifier OWNER TO evergreen;

--
-- Name: series; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION series (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION series
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.series OWNER TO evergreen;

--
-- Name: subject; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION subject (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.subject OWNER TO evergreen;

--
-- Name: title; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION title (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.title OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: author; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION author (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION author
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.author OWNER TO evergreen;

--
-- Name: danish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION danish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR asciiword WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword_asciipart WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR asciihword WITH danish_nostop;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION danish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.danish_nostop OWNER TO evergreen;

--
-- Name: default; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION "default" (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION "default"
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public."default" OWNER TO evergreen;

--
-- Name: dutch_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION dutch_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR asciiword WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword_asciipart WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR asciihword WITH dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION dutch_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop OWNER TO evergreen;

--
-- Name: english_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION english_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION english_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.english_nostop OWNER TO evergreen;

--
-- Name: finnish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION finnish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR asciiword WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword_asciipart WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR asciihword WITH finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION finnish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop OWNER TO evergreen;

--
-- Name: french_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION french_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR asciiword WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword_asciipart WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR asciihword WITH french_nostop;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION french_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.french_nostop OWNER TO evergreen;

--
-- Name: german_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION german_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR asciiword WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword_asciipart WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR asciihword WITH german_nostop;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION german_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.german_nostop OWNER TO evergreen;

--
-- Name: hungarian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION hungarian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR asciiword WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword_asciipart WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR asciihword WITH hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION hungarian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop OWNER TO evergreen;

--
-- Name: italian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION italian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR asciiword WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword_asciipart WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR asciihword WITH italian_nostop;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION italian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.italian_nostop OWNER TO evergreen;

--
-- Name: keyword; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION keyword (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR asciiword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword_asciipart WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR asciihword WITH english_nostop;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION keyword
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.keyword OWNER TO evergreen;

--
-- Name: norwegian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION norwegian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR asciiword WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword_asciipart WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR asciihword WITH norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION norwegian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop OWNER TO evergreen;

--
-- Name: portuguese_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION portuguese_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR asciiword WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword_asciipart WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR asciihword WITH portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION portuguese_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop OWNER TO evergreen;

--
-- Name: romanian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION romanian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR asciiword WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword_asciipart WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR asciihword WITH romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION romanian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop OWNER TO evergreen;

--
-- Name: russian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION russian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR asciiword WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword_asciipart WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR asciihword WITH russian_nostop;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION russian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.russian_nostop OWNER TO evergreen;

--
-- Name: spanish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION spanish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR asciiword WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword_asciipart WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR asciihword WITH spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION spanish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop OWNER TO evergreen;

--
-- Name: subject; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION subject (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION subject
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.subject OWNER TO evergreen;

--
-- Name: swedish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION swedish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR asciiword WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword_asciipart WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR asciihword WITH swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION swedish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop OWNER TO evergreen;

--
-- Name: title; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION title (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION title
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.title OWNER TO evergreen;

--
-- Name: turkish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION turkish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR asciiword WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword_asciipart WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR asciihword WITH turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION turkish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop OWNER TO evergreen;

SET search_path = acq, pg_catalog;

--
-- Name: acq_lineitem_history; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_lineitem_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint
);


ALTER TABLE acq.acq_lineitem_history OWNER TO evergreen;

--
-- Name: lineitem; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem (
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text DEFAULT 'new'::text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint,
    CONSTRAINT picklist_or_po CHECK (((picklist IS NOT NULL) OR (purchase_order IS NOT NULL)))
);


ALTER TABLE acq.lineitem OWNER TO evergreen;

--
-- Name: acq_lineitem_lifecycle; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq_lineitem_lifecycle AS
    SELECT (-1), now() AS audit_time, '-'::text AS audit_action, lineitem.id, lineitem.creator, lineitem.editor, lineitem.selector, lineitem.provider, lineitem.purchase_order, lineitem.picklist, lineitem.expected_recv_time, lineitem.create_time, lineitem.edit_time, lineitem.marc, lineitem.eg_bib_id, lineitem.source_label, lineitem.state, lineitem.cancel_reason, lineitem.estimated_unit_price, lineitem.claim_policy FROM lineitem UNION ALL SELECT acq_lineitem_history.audit_id AS "?column?", acq_lineitem_history.audit_time, acq_lineitem_history.audit_action, acq_lineitem_history.id, acq_lineitem_history.creator, acq_lineitem_history.editor, acq_lineitem_history.selector, acq_lineitem_history.provider, acq_lineitem_history.purchase_order, acq_lineitem_history.picklist, acq_lineitem_history.expected_recv_time, acq_lineitem_history.create_time, acq_lineitem_history.edit_time, acq_lineitem_history.marc, acq_lineitem_history.eg_bib_id, acq_lineitem_history.source_label, acq_lineitem_history.state, acq_lineitem_history.cancel_reason, acq_lineitem_history.estimated_unit_price, acq_lineitem_history.claim_policy FROM acq_lineitem_history;


ALTER TABLE acq.acq_lineitem_lifecycle OWNER TO evergreen;

--
-- Name: acq_lineitem_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq_lineitem_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_lineitem_pkey_seq OWNER TO evergreen;

--
-- Name: acq_purchase_order_history; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_purchase_order_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    provider integer NOT NULL,
    state text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean NOT NULL
);


ALTER TABLE acq.acq_purchase_order_history OWNER TO evergreen;

--
-- Name: purchase_order; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE purchase_order (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    provider integer NOT NULL,
    state text DEFAULT 'new'::text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean DEFAULT false NOT NULL,
    CONSTRAINT valid_po_state CHECK ((state = ANY (ARRAY['new'::text, 'pending'::text, 'on-order'::text, 'received'::text, 'cancelled'::text])))
);


ALTER TABLE acq.purchase_order OWNER TO evergreen;

--
-- Name: acq_purchase_order_lifecycle; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq_purchase_order_lifecycle AS
    SELECT (-1), now() AS audit_time, '-'::text AS audit_action, purchase_order.id, purchase_order.owner, purchase_order.creator, purchase_order.editor, purchase_order.ordering_agency, purchase_order.create_time, purchase_order.edit_time, purchase_order.provider, purchase_order.state, purchase_order.order_date, purchase_order.name, purchase_order.cancel_reason, purchase_order.prepayment_required FROM purchase_order UNION ALL SELECT acq_purchase_order_history.audit_id AS "?column?", acq_purchase_order_history.audit_time, acq_purchase_order_history.audit_action, acq_purchase_order_history.id, acq_purchase_order_history.owner, acq_purchase_order_history.creator, acq_purchase_order_history.editor, acq_purchase_order_history.ordering_agency, acq_purchase_order_history.create_time, acq_purchase_order_history.edit_time, acq_purchase_order_history.provider, acq_purchase_order_history.state, acq_purchase_order_history.order_date, acq_purchase_order_history.name, acq_purchase_order_history.cancel_reason, acq_purchase_order_history.prepayment_required FROM acq_purchase_order_history;


ALTER TABLE acq.acq_purchase_order_lifecycle OWNER TO evergreen;

--
-- Name: acq_purchase_order_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq_purchase_order_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_purchase_order_pkey_seq OWNER TO evergreen;

--
-- Name: fund; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund (
    id integer NOT NULL,
    org integer NOT NULL,
    name text NOT NULL,
    year integer DEFAULT date_part('year'::text, now()) NOT NULL,
    currency_type text NOT NULL,
    code text,
    rollover boolean DEFAULT false NOT NULL,
    propagate boolean DEFAULT true NOT NULL,
    active boolean DEFAULT true NOT NULL,
    balance_warning_percent integer,
    balance_stop_percent integer,
    CONSTRAINT acq_fund_rollover_implies_propagate CHECK ((propagate OR (NOT rollover)))
);


ALTER TABLE acq.fund OWNER TO evergreen;

--
-- Name: fund_allocation; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_allocation (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    fund integer NOT NULL,
    amount numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.fund_allocation OWNER TO evergreen;

--
-- Name: funding_source; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE funding_source (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text
);


ALTER TABLE acq.funding_source OWNER TO evergreen;

--
-- Name: all_fund_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW all_fund_allocation_total AS
    SELECT f.id AS fund, COALESCE((sum((a.amount * exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2), (0)::numeric) AS amount FROM ((fund f LEFT JOIN fund_allocation a ON ((a.fund = f.id))) LEFT JOIN funding_source s ON ((a.funding_source = s.id))) GROUP BY f.id;


ALTER TABLE acq.all_fund_allocation_total OWNER TO evergreen;

--
-- Name: fund_debit; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_debit (
    id integer NOT NULL,
    fund integer NOT NULL,
    origin_amount numeric NOT NULL,
    origin_currency_type text NOT NULL,
    amount numeric NOT NULL,
    encumbrance boolean DEFAULT true NOT NULL,
    debit_type text NOT NULL,
    xfer_destination integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    invoice_entry integer
);


ALTER TABLE acq.fund_debit OWNER TO evergreen;

--
-- Name: all_fund_combined_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW all_fund_combined_balance AS
    SELECT a.fund, (a.amount - COALESCE(c.amount, (0)::numeric)) AS amount FROM (all_fund_allocation_total a LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit GROUP BY fund_debit.fund) c USING (fund));


ALTER TABLE acq.all_fund_combined_balance OWNER TO evergreen;

--
-- Name: all_fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW all_fund_encumbrance_total AS
    SELECT f.id AS fund, COALESCE(encumb.amount, (0)::numeric) AS amount FROM (fund f LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit WHERE fund_debit.encumbrance GROUP BY fund_debit.fund) encumb ON ((f.id = encumb.fund)));


ALTER TABLE acq.all_fund_encumbrance_total OWNER TO evergreen;

--
-- Name: all_fund_spent_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW all_fund_spent_total AS
    SELECT f.id AS fund, COALESCE(spent.amount, (0)::numeric) AS amount FROM (fund f LEFT JOIN (SELECT fund_debit.fund, sum(fund_debit.amount) AS amount FROM fund_debit WHERE (NOT fund_debit.encumbrance) GROUP BY fund_debit.fund) spent ON ((f.id = spent.fund)));


ALTER TABLE acq.all_fund_spent_total OWNER TO evergreen;

--
-- Name: all_fund_spent_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW all_fund_spent_balance AS
    SELECT c.fund, (c.amount - d.amount) AS amount FROM (all_fund_allocation_total c LEFT JOIN all_fund_spent_total d USING (fund));


ALTER TABLE acq.all_fund_spent_balance OWNER TO evergreen;

--
-- Name: cancel_reason; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE cancel_reason (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    label text NOT NULL,
    description text NOT NULL,
    keep_debits boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.cancel_reason OWNER TO evergreen;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE cancel_reason_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.cancel_reason_id_seq OWNER TO evergreen;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE cancel_reason_id_seq OWNED BY cancel_reason.id;


--
-- Name: claim; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim (
    id integer NOT NULL,
    type integer NOT NULL,
    lineitem_detail bigint NOT NULL
);


ALTER TABLE acq.claim OWNER TO evergreen;

--
-- Name: claim_event; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.claim_event OWNER TO evergreen;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_claim_seq OWNER TO evergreen;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_event_claim_seq OWNED BY claim_event.claim;


--
-- Name: claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_id_seq OWNER TO evergreen;

--
-- Name: claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_event_id_seq OWNED BY claim_event.id;


--
-- Name: claim_event_type; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim_event_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    library_initiated boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.claim_event_type OWNER TO evergreen;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_event_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_type_id_seq OWNER TO evergreen;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_event_type_id_seq OWNED BY claim_event_type.id;


--
-- Name: claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_id_seq OWNER TO evergreen;

--
-- Name: claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_id_seq OWNED BY claim.id;


--
-- Name: claim_policy; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim_policy (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_policy OWNER TO evergreen;

--
-- Name: claim_policy_action; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim_policy_action (
    id integer NOT NULL,
    claim_policy integer NOT NULL,
    action_interval interval NOT NULL,
    action integer NOT NULL
);


ALTER TABLE acq.claim_policy_action OWNER TO evergreen;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_policy_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_action_id_seq OWNER TO evergreen;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_policy_action_id_seq OWNED BY claim_policy_action.id;


--
-- Name: claim_policy_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_policy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_id_seq OWNER TO evergreen;

--
-- Name: claim_policy_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_policy_id_seq OWNED BY claim_policy.id;


--
-- Name: claim_type; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE claim_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_type OWNER TO evergreen;

--
-- Name: claim_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE claim_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_type_id_seq OWNER TO evergreen;

--
-- Name: claim_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE claim_type_id_seq OWNED BY claim_type.id;


--
-- Name: currency_type; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE currency_type (
    code text NOT NULL,
    label text
);


ALTER TABLE acq.currency_type OWNER TO evergreen;

--
-- Name: debit_attribution; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE debit_attribution (
    id integer NOT NULL,
    fund_debit integer NOT NULL,
    debit_amount numeric NOT NULL,
    funding_source_credit integer,
    credit_amount numeric
);


ALTER TABLE acq.debit_attribution OWNER TO evergreen;

--
-- Name: distribution_formula; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE distribution_formula (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    skip_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE acq.distribution_formula OWNER TO evergreen;

--
-- Name: distribution_formula_application; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE distribution_formula_application (
    id bigint NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    formula integer NOT NULL,
    lineitem integer NOT NULL
);


ALTER TABLE acq.distribution_formula_application OWNER TO evergreen;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE distribution_formula_application_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_application_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE distribution_formula_application_id_seq OWNED BY distribution_formula_application.id;


--
-- Name: distribution_formula_entry; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE distribution_formula_entry (
    id integer NOT NULL,
    formula integer NOT NULL,
    "position" integer NOT NULL,
    item_count integer NOT NULL,
    owning_lib integer,
    location integer,
    fund integer,
    circ_modifier text,
    collection_code text,
    CONSTRAINT acqdfe_must_be_somewhere CHECK (((owning_lib IS NOT NULL) OR (location IS NOT NULL)))
);


ALTER TABLE acq.distribution_formula_entry OWNER TO evergreen;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE distribution_formula_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_entry_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE distribution_formula_entry_id_seq OWNED BY distribution_formula_entry.id;


--
-- Name: distribution_formula_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE distribution_formula_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE distribution_formula_id_seq OWNED BY distribution_formula.id;


SET search_path = config, pg_catalog;

--
-- Name: remote_account; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE remote_account (
    id integer NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    username text,
    password text,
    account text,
    path text,
    owner integer NOT NULL,
    last_activity timestamp with time zone
);


ALTER TABLE config.remote_account OWNER TO evergreen;

--
-- Name: remote_account_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE remote_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.remote_account_id_seq OWNER TO evergreen;

--
-- Name: remote_account_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE remote_account_id_seq OWNED BY remote_account.id;


SET search_path = acq, pg_catalog;

--
-- Name: edi_account; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE edi_account (
    id integer DEFAULT nextval('config.remote_account_id_seq'::regclass),
    provider integer NOT NULL,
    in_dir text,
    vendcode text,
    vendacct text
)
INHERITS (config.remote_account);


ALTER TABLE acq.edi_account OWNER TO evergreen;

--
-- Name: edi_message; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE edi_message (
    id integer NOT NULL,
    account integer,
    remote_file text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text DEFAULT 'new'::text NOT NULL,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text NOT NULL,
    CONSTRAINT status_value CHECK ((status = ANY (ARRAY['new'::text, 'translated'::text, 'trans_error'::text, 'processed'::text, 'proc_error'::text, 'delete_error'::text, 'retry'::text, 'complete'::text]))),
    CONSTRAINT valid_message_type CHECK ((message_type = ANY (ARRAY['ORDERS'::text, 'ORDRSP'::text, 'INVOIC'::text, 'OSTENQ'::text, 'OSTRPT'::text])))
);


ALTER TABLE acq.edi_message OWNER TO evergreen;

--
-- Name: edi_message_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE edi_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.edi_message_id_seq OWNER TO evergreen;

--
-- Name: edi_message_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE edi_message_id_seq OWNED BY edi_message.id;


--
-- Name: exchange_rate; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE exchange_rate (
    id integer NOT NULL,
    from_currency text NOT NULL,
    to_currency text NOT NULL,
    ratio numeric NOT NULL
);


ALTER TABLE acq.exchange_rate OWNER TO evergreen;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE exchange_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.exchange_rate_id_seq OWNER TO evergreen;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE exchange_rate_id_seq OWNED BY exchange_rate.id;


--
-- Name: fiscal_calendar; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fiscal_calendar (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fiscal_calendar OWNER TO evergreen;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fiscal_calendar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_calendar_id_seq OWNER TO evergreen;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fiscal_calendar_id_seq OWNED BY fiscal_calendar.id;


--
-- Name: fiscal_year; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fiscal_year (
    id integer NOT NULL,
    calendar integer NOT NULL,
    year integer NOT NULL,
    year_begin timestamp with time zone NOT NULL,
    year_end timestamp with time zone NOT NULL
);


ALTER TABLE acq.fiscal_year OWNER TO evergreen;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fiscal_year_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_year_id_seq OWNER TO evergreen;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fiscal_year_id_seq OWNED BY fiscal_year.id;


--
-- Name: fund_allocation_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_allocation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_id_seq OWNER TO evergreen;

--
-- Name: fund_allocation_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_allocation_id_seq OWNED BY fund_allocation.id;


--
-- Name: fund_allocation_percent; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_allocation_percent (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    org integer NOT NULL,
    fund_code text,
    percent numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT percentage_range CHECK (((percent >= (0)::numeric) AND (percent <= (100)::numeric)))
);


ALTER TABLE acq.fund_allocation_percent OWNER TO evergreen;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_allocation_percent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_percent_id_seq OWNER TO evergreen;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_allocation_percent_id_seq OWNED BY fund_allocation_percent.id;


--
-- Name: fund_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_allocation_total AS
    SELECT a.fund, (sum((a.amount * exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2) AS amount FROM ((fund_allocation a JOIN fund f ON ((a.fund = f.id))) JOIN funding_source s ON ((a.funding_source = s.id))) GROUP BY a.fund;


ALTER TABLE acq.fund_allocation_total OWNER TO evergreen;

--
-- Name: fund_debit_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_debit_total AS
    SELECT fund.id AS fund, fund_debit.encumbrance, sum(COALESCE(fund_debit.amount, (0)::numeric)) AS amount FROM (fund fund LEFT JOIN fund_debit fund_debit ON ((fund.id = fund_debit.fund))) GROUP BY fund.id, fund_debit.encumbrance;


ALTER TABLE acq.fund_debit_total OWNER TO evergreen;

--
-- Name: fund_combined_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_combined_balance AS
    SELECT c.fund, (c.amount - COALESCE(d.amount, 0.0)) AS amount FROM (fund_allocation_total c LEFT JOIN fund_debit_total d USING (fund));


ALTER TABLE acq.fund_combined_balance OWNER TO evergreen;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_debit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_debit_id_seq OWNER TO evergreen;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_debit_id_seq OWNED BY fund_debit.id;


--
-- Name: fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_encumbrance_total AS
    SELECT fund_debit_total.fund, sum(fund_debit_total.amount) AS amount FROM fund_debit_total WHERE (fund_debit_total.encumbrance IS TRUE) GROUP BY fund_debit_total.fund;


ALTER TABLE acq.fund_encumbrance_total OWNER TO evergreen;

--
-- Name: fund_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_id_seq OWNER TO evergreen;

--
-- Name: fund_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_id_seq OWNED BY fund.id;


--
-- Name: fund_spent_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_spent_total AS
    SELECT fund_debit_total.fund, sum(fund_debit_total.amount) AS amount FROM fund_debit_total WHERE (fund_debit_total.encumbrance IS FALSE) GROUP BY fund_debit_total.fund;


ALTER TABLE acq.fund_spent_total OWNER TO evergreen;

--
-- Name: fund_spent_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW fund_spent_balance AS
    SELECT c.fund, (c.amount - COALESCE(d.amount, 0.0)) AS amount FROM (fund_allocation_total c LEFT JOIN fund_spent_total d USING (fund));


ALTER TABLE acq.fund_spent_balance OWNER TO evergreen;

--
-- Name: fund_tag; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_tag (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fund_tag OWNER TO evergreen;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_id_seq OWNER TO evergreen;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_tag_id_seq OWNED BY fund_tag.id;


--
-- Name: fund_tag_map; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_tag_map (
    id integer NOT NULL,
    fund integer NOT NULL,
    tag integer
);


ALTER TABLE acq.fund_tag_map OWNER TO evergreen;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_tag_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_map_id_seq OWNER TO evergreen;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_tag_map_id_seq OWNED BY fund_tag_map.id;


--
-- Name: fund_transfer; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_transfer (
    id integer NOT NULL,
    src_fund integer NOT NULL,
    src_amount numeric NOT NULL,
    dest_fund integer NOT NULL,
    dest_amount numeric NOT NULL,
    transfer_time timestamp with time zone DEFAULT now() NOT NULL,
    transfer_user integer NOT NULL,
    note text,
    funding_source_credit integer NOT NULL
);


ALTER TABLE acq.fund_transfer OWNER TO evergreen;

--
-- Name: TABLE fund_transfer; Type: COMMENT; Schema: acq; Owner: evergreen
--

COMMENT ON TABLE fund_transfer IS '
/*
 * Copyright (C) 2009  Georgia Public Library Service
 * Scott McKellar <scott@esilibrary.com>
 *
 * Fund Transfer
 *
 * Each row represents the transfer of money from a source fund
 * to a destination fund.  There should be corresponding entries
 * in acq.fund_allocation.  The purpose of acq.fund_transfer is
 * to record how much money moved from which fund to which other
 * fund.
 *
 * The presence of two amount fields, rather than one, reflects
 * the possibility that the two funds are denominated in different
 * currencies.  If they use the same currency type, the two
 * amounts should be the same.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: fund_transfer_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE fund_transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_transfer_id_seq OWNER TO evergreen;

--
-- Name: fund_transfer_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE fund_transfer_id_seq OWNED BY fund_transfer.id;


--
-- Name: funding_source_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW funding_source_allocation_total AS
    SELECT a.funding_source, (sum(a.amount))::numeric(100,2) AS amount FROM fund_allocation a GROUP BY a.funding_source;


ALTER TABLE acq.funding_source_allocation_total OWNER TO evergreen;

--
-- Name: funding_source_credit; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE funding_source_credit (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    amount numeric NOT NULL,
    note text,
    deadline_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.funding_source_credit OWNER TO evergreen;

--
-- Name: funding_source_credit_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW funding_source_credit_total AS
    SELECT funding_source_credit.funding_source, sum(funding_source_credit.amount) AS amount FROM funding_source_credit GROUP BY funding_source_credit.funding_source;


ALTER TABLE acq.funding_source_credit_total OWNER TO evergreen;

--
-- Name: funding_source_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW funding_source_balance AS
    SELECT COALESCE(c.funding_source, a.funding_source) AS funding_source, (sum((COALESCE(c.amount, 0.0) - COALESCE(a.amount, 0.0))))::numeric(100,2) AS amount FROM (funding_source_credit_total c FULL JOIN funding_source_allocation_total a USING (funding_source)) GROUP BY COALESCE(c.funding_source, a.funding_source);


ALTER TABLE acq.funding_source_balance OWNER TO evergreen;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE funding_source_credit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_credit_id_seq OWNER TO evergreen;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE funding_source_credit_id_seq OWNED BY funding_source_credit.id;


--
-- Name: funding_source_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE funding_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_id_seq OWNER TO evergreen;

--
-- Name: funding_source_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE funding_source_id_seq OWNED BY funding_source.id;


--
-- Name: invoice; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice (
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone DEFAULT now() NOT NULL,
    recv_method text DEFAULT 'EDI'::text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    complete boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.invoice OWNER TO evergreen;

--
-- Name: invoice_entry; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice_entry (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2)
);


ALTER TABLE acq.invoice_entry OWNER TO evergreen;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE invoice_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_entry_id_seq OWNER TO evergreen;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE invoice_entry_id_seq OWNED BY invoice_entry.id;


--
-- Name: invoice_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_id_seq OWNER TO evergreen;

--
-- Name: invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE invoice_id_seq OWNED BY invoice.id;


--
-- Name: invoice_item; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice_item (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint
);


ALTER TABLE acq.invoice_item OWNER TO evergreen;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE invoice_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_item_id_seq OWNER TO evergreen;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE invoice_item_id_seq OWNED BY invoice_item.id;


--
-- Name: invoice_item_type; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice_item_type (
    code text NOT NULL,
    name text NOT NULL,
    prorate boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.invoice_item_type OWNER TO evergreen;

--
-- Name: invoice_method; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_method OWNER TO evergreen;

--
-- Name: invoice_payment_method; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE invoice_payment_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_payment_method OWNER TO evergreen;

--
-- Name: lineitem_alert_text; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_alert_text (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    owning_lib integer NOT NULL
);


ALTER TABLE acq.lineitem_alert_text OWNER TO evergreen;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_alert_text_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_alert_text_id_seq OWNER TO evergreen;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_alert_text_id_seq OWNED BY lineitem_alert_text.id;


--
-- Name: lineitem_attr; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_attr (
    id bigint NOT NULL,
    definition bigint NOT NULL,
    lineitem bigint NOT NULL,
    attr_type text NOT NULL,
    attr_name text NOT NULL,
    attr_value text NOT NULL,
    order_ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr OWNER TO evergreen;

--
-- Name: lineitem_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_attr_definition (
    id bigint NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    remove text DEFAULT ''::text NOT NULL,
    ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_attr_definition_id_seq OWNED BY lineitem_attr_definition.id;


--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_id_seq OWNER TO evergreen;

--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_attr_id_seq OWNED BY lineitem_attr.id;


--
-- Name: lineitem_detail; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_detail (
    id bigint NOT NULL,
    lineitem integer NOT NULL,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer,
    receiver integer
);


ALTER TABLE acq.lineitem_detail OWNER TO evergreen;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_detail_id_seq OWNER TO evergreen;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_detail_id_seq OWNED BY lineitem_detail.id;


--
-- Name: lineitem_generated_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_generated_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_generated_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_id_seq OWNER TO evergreen;

--
-- Name: lineitem_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_id_seq OWNED BY lineitem.id;


--
-- Name: lineitem_local_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_local_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass)
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_local_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_marc_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_marc_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_marc_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_note; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_note (
    id integer NOT NULL,
    lineitem integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    alert_text integer,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_note OWNER TO evergreen;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE lineitem_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_note_id_seq OWNER TO evergreen;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE lineitem_note_id_seq OWNED BY lineitem_note.id;


--
-- Name: lineitem_provider_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_provider_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL,
    provider integer NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_provider_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_summary; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW lineitem_summary AS
    SELECT li.id AS lineitem, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE (lid.lineitem = li.id)) AS item_count, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE ((lid.recv_time IS NOT NULL) AND (lid.lineitem = li.id))) AS recv_count, (SELECT count(lid.id) AS count FROM lineitem_detail lid WHERE ((lid.cancel_reason IS NOT NULL) AND (lid.lineitem = li.id))) AS cancel_count, (SELECT count(lid.id) AS count FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS invoice_count, (SELECT count(DISTINCT lid.id) AS count FROM (lineitem_detail lid JOIN claim claim ON ((claim.lineitem_detail = lid.id))) WHERE (lid.lineitem = li.id)) AS claim_count, (SELECT (((count(lid.id))::numeric * li.estimated_unit_price))::numeric(8,2) AS "numeric" FROM lineitem_detail lid WHERE ((lid.cancel_reason IS NULL) AND (lid.lineitem = li.id))) AS estimated_amount, (SELECT (sum(debit.amount))::numeric(8,2) AS sum FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE (debit.encumbrance AND (lid.lineitem = li.id))) AS encumbrance_amount, (SELECT (sum(debit.amount))::numeric(8,2) AS sum FROM (lineitem_detail lid JOIN fund_debit debit ON ((lid.fund_debit = debit.id))) WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS paid_amount FROM lineitem li;


ALTER TABLE acq.lineitem_summary OWNER TO evergreen;

--
-- Name: lineitem_usr_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE lineitem_usr_attr_definition (
    id bigint DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass),
    usr integer NOT NULL
)
INHERITS (lineitem_attr_definition);


ALTER TABLE acq.lineitem_usr_attr_definition OWNER TO evergreen;

--
-- Name: ordered_funding_source_credit; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW ordered_funding_source_credit AS
    SELECT CASE WHEN (funding_source_credit.deadline_date IS NULL) THEN 2 ELSE 1 END AS sort_priority, CASE WHEN (funding_source_credit.deadline_date IS NULL) THEN funding_source_credit.effective_date ELSE funding_source_credit.deadline_date END AS sort_date, funding_source_credit.id, funding_source_credit.funding_source, funding_source_credit.amount, funding_source_credit.note FROM funding_source_credit;


ALTER TABLE acq.ordered_funding_source_credit OWNER TO evergreen;

--
-- Name: VIEW ordered_funding_source_credit; Type: COMMENT; Schema: acq; Owner: evergreen
--

COMMENT ON VIEW ordered_funding_source_credit IS '
/*
 * Copyright (C) 2009  Georgia Public Library Service
 * Scott McKellar <scott@gmail.com>
 *
 * The acq.ordered_funding_source_credit view is a prioritized
 * ordering of funding source credits.  When ordered by the first
 * three columns, this view defines the order in which the various
 * credits are to be tapped for spending, subject to the allocations
 * in the acq.fund_allocation table.
 *
 * The first column reflects the principle that we should spend
 * money with deadlines before spending money without deadlines.
 *
 * The second column reflects the principle that we should spend the
 * oldest money first.  For money with deadlines, that means that we
 * spend first from the credit with the earliest deadline.  For
 * money without deadlines, we spend first from the credit with the
 * earliest effective date.
 *
 * The third column is a tie breaker to ensure a consistent
 * ordering.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: picklist; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE picklist (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.picklist OWNER TO evergreen;

--
-- Name: picklist_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE picklist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.picklist_id_seq OWNER TO evergreen;

--
-- Name: picklist_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE picklist_id_seq OWNED BY picklist.id;


--
-- Name: po_item; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE po_item (
    id integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    estimated_cost numeric(8,2),
    fund integer,
    target bigint
);


ALTER TABLE acq.po_item OWNER TO evergreen;

--
-- Name: po_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE po_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_item_id_seq OWNER TO evergreen;

--
-- Name: po_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE po_item_id_seq OWNED BY po_item.id;


--
-- Name: po_note; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE po_note (
    id integer NOT NULL,
    purchase_order integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.po_note OWNER TO evergreen;

--
-- Name: po_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE po_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_note_id_seq OWNER TO evergreen;

--
-- Name: po_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE po_note_id_seq OWNED BY po_note.id;


--
-- Name: provider; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text NOT NULL,
    holding_tag text,
    san text,
    edi_default integer,
    active boolean DEFAULT true NOT NULL,
    prepayment_required boolean DEFAULT false NOT NULL,
    url text,
    email text,
    phone text,
    fax_phone text,
    default_claim_policy integer,
    default_copy_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE acq.provider OWNER TO evergreen;

--
-- Name: provider_address; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    provider integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text NOT NULL
);


ALTER TABLE acq.provider_address OWNER TO evergreen;

--
-- Name: provider_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_address_id_seq OWNER TO evergreen;

--
-- Name: provider_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_address_id_seq OWNED BY provider_address.id;


--
-- Name: provider_contact; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider_contact (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    role text,
    email text,
    phone text
);


ALTER TABLE acq.provider_contact OWNER TO evergreen;

--
-- Name: provider_contact_address; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider_contact_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    contact integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text
);


ALTER TABLE acq.provider_contact_address OWNER TO evergreen;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_contact_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_address_id_seq OWNER TO evergreen;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_contact_address_id_seq OWNED BY provider_contact_address.id;


--
-- Name: provider_contact_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_id_seq OWNER TO evergreen;

--
-- Name: provider_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_contact_id_seq OWNED BY provider_contact.id;


--
-- Name: provider_holding_subfield_map; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider_holding_subfield_map (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    subfield text NOT NULL
);


ALTER TABLE acq.provider_holding_subfield_map OWNER TO evergreen;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_holding_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_holding_subfield_map_id_seq OWNER TO evergreen;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_holding_subfield_map_id_seq OWNED BY provider_holding_subfield_map.id;


--
-- Name: provider_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_id_seq OWNER TO evergreen;

--
-- Name: provider_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_id_seq OWNED BY provider.id;


--
-- Name: provider_note; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE provider_note (
    id integer NOT NULL,
    provider integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL
);


ALTER TABLE acq.provider_note OWNER TO evergreen;

--
-- Name: provider_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE provider_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_note_id_seq OWNER TO evergreen;

--
-- Name: provider_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE provider_note_id_seq OWNED BY provider_note.id;


--
-- Name: purchase_order_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE purchase_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.purchase_order_id_seq OWNER TO evergreen;

--
-- Name: purchase_order_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE purchase_order_id_seq OWNED BY purchase_order.id;


--
-- Name: serial_claim; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE serial_claim (
    id integer NOT NULL,
    type integer NOT NULL,
    item bigint NOT NULL
);


ALTER TABLE acq.serial_claim OWNER TO evergreen;

--
-- Name: serial_claim_event; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE serial_claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.serial_claim_event OWNER TO evergreen;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE serial_claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_claim_seq OWNER TO evergreen;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE serial_claim_event_claim_seq OWNED BY serial_claim_event.claim;


--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE serial_claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_id_seq OWNER TO evergreen;

--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE serial_claim_event_id_seq OWNED BY serial_claim_event.id;


--
-- Name: serial_claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE serial_claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_id_seq OWNER TO evergreen;

--
-- Name: serial_claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE serial_claim_id_seq OWNED BY serial_claim.id;


--
-- Name: user_request; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_request (
    id integer NOT NULL,
    usr integer NOT NULL,
    hold boolean DEFAULT true NOT NULL,
    pickup_lib integer NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    lineitem integer,
    eg_bib bigint,
    request_date timestamp with time zone DEFAULT now() NOT NULL,
    need_before timestamp with time zone,
    max_fee text,
    request_type integer NOT NULL,
    isxn text,
    title text,
    volume text,
    author text,
    article_title text,
    article_pages text,
    publisher text,
    location text,
    pubdate text,
    mentioned text,
    other_info text,
    cancel_reason integer
);


ALTER TABLE acq.user_request OWNER TO evergreen;

--
-- Name: user_request_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE user_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_id_seq OWNER TO evergreen;

--
-- Name: user_request_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE user_request_id_seq OWNED BY user_request.id;


--
-- Name: user_request_type; Type: TABLE; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_request_type (
    id integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE acq.user_request_type OWNER TO evergreen;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE user_request_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_type_id_seq OWNER TO evergreen;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE user_request_type_id_seq OWNED BY user_request_type.id;


SET search_path = action, pg_catalog;

--
-- Name: aged_circulation; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE aged_circulation (
    usr_post_code text,
    usr_home_ou integer NOT NULL,
    usr_profile integer NOT NULL,
    usr_birth_year integer,
    copy_call_number integer NOT NULL,
    copy_location integer NOT NULL,
    copy_owning_lib integer NOT NULL,
    copy_circ_lib integer NOT NULL,
    copy_bib_record bigint NOT NULL,
    id bigint NOT NULL,
    xact_start timestamp with time zone NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    duration interval,
    fine_interval interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean NOT NULL,
    desk_renewal boolean NOT NULL,
    opac_renewal boolean NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval NOT NULL
);


ALTER TABLE action.aged_circulation OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: usr_address; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE actor.usr_address OWNER TO evergreen;

SET search_path = asset, pg_catalog;

--
-- Name: call_number; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number (
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint NOT NULL,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint NOT NULL,
    label_sortkey text,
    prefix integer DEFAULT (-1) NOT NULL,
    suffix integer DEFAULT (-1) NOT NULL
);


ALTER TABLE asset.call_number OWNER TO evergreen;

SET search_path = action, pg_catalog;

--
-- Name: all_circulation; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW all_circulation AS
    SELECT aged_circulation.id, aged_circulation.usr_post_code, aged_circulation.usr_home_ou, aged_circulation.usr_profile, aged_circulation.usr_birth_year, aged_circulation.copy_call_number, aged_circulation.copy_location, aged_circulation.copy_owning_lib, aged_circulation.copy_circ_lib, aged_circulation.copy_bib_record, aged_circulation.xact_start, aged_circulation.xact_finish, aged_circulation.target_copy, aged_circulation.circ_lib, aged_circulation.circ_staff, aged_circulation.checkin_staff, aged_circulation.checkin_lib, aged_circulation.renewal_remaining, aged_circulation.grace_period, aged_circulation.due_date, aged_circulation.stop_fines_time, aged_circulation.checkin_time, aged_circulation.create_time, aged_circulation.duration, aged_circulation.fine_interval, aged_circulation.recurring_fine, aged_circulation.max_fine, aged_circulation.phone_renewal, aged_circulation.desk_renewal, aged_circulation.opac_renewal, aged_circulation.duration_rule, aged_circulation.recurring_fine_rule, aged_circulation.max_fine_rule, aged_circulation.stop_fines, aged_circulation.workstation, aged_circulation.checkin_workstation, aged_circulation.checkin_scan_time, aged_circulation.parent_circ FROM aged_circulation UNION ALL SELECT DISTINCT circ.id, COALESCE(a.post_code, b.post_code) AS usr_post_code, p.home_ou AS usr_home_ou, p.profile AS usr_profile, (date_part('year'::text, p.dob))::integer AS usr_birth_year, cp.call_number AS copy_call_number, circ.copy_location, cn.owning_lib AS copy_owning_lib, cp.circ_lib AS copy_circ_lib, cn.record AS copy_bib_record, circ.xact_start, circ.xact_finish, circ.target_copy, circ.circ_lib, circ.circ_staff, circ.checkin_staff, circ.checkin_lib, circ.renewal_remaining, circ.grace_period, circ.due_date, circ.stop_fines_time, circ.checkin_time, circ.create_time, circ.duration, circ.fine_interval, circ.recurring_fine, circ.max_fine, circ.phone_renewal, circ.desk_renewal, circ.opac_renewal, circ.duration_rule, circ.recurring_fine_rule, circ.max_fine_rule, circ.stop_fines, circ.workstation, circ.checkin_workstation, circ.checkin_scan_time, circ.parent_circ FROM (((((circulation circ JOIN asset.copy cp ON ((circ.target_copy = cp.id))) JOIN asset.call_number cn ON ((cp.call_number = cn.id))) JOIN actor.usr p ON ((circ.usr = p.id))) LEFT JOIN actor.usr_address a ON ((p.mailing_address = a.id))) LEFT JOIN actor.usr_address b ON ((p.billing_address = b.id)));


ALTER TABLE action.all_circulation OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archive_actor_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_actor_stat_cat OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE archive_actor_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_actor_stat_cat_id_seq OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE archive_actor_stat_cat_id_seq OWNED BY archive_actor_stat_cat.id;


--
-- Name: archive_asset_stat_cat; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archive_asset_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_asset_stat_cat OWNER TO evergreen;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE archive_asset_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_asset_stat_cat_id_seq OWNER TO evergreen;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE archive_asset_stat_cat_id_seq OWNED BY archive_asset_stat_cat.id;


--
-- Name: archived_hold_request; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request (
    id integer NOT NULL,
    request_time timestamp with time zone NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    requestor integer NOT NULL,
    usr integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean NOT NULL,
    frozen boolean NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer
);


ALTER TABLE action.archived_hold_request OWNER TO evergreen;

--
-- Name: archived_hold_request_2005; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2005 (
    CONSTRAINT archived_hold_request_2005_request_time_check CHECK (((request_time >= '2005-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2006-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2005 OWNER TO evergreen;

--
-- Name: archived_hold_request_2006; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2006 (
    CONSTRAINT archived_hold_request_2006_request_time_check CHECK (((request_time >= '2006-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2007-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2006 OWNER TO evergreen;

--
-- Name: archived_hold_request_2007; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2007 (
    CONSTRAINT archived_hold_request_2007_request_time_check CHECK (((request_time >= '2007-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2008-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2007 OWNER TO evergreen;

--
-- Name: archived_hold_request_2008; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2008 (
    CONSTRAINT archived_hold_request_2008_request_time_check CHECK (((request_time >= '2008-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2009-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2008 OWNER TO evergreen;

--
-- Name: archived_hold_request_2009; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2009 (
    CONSTRAINT archived_hold_request_2009_request_time_check CHECK (((request_time >= '2009-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2010-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2009 OWNER TO evergreen;

--
-- Name: archived_hold_request_2010; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2010 (
    CONSTRAINT archived_hold_request_2010_request_time_check CHECK (((request_time >= '2010-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2011-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2010 OWNER TO evergreen;

--
-- Name: archived_hold_request_2011; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2011 (
    CONSTRAINT archived_hold_request_2011_request_time_check CHECK (((request_time >= '2011-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2012-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2011 OWNER TO evergreen;

--
-- Name: archived_hold_request_2012; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2012 (
    CONSTRAINT archived_hold_request_2012_request_time_check CHECK (((request_time >= '2012-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2013-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2012 OWNER TO evergreen;

--
-- Name: archived_hold_request_2013; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request_2013 (
    CONSTRAINT archived_hold_request_2013_request_time_check CHECK (((request_time >= '2013-01-01 00:00:00-08'::timestamp with time zone) AND (request_time < '2014-01-01 00:00:00-08'::timestamp with time zone)))
)
INHERITS (archived_hold_request);


ALTER TABLE action.archived_hold_request_2013 OWNER TO evergreen;

--
-- Name: billable_circulations; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW billable_circulations AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.checkin_scan_time, circulation.parent_circ, circulation.grace_period FROM circulation WHERE (circulation.xact_finish IS NULL);


ALTER TABLE action.billable_circulations OWNER TO evergreen;

--
-- Name: circulation_limit_group_map; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE circulation_limit_group_map (
    circ bigint NOT NULL,
    limit_group integer NOT NULL
);


ALTER TABLE action.circulation_limit_group_map OWNER TO evergreen;

--
-- Name: fieldset; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE fieldset (
    id integer NOT NULL,
    owner integer NOT NULL,
    owning_lib integer NOT NULL,
    status text NOT NULL,
    creation_time timestamp with time zone DEFAULT now() NOT NULL,
    scheduled_time timestamp with time zone,
    applied_time timestamp with time zone,
    classname text NOT NULL,
    name text NOT NULL,
    stored_query integer,
    pkey_value text,
    CONSTRAINT fieldset_one_or_the_other CHECK ((((stored_query IS NOT NULL) AND (pkey_value IS NULL)) OR ((pkey_value IS NOT NULL) AND (stored_query IS NULL)))),
    CONSTRAINT valid_status CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPLIED'::text, 'ERROR'::text])))
);


ALTER TABLE action.fieldset OWNER TO evergreen;

--
-- Name: fieldset_col_val; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE fieldset_col_val (
    id integer NOT NULL,
    fieldset integer NOT NULL,
    col text NOT NULL,
    val text
);


ALTER TABLE action.fieldset_col_val OWNER TO evergreen;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE fieldset_col_val_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_col_val_id_seq OWNER TO evergreen;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE fieldset_col_val_id_seq OWNED BY fieldset_col_val.id;


--
-- Name: fieldset_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE fieldset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_id_seq OWNER TO evergreen;

--
-- Name: fieldset_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE fieldset_id_seq OWNED BY fieldset.id;


--
-- Name: hold_copy_map; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_copy_map (
    id bigint NOT NULL,
    hold integer NOT NULL,
    target_copy bigint NOT NULL,
    proximity numeric
)
WITH (autovacuum_enabled=true, autovacuum_vacuum_cost_delay=5, toast.autovacuum_enabled=true);
ALTER TABLE ONLY hold_copy_map ALTER COLUMN hold SET STATISTICS 500;
ALTER TABLE ONLY hold_copy_map ALTER COLUMN target_copy SET STATISTICS 500;


ALTER TABLE action.hold_copy_map OWNER TO evergreen;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE hold_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_copy_map_id_seq OWNER TO evergreen;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE hold_copy_map_id_seq OWNED BY hold_copy_map.id;


--
-- Name: hold_count; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_count (
    record_entry_id bigint NOT NULL,
    holds_count integer
);


ALTER TABLE action.hold_count OWNER TO evergreen;

--
-- Name: hold_notification; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_notification (
    id integer NOT NULL,
    hold integer NOT NULL,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text NOT NULL,
    note text
);


ALTER TABLE action.hold_notification OWNER TO evergreen;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE hold_notification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_notification_id_seq OWNER TO evergreen;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE hold_notification_id_seq OWNED BY hold_notification.id;


--
-- Name: hold_request_back; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request_back (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer
);


ALTER TABLE action.hold_request_back OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request_cancel_cause (
    id integer NOT NULL,
    label text
);


ALTER TABLE action.hold_request_cancel_cause OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE hold_request_cancel_cause_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_cancel_cause_id_seq OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE hold_request_cancel_cause_id_seq OWNED BY hold_request_cancel_cause.id;


--
-- Name: hold_request_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE hold_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_id_seq OWNER TO evergreen;

--
-- Name: hold_request_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE hold_request_id_seq OWNED BY hold_request.id;


--
-- Name: hold_request_note; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request_note (
    id bigint NOT NULL,
    hold bigint NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    slip boolean DEFAULT false NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    staff boolean DEFAULT false NOT NULL
);


ALTER TABLE action.hold_request_note OWNER TO evergreen;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE hold_request_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_note_id_seq OWNER TO evergreen;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE hold_request_note_id_seq OWNED BY hold_request_note.id;


--
-- Name: transit_copy; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE transit_copy (
    id integer NOT NULL,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint NOT NULL,
    source integer NOT NULL,
    dest integer NOT NULL,
    prev_hop integer,
    copy_status integer NOT NULL,
    persistant_transfer boolean DEFAULT false NOT NULL,
    prev_dest integer
);


ALTER TABLE action.transit_copy OWNER TO evergreen;

--
-- Name: hold_transit_copy; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_transit_copy (
    hold integer
)
INHERITS (transit_copy);


ALTER TABLE action.hold_transit_copy OWNER TO evergreen;

--
-- Name: in_house_use; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE in_house_use (
    id integer NOT NULL,
    item bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.in_house_use OWNER TO evergreen;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.in_house_use_id_seq OWNER TO evergreen;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE in_house_use_id_seq OWNED BY in_house_use.id;


--
-- Name: non_cat_in_house_use; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE non_cat_in_house_use (
    id integer NOT NULL,
    item_type bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.non_cat_in_house_use OWNER TO evergreen;

--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE non_cat_in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cat_in_house_use_id_seq OWNER TO evergreen;

--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE non_cat_in_house_use_id_seq OWNED BY non_cat_in_house_use.id;


--
-- Name: non_cataloged_circulation; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE non_cataloged_circulation (
    id integer NOT NULL,
    patron integer NOT NULL,
    staff integer NOT NULL,
    circ_lib integer NOT NULL,
    item_type integer NOT NULL,
    circ_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.non_cataloged_circulation OWNER TO evergreen;

--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE non_cataloged_circulation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cataloged_circulation_id_seq OWNER TO evergreen;

--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE non_cataloged_circulation_id_seq OWNED BY non_cataloged_circulation.id;


--
-- Name: open_circulation; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW open_circulation AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.checkin_scan_time, circulation.parent_circ, circulation.grace_period FROM circulation WHERE (circulation.checkin_time IS NULL) ORDER BY circulation.due_date;


ALTER TABLE action.open_circulation OWNER TO evergreen;

--
-- Name: reservation_transit_copy; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE reservation_transit_copy (
    reservation integer
)
INHERITS (transit_copy);


ALTER TABLE action.reservation_transit_copy OWNER TO evergreen;

--
-- Name: survey; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE survey (
    id integer NOT NULL,
    owner integer NOT NULL,
    start_date timestamp with time zone DEFAULT now() NOT NULL,
    end_date timestamp with time zone DEFAULT (now() + '10 years'::interval) NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    opac boolean DEFAULT false NOT NULL,
    poll boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE action.survey OWNER TO evergreen;

--
-- Name: survey_answer; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE survey_answer (
    id integer NOT NULL,
    question integer NOT NULL,
    answer text NOT NULL
);


ALTER TABLE action.survey_answer OWNER TO evergreen;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE survey_answer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_answer_id_seq OWNER TO evergreen;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE survey_answer_id_seq OWNED BY survey_answer.id;


--
-- Name: survey_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE survey_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_id_seq OWNER TO evergreen;

--
-- Name: survey_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE survey_id_seq OWNED BY survey.id;


--
-- Name: survey_question; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE survey_question (
    id integer NOT NULL,
    survey integer NOT NULL,
    question text NOT NULL
);


ALTER TABLE action.survey_question OWNER TO evergreen;

--
-- Name: survey_question_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE survey_question_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_question_id_seq OWNER TO evergreen;

--
-- Name: survey_question_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE survey_question_id_seq OWNED BY survey_question.id;


--
-- Name: survey_response; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE survey_response (
    id bigint NOT NULL,
    response_group_id integer,
    usr integer,
    survey integer NOT NULL,
    question integer NOT NULL,
    answer integer NOT NULL,
    answer_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.survey_response OWNER TO evergreen;

--
-- Name: survey_response_group_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE survey_response_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_group_id_seq OWNER TO evergreen;

--
-- Name: survey_response_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE survey_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_id_seq OWNER TO evergreen;

--
-- Name: survey_response_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE survey_response_id_seq OWNED BY survey_response.id;


--
-- Name: transit_copy_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE transit_copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.transit_copy_id_seq OWNER TO evergreen;

--
-- Name: transit_copy_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE transit_copy_id_seq OWNED BY transit_copy.id;


--
-- Name: unfulfilled_hold_list; Type: TABLE; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE TABLE unfulfilled_hold_list (
    id bigint NOT NULL,
    current_copy bigint NOT NULL,
    hold integer NOT NULL,
    circ_lib integer NOT NULL,
    fail_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.unfulfilled_hold_list OWNER TO evergreen;

--
-- Name: unfulfilled_hold_loops; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW unfulfilled_hold_loops AS
    SELECT u.hold, c.circ_lib, count(*) AS count FROM (unfulfilled_hold_list u JOIN asset.copy c ON ((c.id = u.current_copy))) GROUP BY u.hold, c.circ_lib;


ALTER TABLE action.unfulfilled_hold_loops OWNER TO evergreen;

--
-- Name: unfulfilled_hold_min_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW unfulfilled_hold_min_loop AS
    SELECT unfulfilled_hold_loops.hold, min(unfulfilled_hold_loops.count) AS min FROM unfulfilled_hold_loops GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_min_loop OWNER TO evergreen;

--
-- Name: unfulfilled_hold_innermost_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW unfulfilled_hold_innermost_loop AS
    SELECT DISTINCT l.hold, l.circ_lib, l.count FROM (unfulfilled_hold_loops l JOIN unfulfilled_hold_min_loop m USING (hold)) WHERE (l.count = m.min);


ALTER TABLE action.unfulfilled_hold_innermost_loop OWNER TO evergreen;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE unfulfilled_hold_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.unfulfilled_hold_list_id_seq OWNER TO evergreen;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE unfulfilled_hold_list_id_seq OWNED BY unfulfilled_hold_list.id;


--
-- Name: unfulfilled_hold_max_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW unfulfilled_hold_max_loop AS
    SELECT unfulfilled_hold_loops.hold, max(unfulfilled_hold_loops.count) AS max FROM unfulfilled_hold_loops GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_max_loop OWNER TO evergreen;

SET search_path = action_trigger, pg_catalog;

--
-- Name: cleanup; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE cleanup (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.cleanup OWNER TO evergreen;

--
-- Name: collector; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE collector (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.collector OWNER TO evergreen;

--
-- Name: environment; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE environment (
    id integer NOT NULL,
    event_def integer NOT NULL,
    path text,
    collector text,
    label text,
    CONSTRAINT environment_label_check CHECK ((label <> ALL (ARRAY['result'::text, 'target'::text, 'event'::text])))
);


ALTER TABLE action_trigger.environment OWNER TO evergreen;

--
-- Name: environment_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE environment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.environment_id_seq OWNER TO evergreen;

--
-- Name: environment_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE environment_id_seq OWNED BY environment.id;


--
-- Name: event; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE event (
    id bigint NOT NULL,
    target bigint NOT NULL,
    event_def integer,
    add_time timestamp with time zone DEFAULT now() NOT NULL,
    run_time timestamp with time zone NOT NULL,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text DEFAULT 'pending'::text NOT NULL,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint,
    CONSTRAINT event_state_check CHECK ((state = ANY (ARRAY['pending'::text, 'invalid'::text, 'found'::text, 'collecting'::text, 'collected'::text, 'validating'::text, 'valid'::text, 'reacting'::text, 'reacted'::text, 'cleaning'::text, 'complete'::text, 'error'::text]))),
    CONSTRAINT event_user_data_check CHECK (((user_data IS NULL) OR public.is_json(user_data)))
);


ALTER TABLE action_trigger.event OWNER TO evergreen;

--
-- Name: event_definition; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_definition (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    hook text NOT NULL,
    validator text NOT NULL,
    reactor text NOT NULL,
    cleanup_success text,
    cleanup_failure text,
    delay interval DEFAULT '00:05:00'::interval NOT NULL,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE action_trigger.event_definition OWNER TO evergreen;

--
-- Name: event_definition_backup; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_definition_backup (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE action_trigger.event_definition_backup OWNER TO evergreen;

--
-- Name: event_definition_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE event_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_definition_id_seq OWNER TO evergreen;

--
-- Name: event_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE event_definition_id_seq OWNED BY event_definition.id;


--
-- Name: event_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_id_seq OWNER TO evergreen;

--
-- Name: event_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE event_id_seq OWNED BY event.id;


--
-- Name: event_output; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_output (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    is_error boolean DEFAULT false NOT NULL,
    data text NOT NULL
);


ALTER TABLE action_trigger.event_output OWNER TO evergreen;

--
-- Name: event_output_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE event_output_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_output_id_seq OWNER TO evergreen;

--
-- Name: event_output_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE event_output_id_seq OWNED BY event_output.id;


--
-- Name: event_params; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_params (
    id bigint NOT NULL,
    event_def integer NOT NULL,
    param text NOT NULL,
    value text NOT NULL
);


ALTER TABLE action_trigger.event_params OWNER TO evergreen;

--
-- Name: event_params_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE event_params_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_params_id_seq OWNER TO evergreen;

--
-- Name: event_params_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE event_params_id_seq OWNED BY event_params.id;


--
-- Name: hook; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE hook (
    key text NOT NULL,
    core_type text NOT NULL,
    description text,
    passive boolean DEFAULT false NOT NULL
);


ALTER TABLE action_trigger.hook OWNER TO evergreen;

--
-- Name: reactor; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE reactor (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.reactor OWNER TO evergreen;

--
-- Name: validator; Type: TABLE; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE TABLE validator (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.validator OWNER TO evergreen;

SET search_path = actor, pg_catalog;

--
-- Name: address_alert_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE address_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.address_alert_id_seq OWNER TO evergreen;

--
-- Name: address_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE address_alert_id_seq OWNED BY address_alert.id;


--
-- Name: card; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE card (
    id integer NOT NULL,
    usr integer NOT NULL,
    barcode text NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.card OWNER TO evergreen;

--
-- Name: TABLE card; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE card IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Library Cards
 *
 * Each User has one or more library cards.  The current "main"
 * card is linked to here from the actor.usr table, and it is up
 * to the consortium policy whether more than one card can be
 * active for any one user at a given time.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: card_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.card_id_seq OWNER TO evergreen;

--
-- Name: card_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE card_id_seq OWNED BY card.id;


--
-- Name: hours_of_operation; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE hours_of_operation (
    id integer NOT NULL,
    dow_0_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_0_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_1_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_1_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_2_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_2_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_3_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_3_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_4_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_4_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_5_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_5_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_6_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_6_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL
);


ALTER TABLE actor.hours_of_operation OWNER TO evergreen;

--
-- Name: TABLE hours_of_operation; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE hours_of_operation IS '
When does this org_unit usually open and close?  (Variations
are expressed in the actor.org_unit_closed table.)
';


--
-- Name: COLUMN hours_of_operation.dow_0_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_0_open IS '
When does this org_unit open on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_0_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_0_close IS '
When does this org_unit close on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_1_open IS '
When does this org_unit open on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_1_close IS '
When does this org_unit close on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_2_open IS '
When does this org_unit open on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_2_close IS '
When does this org_unit close on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_3_open IS '
When does this org_unit open on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_3_close IS '
When does this org_unit close on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_4_open IS '
When does this org_unit open on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_4_close IS '
When does this org_unit close on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_5_open IS '
When does this org_unit open on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_5_close IS '
When does this org_unit close on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_6_open IS '
When does this org_unit open on Sunday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN hours_of_operation.dow_6_close IS '
When does this org_unit close on Sunday?
';


--
-- Name: org_address; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    org_unit integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    san text
);


ALTER TABLE actor.org_address OWNER TO evergreen;

--
-- Name: org_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_address_id_seq OWNER TO evergreen;

--
-- Name: org_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_address_id_seq OWNED BY org_address.id;


--
-- Name: org_lasso; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_lasso (
    id integer NOT NULL,
    name text
);


ALTER TABLE actor.org_lasso OWNER TO evergreen;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_lasso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_id_seq OWNER TO evergreen;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_lasso_id_seq OWNED BY org_lasso.id;


--
-- Name: org_lasso_map; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_lasso_map (
    id integer NOT NULL,
    lasso integer NOT NULL,
    org_unit integer NOT NULL
);


ALTER TABLE actor.org_lasso_map OWNER TO evergreen;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_lasso_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_map_id_seq OWNER TO evergreen;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_lasso_map_id_seq OWNED BY org_lasso_map.id;


--
-- Name: org_unit_closed; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_closed (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    close_start timestamp with time zone NOT NULL,
    close_end timestamp with time zone NOT NULL,
    reason text
);


ALTER TABLE actor.org_unit_closed OWNER TO evergreen;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_closed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_closed_id_seq OWNER TO evergreen;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_closed_id_seq OWNED BY org_unit_closed.id;


--
-- Name: org_unit_custom_tree; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_custom_tree (
    id integer NOT NULL,
    active boolean DEFAULT false,
    purpose org_unit_custom_tree_purpose DEFAULT 'opac'::org_unit_custom_tree_purpose NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_custom_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_id_seq OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_custom_tree_id_seq OWNED BY org_unit_custom_tree.id;


--
-- Name: org_unit_custom_tree_node; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_custom_tree_node (
    id integer NOT NULL,
    tree integer,
    org_unit integer NOT NULL,
    parent_node integer,
    sibling_order integer DEFAULT 0 NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree_node OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_custom_tree_node_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_node_id_seq OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_custom_tree_node_id_seq OWNED BY org_unit_custom_tree_node.id;


--
-- Name: org_unit_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_id_seq OWNER TO evergreen;

--
-- Name: org_unit_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_id_seq OWNED BY org_unit.id;


--
-- Name: org_unit_proximity; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_proximity (
    id bigint NOT NULL,
    from_org integer,
    to_org integer,
    prox integer
);


ALTER TABLE actor.org_unit_proximity OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_proximity_adjustment (
    id integer NOT NULL,
    item_circ_lib integer,
    item_owning_lib integer,
    copy_location integer,
    hold_pickup_lib integer,
    hold_request_lib integer,
    pos integer DEFAULT 0 NOT NULL,
    absolute_adjustment boolean DEFAULT false NOT NULL,
    prox_adjustment numeric,
    circ_mod text,
    CONSTRAINT prox_adj_criterium CHECK ((COALESCE((item_circ_lib)::text, (item_owning_lib)::text, (copy_location)::text, (hold_pickup_lib)::text, (hold_request_lib)::text, circ_mod) IS NOT NULL))
);


ALTER TABLE actor.org_unit_proximity_adjustment OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_proximity_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_adjustment_id_seq OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_proximity_adjustment_id_seq OWNED BY org_unit_proximity_adjustment.id;


--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_proximity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_id_seq OWNER TO evergreen;

--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_proximity_id_seq OWNED BY org_unit_proximity.id;


--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_setting_id_seq OWNER TO evergreen;

--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_setting_id_seq OWNED BY org_unit_setting.id;


--
-- Name: org_unit_type; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_type (
    id integer NOT NULL,
    name text NOT NULL,
    opac_label text NOT NULL,
    depth integer NOT NULL,
    parent integer,
    can_have_vols boolean DEFAULT true NOT NULL,
    can_have_users boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.org_unit_type OWNER TO evergreen;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE org_unit_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_type_id_seq OWNER TO evergreen;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE org_unit_type_id_seq OWNED BY org_unit_type.id;


--
-- Name: search_filter_group; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE search_filter_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    code text NOT NULL,
    label text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.search_filter_group OWNER TO evergreen;

--
-- Name: search_filter_group_entry; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE search_filter_group_entry (
    id integer NOT NULL,
    grp integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    query integer NOT NULL
);


ALTER TABLE actor.search_filter_group_entry OWNER TO evergreen;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE search_filter_group_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_entry_id_seq OWNER TO evergreen;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE search_filter_group_entry_id_seq OWNED BY search_filter_group_entry.id;


--
-- Name: search_filter_group_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE search_filter_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_id_seq OWNER TO evergreen;

--
-- Name: search_filter_group_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE search_filter_group_id_seq OWNED BY search_filter_group.id;


--
-- Name: search_query; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE search_query (
    id integer NOT NULL,
    label text NOT NULL,
    query_text text NOT NULL
);


ALTER TABLE actor.search_query OWNER TO evergreen;

--
-- Name: search_query_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE search_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_query_id_seq OWNER TO evergreen;

--
-- Name: search_query_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE search_query_id_seq OWNED BY search_query.id;


--
-- Name: stat_cat; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    allow_freetext boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.stat_cat OWNER TO evergreen;

--
-- Name: TABLE stat_cat; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE stat_cat IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User Statistical Catagories
 *
 * Local data collected about Users is placed into a Statistical
 * Catagory.  Here''s where those catagories are defined.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.stat_cat_entry OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE stat_cat_entry IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User Statistical Catagory Entries
 *
 * Local data collected about Users is placed into a Statistical
 * Catagory.  Each library can create entries into any of its own
 * stat_cats, its ancestors'' stat_cats, or its descendants'' stat_cats.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry_default; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry_default (
    id integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_default OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry_default; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE stat_cat_entry_default IS '
User Statistical Category Default Entry

A library may choose one of the stat_cat entries to be the
default entry.
';


--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_default_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_default_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_default_id_seq OWNED BY stat_cat_entry_default.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_id_seq OWNED BY stat_cat_entry.id;


--
-- Name: stat_cat_entry_usr_map; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry_usr_map (
    id bigint NOT NULL,
    stat_cat_entry text NOT NULL,
    stat_cat integer NOT NULL,
    target_usr integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry_usr_map; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE stat_cat_entry_usr_map IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Statistical Catagory Entry to User map
 *
 * Records the stat_cat entries for each user.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_usr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_usr_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_usr_map_id_seq OWNED BY stat_cat_entry_usr_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE stat_cat_id_seq OWNED BY stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.stat_cat_sip_fields OWNER TO evergreen;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE stat_cat_sip_fields IS '
Actor Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: toolbar; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE toolbar (
    id bigint NOT NULL,
    ws integer,
    org integer,
    usr integer,
    label text NOT NULL,
    layout text NOT NULL,
    CONSTRAINT layout_must_be_json CHECK (public.is_json(layout)),
    CONSTRAINT only_one_type CHECK (((((ws IS NOT NULL) AND (COALESCE(org, usr) IS NULL)) OR ((org IS NOT NULL) AND (COALESCE(ws, usr) IS NULL))) OR ((usr IS NOT NULL) AND (COALESCE(org, ws) IS NULL))))
);


ALTER TABLE actor.toolbar OWNER TO evergreen;

--
-- Name: toolbar_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE toolbar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.toolbar_id_seq OWNER TO evergreen;

--
-- Name: toolbar_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE toolbar_id_seq OWNED BY toolbar.id;


--
-- Name: usr_activity_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_activity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_activity_id_seq OWNER TO evergreen;

--
-- Name: usr_activity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_activity_id_seq OWNED BY usr_activity.id;


--
-- Name: usr_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_address_id_seq OWNER TO evergreen;

--
-- Name: usr_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_address_id_seq OWNED BY usr_address.id;


--
-- Name: usr_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_id_seq OWNER TO evergreen;

--
-- Name: usr_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_id_seq OWNED BY usr.id;


--
-- Name: usr_note; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_note (
    id bigint NOT NULL,
    usr bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.usr_note OWNER TO evergreen;

--
-- Name: usr_note_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_note_id_seq OWNER TO evergreen;

--
-- Name: usr_note_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_note_id_seq OWNED BY usr_note.id;


--
-- Name: usr_org_unit_opt_in; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_org_unit_opt_in (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    staff integer NOT NULL,
    opt_in_ts timestamp with time zone DEFAULT now() NOT NULL,
    opt_in_ws integer NOT NULL
);


ALTER TABLE actor.usr_org_unit_opt_in OWNER TO evergreen;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_org_unit_opt_in_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_org_unit_opt_in_id_seq OWNER TO evergreen;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_org_unit_opt_in_id_seq OWNED BY usr_org_unit_opt_in.id;


--
-- Name: usr_password_reset; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_password_reset (
    id integer NOT NULL,
    uuid text NOT NULL,
    usr bigint NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    has_been_reset boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.usr_password_reset OWNER TO evergreen;

--
-- Name: TABLE usr_password_reset; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE usr_password_reset IS '
/*
 * Copyright (C) 2010 Laurentian University
 * Dan Scott <dscott@laurentian.ca>
 *
 * Self-serve password reset requests
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_password_reset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_password_reset_id_seq OWNER TO evergreen;

--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_password_reset_id_seq OWNED BY usr_password_reset.id;


--
-- Name: usr_saved_search; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_saved_search (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    query_text text NOT NULL,
    query_type text DEFAULT 'URL'::text NOT NULL,
    target text NOT NULL,
    CONSTRAINT valid_query_text CHECK ((query_type = 'URL'::text)),
    CONSTRAINT valid_target CHECK ((target = ANY (ARRAY['record'::text, 'metarecord'::text, 'callnumber'::text])))
);


ALTER TABLE actor.usr_saved_search OWNER TO evergreen;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_saved_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_saved_search_id_seq OWNER TO evergreen;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_saved_search_id_seq OWNED BY usr_saved_search.id;


--
-- Name: usr_setting; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_setting (
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.usr_setting OWNER TO evergreen;

--
-- Name: TABLE usr_setting; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE usr_setting IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User settings
 *
 * This table contains any arbitrary settings that a client
 * program would like to save for a user.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: usr_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_setting_id_seq OWNER TO evergreen;

--
-- Name: usr_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_setting_id_seq OWNED BY usr_setting.id;


--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_standing_penalty_id_seq OWNER TO evergreen;

--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_standing_penalty_id_seq OWNED BY usr_standing_penalty.id;


--
-- Name: usr_usrgroup_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE usr_usrgroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_usrgroup_seq OWNER TO evergreen;

--
-- Name: usr_usrgroup_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE usr_usrgroup_seq OWNED BY usr.usrgroup;


--
-- Name: workstation; Type: TABLE; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE TABLE workstation (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL
);


ALTER TABLE actor.workstation OWNER TO evergreen;

--
-- Name: workstation_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE workstation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.workstation_id_seq OWNER TO evergreen;

--
-- Name: workstation_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE workstation_id_seq OWNED BY workstation.id;


SET search_path = asset, pg_catalog;

--
-- Name: call_number_class; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_class (
    id bigint NOT NULL,
    name text NOT NULL,
    normalizer text DEFAULT 'asset.normalize_generic'::text NOT NULL,
    field text DEFAULT '050ab,055ab,060ab,070ab,080ab,082ab,086ab,088ab,090,092,096,098,099'::text NOT NULL
);


ALTER TABLE asset.call_number_class OWNER TO evergreen;

--
-- Name: TABLE call_number_class; Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON TABLE call_number_class IS '
Defines the call number normalization database functions in the "normalizer"
column and the tag/subfield combinations to use to lookup the call number in
the "field" column for a given classification scheme. Tag/subfield combinations
are delimited by commas.
';


--
-- Name: call_number_class_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE call_number_class_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_class_id_seq OWNER TO evergreen;

--
-- Name: call_number_class_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE call_number_class_id_seq OWNED BY call_number_class.id;


--
-- Name: call_number_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE call_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_id_seq OWNER TO evergreen;

--
-- Name: call_number_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE call_number_id_seq OWNED BY call_number.id;


--
-- Name: call_number_note; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_note (
    id bigint NOT NULL,
    call_number bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.call_number_note OWNER TO evergreen;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE call_number_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE call_number_note_id_seq OWNED BY call_number_note.id;


--
-- Name: call_number_prefix; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_prefix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_prefix OWNER TO evergreen;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE call_number_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_prefix_id_seq OWNER TO evergreen;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE call_number_prefix_id_seq OWNED BY call_number_prefix.id;


--
-- Name: call_number_suffix; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_suffix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_suffix OWNER TO evergreen;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE call_number_suffix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_suffix_id_seq OWNER TO evergreen;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE call_number_suffix_id_seq OWNED BY call_number_suffix.id;


--
-- Name: copy_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_id_seq OWNER TO evergreen;

--
-- Name: copy_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_id_seq OWNED BY copy.id;


--
-- Name: copy_location; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_location (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text,
    checkin_alert boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.copy_location OWNER TO evergreen;

--
-- Name: copy_location_group; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_location_group (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    top boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.copy_location_group OWNER TO evergreen;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_location_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_id_seq OWNER TO evergreen;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_location_group_id_seq OWNED BY copy_location_group.id;


--
-- Name: copy_location_group_map; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_location_group_map (
    id integer NOT NULL,
    location integer NOT NULL,
    lgroup integer NOT NULL
);


ALTER TABLE asset.copy_location_group_map OWNER TO evergreen;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_location_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_map_id_seq OWNER TO evergreen;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_location_group_map_id_seq OWNED BY copy_location_group_map.id;


--
-- Name: copy_location_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_location_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_id_seq OWNER TO evergreen;

--
-- Name: copy_location_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_location_id_seq OWNED BY copy_location.id;


--
-- Name: copy_location_order; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_location_order (
    id integer NOT NULL,
    location integer NOT NULL,
    org integer NOT NULL,
    "position" integer DEFAULT 0 NOT NULL
);


ALTER TABLE asset.copy_location_order OWNER TO evergreen;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_location_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_order_id_seq OWNER TO evergreen;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_location_order_id_seq OWNED BY copy_location_order.id;


--
-- Name: copy_note; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_note (
    id bigint NOT NULL,
    owning_copy bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.copy_note OWNER TO evergreen;

--
-- Name: copy_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_note_id_seq OWNER TO evergreen;

--
-- Name: copy_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_note_id_seq OWNED BY copy_note.id;


--
-- Name: copy_part_map; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_part_map (
    id integer NOT NULL,
    target_copy bigint NOT NULL,
    part integer NOT NULL
);


ALTER TABLE asset.copy_part_map OWNER TO evergreen;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_part_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_part_map_id_seq OWNER TO evergreen;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_part_map_id_seq OWNED BY copy_part_map.id;


--
-- Name: copy_template; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_template (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    creator bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    name text NOT NULL,
    circ_lib integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible boolean,
    floating boolean,
    mint_condition boolean,
    CONSTRAINT valid_fine_level CHECK (((fine_level IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3])))),
    CONSTRAINT valid_loan_duration CHECK (((loan_duration IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3]))))
);


ALTER TABLE asset.copy_template OWNER TO evergreen;

--
-- Name: copy_template_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE copy_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_template_id_seq OWNER TO evergreen;

--
-- Name: copy_template_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE copy_template_id_seq OWNED BY copy_template.id;


--
-- Name: opac_visible_copies; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE opac_visible_copies (
    id bigint NOT NULL,
    copy_id bigint,
    record bigint,
    circ_lib integer
);


ALTER TABLE asset.opac_visible_copies OWNER TO evergreen;

--
-- Name: opac_visible_copies_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE opac_visible_copies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.opac_visible_copies_id_seq OWNER TO evergreen;

--
-- Name: opac_visible_copies_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE opac_visible_copies_id_seq OWNED BY opac_visible_copies.id;


--
-- Name: stat_cat; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    required boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat OWNER TO evergreen;

--
-- Name: stat_cat_entry; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.stat_cat_entry OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry_copy_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_copy bigint NOT NULL
);


ALTER TABLE asset.stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_copy_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_copy_map_id_seq OWNED BY stat_cat_entry_copy_map.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_id_seq OWNED BY stat_cat_entry.id;


--
-- Name: stat_cat_entry_transparency_map; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_entry_transparency_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_transparency integer NOT NULL
);


ALTER TABLE asset.stat_cat_entry_transparency_map OWNER TO evergreen;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE stat_cat_entry_transparency_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_transparency_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE stat_cat_entry_transparency_map_id_seq OWNED BY stat_cat_entry_transparency_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE stat_cat_id_seq OWNED BY stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat_sip_fields OWNER TO evergreen;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON TABLE stat_cat_sip_fields IS '
Asset Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: uri; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE uri (
    id integer NOT NULL,
    href text NOT NULL,
    label text,
    use_restriction text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.uri OWNER TO evergreen;

--
-- Name: uri_call_number_map; Type: TABLE; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE TABLE uri_call_number_map (
    id bigint NOT NULL,
    uri integer NOT NULL,
    call_number integer NOT NULL
);


ALTER TABLE asset.uri_call_number_map OWNER TO evergreen;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE uri_call_number_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_call_number_map_id_seq OWNER TO evergreen;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE uri_call_number_map_id_seq OWNED BY uri_call_number_map.id;


--
-- Name: uri_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE uri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_id_seq OWNER TO evergreen;

--
-- Name: uri_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE uri_id_seq OWNED BY uri.id;


SET search_path = auditor, pg_catalog;

--
-- Name: acq_fund_debit_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_fund_debit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    fund integer NOT NULL,
    origin_amount numeric NOT NULL,
    origin_currency_type text NOT NULL,
    amount numeric NOT NULL,
    encumbrance boolean NOT NULL,
    debit_type text NOT NULL,
    xfer_destination integer,
    create_time timestamp with time zone NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_fund_debit_history OWNER TO evergreen;

--
-- Name: acq_fund_debit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW acq_fund_debit_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, fund_debit.id, fund_debit.fund, fund_debit.origin_amount, fund_debit.origin_currency_type, fund_debit.amount, fund_debit.encumbrance, fund_debit.debit_type, fund_debit.xfer_destination, fund_debit.create_time FROM acq.fund_debit UNION ALL SELECT acq_fund_debit_history.audit_id, acq_fund_debit_history.audit_time, acq_fund_debit_history.audit_action, acq_fund_debit_history.audit_user, acq_fund_debit_history.audit_ws, acq_fund_debit_history.id, acq_fund_debit_history.fund, acq_fund_debit_history.origin_amount, acq_fund_debit_history.origin_currency_type, acq_fund_debit_history.amount, acq_fund_debit_history.encumbrance, acq_fund_debit_history.debit_type, acq_fund_debit_history.xfer_destination, acq_fund_debit_history.create_time FROM acq_fund_debit_history;


ALTER TABLE auditor.acq_fund_debit_lifecycle OWNER TO evergreen;

--
-- Name: acq_fund_debit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE acq_fund_debit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_fund_debit_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_entry_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_invoice_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2),
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_invoice_entry_history OWNER TO evergreen;

--
-- Name: acq_invoice_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW acq_invoice_entry_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice_entry.id, invoice_entry.invoice, invoice_entry.purchase_order, invoice_entry.lineitem, invoice_entry.inv_item_count, invoice_entry.phys_item_count, invoice_entry.note, invoice_entry.billed_per_item, invoice_entry.cost_billed, invoice_entry.actual_cost, invoice_entry.amount_paid FROM acq.invoice_entry UNION ALL SELECT acq_invoice_entry_history.audit_id, acq_invoice_entry_history.audit_time, acq_invoice_entry_history.audit_action, acq_invoice_entry_history.audit_user, acq_invoice_entry_history.audit_ws, acq_invoice_entry_history.id, acq_invoice_entry_history.invoice, acq_invoice_entry_history.purchase_order, acq_invoice_entry_history.lineitem, acq_invoice_entry_history.inv_item_count, acq_invoice_entry_history.phys_item_count, acq_invoice_entry_history.note, acq_invoice_entry_history.billed_per_item, acq_invoice_entry_history.cost_billed, acq_invoice_entry_history.actual_cost, acq_invoice_entry_history.amount_paid FROM acq_invoice_entry_history;


ALTER TABLE auditor.acq_invoice_entry_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE acq_invoice_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_entry_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_invoice_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone NOT NULL,
    recv_method text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    complete boolean NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_invoice_history OWNER TO evergreen;

--
-- Name: acq_invoice_item_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_invoice_item_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_invoice_item_history OWNER TO evergreen;

--
-- Name: acq_invoice_item_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW acq_invoice_item_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice_item.id, invoice_item.invoice, invoice_item.purchase_order, invoice_item.fund_debit, invoice_item.inv_item_type, invoice_item.title, invoice_item.author, invoice_item.note, invoice_item.cost_billed, invoice_item.actual_cost, invoice_item.fund, invoice_item.amount_paid, invoice_item.po_item, invoice_item.target FROM acq.invoice_item UNION ALL SELECT acq_invoice_item_history.audit_id, acq_invoice_item_history.audit_time, acq_invoice_item_history.audit_action, acq_invoice_item_history.audit_user, acq_invoice_item_history.audit_ws, acq_invoice_item_history.id, acq_invoice_item_history.invoice, acq_invoice_item_history.purchase_order, acq_invoice_item_history.fund_debit, acq_invoice_item_history.inv_item_type, acq_invoice_item_history.title, acq_invoice_item_history.author, acq_invoice_item_history.note, acq_invoice_item_history.cost_billed, acq_invoice_item_history.actual_cost, acq_invoice_item_history.fund, acq_invoice_item_history.amount_paid, acq_invoice_item_history.po_item, acq_invoice_item_history.target FROM acq_invoice_item_history;


ALTER TABLE auditor.acq_invoice_item_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_item_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE acq_invoice_item_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_item_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW acq_invoice_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, invoice.id, invoice.receiver, invoice.provider, invoice.shipper, invoice.recv_date, invoice.recv_method, invoice.inv_type, invoice.inv_ident, invoice.payment_auth, invoice.payment_method, invoice.note, invoice.complete FROM acq.invoice UNION ALL SELECT acq_invoice_history.audit_id, acq_invoice_history.audit_time, acq_invoice_history.audit_action, acq_invoice_history.audit_user, acq_invoice_history.audit_ws, acq_invoice_history.id, acq_invoice_history.receiver, acq_invoice_history.provider, acq_invoice_history.shipper, acq_invoice_history.recv_date, acq_invoice_history.recv_method, acq_invoice_history.inv_type, acq_invoice_history.inv_ident, acq_invoice_history.payment_auth, acq_invoice_history.payment_method, acq_invoice_history.note, acq_invoice_history.complete FROM acq_invoice_history;


ALTER TABLE auditor.acq_invoice_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE acq_invoice_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_pkey_seq OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_lineitem_detail_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    lineitem integer NOT NULL,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer,
    receiver integer,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_lineitem_detail_history OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW acq_lineitem_detail_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, lineitem_detail.id, lineitem_detail.lineitem, lineitem_detail.fund, lineitem_detail.fund_debit, lineitem_detail.eg_copy_id, lineitem_detail.barcode, lineitem_detail.cn_label, lineitem_detail.note, lineitem_detail.collection_code, lineitem_detail.circ_modifier, lineitem_detail.owning_lib, lineitem_detail.location, lineitem_detail.recv_time, lineitem_detail.cancel_reason, lineitem_detail.receiver FROM acq.lineitem_detail UNION ALL SELECT acq_lineitem_detail_history.audit_id, acq_lineitem_detail_history.audit_time, acq_lineitem_detail_history.audit_action, acq_lineitem_detail_history.audit_user, acq_lineitem_detail_history.audit_ws, acq_lineitem_detail_history.id, acq_lineitem_detail_history.lineitem, acq_lineitem_detail_history.fund, acq_lineitem_detail_history.fund_debit, acq_lineitem_detail_history.eg_copy_id, acq_lineitem_detail_history.barcode, acq_lineitem_detail_history.cn_label, acq_lineitem_detail_history.note, acq_lineitem_detail_history.collection_code, acq_lineitem_detail_history.circ_modifier, acq_lineitem_detail_history.owning_lib, acq_lineitem_detail_history.location, acq_lineitem_detail_history.recv_time, acq_lineitem_detail_history.cancel_reason, acq_lineitem_detail_history.receiver FROM acq_lineitem_detail_history;


ALTER TABLE auditor.acq_lineitem_detail_lifecycle OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE acq_lineitem_detail_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_lineitem_detail_pkey_seq OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_trigger_event_definition_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    active boolean NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    hook text NOT NULL,
    validator text NOT NULL,
    reactor text NOT NULL,
    cleanup_success text,
    cleanup_failure text,
    delay interval NOT NULL,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.action_trigger_event_definition_history OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW action_trigger_event_definition_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, event_definition.id, event_definition.active, event_definition.owner, event_definition.name, event_definition.hook, event_definition.validator, event_definition.reactor, event_definition.cleanup_success, event_definition.cleanup_failure, event_definition.delay, event_definition.max_delay, event_definition.usr_field, event_definition.opt_in_setting, event_definition.delay_field, event_definition.group_field, event_definition.template, event_definition.granularity FROM action_trigger.event_definition UNION ALL SELECT action_trigger_event_definition_history.audit_id, action_trigger_event_definition_history.audit_time, action_trigger_event_definition_history.audit_action, action_trigger_event_definition_history.audit_user, action_trigger_event_definition_history.audit_ws, action_trigger_event_definition_history.id, action_trigger_event_definition_history.active, action_trigger_event_definition_history.owner, action_trigger_event_definition_history.name, action_trigger_event_definition_history.hook, action_trigger_event_definition_history.validator, action_trigger_event_definition_history.reactor, action_trigger_event_definition_history.cleanup_success, action_trigger_event_definition_history.cleanup_failure, action_trigger_event_definition_history.delay, action_trigger_event_definition_history.max_delay, action_trigger_event_definition_history.usr_field, action_trigger_event_definition_history.opt_in_setting, action_trigger_event_definition_history.delay_field, action_trigger_event_definition_history.group_field, action_trigger_event_definition_history.template, action_trigger_event_definition_history.granularity FROM action_trigger_event_definition_history;


ALTER TABLE auditor.action_trigger_event_definition_lifecycle OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE action_trigger_event_definition_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.action_trigger_event_definition_pkey_seq OWNER TO evergreen;

--
-- Name: actor_org_unit_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_org_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean NOT NULL,
    fiscal_calendar integer NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_org_unit_history OWNER TO evergreen;

--
-- Name: actor_org_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW actor_org_unit_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, org_unit.id, org_unit.parent_ou, org_unit.ou_type, org_unit.ill_address, org_unit.holds_address, org_unit.mailing_address, org_unit.billing_address, org_unit.shortname, org_unit.name, org_unit.email, org_unit.phone, org_unit.opac_visible, org_unit.fiscal_calendar FROM actor.org_unit UNION ALL SELECT actor_org_unit_history.audit_id, actor_org_unit_history.audit_time, actor_org_unit_history.audit_action, actor_org_unit_history.audit_user, actor_org_unit_history.audit_ws, actor_org_unit_history.id, actor_org_unit_history.parent_ou, actor_org_unit_history.ou_type, actor_org_unit_history.ill_address, actor_org_unit_history.holds_address, actor_org_unit_history.mailing_address, actor_org_unit_history.billing_address, actor_org_unit_history.shortname, actor_org_unit_history.name, actor_org_unit_history.email, actor_org_unit_history.phone, actor_org_unit_history.opac_visible, actor_org_unit_history.fiscal_calendar FROM actor_org_unit_history;


ALTER TABLE auditor.actor_org_unit_lifecycle OWNER TO evergreen;

--
-- Name: actor_org_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE actor_org_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_org_unit_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_address_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    valid boolean NOT NULL,
    within_city_limits boolean NOT NULL,
    address_type text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean NOT NULL,
    replaces integer,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_usr_address_history OWNER TO evergreen;

--
-- Name: actor_usr_address_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW actor_usr_address_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, usr_address.id, usr_address.valid, usr_address.within_city_limits, usr_address.address_type, usr_address.usr, usr_address.street1, usr_address.street2, usr_address.city, usr_address.county, usr_address.state, usr_address.country, usr_address.post_code, usr_address.pending, usr_address.replaces FROM actor.usr_address UNION ALL SELECT actor_usr_address_history.audit_id, actor_usr_address_history.audit_time, actor_usr_address_history.audit_action, actor_usr_address_history.audit_user, actor_usr_address_history.audit_ws, actor_usr_address_history.id, actor_usr_address_history.valid, actor_usr_address_history.within_city_limits, actor_usr_address_history.address_type, actor_usr_address_history.usr, actor_usr_address_history.street1, actor_usr_address_history.street2, actor_usr_address_history.city, actor_usr_address_history.county, actor_usr_address_history.state, actor_usr_address_history.country, actor_usr_address_history.post_code, actor_usr_address_history.pending, actor_usr_address_history.replaces FROM actor_usr_address_history;


ALTER TABLE auditor.actor_usr_address_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_address_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE actor_usr_address_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_address_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean NOT NULL,
    master_account boolean NOT NULL,
    super_user boolean NOT NULL,
    barred boolean NOT NULL,
    deleted boolean NOT NULL,
    juvenile boolean NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer NOT NULL,
    credit_forward_balance numeric(6,2) NOT NULL,
    last_xact_id text NOT NULL,
    alert_message text,
    create_date timestamp with time zone NOT NULL,
    expire_date timestamp with time zone NOT NULL,
    claims_never_checked_out_count integer NOT NULL,
    last_update_time timestamp with time zone,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_usr_history OWNER TO evergreen;

--
-- Name: actor_usr_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW actor_usr_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, usr.id, usr.card, usr.profile, usr.usrname, usr.email, usr.passwd, usr.standing, usr.ident_type, usr.ident_value, usr.ident_type2, usr.ident_value2, usr.net_access_level, usr.photo_url, usr.prefix, usr.first_given_name, usr.second_given_name, usr.family_name, usr.suffix, usr.alias, usr.day_phone, usr.evening_phone, usr.other_phone, usr.mailing_address, usr.billing_address, usr.home_ou, usr.dob, usr.active, usr.master_account, usr.super_user, usr.barred, usr.deleted, usr.juvenile, usr.usrgroup, usr.claims_returned_count, usr.credit_forward_balance, usr.last_xact_id, usr.alert_message, usr.create_date, usr.expire_date, usr.claims_never_checked_out_count, usr.last_update_time FROM actor.usr UNION ALL SELECT actor_usr_history.audit_id, actor_usr_history.audit_time, actor_usr_history.audit_action, actor_usr_history.audit_user, actor_usr_history.audit_ws, actor_usr_history.id, actor_usr_history.card, actor_usr_history.profile, actor_usr_history.usrname, actor_usr_history.email, actor_usr_history.passwd, actor_usr_history.standing, actor_usr_history.ident_type, actor_usr_history.ident_value, actor_usr_history.ident_type2, actor_usr_history.ident_value2, actor_usr_history.net_access_level, actor_usr_history.photo_url, actor_usr_history.prefix, actor_usr_history.first_given_name, actor_usr_history.second_given_name, actor_usr_history.family_name, actor_usr_history.suffix, actor_usr_history.alias, actor_usr_history.day_phone, actor_usr_history.evening_phone, actor_usr_history.other_phone, actor_usr_history.mailing_address, actor_usr_history.billing_address, actor_usr_history.home_ou, actor_usr_history.dob, actor_usr_history.active, actor_usr_history.master_account, actor_usr_history.super_user, actor_usr_history.barred, actor_usr_history.deleted, actor_usr_history.juvenile, actor_usr_history.usrgroup, actor_usr_history.claims_returned_count, actor_usr_history.credit_forward_balance, actor_usr_history.last_xact_id, actor_usr_history.alert_message, actor_usr_history.create_date, actor_usr_history.expire_date, actor_usr_history.claims_never_checked_out_count, actor_usr_history.last_update_time FROM actor_usr_history;


ALTER TABLE auditor.actor_usr_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE actor_usr_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_setting_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_setting_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_usr_setting_history OWNER TO evergreen;

--
-- Name: actor_usr_setting_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW actor_usr_setting_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, usr_setting.id, usr_setting.usr, usr_setting.name, usr_setting.value FROM actor.usr_setting UNION ALL SELECT actor_usr_setting_history.audit_id, actor_usr_setting_history.audit_time, actor_usr_setting_history.audit_action, actor_usr_setting_history.audit_user, actor_usr_setting_history.audit_ws, actor_usr_setting_history.id, actor_usr_setting_history.usr, actor_usr_setting_history.name, actor_usr_setting_history.value FROM actor_usr_setting_history;


ALTER TABLE auditor.actor_usr_setting_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_setting_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE actor_usr_setting_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_setting_pkey_seq OWNER TO evergreen;

--
-- Name: asset_call_number_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone,
    editor bigint NOT NULL,
    edit_date timestamp with time zone,
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean NOT NULL,
    label_class bigint,
    label_sortkey text,
    prefix integer DEFAULT (-1) NOT NULL,
    suffix integer DEFAULT (-1) NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.asset_call_number_history OWNER TO evergreen;

--
-- Name: asset_call_number_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW asset_call_number_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, call_number.id, call_number.creator, call_number.create_date, call_number.editor, call_number.edit_date, call_number.record, call_number.owning_lib, call_number.label, call_number.deleted, call_number.label_class, call_number.label_sortkey, call_number.prefix, call_number.suffix FROM asset.call_number UNION ALL SELECT asset_call_number_history.audit_id, asset_call_number_history.audit_time, asset_call_number_history.audit_action, asset_call_number_history.audit_user, asset_call_number_history.audit_ws, asset_call_number_history.id, asset_call_number_history.creator, asset_call_number_history.create_date, asset_call_number_history.editor, asset_call_number_history.edit_date, asset_call_number_history.record, asset_call_number_history.owning_lib, asset_call_number_history.label, asset_call_number_history.deleted, asset_call_number_history.label_class, asset_call_number_history.label_sortkey, asset_call_number_history.prefix, asset_call_number_history.suffix FROM asset_call_number_history;


ALTER TABLE auditor.asset_call_number_lifecycle OWNER TO evergreen;

--
-- Name: asset_call_number_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE asset_call_number_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_call_number_pkey_seq OWNER TO evergreen;

--
-- Name: asset_copy_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating boolean NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2),
    active_date timestamp with time zone,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.asset_copy_history OWNER TO evergreen;

--
-- Name: asset_copy_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW asset_copy_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, copy.id, copy.circ_lib, copy.creator, copy.call_number, copy.editor, copy.create_date, copy.edit_date, copy.copy_number, copy.status, copy.location, copy.loan_duration, copy.fine_level, copy.age_protect, copy.circulate, copy.deposit, copy.ref, copy.holdable, copy.deposit_amount, copy.price, copy.barcode, copy.circ_modifier, copy.circ_as_type, copy.dummy_title, copy.dummy_author, copy.alert_message, copy.opac_visible, copy.deleted, copy.floating, copy.dummy_isbn, copy.status_changed_time, copy.mint_condition, copy.cost, copy.active_date FROM asset.copy UNION ALL SELECT asset_copy_history.audit_id, asset_copy_history.audit_time, asset_copy_history.audit_action, asset_copy_history.audit_user, asset_copy_history.audit_ws, asset_copy_history.id, asset_copy_history.circ_lib, asset_copy_history.creator, asset_copy_history.call_number, asset_copy_history.editor, asset_copy_history.create_date, asset_copy_history.edit_date, asset_copy_history.copy_number, asset_copy_history.status, asset_copy_history.location, asset_copy_history.loan_duration, asset_copy_history.fine_level, asset_copy_history.age_protect, asset_copy_history.circulate, asset_copy_history.deposit, asset_copy_history.ref, asset_copy_history.holdable, asset_copy_history.deposit_amount, asset_copy_history.price, asset_copy_history.barcode, asset_copy_history.circ_modifier, asset_copy_history.circ_as_type, asset_copy_history.dummy_title, asset_copy_history.dummy_author, asset_copy_history.alert_message, asset_copy_history.opac_visible, asset_copy_history.deleted, asset_copy_history.floating, asset_copy_history.dummy_isbn, asset_copy_history.status_changed_time, asset_copy_history.mint_condition, asset_copy_history.cost, asset_copy_history.active_date FROM asset_copy_history;


ALTER TABLE auditor.asset_copy_lifecycle OWNER TO evergreen;

--
-- Name: asset_copy_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE asset_copy_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_copy_pkey_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone NOT NULL,
    edit_date timestamp with time zone NOT NULL,
    active boolean NOT NULL,
    deleted boolean NOT NULL,
    fingerprint text,
    tcn_source text NOT NULL,
    tcn_value text NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer,
    audit_ws integer,
    audit_user integer,
    cataloging_date timestamp with time zone
);


ALTER TABLE auditor.biblio_record_entry_history OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: record_entry; Type: TABLE; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    fingerprint text,
    tcn_source text DEFAULT 'AUTOGEN'::text NOT NULL,
    tcn_value text DEFAULT next_autogen_tcn_value() NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer,
    cataloging_date timestamp with time zone
);


ALTER TABLE biblio.record_entry OWNER TO evergreen;

SET search_path = auditor, pg_catalog;

--
-- Name: biblio_record_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW biblio_record_entry_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, record_entry.id, record_entry.creator, record_entry.editor, record_entry.source, record_entry.quality, record_entry.create_date, record_entry.edit_date, record_entry.active, record_entry.deleted, record_entry.fingerprint, record_entry.tcn_source, record_entry.tcn_value, record_entry.marc, record_entry.last_xact_id, record_entry.owner, record_entry.share_depth FROM biblio.record_entry UNION ALL SELECT biblio_record_entry_history.audit_id, biblio_record_entry_history.audit_time, biblio_record_entry_history.audit_action, biblio_record_entry_history.audit_user, biblio_record_entry_history.audit_ws, biblio_record_entry_history.id, biblio_record_entry_history.creator, biblio_record_entry_history.editor, biblio_record_entry_history.source, biblio_record_entry_history.quality, biblio_record_entry_history.create_date, biblio_record_entry_history.edit_date, biblio_record_entry_history.active, biblio_record_entry_history.deleted, biblio_record_entry_history.fingerprint, biblio_record_entry_history.tcn_source, biblio_record_entry_history.tcn_value, biblio_record_entry_history.marc, biblio_record_entry_history.last_xact_id, biblio_record_entry_history.owner, biblio_record_entry_history.share_depth FROM biblio_record_entry_history;


ALTER TABLE auditor.biblio_record_entry_lifecycle OWNER TO evergreen;

--
-- Name: biblio_record_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE biblio_record_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.biblio_record_entry_pkey_seq OWNER TO evergreen;

--
-- Name: serial_unit_history; Type: TABLE; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE TABLE serial_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating boolean NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2),
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL,
    active_date timestamp with time zone,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.serial_unit_history OWNER TO evergreen;

SET search_path = serial, pg_catalog;

--
-- Name: unit; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE unit (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass),
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL
)
INHERITS (asset.copy);


ALTER TABLE serial.unit OWNER TO evergreen;

SET search_path = auditor, pg_catalog;

--
-- Name: serial_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW serial_unit_lifecycle AS
    SELECT (-1) AS audit_id, now() AS audit_time, '-'::text AS audit_action, (-1) AS audit_user, (-1) AS audit_ws, unit.id, unit.circ_lib, unit.creator, unit.call_number, unit.editor, unit.create_date, unit.edit_date, unit.copy_number, unit.status, unit.location, unit.loan_duration, unit.fine_level, unit.age_protect, unit.circulate, unit.deposit, unit.ref, unit.holdable, unit.deposit_amount, unit.price, unit.barcode, unit.circ_modifier, unit.circ_as_type, unit.dummy_title, unit.dummy_author, unit.alert_message, unit.opac_visible, unit.deleted, unit.floating, unit.dummy_isbn, unit.status_changed_time, unit.mint_condition, unit.cost, unit.sort_key, unit.detailed_contents, unit.summary_contents, unit.active_date FROM serial.unit UNION ALL SELECT serial_unit_history.audit_id, serial_unit_history.audit_time, serial_unit_history.audit_action, serial_unit_history.audit_user, serial_unit_history.audit_ws, serial_unit_history.id, serial_unit_history.circ_lib, serial_unit_history.creator, serial_unit_history.call_number, serial_unit_history.editor, serial_unit_history.create_date, serial_unit_history.edit_date, serial_unit_history.copy_number, serial_unit_history.status, serial_unit_history.location, serial_unit_history.loan_duration, serial_unit_history.fine_level, serial_unit_history.age_protect, serial_unit_history.circulate, serial_unit_history.deposit, serial_unit_history.ref, serial_unit_history.holdable, serial_unit_history.deposit_amount, serial_unit_history.price, serial_unit_history.barcode, serial_unit_history.circ_modifier, serial_unit_history.circ_as_type, serial_unit_history.dummy_title, serial_unit_history.dummy_author, serial_unit_history.alert_message, serial_unit_history.opac_visible, serial_unit_history.deleted, serial_unit_history.floating, serial_unit_history.dummy_isbn, serial_unit_history.status_changed_time, serial_unit_history.mint_condition, serial_unit_history.cost, serial_unit_history.sort_key, serial_unit_history.detailed_contents, serial_unit_history.summary_contents, serial_unit_history.active_date FROM serial_unit_history;


ALTER TABLE auditor.serial_unit_lifecycle OWNER TO evergreen;

--
-- Name: serial_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE serial_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.serial_unit_pkey_seq OWNER TO evergreen;

SET search_path = authority, pg_catalog;

--
-- Name: authority_linking_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority_linking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.authority_linking_id_seq OWNER TO evergreen;

--
-- Name: authority_linking_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority_linking_id_seq OWNED BY authority_linking.id;


--
-- Name: bib_linking; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_linking (
    id bigint NOT NULL,
    bib bigint NOT NULL,
    authority bigint NOT NULL
);


ALTER TABLE authority.bib_linking OWNER TO evergreen;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE bib_linking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.bib_linking_id_seq OWNER TO evergreen;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE bib_linking_id_seq OWNED BY bib_linking.id;


--
-- Name: browse_axis; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_axis (
    code text NOT NULL,
    name text NOT NULL,
    sorter text,
    description text
);


ALTER TABLE authority.browse_axis OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_axis_authority_field_map (
    id integer NOT NULL,
    axis text NOT NULL,
    field integer NOT NULL
);


ALTER TABLE authority.browse_axis_authority_field_map OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE browse_axis_authority_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.browse_axis_authority_field_map_id_seq OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE browse_axis_authority_field_map_id_seq OWNED BY browse_axis_authority_field_map.id;


--
-- Name: control_set; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE control_set (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.control_set OWNER TO evergreen;

--
-- Name: control_set_bib_field; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE control_set_bib_field (
    id integer NOT NULL,
    authority_field integer NOT NULL,
    tag character(3) NOT NULL
);


ALTER TABLE authority.control_set_bib_field OWNER TO evergreen;

--
-- Name: control_set_bib_field_metabib_field_map; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE control_set_bib_field_metabib_field_map (
    id integer NOT NULL,
    bib_field integer NOT NULL,
    metabib_field integer NOT NULL
);


ALTER TABLE authority.control_set_bib_field_metabib_field_map OWNER TO evergreen;

--
-- Name: control_set_auth_field_metabib_field_map_main; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_main AS
    SELECT DISTINCT b.authority_field, m.metabib_field FROM (control_set_bib_field_metabib_field_map m JOIN control_set_bib_field b ON ((b.id = m.bib_field)));


ALTER TABLE authority.control_set_auth_field_metabib_field_map_main OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_main; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_main IS 'metabib fields for main entry auth fields';


--
-- Name: control_set_authority_field; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE control_set_authority_field (
    id integer NOT NULL,
    main_entry integer,
    control_set integer NOT NULL,
    tag character(3) NOT NULL,
    nfi character(1),
    sf_list text NOT NULL,
    name text NOT NULL,
    description text,
    linking_subfield character(1),
    display_sf_list text NOT NULL,
    joiner text
);


ALTER TABLE authority.control_set_authority_field OWNER TO evergreen;

--
-- Name: control_set_auth_field_metabib_field_map_blind_main; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_blind_main AS
    SELECT r.authority_field, r.metabib_field FROM (control_set_auth_field_metabib_field_map_main r JOIN control_set_authority_field a ON ((r.authority_field = a.id))) WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_main OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_main; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_blind_main IS 'metabib fields for main entry auth fields that can''t be linked to other records';


--
-- Name: control_set_auth_field_metabib_field_map_refs_only; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_refs_only AS
    SELECT DISTINCT a.id AS authority_field, m.metabib_field FROM ((((control_set_authority_field a JOIN control_set_authority_field ame ON ((a.main_entry = ame.id))) JOIN control_set_bib_field b ON ((b.authority_field = ame.id))) JOIN control_set_bib_field_metabib_field_map mf ON ((mf.bib_field = b.id))) JOIN control_set_auth_field_metabib_field_map_main m ON ((ame.id = m.authority_field)));


ALTER TABLE authority.control_set_auth_field_metabib_field_map_refs_only OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_refs_only; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_refs_only IS 'metabib fields for NON-main entry auth fields';


--
-- Name: control_set_auth_field_metabib_field_map_refs; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_refs AS
    SELECT control_set_auth_field_metabib_field_map_main.authority_field, control_set_auth_field_metabib_field_map_main.metabib_field FROM control_set_auth_field_metabib_field_map_main UNION SELECT control_set_auth_field_metabib_field_map_refs_only.authority_field, control_set_auth_field_metabib_field_map_refs_only.metabib_field FROM control_set_auth_field_metabib_field_map_refs_only;


ALTER TABLE authority.control_set_auth_field_metabib_field_map_refs OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_refs; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_refs IS 'metabib fields for all auth fields';


--
-- Name: control_set_auth_field_metabib_field_map_blind_refs; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_blind_refs AS
    SELECT r.authority_field, r.metabib_field FROM (control_set_auth_field_metabib_field_map_refs r JOIN control_set_authority_field a ON ((r.authority_field = a.id))) WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_refs OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_refs; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_blind_refs IS 'metabib fields for all auth fields that can''t be linked to other records';


--
-- Name: control_set_auth_field_metabib_field_map_blind_refs_only; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW control_set_auth_field_metabib_field_map_blind_refs_only AS
    SELECT r.authority_field, r.metabib_field FROM (control_set_auth_field_metabib_field_map_refs_only r JOIN control_set_authority_field a ON ((r.authority_field = a.id))) WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_refs_only OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_refs_only; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW control_set_auth_field_metabib_field_map_blind_refs_only IS 'metabib fields for NON-main entry auth fields that can''t be linked to other records';


--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE control_set_authority_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_authority_field_id_seq OWNER TO evergreen;

--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE control_set_authority_field_id_seq OWNED BY control_set_authority_field.id;


--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE control_set_bib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_bib_field_id_seq OWNER TO evergreen;

--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE control_set_bib_field_id_seq OWNED BY control_set_bib_field.id;


--
-- Name: control_set_bib_field_metabib_field_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE control_set_bib_field_metabib_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_bib_field_metabib_field_map_id_seq OWNER TO evergreen;

--
-- Name: control_set_bib_field_metabib_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE control_set_bib_field_metabib_field_map_id_seq OWNED BY control_set_bib_field_metabib_field_map.id;


--
-- Name: control_set_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE control_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_id_seq OWNER TO evergreen;

--
-- Name: control_set_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE control_set_id_seq OWNED BY control_set.id;


--
-- Name: display_5xx_headings; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE display_5xx_headings (
    id integer NOT NULL,
    w_subfield_0 character(1),
    w_subfield_1 character(1),
    w_subfield_2 character(1),
    w_subfield_3 character(1),
    heading text
);


ALTER TABLE authority.display_5xx_headings OWNER TO evergreen;

--
-- Name: display_5xx_headings_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE display_5xx_headings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.display_5xx_headings_id_seq OWNER TO evergreen;

--
-- Name: display_5xx_headings_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE display_5xx_headings_id_seq OWNED BY display_5xx_headings.id;


--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.full_rec_id_seq OWNER TO evergreen;

--
-- Name: full_rec_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE full_rec_id_seq OWNED BY full_rec.id;


--
-- Name: rec_descriptor; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE rec_descriptor (
    id bigint NOT NULL,
    record bigint,
    record_status text,
    encoding_level text,
    thesaurus text
);


ALTER TABLE authority.rec_descriptor OWNER TO evergreen;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE rec_descriptor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.rec_descriptor_id_seq OWNER TO evergreen;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE rec_descriptor_id_seq OWNED BY rec_descriptor.id;


--
-- Name: record_entry; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    source integer,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    control_set integer
);


ALTER TABLE authority.record_entry OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE authority.record_note OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_note_id_seq OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE record_note_id_seq OWNED BY record_note.id;


--
-- Name: simple_heading_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE simple_heading_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.simple_heading_id_seq OWNER TO evergreen;

--
-- Name: simple_heading_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE simple_heading_id_seq OWNED BY simple_heading.id;


--
-- Name: thesaurus; Type: TABLE; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE TABLE thesaurus (
    code text NOT NULL,
    control_set integer,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.thesaurus OWNER TO evergreen;

--
-- Name: tracing_links; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW tracing_links AS
    SELECT main.record, main.id AS main_id, main.tag AS main_tag, public.oils_xpath_string((('//*[@tag="'::text || (main.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS main_value, substr(link.value, 1, 1) AS relationship, substr(link.value, 2, 1) AS use_restriction, substr(link.value, 3, 1) AS deprecation, substr(link.value, 4, 1) AS display_restriction, link.id AS link_id, link.tag AS link_tag, public.oils_xpath_string((('//*[@tag="'::text || (link.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS link_value, normalize_heading(are.marc) AS normalized_main_value FROM ((((full_rec main JOIN record_entry are ON ((main.record = are.id))) JOIN control_set_authority_field main_entry ON ((((main_entry.tag = main.tag) AND (main_entry.main_entry IS NULL)) AND (main.subfield = 'a'::text)))) JOIN control_set_authority_field sub_entry ON ((main_entry.id = sub_entry.main_entry))) JOIN full_rec link ON ((((link.record = main.record) AND (link.tag = sub_entry.tag)) AND (link.subfield = 'w'::text))));


ALTER TABLE authority.tracing_links OWNER TO evergreen;

SET search_path = biblio, pg_catalog;

--
-- Name: autogen_tcn_value_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE autogen_tcn_value_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.autogen_tcn_value_seq OWNER TO evergreen;

--
-- Name: monograph_part; Type: TABLE; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE TABLE monograph_part (
    id integer NOT NULL,
    record bigint NOT NULL,
    label text NOT NULL,
    label_sortkey text NOT NULL
);


ALTER TABLE biblio.monograph_part OWNER TO evergreen;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE monograph_part_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.monograph_part_id_seq OWNER TO evergreen;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE monograph_part_id_seq OWNED BY monograph_part.id;


--
-- Name: peer_bib_copy_map; Type: TABLE; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE TABLE peer_bib_copy_map (
    id integer NOT NULL,
    peer_type integer NOT NULL,
    peer_record bigint NOT NULL,
    target_copy bigint NOT NULL
);


ALTER TABLE biblio.peer_bib_copy_map OWNER TO evergreen;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE peer_bib_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_bib_copy_map_id_seq OWNER TO evergreen;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE peer_bib_copy_map_id_seq OWNED BY peer_bib_copy_map.id;


--
-- Name: peer_type; Type: TABLE; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE TABLE peer_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE biblio.peer_type OWNER TO evergreen;

--
-- Name: peer_type_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE peer_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_type_id_seq OWNER TO evergreen;

--
-- Name: peer_type_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE peer_type_id_seq OWNED BY peer_type.id;


--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE biblio.record_note OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_note_id_seq OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE record_note_id_seq OWNED BY record_note.id;


SET search_path = booking, pg_catalog;

--
-- Name: reservation; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE reservation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass),
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    capture_time timestamp with time zone,
    cancel_time timestamp with time zone,
    pickup_time timestamp with time zone,
    return_time timestamp with time zone,
    booking_interval interval,
    fine_interval interval,
    fine_amount numeric(8,2),
    max_fine numeric(8,2),
    target_resource_type integer NOT NULL,
    target_resource integer,
    current_resource integer,
    request_lib integer NOT NULL,
    pickup_lib integer,
    capture_staff integer,
    email_notify boolean DEFAULT false NOT NULL
)
INHERITS (money.billable_xact);


ALTER TABLE booking.reservation OWNER TO evergreen;

--
-- Name: reservation_attr_value_map; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE reservation_attr_value_map (
    id integer NOT NULL,
    reservation integer NOT NULL,
    attr_value integer NOT NULL
);


ALTER TABLE booking.reservation_attr_value_map OWNER TO evergreen;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE reservation_attr_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.reservation_attr_value_map_id_seq OWNER TO evergreen;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE reservation_attr_value_map_id_seq OWNED BY reservation_attr_value_map.id;


--
-- Name: resource; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE resource (
    id integer NOT NULL,
    owner integer NOT NULL,
    type integer NOT NULL,
    overbook boolean DEFAULT false NOT NULL,
    barcode text NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    deposit_amount numeric(8,2) DEFAULT 0.00 NOT NULL,
    user_fee numeric(8,2) DEFAULT 0.00 NOT NULL
);


ALTER TABLE booking.resource OWNER TO evergreen;

--
-- Name: resource_attr; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE resource_attr (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    resource_type integer NOT NULL,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE booking.resource_attr OWNER TO evergreen;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE resource_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE resource_attr_id_seq OWNED BY resource_attr.id;


--
-- Name: resource_attr_map; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE resource_attr_map (
    id integer NOT NULL,
    resource integer NOT NULL,
    resource_attr integer NOT NULL,
    value integer NOT NULL
);


ALTER TABLE booking.resource_attr_map OWNER TO evergreen;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE resource_attr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_map_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE resource_attr_map_id_seq OWNED BY resource_attr_map.id;


--
-- Name: resource_attr_value; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE resource_attr_value (
    id integer NOT NULL,
    owner integer NOT NULL,
    attr integer NOT NULL,
    valid_value text NOT NULL
);


ALTER TABLE booking.resource_attr_value OWNER TO evergreen;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE resource_attr_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_value_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE resource_attr_value_id_seq OWNED BY resource_attr_value.id;


--
-- Name: resource_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_id_seq OWNER TO evergreen;

--
-- Name: resource_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE resource_id_seq OWNED BY resource.id;


--
-- Name: resource_type; Type: TABLE; Schema: booking; Owner: evergreen; Tablespace: 
--

CREATE TABLE resource_type (
    id integer NOT NULL,
    name text NOT NULL,
    elbow_room interval,
    fine_interval interval,
    fine_amount numeric(8,2) DEFAULT 0 NOT NULL,
    max_fine numeric(8,2),
    owner integer NOT NULL,
    catalog_item boolean DEFAULT false NOT NULL,
    transferable boolean DEFAULT false NOT NULL,
    record bigint
);


ALTER TABLE booking.resource_type OWNER TO evergreen;

--
-- Name: resource_type_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE resource_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_type_id_seq OWNER TO evergreen;

--
-- Name: resource_type_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE resource_type_id_seq OWNED BY resource_type.id;


SET search_path = cmd, pg_catalog;

--
-- Name: unused_indexes; Type: TABLE; Schema: cmd; Owner: postgres; Tablespace: 
--

CREATE TABLE unused_indexes (
    fqindexname text,
    total_size text,
    raw_size bigint
);


ALTER TABLE cmd.unused_indexes OWNER TO postgres;

SET search_path = config, pg_catalog;

--
-- Name: coded_value_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE coded_value_map (
    id integer NOT NULL,
    ctype text NOT NULL,
    code text NOT NULL,
    value text NOT NULL,
    description text,
    opac_visible boolean DEFAULT true NOT NULL,
    search_label text,
    is_simple boolean DEFAULT false NOT NULL
);


ALTER TABLE config.coded_value_map OWNER TO evergreen;

--
-- Name: audience_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW audience_map AS
    SELECT coded_value_map.code, coded_value_map.value, coded_value_map.description FROM coded_value_map WHERE (coded_value_map.ctype = 'audience'::text);


ALTER TABLE config.audience_map OWNER TO evergreen;

--
-- Name: backup_circ_limit_set; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE backup_circ_limit_set (
    id integer,
    name text,
    owning_lib integer,
    items_out integer,
    depth integer,
    global boolean,
    description text
);


ALTER TABLE config.backup_circ_limit_set OWNER TO evergreen;

--
-- Name: backup_circ_limit_set_circ_mod_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE backup_circ_limit_set_circ_mod_map (
    id integer,
    limit_set integer,
    circ_mod text
);


ALTER TABLE config.backup_circ_limit_set_circ_mod_map OWNER TO evergreen;

--
-- Name: backup_circ_limit_set_group_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE backup_circ_limit_set_group_map (
    id integer,
    limit_set integer,
    limit_group integer,
    check_only boolean
);


ALTER TABLE config.backup_circ_limit_set_group_map OWNER TO evergreen;

--
-- Name: backup_circ_matrix_limit_set_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE backup_circ_matrix_limit_set_map (
    id integer,
    matchpoint integer,
    limit_set integer,
    fallthrough boolean,
    active boolean
);


ALTER TABLE config.backup_circ_matrix_limit_set_map OWNER TO evergreen;

--
-- Name: backup_circ_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE backup_circ_matrix_matchpoint (
    id integer,
    active boolean,
    org_unit integer,
    grp integer,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    ref_flag boolean,
    juvenile_flag boolean,
    is_renewal boolean,
    usr_age_lower_bound interval,
    usr_age_upper_bound interval,
    circulate boolean,
    duration_rule integer,
    recurring_fine_rule integer,
    max_fine_rule integer,
    script_test text,
    total_copy_hold_ratio double precision,
    available_copy_hold_ratio double precision,
    copy_circ_lib integer,
    copy_owning_lib integer,
    hard_due_date integer,
    renewals integer,
    user_home_ou integer,
    grace_period interval,
    marc_bib_level text,
    item_age interval
);


ALTER TABLE config.backup_circ_matrix_matchpoint OWNER TO evergreen;

--
-- Name: barcode_completion; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE barcode_completion (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    prefix text,
    suffix text,
    length integer DEFAULT 0 NOT NULL,
    padding text,
    padding_end boolean DEFAULT false NOT NULL,
    asset boolean DEFAULT true NOT NULL,
    actor boolean DEFAULT true NOT NULL
);


ALTER TABLE config.barcode_completion OWNER TO evergreen;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE barcode_completion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.barcode_completion_id_seq OWNER TO evergreen;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE barcode_completion_id_seq OWNED BY barcode_completion.id;


--
-- Name: best_hold_order; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE best_hold_order (
    id integer NOT NULL,
    name text,
    pprox integer,
    hprox integer,
    aprox integer,
    approx integer,
    priority integer,
    cut integer,
    depth integer,
    htime integer,
    rtime integer,
    shtime integer,
    CONSTRAINT best_hold_order_check CHECK (((((((((pprox IS NOT NULL) OR (hprox IS NOT NULL)) OR (aprox IS NOT NULL)) OR (priority IS NOT NULL)) OR (cut IS NOT NULL)) OR (depth IS NOT NULL)) OR (htime IS NOT NULL)) OR (rtime IS NOT NULL)))
);


ALTER TABLE config.best_hold_order OWNER TO evergreen;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE best_hold_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.best_hold_order_id_seq OWNER TO evergreen;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE best_hold_order_id_seq OWNED BY best_hold_order.id;


--
-- Name: bib_level_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW bib_level_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'bib_level'::text);


ALTER TABLE config.bib_level_map OWNER TO evergreen;

--
-- Name: bib_source; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_source (
    id integer NOT NULL,
    quality integer,
    source text NOT NULL,
    transcendant boolean DEFAULT false NOT NULL,
    can_have_copies boolean DEFAULT true NOT NULL,
    CONSTRAINT bib_source_quality_check CHECK (((quality >= 0) AND (quality <= 100)))
);


ALTER TABLE config.bib_source OWNER TO evergreen;

--
-- Name: TABLE bib_source; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE bib_source IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Valid sources of MARC records
 *
 * This is table is used to set up the relative "quality" of each
 * MARC source, such as OCLC.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: bib_source_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE bib_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.bib_source_id_seq OWNER TO evergreen;

--
-- Name: bib_source_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE bib_source_id_seq OWNED BY bib_source.id;


--
-- Name: biblio_fingerprint; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_fingerprint (
    id integer NOT NULL,
    name text NOT NULL,
    xpath text NOT NULL,
    first_word boolean DEFAULT false NOT NULL,
    format text DEFAULT 'marcxml'::text NOT NULL
);


ALTER TABLE config.biblio_fingerprint OWNER TO evergreen;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE biblio_fingerprint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.biblio_fingerprint_id_seq OWNER TO evergreen;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE biblio_fingerprint_id_seq OWNED BY biblio_fingerprint.id;


--
-- Name: billing_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE billing_type (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    default_price numeric(6,2)
);


ALTER TABLE config.billing_type OWNER TO evergreen;

--
-- Name: billing_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE billing_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.billing_type_id_seq OWNER TO evergreen;

--
-- Name: billing_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE billing_type_id_seq OWNED BY billing_type.id;


--
-- Name: circ_limit_group; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_limit_group (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_group OWNER TO evergreen;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_limit_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_group_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_limit_group_id_seq OWNED BY circ_limit_group.id;


--
-- Name: circ_limit_set; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_limit_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    items_out integer NOT NULL,
    depth integer DEFAULT 0 NOT NULL,
    global boolean DEFAULT false NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_set OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_limit_set_circ_mod_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    circ_mod text NOT NULL
);


ALTER TABLE config.circ_limit_set_circ_mod_map OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_limit_set_circ_mod_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_circ_mod_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_limit_set_circ_mod_map_id_seq OWNED BY circ_limit_set_circ_mod_map.id;


--
-- Name: circ_limit_set_copy_loc_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_limit_set_copy_loc_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    copy_loc integer NOT NULL
);


ALTER TABLE config.circ_limit_set_copy_loc_map OWNER TO evergreen;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_limit_set_copy_loc_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_copy_loc_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_limit_set_copy_loc_map_id_seq OWNED BY circ_limit_set_copy_loc_map.id;


--
-- Name: circ_limit_set_group_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_limit_set_group_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    limit_group integer NOT NULL,
    check_only boolean DEFAULT false NOT NULL
);


ALTER TABLE config.circ_limit_set_group_map OWNER TO evergreen;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_limit_set_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_group_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_limit_set_group_map_id_seq OWNED BY circ_limit_set_group_map.id;


--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_limit_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_limit_set_id_seq OWNED BY circ_limit_set.id;


--
-- Name: circ_matrix_circ_mod_test; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_matrix_circ_mod_test (
    id integer NOT NULL,
    matchpoint integer NOT NULL,
    items_out integer NOT NULL
);


ALTER TABLE config.circ_matrix_circ_mod_test OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_matrix_circ_mod_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_circ_mod_test_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_matrix_circ_mod_test_id_seq OWNED BY circ_matrix_circ_mod_test.id;


--
-- Name: circ_matrix_circ_mod_test_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_matrix_circ_mod_test_map (
    id integer NOT NULL,
    circ_mod_test integer NOT NULL,
    circ_mod text NOT NULL
);


ALTER TABLE config.circ_matrix_circ_mod_test_map OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_matrix_circ_mod_test_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_circ_mod_test_map_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_matrix_circ_mod_test_map_id_seq OWNED BY circ_matrix_circ_mod_test_map.id;


--
-- Name: circ_matrix_limit_set_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_matrix_limit_set_map (
    id integer NOT NULL,
    matchpoint integer NOT NULL,
    limit_set integer NOT NULL,
    fallthrough boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE config.circ_matrix_limit_set_map OWNER TO evergreen;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_matrix_limit_set_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_limit_set_map_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_matrix_limit_set_map_id_seq OWNED BY circ_matrix_limit_set_map.id;


--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_matchpoint_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_matrix_matchpoint_id_seq OWNED BY circ_matrix_matchpoint.id;


--
-- Name: circ_matrix_weights; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    org_unit numeric(6,2) NOT NULL,
    grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    copy_circ_lib numeric(6,2) NOT NULL,
    copy_owning_lib numeric(6,2) NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    is_renewal numeric(6,2) NOT NULL,
    usr_age_lower_bound numeric(6,2) NOT NULL,
    usr_age_upper_bound numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL,
    copy_location numeric(6,2) NOT NULL
);


ALTER TABLE config.circ_matrix_weights OWNER TO evergreen;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE circ_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_weights_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE circ_matrix_weights_id_seq OWNED BY circ_matrix_weights.id;


--
-- Name: circ_modifier; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_modifier (
    code text NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    sip2_media_type text NOT NULL,
    magnetic_media boolean DEFAULT true NOT NULL,
    avg_wait_time interval
);


ALTER TABLE config.circ_modifier OWNER TO evergreen;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE coded_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.coded_value_map_id_seq OWNER TO evergreen;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE coded_value_map_id_seq OWNED BY coded_value_map.id;


--
-- Name: copy_status; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_status (
    id integer NOT NULL,
    name text NOT NULL,
    holdable boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    copy_active boolean DEFAULT false NOT NULL,
    restrict_copy_delete boolean DEFAULT false NOT NULL
);


ALTER TABLE config.copy_status OWNER TO evergreen;

--
-- Name: TABLE copy_status; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE copy_status IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Copy Statuses
 *
 * The available copy statuses, and whether a copy in that
 * status is available for hold request capture.  0 (zero) is
 * the only special number in this set, meaning that the item
 * is available for immediate checkout, and is counted as available
 * in the OPAC.
 *
 * Statuses with an ID below 100 are not removable, and have special
 * meaning in the code.  Do not change them except to translate the
 * textual name.
 *
 * You may add and remove statuses above 100, and these can be used
 * to remove items from normal circulation without affecting the rest
 * of the copy''s values or its location.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: copy_status_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE copy_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.copy_status_id_seq OWNER TO evergreen;

--
-- Name: copy_status_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE copy_status_id_seq OWNED BY copy_status.id;


--
-- Name: db_patch_dependencies; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE db_patch_dependencies (
    db_patch text NOT NULL,
    supersedes text[],
    deprecates text[]
);


ALTER TABLE config.db_patch_dependencies OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE filter_dialog_filter_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    interface text NOT NULL,
    filters text NOT NULL,
    CONSTRAINT filter_dialog_filter_set_filters_check CHECK (public.is_json(filters))
);


ALTER TABLE config.filter_dialog_filter_set OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE filter_dialog_filter_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.filter_dialog_filter_set_id_seq OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE filter_dialog_filter_set_id_seq OWNED BY filter_dialog_filter_set.id;


--
-- Name: filter_dialog_interface; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE filter_dialog_interface (
    key text NOT NULL,
    description text
);


ALTER TABLE config.filter_dialog_interface OWNER TO evergreen;

--
-- Name: internal_flag; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE internal_flag (
    name text NOT NULL,
    value text,
    enabled boolean DEFAULT false NOT NULL
);


ALTER TABLE config.internal_flag OWNER TO evergreen;

--
-- Name: global_flag; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE global_flag (
    label text NOT NULL
)
INHERITS (internal_flag);


ALTER TABLE config.global_flag OWNER TO evergreen;

--
-- Name: hard_due_date; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE hard_due_date (
    id integer NOT NULL,
    name text NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    forceto boolean NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE config.hard_due_date OWNER TO evergreen;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE hard_due_date_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_id_seq OWNER TO evergreen;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE hard_due_date_id_seq OWNED BY hard_due_date.id;


--
-- Name: hard_due_date_values; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE hard_due_date_values (
    id integer NOT NULL,
    hard_due_date integer NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    active_date timestamp with time zone NOT NULL
);


ALTER TABLE config.hard_due_date_values OWNER TO evergreen;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE hard_due_date_values_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_values_id_seq OWNER TO evergreen;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE hard_due_date_values_id_seq OWNED BY hard_due_date_values.id;


--
-- Name: hold_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    user_home_ou integer,
    request_ou integer,
    pickup_ou integer,
    item_owning_ou integer,
    item_circ_ou integer,
    usr_grp integer,
    requestor_grp integer NOT NULL,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    juvenile_flag boolean,
    ref_flag boolean,
    holdable boolean DEFAULT true NOT NULL,
    distance_is_from_owner boolean DEFAULT false NOT NULL,
    transit_range integer,
    max_holds integer,
    include_frozen_holds boolean DEFAULT true NOT NULL,
    stop_blocked_user boolean DEFAULT false NOT NULL,
    age_hold_protect_rule integer,
    strict_ou_match boolean DEFAULT false NOT NULL,
    marc_bib_level text,
    item_age interval
);


ALTER TABLE config.hold_matrix_matchpoint OWNER TO evergreen;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE hold_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_matchpoint_id_seq OWNER TO evergreen;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE hold_matrix_matchpoint_id_seq OWNED BY hold_matrix_matchpoint.id;


--
-- Name: hold_matrix_weights; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    request_ou numeric(6,2) NOT NULL,
    pickup_ou numeric(6,2) NOT NULL,
    item_owning_ou numeric(6,2) NOT NULL,
    item_circ_ou numeric(6,2) NOT NULL,
    usr_grp numeric(6,2) NOT NULL,
    requestor_grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL
);


ALTER TABLE config.hold_matrix_weights OWNER TO evergreen;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE hold_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_weights_id_seq OWNER TO evergreen;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE hold_matrix_weights_id_seq OWNED BY hold_matrix_weights.id;


--
-- Name: i18n_core; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE i18n_core (
    id bigint NOT NULL,
    fq_field text NOT NULL,
    identity_value text NOT NULL,
    translation text NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.i18n_core OWNER TO evergreen;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE i18n_core_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.i18n_core_id_seq OWNER TO evergreen;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE i18n_core_id_seq OWNED BY i18n_core.id;


--
-- Name: i18n_locale; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE i18n_locale (
    code text NOT NULL,
    marc_code text NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE config.i18n_locale OWNER TO evergreen;

--
-- Name: identification_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE identification_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.identification_type OWNER TO evergreen;

--
-- Name: TABLE identification_type; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE identification_type IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Types of valid patron identification.
 *
 * Each patron must display at least one valid form of identification
 * in order to get a library card.  This table lists those forms.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: identification_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE identification_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.identification_type_id_seq OWNER TO evergreen;

--
-- Name: identification_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE identification_type_id_seq OWNED BY identification_type.id;


--
-- Name: idl_field_doc; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE idl_field_doc (
    id bigint NOT NULL,
    fm_class text NOT NULL,
    field text NOT NULL,
    owner integer NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.idl_field_doc OWNER TO evergreen;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE idl_field_doc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.idl_field_doc_id_seq OWNER TO evergreen;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE idl_field_doc_id_seq OWNED BY idl_field_doc.id;


--
-- Name: index_normalizer; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE index_normalizer (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    func text NOT NULL,
    param_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.index_normalizer OWNER TO evergreen;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE index_normalizer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.index_normalizer_id_seq OWNER TO evergreen;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE index_normalizer_id_seq OWNED BY index_normalizer.id;


--
-- Name: item_form_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW item_form_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_form'::text);


ALTER TABLE config.item_form_map OWNER TO evergreen;

--
-- Name: item_type_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW item_type_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_type'::text);


ALTER TABLE config.item_type_map OWNER TO evergreen;

--
-- Name: language_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW language_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'item_lang'::text);


ALTER TABLE config.language_map OWNER TO evergreen;

--
-- Name: lit_form_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW lit_form_map AS
    SELECT coded_value_map.code, coded_value_map.value, coded_value_map.description FROM coded_value_map WHERE (coded_value_map.ctype = 'lit_form'::text);


ALTER TABLE config.lit_form_map OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc21_ff_pos_map (
    id integer NOT NULL,
    fixed_field text NOT NULL,
    tag text NOT NULL,
    rec_type text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    default_val text DEFAULT ' '::text NOT NULL
);


ALTER TABLE config.marc21_ff_pos_map OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE marc21_ff_pos_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_ff_pos_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE marc21_ff_pos_map_id_seq OWNED BY marc21_ff_pos_map.id;


--
-- Name: marc21_physical_characteristic_subfield_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_subfield_map (
    id integer NOT NULL,
    ptype_key text NOT NULL,
    subfield text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_subfield_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE marc21_physical_characteristic_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_subfield_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE marc21_physical_characteristic_subfield_map_id_seq OWNED BY marc21_physical_characteristic_subfield_map.id;


--
-- Name: marc21_physical_characteristic_type_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_type_map (
    ptype_key text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_type_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc21_physical_characteristic_value_map (
    id integer NOT NULL,
    value text NOT NULL,
    ptype_subfield integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_value_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE marc21_physical_characteristic_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_value_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE marc21_physical_characteristic_value_map_id_seq OWNED BY marc21_physical_characteristic_value_map.id;


--
-- Name: metabib_class; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_class (
    name text NOT NULL,
    label text NOT NULL,
    restrict boolean DEFAULT false NOT NULL,
    buoyant boolean DEFAULT false NOT NULL,
    a_weight numeric DEFAULT 1.0 NOT NULL,
    b_weight numeric DEFAULT 0.4 NOT NULL,
    c_weight numeric DEFAULT 0.2 NOT NULL,
    d_weight numeric DEFAULT 0.1 NOT NULL,
    combined boolean DEFAULT false NOT NULL
);


ALTER TABLE config.metabib_class OWNER TO evergreen;

--
-- Name: metabib_class_ts_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_class_ts_map (
    id integer NOT NULL,
    field_class text NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    always boolean DEFAULT true NOT NULL,
    CONSTRAINT metabib_class_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_class_ts_map OWNER TO evergreen;

--
-- Name: TABLE metabib_class_ts_map; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE metabib_class_ts_map IS '
Text Search Configs for metabib class indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE metabib_class_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_class_ts_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE metabib_class_ts_map_id_seq OWNED BY metabib_class_ts_map.id;


--
-- Name: metabib_field; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_field (
    id integer NOT NULL,
    field_class text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    xpath text NOT NULL,
    weight integer DEFAULT 1 NOT NULL,
    format text DEFAULT 'mods33'::text NOT NULL,
    search_field boolean DEFAULT true NOT NULL,
    facet_field boolean DEFAULT false NOT NULL,
    facet_xpath text,
    browse_field boolean DEFAULT true NOT NULL,
    browse_xpath text,
    restrict boolean DEFAULT false NOT NULL,
    authority_xpath text,
    browse_sort_xpath text,
    joiner text
);


ALTER TABLE config.metabib_field OWNER TO evergreen;

--
-- Name: TABLE metabib_field; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE metabib_field IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * XPath used for record indexing ingest
 *
 * This table contains the XPath used to chop up MODS into its
 * indexable parts.  Each XPath entry is named and assigned to
 * a "class" of either title, subject, author, keyword or series.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: metabib_field_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE metabib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE metabib_field_id_seq OWNED BY metabib_field.id;


--
-- Name: metabib_field_index_norm_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_field_index_norm_map (
    id integer NOT NULL,
    field integer NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.metabib_field_index_norm_map OWNER TO evergreen;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE metabib_field_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_index_norm_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE metabib_field_index_norm_map_id_seq OWNED BY metabib_field_index_norm_map.id;


--
-- Name: metabib_field_ts_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_field_ts_map (
    id integer NOT NULL,
    metabib_field integer NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    CONSTRAINT metabib_field_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_field_ts_map OWNER TO evergreen;

--
-- Name: TABLE metabib_field_ts_map; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE metabib_field_ts_map IS '
Text Search Configs for metabib field indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE metabib_field_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_ts_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE metabib_field_ts_map_id_seq OWNED BY metabib_field_ts_map.id;


--
-- Name: metabib_search_alias; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_search_alias (
    alias text NOT NULL,
    field_class text NOT NULL,
    field integer
);


ALTER TABLE config.metabib_search_alias OWNER TO evergreen;

--
-- Name: net_access_level; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE net_access_level (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.net_access_level OWNER TO evergreen;

--
-- Name: TABLE net_access_level; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE net_access_level IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Patron Network Access level
 *
 * This will be used to inform the in-library firewall of how much
 * internet access the using patron should be allowed.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: net_access_level_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE net_access_level_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.net_access_level_id_seq OWNER TO evergreen;

--
-- Name: net_access_level_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE net_access_level_id_seq OWNED BY net_access_level.id;


--
-- Name: non_cataloged_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE non_cataloged_type (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    name text NOT NULL,
    circ_duration interval DEFAULT '14 days'::interval NOT NULL,
    in_house boolean DEFAULT false NOT NULL
);


ALTER TABLE config.non_cataloged_type OWNER TO evergreen;

--
-- Name: TABLE non_cataloged_type; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE non_cataloged_type IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Types of valid non-cataloged items.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE non_cataloged_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.non_cataloged_type_id_seq OWNER TO evergreen;

--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE non_cataloged_type_id_seq OWNED BY non_cataloged_type.id;


--
-- Name: org_unit_setting_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_setting_type (
    name text NOT NULL,
    label text NOT NULL,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    view_perm integer,
    update_perm integer,
    grp text,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.org_unit_setting_type OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_setting_type_log (
    id bigint NOT NULL,
    date_applied timestamp with time zone DEFAULT now() NOT NULL,
    org integer,
    original_value text,
    new_value text,
    field_name text
);


ALTER TABLE config.org_unit_setting_type_log OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE org_unit_setting_type_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.org_unit_setting_type_log_id_seq OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE org_unit_setting_type_log_id_seq OWNED BY org_unit_setting_type_log.id;


--
-- Name: patron_message; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_message (
    id integer NOT NULL,
    message text NOT NULL,
    weight integer DEFAULT 0
);


ALTER TABLE config.patron_message OWNER TO evergreen;

--
-- Name: patron_message_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE patron_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.patron_message_id_seq OWNER TO evergreen;

--
-- Name: patron_message_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE patron_message_id_seq OWNED BY patron_message.id;


--
-- Name: record_attr_definition; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_attr_definition (
    name text NOT NULL,
    label text NOT NULL,
    description text,
    filter boolean DEFAULT true NOT NULL,
    sorter boolean DEFAULT false NOT NULL,
    tag text,
    sf_list text,
    joiner text,
    xpath text,
    format text,
    start_pos integer,
    string_len integer,
    fixed_field text,
    phys_char_sf integer
);


ALTER TABLE config.record_attr_definition OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_attr_index_norm_map (
    id integer NOT NULL,
    attr text NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.record_attr_index_norm_map OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE record_attr_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.record_attr_index_norm_map_id_seq OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE record_attr_index_norm_map_id_seq OWNED BY record_attr_index_norm_map.id;


--
-- Name: rule_age_hold_protect; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE rule_age_hold_protect (
    id integer NOT NULL,
    name text NOT NULL,
    age interval NOT NULL,
    prox integer NOT NULL,
    CONSTRAINT rule_age_hold_protect_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_age_hold_protect OWNER TO evergreen;

--
-- Name: TABLE rule_age_hold_protect; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE rule_age_hold_protect IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Hold Item Age Protection rules
 *
 * A hold request can only capture new(ish) items when they are
 * within a particular proximity of the home_ou of the requesting
 * user.  The proximity (''prox'' column) is calculated by counting
 * the number of tree edges between the user''s home_ou and the owning_lib
 * of the copy that could fulfill the hold.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE rule_age_hold_protect_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_age_hold_protect_id_seq OWNER TO evergreen;

--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE rule_age_hold_protect_id_seq OWNED BY rule_age_hold_protect.id;


--
-- Name: rule_circ_duration; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE rule_circ_duration (
    id integer NOT NULL,
    name text NOT NULL,
    extended interval NOT NULL,
    normal interval NOT NULL,
    shrt interval NOT NULL,
    max_renewals integer NOT NULL,
    CONSTRAINT rule_circ_duration_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_circ_duration OWNER TO evergreen;

--
-- Name: TABLE rule_circ_duration; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE rule_circ_duration IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Duration rules
 *
 * Each circulation is given a duration based on one of these rules.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE rule_circ_duration_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_circ_duration_id_seq OWNER TO evergreen;

--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE rule_circ_duration_id_seq OWNED BY rule_circ_duration.id;


--
-- Name: rule_max_fine; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE rule_max_fine (
    id integer NOT NULL,
    name text NOT NULL,
    amount numeric(6,2) NOT NULL,
    is_percent boolean DEFAULT false NOT NULL,
    CONSTRAINT rule_max_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_max_fine OWNER TO evergreen;

--
-- Name: TABLE rule_max_fine; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE rule_max_fine IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Max Fine rules
 *
 * Each circulation is given a maximum fine based on one of
 * these rules.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE rule_max_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_max_fine_id_seq OWNER TO evergreen;

--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE rule_max_fine_id_seq OWNED BY rule_max_fine.id;


--
-- Name: rule_recurring_fine; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE rule_recurring_fine (
    id integer NOT NULL,
    name text NOT NULL,
    high numeric(6,2) NOT NULL,
    normal numeric(6,2) NOT NULL,
    low numeric(6,2) NOT NULL,
    recurrence_interval interval DEFAULT '1 day'::interval NOT NULL,
    grace_period interval DEFAULT '1 day'::interval NOT NULL,
    CONSTRAINT rule_recurring_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_recurring_fine OWNER TO evergreen;

--
-- Name: TABLE rule_recurring_fine; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE rule_recurring_fine IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Recurring Fine rules
 *
 * Each circulation is given a recurring fine amount based on one of
 * these rules.  The recurrence_interval should not be any shorter
 * than the interval between runs of the fine_processor.pl script
 * (which is run from CRON), or you could miss fines.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE rule_recurring_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_recurring_fine_id_seq OWNER TO evergreen;

--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE rule_recurring_fine_id_seq OWNED BY rule_recurring_fine.id;


--
-- Name: settings_group; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE settings_group (
    name text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.settings_group OWNER TO evergreen;

--
-- Name: sms_carrier; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE sms_carrier (
    id integer NOT NULL,
    region text,
    name text,
    email_gateway text,
    active boolean DEFAULT true
);


ALTER TABLE config.sms_carrier OWNER TO evergreen;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE sms_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.sms_carrier_id_seq OWNER TO evergreen;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE sms_carrier_id_seq OWNED BY sms_carrier.id;


--
-- Name: standing; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE standing (
    id integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE config.standing OWNER TO evergreen;

--
-- Name: TABLE standing; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE standing IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Patron Standings
 *
 * This table contains the values that can be applied to a patron
 * by a staff member.  These values should not be changed, other
 * than for translation, as the ID column is currently a "magic
 * number" in the source. :(
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: standing_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE standing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_id_seq OWNER TO evergreen;

--
-- Name: standing_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE standing_id_seq OWNED BY standing.id;


--
-- Name: standing_penalty; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE standing_penalty (
    id integer NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    block_list text,
    org_depth integer,
    staff_alert boolean DEFAULT false NOT NULL
);


ALTER TABLE config.standing_penalty OWNER TO evergreen;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_penalty_id_seq OWNER TO evergreen;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE standing_penalty_id_seq OWNED BY standing_penalty.id;


--
-- Name: ts_config_list; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE ts_config_list (
    id text NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.ts_config_list OWNER TO evergreen;

--
-- Name: TABLE ts_config_list; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE ts_config_list IS '
Full Text Configs

A list of full text configs with names and descriptions.
';


--
-- Name: upgrade_log; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE upgrade_log (
    version text NOT NULL,
    install_date timestamp with time zone DEFAULT now() NOT NULL,
    applied_to text
);


ALTER TABLE config.upgrade_log OWNER TO evergreen;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE usr_activity_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.usr_activity_type_id_seq OWNER TO evergreen;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE usr_activity_type_id_seq OWNED BY usr_activity_type.id;


--
-- Name: usr_setting_type; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_setting_type (
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    label text NOT NULL,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    grp text,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.usr_setting_type OWNER TO evergreen;

--
-- Name: videorecording_format_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW videorecording_format_map AS
    SELECT coded_value_map.code, coded_value_map.value FROM coded_value_map WHERE (coded_value_map.ctype = 'vr_format'::text);


ALTER TABLE config.videorecording_format_map OWNER TO evergreen;

--
-- Name: weight_assoc; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE weight_assoc (
    id integer NOT NULL,
    active boolean NOT NULL,
    org_unit integer NOT NULL,
    circ_weights integer,
    hold_weights integer
);


ALTER TABLE config.weight_assoc OWNER TO evergreen;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE weight_assoc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.weight_assoc_id_seq OWNER TO evergreen;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE weight_assoc_id_seq OWNED BY weight_assoc.id;


--
-- Name: xml_transform; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE xml_transform (
    name text NOT NULL,
    namespace_uri text NOT NULL,
    prefix text NOT NULL,
    xslt text NOT NULL
);


ALTER TABLE config.xml_transform OWNER TO evergreen;

--
-- Name: xml_transform_back; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE xml_transform_back (
    name text,
    namespace_uri text,
    prefix text,
    xslt text
);


ALTER TABLE config.xml_transform_back OWNER TO evergreen;

--
-- Name: z3950_attr; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE z3950_attr (
    id integer NOT NULL,
    source text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    code integer NOT NULL,
    format integer NOT NULL,
    truncation integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.z3950_attr OWNER TO evergreen;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE z3950_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_attr_id_seq OWNER TO evergreen;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE z3950_attr_id_seq OWNED BY z3950_attr.id;


--
-- Name: z3950_source; Type: TABLE; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE TABLE z3950_source (
    name text NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    port integer NOT NULL,
    db text NOT NULL,
    record_format text DEFAULT 'FI'::text NOT NULL,
    transmission_format text DEFAULT 'usmarc'::text NOT NULL,
    auth boolean DEFAULT true NOT NULL,
    use_perm integer
);


ALTER TABLE config.z3950_source OWNER TO evergreen;

--
-- Name: TABLE z3950_source; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE z3950_source IS '
Z39.50 Sources

Each row in this table represents a database searchable via Z39.50.
';


--
-- Name: COLUMN z3950_source.record_format; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN z3950_source.record_format IS '
Z39.50 element set.
';


--
-- Name: COLUMN z3950_source.transmission_format; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN z3950_source.transmission_format IS '
Z39.50 preferred record syntax..
';


--
-- Name: COLUMN z3950_source.use_perm; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN z3950_source.use_perm IS '
If set, this permission is required for the source to be listed in the staff
client Z39.50 interface.  Similar to permission.grp_tree.application_perm.
';


--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE z3950_source_credentials_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_source_credentials_id_seq OWNER TO evergreen;

--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE z3950_source_credentials_id_seq OWNED BY z3950_source_credentials.id;


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text
);


ALTER TABLE container.biblio_record_entry_bucket OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE biblio_record_entry_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE biblio_record_entry_bucket_id_seq OWNED BY biblio_record_entry_bucket.id;


--
-- Name: biblio_record_entry_bucket_item; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_biblio_record_entry bigint NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE biblio_record_entry_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE biblio_record_entry_bucket_item_id_seq OWNED BY biblio_record_entry_bucket_item.id;


--
-- Name: biblio_record_entry_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item_note OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE biblio_record_entry_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE biblio_record_entry_bucket_item_note_id_seq OWNED BY biblio_record_entry_bucket_item_note.id;


--
-- Name: biblio_record_entry_bucket_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_note OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE biblio_record_entry_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE biblio_record_entry_bucket_note_id_seq OWNED BY biblio_record_entry_bucket_note.id;


--
-- Name: biblio_record_entry_bucket_type; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE biblio_record_entry_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_type OWNER TO evergreen;

--
-- Name: call_number_bucket; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text
);


ALTER TABLE container.call_number_bucket OWNER TO evergreen;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE call_number_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE call_number_bucket_id_seq OWNED BY call_number_bucket.id;


--
-- Name: call_number_bucket_item; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_call_number integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.call_number_bucket_item OWNER TO evergreen;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE call_number_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE call_number_bucket_item_id_seq OWNED BY call_number_bucket_item.id;


--
-- Name: call_number_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_item_note OWNER TO evergreen;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE call_number_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE call_number_bucket_item_note_id_seq OWNED BY call_number_bucket_item_note.id;


--
-- Name: call_number_bucket_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_note OWNER TO evergreen;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE call_number_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE call_number_bucket_note_id_seq OWNED BY call_number_bucket_note.id;


--
-- Name: call_number_bucket_type; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.call_number_bucket_type OWNER TO evergreen;

--
-- Name: copy_bucket; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text
);


ALTER TABLE container.copy_bucket OWNER TO evergreen;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE copy_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE copy_bucket_id_seq OWNED BY copy_bucket.id;


--
-- Name: copy_bucket_item; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_copy integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.copy_bucket_item OWNER TO evergreen;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE copy_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE copy_bucket_item_id_seq OWNED BY copy_bucket_item.id;


--
-- Name: copy_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_item_note OWNER TO evergreen;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE copy_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE copy_bucket_item_note_id_seq OWNED BY copy_bucket_item_note.id;


--
-- Name: copy_bucket_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_note OWNER TO evergreen;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE copy_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE copy_bucket_note_id_seq OWNED BY copy_bucket_note.id;


--
-- Name: copy_bucket_type; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.copy_bucket_type OWNER TO evergreen;

--
-- Name: user_bucket; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text
);


ALTER TABLE container.user_bucket OWNER TO evergreen;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE user_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE user_bucket_id_seq OWNED BY user_bucket.id;


--
-- Name: user_bucket_item; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_user integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.user_bucket_item OWNER TO evergreen;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE user_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE user_bucket_item_id_seq OWNED BY user_bucket_item.id;


--
-- Name: user_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_item_note OWNER TO evergreen;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE user_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE user_bucket_item_note_id_seq OWNED BY user_bucket_item_note.id;


--
-- Name: user_bucket_note; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_note OWNER TO evergreen;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE user_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE user_bucket_note_id_seq OWNED BY user_bucket_note.id;


--
-- Name: user_bucket_type; Type: TABLE; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.user_bucket_type OWNER TO evergreen;

SET search_path = envisionware, pg_catalog;

--
-- Name: users_made_no_access; Type: TABLE; Schema: envisionware; Owner: evergreen; Tablespace: 
--

CREATE TABLE users_made_no_access (
    id integer,
    original_net_access_level integer,
    date_changed timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE envisionware.users_made_no_access OWNER TO evergreen;

SET search_path = esi, pg_catalog;

--
-- Name: action_circulation_hs22978; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation_hs22978 (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval,
    copy_location integer
);


ALTER TABLE esi.action_circulation_hs22978 OWNER TO evergreen;

--
-- Name: backroom_items; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE backroom_items (
    barcode text,
    id bigint,
    status integer
);


ALTER TABLE esi.backroom_items OWNER TO evergreen;

--
-- Name: bad_hold_transit_copy; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE bad_hold_transit_copy (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer,
    hold integer
);


ALTER TABLE esi.bad_hold_transit_copy OWNER TO evergreen;

--
-- Name: bibs_to_reingest_hs21524; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE bibs_to_reingest_hs21524 (
    id bigint
);


ALTER TABLE esi.bibs_to_reingest_hs21524 OWNER TO evergreen;

--
-- Name: bibstodelete19187; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE bibstodelete19187 (
    record bigint,
    tag character(3),
    count bigint,
    title text,
    author text,
    isbn text[],
    value text
);


ALTER TABLE esi.bibstodelete19187 OWNER TO evergreen;

--
-- Name: chartest; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE chartest (
    marc text
);


ALTER TABLE esi.chartest OWNER TO evergreen;

--
-- Name: cleanupvolumes1; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE cleanupvolumes1 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes1 OWNER TO evergreen;

--
-- Name: cleanupvolumes18552; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE cleanupvolumes18552 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes18552 OWNER TO evergreen;

--
-- Name: cleanupvolumes2; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE cleanupvolumes2 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes2 OWNER TO evergreen;

--
-- Name: deletedfunds18487; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE deletedfunds18487 (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.deletedfunds18487 OWNER TO evergreen;

--
-- Name: fundstodelete; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE fundstodelete (
    id integer
);


ALTER TABLE esi.fundstodelete OWNER TO evergreen;

--
-- Name: fundstodelete2; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE fundstodelete2 (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.fundstodelete2 OWNER TO evergreen;

--
-- Name: headings; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE headings (
    id integer
);


ALTER TABLE esi.headings OWNER TO evergreen;

--
-- Name: hold_request_hs20783; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request_hs20783 (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.hold_request_hs20783 OWNER TO evergreen;

--
-- Name: hold_request_hs20783_2nd_file; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE hold_request_hs20783_2nd_file (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.hold_request_hs20783_2nd_file OWNER TO evergreen;

--
-- Name: hs17295_edi_message; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE hs17295_edi_message (
    id integer,
    account integer,
    remote_file text,
    create_time timestamp with time zone,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text
);


ALTER TABLE esi.hs17295_edi_message OWNER TO evergreen;

--
-- Name: needsoverduephone; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE needsoverduephone (
    id integer
);


ALTER TABLE esi.needsoverduephone OWNER TO evergreen;

--
-- Name: offline_script_hs20920; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE offline_script_hs20920 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.offline_script_hs20920 OWNER TO evergreen;

--
-- Name: offline_session_hs20920; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE offline_session_hs20920 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.offline_session_hs20920 OWNER TO evergreen;

--
-- Name: old_notice_events; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE old_notice_events (
    id bigint,
    target bigint,
    event_def integer,
    add_time timestamp with time zone,
    run_time timestamp with time zone,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint
);


ALTER TABLE esi.old_notice_events OWNER TO evergreen;

--
-- Name: phasefx16756_xacts; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE phasefx16756_xacts (
    id bigint
);


ALTER TABLE esi.phasefx16756_xacts OWNER TO evergreen;

--
-- Name: saved_inactive_patron_cards; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE saved_inactive_patron_cards (
    id integer,
    usr integer,
    barcode text,
    active boolean
);


ALTER TABLE esi.saved_inactive_patron_cards OWNER TO evergreen;

--
-- Name: statuschange17802; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE statuschange17802 (
    id bigint,
    status integer
);


ALTER TABLE esi.statuschange17802 OWNER TO evergreen;

--
-- Name: steve092711oldholdnotices; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve092711oldholdnotices (
    id bigint,
    target bigint,
    event_def integer,
    add_time timestamp with time zone,
    run_time timestamp with time zone,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint
);


ALTER TABLE esi.steve092711oldholdnotices OWNER TO evergreen;

--
-- Name: steve17090funddebit; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve17090funddebit (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.steve17090funddebit OWNER TO evergreen;

--
-- Name: steve17090lineitems; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve17090lineitems (
    id bigint,
    creator integer,
    editor integer,
    selector integer,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone,
    edit_time timestamp with time zone,
    marc text,
    eg_bib_id bigint,
    source_label text,
    state text,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer
);


ALTER TABLE esi.steve17090lineitems OWNER TO evergreen;

--
-- Name: steve17090lineitemsdetails; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve17090lineitemsdetails (
    id bigint,
    lineitem integer,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer
);


ALTER TABLE esi.steve17090lineitemsdetails OWNER TO evergreen;

--
-- Name: steve2371665holds; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve2371665holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.steve2371665holds OWNER TO evergreen;

--
-- Name: steve2759532holds; Type: TABLE; Schema: esi; Owner: postgres; Tablespace: 
--

CREATE TABLE steve2759532holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.steve2759532holds OWNER TO postgres;

--
-- Name: steve_reshelving_fix18027; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve_reshelving_fix18027 (
    id bigint
);


ALTER TABLE esi.steve_reshelving_fix18027 OWNER TO evergreen;

--
-- Name: steve_reshelving_fix180271; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steve_reshelving_fix180271 (
    id bigint
);


ALTER TABLE esi.steve_reshelving_fix180271 OWNER TO evergreen;

--
-- Name: steveacqedimessagebackup18700; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveacqedimessagebackup18700 (
    id integer,
    account integer,
    remote_file text,
    create_time timestamp with time zone,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text
);


ALTER TABLE esi.steveacqedimessagebackup18700 OWNER TO evergreen;

--
-- Name: steveaction_collector; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_collector (
    module text,
    description text
);


ALTER TABLE esi.steveaction_collector OWNER TO evergreen;

--
-- Name: steveaction_def; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_def (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE esi.steveaction_def OWNER TO evergreen;

--
-- Name: steveaction_environment; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_environment (
    id integer,
    event_def integer,
    path text,
    collector text,
    label text
);


ALTER TABLE esi.steveaction_environment OWNER TO evergreen;

--
-- Name: steveaction_hook; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_hook (
    key text,
    core_type text,
    description text,
    passive boolean
);


ALTER TABLE esi.steveaction_hook OWNER TO evergreen;

--
-- Name: steveaction_params; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_params (
    id bigint,
    event_def integer,
    param text,
    value text
);


ALTER TABLE esi.steveaction_params OWNER TO evergreen;

--
-- Name: steveaction_reactor; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_reactor (
    module text,
    description text
);


ALTER TABLE esi.steveaction_reactor OWNER TO evergreen;

--
-- Name: steveaction_validator; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveaction_validator (
    module text,
    description text
);


ALTER TABLE esi.steveaction_validator OWNER TO evergreen;

--
-- Name: stevebackupdef23; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevebackupdef23 (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE esi.stevebackupdef23 OWNER TO evergreen;

--
-- Name: stevecheckingvolumes; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevecheckingvolumes (
    volume_id bigint
);


ALTER TABLE esi.stevecheckingvolumes OWNER TO evergreen;

--
-- Name: stevecheckmissing; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevecheckmissing (
    id bigint,
    max timestamp with time zone,
    deleted boolean
);


ALTER TABLE esi.stevecheckmissing OWNER TO evergreen;

--
-- Name: stevecheckreshelv; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevecheckreshelv (
    id bigint,
    "Max Checkin Time" timestamp with time zone,
    "Max Dest Time" timestamp with time zone
);


ALTER TABLE esi.stevecheckreshelv OWNER TO evergreen;

--
-- Name: stevecopydelete; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevecopydelete (
    id bigint
);


ALTER TABLE esi.stevecopydelete OWNER TO evergreen;

--
-- Name: steveholdprintingorig; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveholdprintingorig (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorig OWNER TO evergreen;

--
-- Name: steveholdprintingorigtakeone; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveholdprintingorigtakeone (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtakeone OWNER TO evergreen;

--
-- Name: steveholdprintingorigtakethree; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveholdprintingorigtakethree (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtakethree OWNER TO evergreen;

--
-- Name: steveholdprintingorigtaketwo; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveholdprintingorigtaketwo (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtaketwo OWNER TO evergreen;

--
-- Name: steveholdprintingorigtesting; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveholdprintingorigtesting (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtesting OWNER TO evergreen;

--
-- Name: stevelongmissingitemsdelete; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevelongmissingitemsdelete (
    id bigint
);


ALTER TABLE esi.stevelongmissingitemsdelete OWNER TO evergreen;

--
-- Name: steveofflinescript18148; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinescript18148 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148 OWNER TO evergreen;

--
-- Name: steveofflinescript18148_2; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinescript18148_2 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148_2 OWNER TO evergreen;

--
-- Name: steveofflinescript18148_3; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinescript18148_3 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148_3 OWNER TO evergreen;

--
-- Name: steveofflinescript21783; Type: TABLE; Schema: esi; Owner: postgres; Tablespace: 
--

CREATE TABLE steveofflinescript21783 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript21783 OWNER TO postgres;

--
-- Name: steveofflinesession18148; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinesession18148 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148 OWNER TO evergreen;

--
-- Name: steveofflinesession18148_2; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinesession18148_2 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148_2 OWNER TO evergreen;

--
-- Name: steveofflinesession18148_3; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveofflinesession18148_3 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148_3 OWNER TO evergreen;

--
-- Name: steveofflinesession21783; Type: TABLE; Schema: esi; Owner: postgres; Tablespace: 
--

CREATE TABLE steveofflinesession21783 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession21783 OWNER TO postgres;

--
-- Name: steveoverdueprintorig; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveoverdueprintorig (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveoverdueprintorig OWNER TO evergreen;

--
-- Name: steveoverdueprintorigtesting; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveoverdueprintorigtesting (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveoverdueprintorigtesting OWNER TO evergreen;

--
-- Name: stevepenalties14512; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevepenalties14512 (
    id integer,
    org_unit integer,
    usr integer,
    standing_penalty integer,
    staff integer,
    set_date timestamp with time zone,
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE esi.stevepenalties14512 OWNER TO evergreen;

--
-- Name: stevestandingorg14512; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevestandingorg14512 (
    id integer,
    org_unit integer,
    usr integer,
    standing_penalty integer,
    staff integer,
    set_date timestamp with time zone,
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE esi.stevestandingorg14512 OWNER TO evergreen;

--
-- Name: stevestopfines17480; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevestopfines17480 (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval
);


ALTER TABLE esi.stevestopfines17480 OWNER TO evergreen;

--
-- Name: stevesupetransitcleanup; Type: TABLE; Schema: esi; Owner: postgres; Tablespace: 
--

CREATE TABLE stevesupetransitcleanup (
    target_copy bigint
);


ALTER TABLE esi.stevesupetransitcleanup OWNER TO postgres;

--
-- Name: stevetestadd; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevetestadd (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.stevetestadd OWNER TO evergreen;

--
-- Name: stevetestsettings; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevetestsettings (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.stevetestsettings OWNER TO evergreen;

--
-- Name: stevetransitupdate; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevetransitupdate (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer
);


ALTER TABLE esi.stevetransitupdate OWNER TO evergreen;

--
-- Name: stevetransitupdate2; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE stevetransitupdate2 (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer
);


ALTER TABLE esi.stevetransitupdate2 OWNER TO evergreen;

--
-- Name: steveusrsettingbackup; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE steveusrsettingbackup (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveusrsettingbackup OWNER TO evergreen;

--
-- Name: templatestoconvert; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE templatestoconvert (
    id integer,
    owner integer,
    create_time timestamp with time zone,
    name text,
    description text,
    data text,
    folder integer
);


ALTER TABLE esi.templatestoconvert OWNER TO evergreen;

--
-- Name: to_keep; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE to_keep (
    barcode text
);


ALTER TABLE esi.to_keep OWNER TO evergreen;

--
-- Name: toclose; Type: TABLE; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE TABLE toclose (
    id bigint
);


ALTER TABLE esi.toclose OWNER TO evergreen;

--
-- Name: transitclear; Type: TABLE; Schema: esi; Owner: postgres; Tablespace: 
--

CREATE TABLE transitclear (
    first integer,
    target_copy bigint
);


ALTER TABLE esi.transitclear OWNER TO postgres;

SET search_path = esi16538, pg_catalog;

--
-- Name: actor_card; Type: TABLE; Schema: esi16538; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer,
    usr integer,
    barcode text,
    active boolean
);


ALTER TABLE esi16538.actor_card OWNER TO evergreen;

SET search_path = esi_14812, pg_catalog;

--
-- Name: fw_items; Type: TABLE; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE TABLE fw_items (
    item_id bigint,
    circ_lib integer,
    barcode text,
    orig_status integer,
    orig_status_date timestamp without time zone,
    done boolean DEFAULT false,
    to_fix boolean DEFAULT false
);


ALTER TABLE esi_14812.fw_items OWNER TO evergreen;

--
-- Name: nw_items_changed; Type: TABLE; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE TABLE nw_items_changed (
    id bigint,
    status integer
);


ALTER TABLE esi_14812.nw_items_changed OWNER TO evergreen;

--
-- Name: rn_dvds; Type: TABLE; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE TABLE rn_dvds (
    id bigint,
    holdable boolean,
    opac_visible boolean
);


ALTER TABLE esi_14812.rn_dvds OWNER TO evergreen;

--
-- Name: rn_missing_items; Type: TABLE; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE TABLE rn_missing_items (
    item_id bigint,
    circ_lib integer,
    barcode text,
    orig_status integer,
    orig_status_date timestamp without time zone,
    done boolean DEFAULT false,
    to_fix boolean DEFAULT false
);


ALTER TABLE esi_14812.rn_missing_items OWNER TO evergreen;

SET search_path = evergreen, pg_catalog;

--
-- Name: marc; Type: TABLE; Schema: evergreen; Owner: evergreen; Tablespace: 
--

CREATE TABLE marc (
    marc text
);


ALTER TABLE evergreen.marc OWNER TO evergreen;

--
-- Name: unused_indexes; Type: VIEW; Schema: evergreen; Owner: postgres
--

CREATE VIEW unused_indexes AS
    SELECT (((pg_stat_user_indexes.schemaname)::text || '.'::text) || (pg_stat_user_indexes.indexrelname)::text) AS fqindexname, pg_size_pretty(pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass)) AS total_size, pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass) AS raw_size FROM (pg_stat_user_indexes JOIN pg_index USING (indexrelid)) WHERE (((((((((pg_stat_user_indexes.idx_scan = 0) AND (pg_stat_user_indexes.idx_tup_read = 0)) AND (pg_stat_user_indexes.idx_tup_fetch = 0)) AND (NOT pg_index.indisprimary)) AND (NOT pg_index.indisunique)) AND (NOT pg_index.indisexclusion)) AND pg_index.indisvalid) AND pg_index.indisready) AND (pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass) > 8192)) ORDER BY pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass) DESC;


ALTER TABLE evergreen.unused_indexes OWNER TO postgres;

SET search_path = extend_reporter, pg_catalog;

--
-- Name: archived_hold_notification; Type: TABLE; Schema: extend_reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_notification (
    id integer,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone,
    method text,
    note text
);


ALTER TABLE extend_reporter.archived_hold_notification OWNER TO evergreen;

--
-- Name: archived_hold_request; Type: TABLE; Schema: extend_reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_request (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE extend_reporter.archived_hold_request OWNER TO evergreen;

--
-- Name: archived_hold_transit_copy; Type: TABLE; Schema: extend_reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE archived_hold_transit_copy (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer,
    hold integer
);


ALTER TABLE extend_reporter.archived_hold_transit_copy OWNER TO evergreen;

--
-- Name: cdr; Type: VIEW; Schema: extend_reporter; Owner: postgres
--

CREATE VIEW cdr AS
    SELECT t.calldate, t.clid, t.src, t.dst, t.dcontext, t.channel, t.dstchannel, t.lastapp, t.lastdata, t.duration, t.billsec, t.disposition, t.amaflags, t.accountcode, t.uniqueid, t.userfield FROM evergreen.dblink('dbname=asterisk user=asterisk password=w@ts0n1n33du'::text, 'select * from cdr'::text) t(calldate timestamp with time zone, clid character varying(80), src character varying(80), dst character varying(80), dcontext character varying(80), channel character varying(80), dstchannel character varying(80), lastapp character varying(80), lastdata character varying(80), duration bigint, billsec bigint, disposition character varying(45), amaflags bigint, accountcode text, uniqueid character varying(32), userfield character varying(255));


ALTER TABLE extend_reporter.cdr OWNER TO postgres;

--
-- Name: legacy_circ_count; Type: TABLE; Schema: extend_reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE legacy_circ_count (
    id bigint NOT NULL,
    circ_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE extend_reporter.legacy_circ_count OWNER TO evergreen;

--
-- Name: full_circ_count; Type: VIEW; Schema: extend_reporter; Owner: evergreen
--

CREATE VIEW full_circ_count AS
    SELECT cp.id, ((COALESCE(sum(c.circ_count), (0)::bigint) + COALESCE(count(circ.id), (0)::bigint)) + COALESCE(count(acirc.id), (0)::bigint)) AS circ_count FROM (((asset.copy cp LEFT JOIN legacy_circ_count c USING (id)) LEFT JOIN action.circulation circ ON ((circ.target_copy = cp.id))) LEFT JOIN action.aged_circulation acirc ON ((acirc.target_copy = cp.id))) GROUP BY cp.id;


ALTER TABLE extend_reporter.full_circ_count OWNER TO evergreen;

--
-- Name: global_bibs_by_holding_update; Type: VIEW; Schema: extend_reporter; Owner: evergreen
--

CREATE VIEW global_bibs_by_holding_update AS
    SELECT DISTINCT ON (x.id) x.id, x.holding_update, x.update_type FROM (SELECT b.id, public.last(cp.create_date) AS holding_update, 'add'::text AS update_type FROM ((biblio.record_entry b JOIN asset.call_number cn ON ((cn.record = b.id))) JOIN asset.copy cp ON ((cp.call_number = cn.id))) WHERE ((NOT cp.deleted) AND (b.id > 0)) GROUP BY b.id UNION SELECT b.id, public.last(cp.edit_date) AS holding_update, 'delete'::text AS update_type FROM ((biblio.record_entry b JOIN asset.call_number cn ON ((cn.record = b.id))) JOIN asset.copy cp ON ((cp.call_number = cn.id))) WHERE (cp.deleted AND (b.id > 0)) GROUP BY b.id) x ORDER BY x.id, x.holding_update;


ALTER TABLE extend_reporter.global_bibs_by_holding_update OWNER TO evergreen;

SET search_path = m_enum, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval
);


ALTER TABLE m_enum.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_enum.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT false NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_enum.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_enum.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_enum.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_enum.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_map (
    id integer NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    org_id integer,
    l_library text,
    name text,
    legacy_field1 text,
    legacy_value1 text,
    entry text
);


ALTER TABLE m_enum.actor_stat_cat_entry_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE actor_stat_cat_entry_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.actor_stat_cat_entry_map_id_seq OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE actor_stat_cat_entry_map_id_seq OWNED BY actor_stat_cat_entry_map.id;


--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_enum.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_map (
    id integer NOT NULL,
    stat_cat integer,
    org_id integer,
    l_library text,
    name text
);


ALTER TABLE m_enum.actor_stat_cat_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE actor_stat_cat_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.actor_stat_cat_map_id_seq OWNER TO evergreen;

--
-- Name: actor_stat_cat_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE actor_stat_cat_map_id_seq OWNED BY actor_stat_cat_map.id;


--
-- Name: actor_usr; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_enum.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_enum.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_legacy; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_legacy (
    l_borrower_borrower text,
    l_borrower_location text,
    l_borrower_btype text,
    l_borrower_second_id text,
    l_borrower_name text,
    l_borrower_name_reconstructed text,
    l_borrower_birth_date text,
    l_borrower_backlink text,
    l_borrower_last_cko_date text,
    l_borrower_n_ckos text,
    l_borrower_registration_date text,
    l_borrower_expiration_date text,
    l_borrower_creation_date text,
    l_borrower_last_update_date text,
    l_borrower_borrower_note text,
    l_borrower_source text,
    l_borrower_language text,
    l_borrower_pin text,
    l_borrower_last_authentication_date text,
    l_borrower_self_registered text,
    l_borrower_approved_status text,
    l_borrower_homeroom text,
    l_borrower_grade text,
    l_borrower_teacher text,
    l_borrower_parent_guardian text,
    l_borrower_note1 text,
    l_borrower_note2 text,
    l_borrower_note3 text,
    l_borrower_dynix_pkey text,
    l_borrower_id text,
    l_borrower_internet_permission text,
    l_borrower_approved_borrowers text,
    l_borrower_keep_circ_history text,
    l_borrower_last_alert_date text,
    l_borrower_borr_ldap_dn text,
    l_borrower_use_guardian text,
    l_borrower_address_1__ord text,
    l_borrower_address_1__address_type text,
    l_borrower_address_1__mail_sort_type text,
    l_borrower_address_1__send_notice_by text,
    l_borrower_address_1__valid_from_date text,
    l_borrower_address_1__valid_to_date text,
    l_borrower_address_1__address1 text,
    l_borrower_address_1__address2 text,
    l_borrower_address_1__address3 text,
    l_borrower_address_1__address4 text,
    l_borrower_address_1__postal_code text,
    l_borrower_address_1__city_st text,
    l_borrower_address_1__email_name text,
    l_borrower_address_1__email_address text,
    l_borrower_address_1__send_preoverdue text,
    l_borrower_address_2__ord text,
    l_borrower_address_2__address_type text,
    l_borrower_address_2__mail_sort_type text,
    l_borrower_address_2__send_notice_by text,
    l_borrower_address_2__valid_from_date text,
    l_borrower_address_2__valid_to_date text,
    l_borrower_address_2__address1 text,
    l_borrower_address_2__address2 text,
    l_borrower_address_2__address3 text,
    l_borrower_address_2__address4 text,
    l_borrower_address_2__postal_code text,
    l_borrower_address_2__city_st text,
    l_borrower_address_2__email_name text,
    l_borrower_address_2__email_address text,
    l_borrower_address_2__send_preoverdue text,
    l_borrower_address_3__ord text,
    l_borrower_address_3__address_type text,
    l_borrower_address_3__mail_sort_type text,
    l_borrower_address_3__send_notice_by text,
    l_borrower_address_3__valid_from_date text,
    l_borrower_address_3__valid_to_date text,
    l_borrower_address_3__address1 text,
    l_borrower_address_3__address2 text,
    l_borrower_address_3__address3 text,
    l_borrower_address_3__address4 text,
    l_borrower_address_3__postal_code text,
    l_borrower_address_3__city_st text,
    l_borrower_address_3__email_name text,
    l_borrower_address_3__email_address text,
    l_borrower_address_3__send_preoverdue text,
    l_borrower_phone_1__ord text,
    l_borrower_phone_1__phone_no text,
    l_borrower_phone_1__phone_type text,
    l_borrower_phone_2__ord text,
    l_borrower_phone_2__phone_no text,
    l_borrower_phone_2__phone_type text,
    l_borrower_phone_3__ord text,
    l_borrower_phone_3__phone_no text,
    l_borrower_phone_3__phone_type text,
    l_borrower_bstat_1__bstat text,
    l_borrower_bstat_2__bstat text,
    l_borrower_bstat_3__bstat text,
    l_borrower_barcode_1__ord text,
    l_borrower_barcode_1__bbarcode text,
    l_borrower_barcode_1__barcode_type text,
    l_borrower_barcode_1__lost_date text,
    l_borrower_barcode_1__proxy_borrower text,
    l_borrower_barcode_1__proxy_expiration_date text,
    l_borrower_barcode_2__ord text,
    l_borrower_barcode_2__bbarcode text,
    l_borrower_barcode_2__barcode_type text,
    l_borrower_barcode_2__lost_date text,
    l_borrower_barcode_2__proxy_borrower text,
    l_borrower_barcode_2__proxy_expiration_date text,
    l_borrower_barcode_3__ord text,
    l_borrower_barcode_3__bbarcode text,
    l_borrower_barcode_3__barcode_type text,
    l_borrower_barcode_3__lost_date text,
    l_borrower_barcode_3__proxy_borrower text,
    l_borrower_barcode_3__proxy_expiration_date text,
    l_borrower_barcode_4__ord text,
    l_borrower_barcode_4__bbarcode text,
    l_borrower_barcode_4__barcode_type text,
    l_borrower_barcode_4__lost_date text,
    l_borrower_barcode_4__proxy_borrower text,
    l_borrower_barcode_4__proxy_expiration_date text,
    l_borrower_barcode_5__ord text,
    l_borrower_barcode_5__bbarcode text,
    l_borrower_barcode_5__barcode_type text,
    l_borrower_barcode_5__lost_date text,
    l_borrower_barcode_5__proxy_borrower text,
    l_borrower_barcode_5__proxy_expiration_date text,
    l_borrower_barcode_6__ord text,
    l_borrower_barcode_6__bbarcode text,
    l_borrower_barcode_6__barcode_type text,
    l_borrower_barcode_6__lost_date text,
    l_borrower_barcode_6__proxy_borrower text,
    l_borrower_barcode_6__proxy_expiration_date text,
    l_borrower_barcode_7__ord text,
    l_borrower_barcode_7__bbarcode text,
    l_borrower_barcode_7__barcode_type text,
    l_borrower_barcode_7__lost_date text,
    l_borrower_barcode_7__proxy_borrower text,
    l_borrower_barcode_7__proxy_expiration_date text,
    l_borrowerextradata_symphonykey text,
    l_borrowerextradata_symphonyalt_id text,
    l_borrowerextradata_library text,
    l_borrowerextradata_user_profile text,
    l_borrowerextradata_default_pin text,
    l_borrowerextradata_default_name text
)
INHERITS (actor_usr);


ALTER TABLE m_enum.actor_usr_legacy OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_enum.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint,
    label_sortkey text,
    prefix integer DEFAULT (-1) NOT NULL,
    suffix integer DEFAULT (-1) NOT NULL
);


ALTER TABLE m_enum.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_enum.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
)
INHERITS (asset_copy);


ALTER TABLE m_enum.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_enum.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_enum.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_enum.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_enum.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_enum.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_enum.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: bib_hbib_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_hbib_map (
    record bigint,
    value text
);


ALTER TABLE m_enum.bib_hbib_map OWNER TO evergreen;

--
-- Name: bib_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_map (
    item_eg_id bigint,
    egid bigint
);


ALTER TABLE m_enum.bib_map OWNER TO evergreen;

--
-- Name: card_collisions; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE card_collisions (
    id integer NOT NULL,
    reason text,
    usr integer,
    barcode text
);


ALTER TABLE m_enum.card_collisions OWNER TO evergreen;

--
-- Name: card_collisions_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE card_collisions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.card_collisions_id_seq OWNER TO evergreen;

--
-- Name: card_collisions_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE card_collisions_id_seq OWNED BY card_collisions.id;


--
-- Name: circ; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ (
    l_item_barcode text,
    l_patron_num text,
    l_barcode text,
    l_checkout timestamp without time zone,
    l_loc text,
    l_due timestamp without time zone,
    l_renewals text
)
INHERITS (action_circulation);


ALTER TABLE m_enum.circ OWNER TO evergreen;

--
-- Name: circ_mod_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_mod_map (
    l_collection text,
    l_circ_mod text
);


ALTER TABLE m_enum.circ_mod_map OWNER TO evergreen;

--
-- Name: circs_missing_data; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE circs_missing_data (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval,
    l_item_barcode text,
    l_patron_num text,
    l_barcode text,
    l_checkout timestamp without time zone,
    l_loc text,
    l_due timestamp without time zone,
    l_renewals text
);


ALTER TABLE m_enum.circs_missing_data OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_enum.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_enum.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: holds; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE holds (
    l_bib_num text,
    l_item_num text,
    l_bnum text,
    l_bbarc text,
    l_request_date text,
    l_expire_date text,
    l_on_shelf text,
    l_shelf_expire text,
    l_reactive text,
    l_status text,
    l_notes text
)
INHERITS (action_hold_request);


ALTER TABLE m_enum.holds OWNER TO evergreen;

--
-- Name: holds_missing_stuff; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE holds_missing_stuff (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_bib_num text,
    l_item_num text,
    l_bnum text,
    l_bbarc text,
    l_request_date text,
    l_expire_date text,
    l_on_shelf text,
    l_shelf_expire text,
    l_reactive text,
    l_status text,
    l_notes text
);


ALTER TABLE m_enum.holds_missing_stuff OWNER TO evergreen;

--
-- Name: home_location_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE home_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.home_location_map OWNER TO evergreen;

--
-- Name: home_location_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE home_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.home_location_map_id_seq OWNER TO evergreen;

--
-- Name: home_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE home_location_map_id_seq OWNED BY home_location_map.id;


--
-- Name: item_dynamic_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.item_dynamic_field_map OWNER TO evergreen;

--
-- Name: item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE item_dynamic_field_map_id_seq OWNED BY item_dynamic_field_map.id;


--
-- Name: item_key_barcode_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_key_barcode_map (
    key1 text,
    key2 text,
    key3 text,
    barcode text
);


ALTER TABLE m_enum.item_key_barcode_map OWNER TO evergreen;

--
-- Name: items_missing_barcodes; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE items_missing_barcodes (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
);


ALTER TABLE m_enum.items_missing_barcodes OWNER TO evergreen;

--
-- Name: items_not_migrating; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE items_not_migrating (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
);


ALTER TABLE m_enum.items_not_migrating OWNER TO evergreen;

--
-- Name: loc_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE loc_map (
    l_collection text,
    l_loc text
);


ALTER TABLE m_enum.loc_map OWNER TO evergreen;

SET search_path = money, pg_catalog;

--
-- Name: billing; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE billing (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2) NOT NULL,
    billing_type text NOT NULL,
    btype integer NOT NULL,
    note text
);


ALTER TABLE money.billing OWNER TO evergreen;

--
-- Name: billing_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE billing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billing_id_seq OWNER TO evergreen;

--
-- Name: billing_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE billing_id_seq OWNED BY billing.id;


SET search_path = m_enum, pg_catalog;

--
-- Name: money_billing; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_enum.money_billing OWNER TO evergreen;

SET search_path = money, pg_catalog;

--
-- Name: payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE payment (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2) NOT NULL,
    note text
);


ALTER TABLE money.payment OWNER TO evergreen;

--
-- Name: payment_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.payment_id_seq OWNER TO evergreen;

--
-- Name: payment_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE payment_id_seq OWNED BY payment.id;


SET search_path = m_enum, pg_catalog;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_enum.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_enum.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_enum.money_grocery OWNER TO evergreen;

--
-- Name: new_merge; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE new_merge (
    hbib_id bigint,
    source_egid bigint,
    target_egid bigint
);


ALTER TABLE m_enum.new_merge OWNER TO evergreen;

--
-- Name: org_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_map (
    id integer NOT NULL,
    org_id integer,
    transcribed_shortname text,
    l_library text NOT NULL,
    patron_rebarcode_offset bigint DEFAULT 0 NOT NULL,
    item_rebarcode_offset bigint DEFAULT 0 NOT NULL,
    default_circ_staff integer DEFAULT 1 NOT NULL
);


ALTER TABLE m_enum.org_map OWNER TO evergreen;

--
-- Name: org_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE org_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.org_map_id_seq OWNER TO evergreen;

--
-- Name: org_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE org_map_id_seq OWNED BY org_map.id;


--
-- Name: orig_egid_copy_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE orig_egid_copy_map (
    id bigint,
    egid integer
);


ALTER TABLE m_enum.orig_egid_copy_map OWNER TO evergreen;

--
-- Name: profile_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.profile_map OWNER TO evergreen;

--
-- Name: profile_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.profile_map_id_seq OWNER TO evergreen;

--
-- Name: profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE profile_map_id_seq OWNED BY profile_map.id;


--
-- Name: sql_current; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_enum.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_enum.sql_log OWNER TO evergreen;

--
-- Name: user_key_barcode_map; Type: TABLE; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_key_barcode_map (
    key text,
    barcode text
);


ALTER TABLE m_enum.user_key_barcode_map OWNER TO evergreen;

SET search_path = m_kcls, pg_catalog;

--
-- Name: acq_provider_address_bkp; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_address_bkp (
    id integer,
    valid boolean,
    address_type text,
    provider integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    fax_phone text
);


ALTER TABLE m_kcls.acq_provider_address_bkp OWNER TO evergreen;

--
-- Name: acq_provider_address_new; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_address_new (
    id integer,
    valid boolean,
    address_type text,
    provider integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    fax_phone text
);


ALTER TABLE m_kcls.acq_provider_address_new OWNER TO evergreen;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls.action_circulation OWNER TO evergreen;

--
-- Name: action_circulation_legacy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation_legacy (
    l_item_id text,
    l_patron_id text,
    l_checkout_date text,
    l_due_date text,
    l_status text,
    l_loan_rule text,
    l_out_loc text,
    x_date text
)
INHERITS (action_circulation);


ALTER TABLE m_kcls.action_circulation_legacy OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls.actor_card OWNER TO evergreen;

--
-- Name: actor_dupe_barcodes; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_dupe_barcodes (
    usrname text,
    to_fix integer
);


ALTER TABLE m_kcls.actor_dupe_barcodes OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_legacy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_legacy (
    l_patron_id text,
    l_last_circ text,
    l_exp_date text,
    l_pcode1 text,
    l_pcode2 text,
    l_pcode3 text,
    l_ptype text,
    l_homelib text,
    l_mblock text,
    l_pmessage text,
    l_pcode4 text,
    l_birth_date text,
    l_tot_loans text,
    l_tot_renew text,
    l_claim_ret text,
    l_barcode text,
    l_name text,
    l_phone1 text,
    l_phone2 text,
    l_email text,
    x_dob text
)
INHERITS (actor_usr);


ALTER TABLE m_kcls.actor_usr_legacy OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls.actor_usr_note OWNER TO evergreen;

--
-- Name: actor_usr_setting; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_setting (
    id bigint DEFAULT nextval('actor.usr_setting_id_seq'::regclass) NOT NULL,
    usr integer,
    name text,
    value text
);


ALTER TABLE m_kcls.actor_usr_setting OWNER TO evergreen;

--
-- Name: actor_usr_standing_penalty; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_standing_penalty (
    id integer DEFAULT nextval('actor.usr_standing_penalty_id_seq'::regclass) NOT NULL,
    org_unit integer,
    usr integer,
    standing_penalty integer,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE m_kcls.actor_usr_standing_penalty OWNER TO evergreen;

--
-- Name: alert_messages; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE alert_messages (
    l_iii_bib_id text,
    l_item_seq integer,
    array_to_string text
);


ALTER TABLE m_kcls.alert_messages OWNER TO evergreen;

--
-- Name: appropriations; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE appropriations (
    l_fund_code text,
    l_amount text
);


ALTER TABLE m_kcls.appropriations OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
)
INHERITS (asset_copy);


ALTER TABLE m_kcls.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: auths_to_del; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE auths_to_del (
    record bigint
);


ALTER TABLE m_kcls.auths_to_del OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: best_avail_copies; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE best_avail_copies (
    hold_id integer,
    request_time timestamp with time zone,
    bib_id bigint,
    copy_id bigint,
    circ_lib integer
);


ALTER TABLE m_kcls.best_avail_copies OWNER TO evergreen;

--
-- Name: bibs_to_fix; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE bibs_to_fix (
    seq integer NOT NULL,
    done boolean DEFAULT false,
    id bigint
);


ALTER TABLE m_kcls.bibs_to_fix OWNER TO evergreen;

--
-- Name: bibs_to_fix_seq_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE bibs_to_fix_seq_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.bibs_to_fix_seq_seq OWNER TO evergreen;

--
-- Name: bibs_to_fix_seq_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE bibs_to_fix_seq_seq OWNED BY bibs_to_fix.seq;


--
-- Name: bibs_with_938; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE bibs_with_938 (
    record bigint,
    id integer NOT NULL,
    done boolean DEFAULT false
);


ALTER TABLE m_kcls.bibs_with_938 OWNER TO evergreen;

--
-- Name: bibs_with_938_id_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE bibs_with_938_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.bibs_with_938_id_seq OWNER TO evergreen;

--
-- Name: bibs_with_938_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE bibs_with_938_id_seq OWNED BY bibs_with_938.id;


--
-- Name: bibs_with_crossed_d; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE bibs_with_crossed_d (
    id bigint
);


ALTER TABLE m_kcls.bibs_with_crossed_d OWNER TO evergreen;

--
-- Name: container_biblio_record_entry_bucket; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE container_biblio_record_entry_bucket (
    id integer DEFAULT nextval('container.biblio_record_entry_bucket_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE m_kcls.container_biblio_record_entry_bucket OWNER TO evergreen;

--
-- Name: bookbag; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE bookbag (
    l_listnum integer,
    l_patron_id integer,
    l_list_name text,
    l_list_desc text,
    l_list_date timestamp without time zone,
    x_patron_id text
)
INHERITS (container_biblio_record_entry_bucket);


ALTER TABLE m_kcls.bookbag OWNER TO evergreen;

--
-- Name: container_biblio_record_entry_bucket_item; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE container_biblio_record_entry_bucket_item (
    id integer DEFAULT nextval('container.biblio_record_entry_bucket_item_id_seq'::regclass) NOT NULL,
    bucket integer,
    target_biblio_record_entry integer,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE m_kcls.container_biblio_record_entry_bucket_item OWNER TO evergreen;

--
-- Name: bookbag_entry; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE bookbag_entry (
    l_bib_id text,
    l_dateadded timestamp without time zone,
    l_listnum integer
)
INHERITS (container_biblio_record_entry_bucket_item);


ALTER TABLE m_kcls.bookbag_entry OWNER TO evergreen;

--
-- Name: circ_rule_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_rule_map (
    l_loan_rule text,
    l_duration text,
    l_recurring_fine text,
    l_max_fine text
);


ALTER TABLE m_kcls.circ_rule_map OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls.config OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls.copy_dupe_barcodes OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes2; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes2 (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls.copy_dupe_barcodes2 OWNER TO evergreen;

--
-- Name: cp_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE cp_map (
    provider_id integer,
    cp_id integer
);


ALTER TABLE m_kcls.cp_map OWNER TO evergreen;

--
-- Name: dist_formulas; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE dist_formulas (
    name text,
    copies integer,
    ou text,
    ou_id integer,
    loc_id integer,
    seq integer
);


ALTER TABLE m_kcls.dist_formulas OWNER TO evergreen;

--
-- Name: dist_formulas2; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE dist_formulas2 (
    name text,
    copies integer,
    ou text,
    ou_id integer,
    seq bigint,
    dist_id integer
);


ALTER TABLE m_kcls.dist_formulas2 OWNER TO evergreen;

--
-- Name: dob_1900; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE dob_1900 (
    l_patron_id text,
    l_barcode text,
    l_dob timestamp without time zone
);


ALTER TABLE m_kcls.dob_1900 OWNER TO evergreen;

--
-- Name: eres_tcns; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE eres_tcns (
    iii_bib_id text
);


ALTER TABLE m_kcls.eres_tcns OWNER TO evergreen;

--
-- Name: event_def_restore; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_def_restore (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE m_kcls.event_def_restore OWNER TO evergreen;

--
-- Name: event_def_restore2; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE event_def_restore2 (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE m_kcls.event_def_restore2 OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: fund_all; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE fund_all (
    source_code text,
    fund_code text,
    amount text,
    source_id integer,
    find_id integer,
    amount_x numeric
);


ALTER TABLE m_kcls.fund_all OWNER TO evergreen;

--
-- Name: ids_eres; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE ids_eres (
    id bigint
);


ALTER TABLE m_kcls.ids_eres OWNER TO evergreen;

--
-- Name: ids_phys; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE ids_phys (
    id bigint
);


ALTER TABLE m_kcls.ids_phys OWNER TO evergreen;

--
-- Name: int_notes; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE int_notes (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
)
INHERITS (asset_copy_note);


ALTER TABLE m_kcls.int_notes OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
);


ALTER TABLE m_kcls.item_exceptions OWNER TO evergreen;

--
-- Name: item_status_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_status_map (
    l_status text,
    eg_status integer
);


ALTER TABLE m_kcls.item_status_map OWNER TO evergreen;

--
-- Name: jan21_pos; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE jan21_pos (
    purchase_order integer,
    state text
);


ALTER TABLE m_kcls.jan21_pos OWNER TO evergreen;

--
-- Name: km_move; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE km_move (
    id bigint,
    job integer NOT NULL,
    done boolean DEFAULT false
);


ALTER TABLE m_kcls.km_move OWNER TO evergreen;

--
-- Name: km_move_job_seq; Type: SEQUENCE; Schema: m_kcls; Owner: evergreen
--

CREATE SEQUENCE km_move_job_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls.km_move_job_seq OWNER TO evergreen;

--
-- Name: km_move_job_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls; Owner: evergreen
--

ALTER SEQUENCE km_move_job_seq OWNED BY km_move.job;


--
-- Name: legacy_circ_count; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE legacy_circ_count (
    id bigint,
    circ_count integer
);


ALTER TABLE m_kcls.legacy_circ_count OWNER TO evergreen;

--
-- Name: locations; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE locations (
    l_location text,
    l_label text
)
INHERITS (asset_copy_location);


ALTER TABLE m_kcls.locations OWNER TO evergreen;

--
-- Name: messages; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE messages (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
);


ALTER TABLE m_kcls.messages OWNER TO evergreen;

--
-- Name: metabib_field; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_field (
    id integer,
    field_class text,
    name text,
    label text,
    xpath text,
    weight integer,
    format text,
    search_field boolean,
    facet_field boolean,
    facet_xpath text
);


ALTER TABLE m_kcls.metabib_field OWNER TO evergreen;

--
-- Name: metabib_field_index_norm_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_field_index_norm_map (
    id integer,
    field integer,
    norm integer,
    params text,
    pos integer
);


ALTER TABLE m_kcls.metabib_field_index_norm_map OWNER TO evergreen;

--
-- Name: metabib_search_alias; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE metabib_search_alias (
    alias text,
    field_class text,
    field integer
);


ALTER TABLE m_kcls.metabib_search_alias OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls.money_grocery OWNER TO evergreen;

--
-- Name: money_grocery_legacy; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery_legacy (
    l_barcode text,
    l_patron_id text,
    l_amount text
)
INHERITS (money_grocery);


ALTER TABLE m_kcls.money_grocery_legacy OWNER TO evergreen;

--
-- Name: netlibrary_bib_ids; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE netlibrary_bib_ids (
    id bigint,
    done boolean DEFAULT false
);


ALTER TABLE m_kcls.netlibrary_bib_ids OWNER TO evergreen;

--
-- Name: old2new; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE old2new (
    l_iii_bib_id text,
    egid bigint
);


ALTER TABLE m_kcls.old2new OWNER TO evergreen;

--
-- Name: orig_notice_setting; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE orig_notice_setting (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE m_kcls.orig_notice_setting OWNER TO evergreen;

--
-- Name: orig_relevance; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE orig_relevance (
    id integer,
    active boolean,
    field integer,
    bump_type text,
    multiplier numeric
);


ALTER TABLE m_kcls.orig_relevance OWNER TO evergreen;

--
-- Name: ou_patrons; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE ou_patrons (
    l_patron_num text,
    l_barcode text,
    id integer
);


ALTER TABLE m_kcls.ou_patrons OWNER TO evergreen;

--
-- Name: patron_addr; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_addr (
    l_patron_id text,
    l_addr_type text,
    l_addr_seq integer,
    l_addr_line integer,
    l_value text
);


ALTER TABLE m_kcls.patron_addr OWNER TO evergreen;

--
-- Name: patron_addr_compressed; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_addr_compressed (
    l_patron_id text,
    l_addr_type text,
    l_addr_seq integer,
    array_accum text[],
    parsed text[]
);


ALTER TABLE m_kcls.patron_addr_compressed OWNER TO evergreen;

--
-- Name: patron_extras; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_extras (
    l_patron_id text,
    l_barcode text,
    l_filter text,
    l_guardian text,
    l_pickupau text,
    l_halias text,
    l_fresh text,
    l_addr_alert text,
    l_owed text
);


ALTER TABLE m_kcls.patron_extras OWNER TO evergreen;

--
-- Name: patron_note; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_note (
    l_patron_id text,
    l_title text,
    l_value text
);


ALTER TABLE m_kcls.patron_note OWNER TO evergreen;

--
-- Name: patrons_with_history; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE patrons_with_history (
    usr integer
);


ALTER TABLE m_kcls.patrons_with_history OWNER TO evergreen;

--
-- Name: pcode3_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE pcode3_map (
    code text,
    value text
);


ALTER TABLE m_kcls.pcode3_map OWNER TO evergreen;

--
-- Name: ptype_map; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE ptype_map (
    l_p_type text,
    l_grp text,
    grp_id integer
);


ALTER TABLE m_kcls.ptype_map OWNER TO evergreen;

--
-- Name: rejected_circs; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_circs (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    l_item_id text,
    l_patron_id text,
    l_checkout_date text,
    l_due_date text,
    l_status text,
    l_loan_rule text,
    l_out_loc text
);


ALTER TABLE m_kcls.rejected_circs OWNER TO evergreen;

--
-- Name: rejected_holds; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls.rejected_holds OWNER TO evergreen;

--
-- Name: relevance_adjustment; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE relevance_adjustment (
    id integer,
    active boolean,
    field integer,
    bump_type text,
    multiplier numeric
);


ALTER TABLE m_kcls.relevance_adjustment OWNER TO evergreen;

--
-- Name: sources; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE sources (
    source_code text,
    amount numeric,
    source_id integer
);


ALTER TABLE m_kcls.sources OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls.sql_log OWNER TO evergreen;

--
-- Name: summer_patrons_to_delete; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE summer_patrons_to_delete (
    id integer
);


ALTER TABLE m_kcls.summer_patrons_to_delete OWNER TO evergreen;

--
-- Name: usr_not_migrated_per_ptype; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_not_migrated_per_ptype (
    id integer,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean,
    master_account boolean,
    super_user boolean,
    barred boolean,
    deleted boolean,
    juvenile boolean,
    usrgroup integer,
    claims_returned_count integer,
    credit_forward_balance numeric(6,2),
    last_xact_id text,
    alert_message text,
    create_date timestamp with time zone,
    expire_date timestamp with time zone,
    claims_never_checked_out_count integer,
    l_patron_id text,
    l_last_circ text,
    l_exp_date text,
    l_pcode1 text,
    l_pcode2 text,
    l_pcode3 text,
    l_ptype text,
    l_homelib text,
    l_mblock text,
    l_pmessage text,
    l_pcode4 text,
    l_birth_date text,
    l_tot_loans text,
    l_tot_renew text,
    l_claim_ret text,
    l_barcode text,
    l_name text,
    l_phone1 text,
    l_phone2 text,
    l_email text,
    x_dob text
);


ALTER TABLE m_kcls.usr_not_migrated_per_ptype OWNER TO evergreen;

--
-- Name: vols_to_delete; Type: TABLE; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE TABLE vols_to_delete (
    volume_id bigint
);


ALTER TABLE m_kcls.vols_to_delete OWNER TO evergreen;

SET search_path = m_kcls2, pg_catalog;

--
-- Name: acq_fund; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_fund (
    id integer DEFAULT nextval('acq.fund_id_seq'::regclass) NOT NULL,
    org integer,
    name text,
    year integer DEFAULT date_part('year'::text, now()) NOT NULL,
    currency_type text,
    code text,
    rollover boolean DEFAULT false NOT NULL,
    propagate boolean DEFAULT true NOT NULL,
    active boolean DEFAULT true NOT NULL,
    balance_warning_percent integer,
    balance_stop_percent integer
);


ALTER TABLE m_kcls2.acq_fund OWNER TO evergreen;

--
-- Name: acq_fund_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_fund_legacy (
    l_code text,
    l_name text,
    l_path text,
    l_type text
)
INHERITS (acq_fund);


ALTER TABLE m_kcls2.acq_fund_legacy OWNER TO evergreen;

--
-- Name: acq_provider; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider (
    id integer DEFAULT nextval('acq.provider_id_seq'::regclass) NOT NULL,
    name text,
    owner integer,
    currency_type text,
    code text,
    holding_tag text,
    san text,
    edi_default integer,
    active boolean DEFAULT true NOT NULL,
    prepayment_required boolean DEFAULT false NOT NULL,
    url text,
    email text,
    phone text,
    fax_phone text,
    default_claim_policy integer
);


ALTER TABLE m_kcls2.acq_provider OWNER TO evergreen;

--
-- Name: acq_provider_address; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_address (
    id integer DEFAULT nextval('acq.provider_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    provider integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    fax_phone text
);


ALTER TABLE m_kcls2.acq_provider_address OWNER TO evergreen;

--
-- Name: acq_provider_address_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_address_legacy (
    l_lines text[]
)
INHERITS (acq_provider_address);


ALTER TABLE m_kcls2.acq_provider_address_legacy OWNER TO evergreen;

--
-- Name: acq_provider_contact; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_contact (
    id integer DEFAULT nextval('acq.provider_contact_id_seq'::regclass) NOT NULL,
    provider integer,
    name text,
    role text,
    email text,
    phone text
);


ALTER TABLE m_kcls2.acq_provider_contact OWNER TO evergreen;

--
-- Name: acq_provider_contact_address; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_contact_address (
    id integer DEFAULT nextval('acq.provider_contact_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    contact integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    fax_phone text
);


ALTER TABLE m_kcls2.acq_provider_contact_address OWNER TO evergreen;

--
-- Name: acq_provider_contact_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_contact_legacy (
    l_contact text[]
)
INHERITS (acq_provider_contact);


ALTER TABLE m_kcls2.acq_provider_contact_legacy OWNER TO evergreen;

--
-- Name: acq_provider_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_legacy (
    l_claimcycle text,
    l_vcode3 text,
    l_gir_code text,
    l_venname text,
    l_vencode text,
    l_sansuffix text,
    l_contact text,
    l_address1 text,
    l_phone_num text,
    l_fax text,
    l_note1 text,
    l_note2 text,
    l_note3 text,
    l_address2 text,
    l_email text,
    l_url text
)
INHERITS (acq_provider);


ALTER TABLE m_kcls2.acq_provider_legacy OWNER TO evergreen;

--
-- Name: acq_provider_note; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_provider_note (
    id integer DEFAULT nextval('acq.provider_note_id_seq'::regclass) NOT NULL,
    provider integer,
    creator integer,
    editor integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text
);


ALTER TABLE m_kcls2.acq_provider_note OWNER TO evergreen;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls2.action_circulation OWNER TO evergreen;

--
-- Name: action_circulation_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation_legacy (
    l_item_id text,
    l_patron_id text,
    l_checkout_date text,
    l_due_date text,
    l_status text,
    l_loan_rule text,
    l_out_loc text,
    x_date bigint
)
INHERITS (action_circulation)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.action_circulation_legacy OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls2.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls2.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
)
INHERITS (action_hold_request)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls2.actor_card OWNER TO evergreen;

--
-- Name: actor_dupe_barcodes; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_dupe_barcodes (
    usrname text,
    to_fix integer
);


ALTER TABLE m_kcls2.actor_dupe_barcodes OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls2.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls2.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls2.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls2.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls2.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_legacy (
    l_patron_id text,
    l_last_circ text,
    l_exp_date text,
    l_pcode1 text,
    l_pcode2 text,
    l_pcode3 text,
    l_ptype text,
    l_homelib text,
    l_mblock text,
    l_pmessage text,
    l_pcode4 text,
    l_birth_date text,
    l_tot_loans text,
    l_tot_renew text,
    l_claim_ret text,
    l_barcode text,
    l_name text,
    l_phone1 text,
    l_phone2 text,
    l_email text,
    x_dob text
)
INHERITS (actor_usr)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.actor_usr_legacy OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls2.actor_usr_note OWNER TO evergreen;

--
-- Name: actor_usr_setting; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_setting (
    id bigint DEFAULT nextval('actor.usr_setting_id_seq'::regclass) NOT NULL,
    usr integer,
    name text,
    value text
);


ALTER TABLE m_kcls2.actor_usr_setting OWNER TO evergreen;

--
-- Name: alert_messages; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE alert_messages (
    l_iii_bib_id text,
    l_item_seq integer,
    array_to_string text
);


ALTER TABLE m_kcls2.alert_messages OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls2.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls2.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text,
    x_location text
)
INHERITS (asset_copy)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls2.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_location_backup; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location_backup (
    id integer,
    name text,
    owning_lib integer,
    holdable boolean,
    hold_verify boolean,
    opac_visible boolean,
    circulate boolean,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls2.asset_copy_location_backup OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls2.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls2.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls2.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls2.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls2.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls2; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls2.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls2; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls2.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls2; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls2.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls2; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls2.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls2; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls2.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls2; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls2.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls2; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls2.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls2; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: container_biblio_record_entry_bucket; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE container_biblio_record_entry_bucket (
    id integer DEFAULT nextval('container.biblio_record_entry_bucket_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE m_kcls2.container_biblio_record_entry_bucket OWNER TO evergreen;

--
-- Name: bookbag; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE bookbag (
    l_listnum integer,
    l_patron_id integer,
    l_list_name text,
    l_list_desc text,
    l_list_date timestamp without time zone,
    x_patron_id text
)
INHERITS (container_biblio_record_entry_bucket)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.bookbag OWNER TO evergreen;

--
-- Name: container_biblio_record_entry_bucket_item; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE container_biblio_record_entry_bucket_item (
    id integer DEFAULT nextval('container.biblio_record_entry_bucket_item_id_seq'::regclass) NOT NULL,
    bucket integer,
    target_biblio_record_entry integer,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE m_kcls2.container_biblio_record_entry_bucket_item OWNER TO evergreen;

--
-- Name: bookbag_entry; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE bookbag_entry (
    l_bib_id text,
    l_dateadded timestamp without time zone,
    l_listnum integer
)
INHERITS (container_biblio_record_entry_bucket_item)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.bookbag_entry OWNER TO evergreen;

--
-- Name: circ_rule_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_rule_map (
    l_loan_rule text,
    l_duration text,
    l_recurring_fine text,
    l_max_fine text
);


ALTER TABLE m_kcls2.circ_rule_map OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls2.config OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls2.copy_dupe_barcodes OWNER TO evergreen;

--
-- Name: copy_name_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_name_map (
    orig_code text,
    name text,
    new_code text
);


ALTER TABLE m_kcls2.copy_name_map OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls2.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: int_notes; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE int_notes (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
)
INHERITS (asset_copy_note)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.int_notes OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
);


ALTER TABLE m_kcls2.item_exceptions OWNER TO evergreen;

--
-- Name: item_status_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_status_map (
    l_status text,
    eg_status integer
);


ALTER TABLE m_kcls2.item_status_map OWNER TO evergreen;

--
-- Name: messages; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE messages (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.messages OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls2.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls2.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls2.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls2.money_grocery OWNER TO evergreen;

--
-- Name: money_grocery_legacy; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery_legacy (
    l_barcode text,
    l_patron_id text,
    l_amount text
)
INHERITS (money_grocery);


ALTER TABLE m_kcls2.money_grocery_legacy OWNER TO evergreen;

--
-- Name: old2new; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE old2new (
    l_iii_bib_id text,
    egid bigint
);


ALTER TABLE m_kcls2.old2new OWNER TO evergreen;

--
-- Name: ou_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE ou_map (
    l_ou text,
    l_lib text,
    l_loc text,
    l_loc_name text,
    l_location text,
    ou_id integer
);


ALTER TABLE m_kcls2.ou_map OWNER TO evergreen;

--
-- Name: patron_addr; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_addr (
    l_patron_id text,
    l_addr_type text,
    l_addr_seq integer,
    l_addr_line integer,
    l_value text
);


ALTER TABLE m_kcls2.patron_addr OWNER TO evergreen;

--
-- Name: patron_addr_compressed; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_addr_compressed (
    l_patron_id text,
    l_addr_type text,
    l_addr_seq integer,
    array_accum text[],
    parsed text[]
)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.patron_addr_compressed OWNER TO evergreen;

--
-- Name: patron_extras; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_extras (
    l_patron_id text,
    l_barcode text,
    l_filter text,
    l_guardian text,
    l_pickupau text,
    l_halias text,
    l_fresh text,
    l_addr_alert text,
    l_owed text
)
WITH (autovacuum_enabled=false);


ALTER TABLE m_kcls2.patron_extras OWNER TO evergreen;

--
-- Name: patron_note; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE patron_note (
    l_patron_id text,
    l_title text,
    l_value text
);


ALTER TABLE m_kcls2.patron_note OWNER TO evergreen;

--
-- Name: ptype_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE ptype_map (
    l_p_type text,
    l_grp text,
    grp_id integer
);


ALTER TABLE m_kcls2.ptype_map OWNER TO evergreen;

--
-- Name: rejected_circs; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_circs (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    l_item_id text,
    l_patron_id text,
    l_checkout_date text,
    l_due_date text,
    l_status text,
    l_loan_rule text,
    l_out_loc text
);


ALTER TABLE m_kcls2.rejected_circs OWNER TO evergreen;

--
-- Name: rejected_holds; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls2.rejected_holds OWNER TO evergreen;

--
-- Name: rename_loc_map; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE rename_loc_map (
    l_location text,
    location integer,
    code text,
    name text,
    new_code text
);


ALTER TABLE m_kcls2.rename_loc_map OWNER TO evergreen;

--
-- Name: root; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE root (
    split_part text
);


ALTER TABLE m_kcls2.root OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls2.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls2.sql_log OWNER TO evergreen;

--
-- Name: transend; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE transend (
    l_iii_bib_id text,
    egid integer
);


ALTER TABLE m_kcls2.transend OWNER TO evergreen;

--
-- Name: usr_not_migrated_per_ptype; Type: TABLE; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_not_migrated_per_ptype (
    id integer,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean,
    master_account boolean,
    super_user boolean,
    barred boolean,
    deleted boolean,
    juvenile boolean,
    usrgroup integer,
    claims_returned_count integer,
    credit_forward_balance numeric(6,2),
    last_xact_id text,
    alert_message text,
    create_date timestamp with time zone,
    expire_date timestamp with time zone,
    claims_never_checked_out_count integer,
    l_patron_id text,
    l_last_circ text,
    l_exp_date text,
    l_pcode1 text,
    l_pcode2 text,
    l_pcode3 text,
    l_ptype text,
    l_homelib text,
    l_mblock text,
    l_pmessage text,
    l_pcode4 text,
    l_birth_date text,
    l_tot_loans text,
    l_tot_renew text,
    l_claim_ret text,
    l_barcode text,
    l_name text,
    l_phone1 text,
    l_phone2 text,
    l_email text,
    x_dob text
);


ALTER TABLE m_kcls2.usr_not_migrated_per_ptype OWNER TO evergreen;

SET search_path = m_kcls3, pg_catalog;

--
-- Name: acq_fund; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_fund (
    id integer DEFAULT nextval('acq.fund_id_seq'::regclass) NOT NULL,
    org integer,
    name text,
    year integer DEFAULT date_part('year'::text, now()) NOT NULL,
    currency_type text,
    code text,
    rollover boolean DEFAULT false NOT NULL,
    propagate boolean DEFAULT true NOT NULL,
    active boolean DEFAULT true NOT NULL,
    balance_warning_percent integer,
    balance_stop_percent integer
);


ALTER TABLE m_kcls3.acq_fund OWNER TO evergreen;

--
-- Name: acq_fund_2; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE acq_fund_2 (
    id integer,
    org integer,
    name text,
    year integer,
    currency_type text,
    code text,
    rollover boolean,
    propagate boolean,
    active boolean,
    balance_warning_percent integer,
    balance_stop_percent integer,
    l_amount numeric,
    l_source integer,
    l_tag text
);


ALTER TABLE m_kcls3.acq_fund_2 OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls3.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls3; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls3.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls3; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls3.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls3; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls3.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls3; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls3.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls3; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls3.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls3; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls3.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls3; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls3.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls3; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls3.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls3.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls3.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls3.sql_log OWNER TO evergreen;

SET search_path = m_kcls_call_fix, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_call_fix.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_call_fix.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_call_fix.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_call_fix.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_call_fix.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_call_fix.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_call_fix.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_call_fix.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_call_fix.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_call_fix.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_call_fix.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_call_fix.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_call_fix.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_call_fix.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_call_fix.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_call_fix.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_call_fix.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_call_fix.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_call_fix; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_call_fix.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_call_fix.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_call_fix; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_call_fix.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_call_fix.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_call_fix; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_call_fix.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_call_fix.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_call_fix; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_call_fix.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: cn_with_one_item; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE cn_with_one_item (
    orig_call_id bigint
);


ALTER TABLE m_kcls_call_fix.cn_with_one_item OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_call_fix.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_call_fix.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: item_calls; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_calls (
    copy_id bigint,
    orig_call_id bigint,
    owning_lib integer,
    record bigint,
    circ_lib integer,
    label text,
    only_one boolean DEFAULT false,
    new_call_id integer
);


ALTER TABLE m_kcls_call_fix.item_calls OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_call_fix.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_call_fix.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_call_fix.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_call_fix.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_call_fix.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_call_fix.sql_log OWNER TO evergreen;

SET search_path = m_kcls_circhist, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_circhist.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_circhist.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_circhist.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_circhist.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_circhist.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_circhist.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_circhist.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_circhist.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_circhist.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_circhist.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_circhist.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_circhist.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_circhist.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_circhist.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_circhist.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_circhist.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_circhist.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_circhist.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_circhist; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_circhist.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_circhist.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_circhist; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_circhist.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_circhist.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_circhist; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_circhist.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_circhist.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_circhist; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_circhist.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: circhist; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE circhist (
    l_patron_id text,
    l_bib_num text,
    l_item_num text,
    l_checkout date,
    x_date text,
    done boolean DEFAULT false
)
INHERITS (action_circulation);


ALTER TABLE m_kcls_circhist.circhist OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_circhist.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_circhist.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_circhist.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_circhist.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_circhist.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_circhist.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_circhist.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_circhist.sql_log OWNER TO evergreen;

SET search_path = m_kcls_gap, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_gap.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_gap.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_gap.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_gap.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_gap.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_gap.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_gap.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_gap.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_gap.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_gap.actor_usr_note OWNER TO evergreen;

--
-- Name: alert_messages; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE alert_messages (
    l_iii_bib_id text,
    l_item_seq integer,
    array_to_string text
);


ALTER TABLE m_kcls_gap.alert_messages OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_gap.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_gap.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_gap.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_gap.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_gap.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_gap.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_gap.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_gap.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_gap.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_gap; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_gap.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_gap; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_gap.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_gap; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_gap.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_gap; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_gap.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_gap; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_gap.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_gap; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_gap.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_gap; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_gap.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_gap; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_gap.config OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls_gap.copy_dupe_barcodes OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_gap.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: int_notes; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE int_notes (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
)
INHERITS (asset_copy_note);


ALTER TABLE m_kcls_gap.int_notes OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
);


ALTER TABLE m_kcls_gap.item_exceptions OWNER TO evergreen;

--
-- Name: messages; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE messages (
    l_iii_bib_id text,
    l_item_seq integer,
    l_note text
);


ALTER TABLE m_kcls_gap.messages OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_gap.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_gap.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_gap.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_gap.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_gap.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_gap.sql_log OWNER TO evergreen;

SET search_path = m_kcls_holds, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_holds.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_holds.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_holds.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls_holds.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_holds.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holds.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holds.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_holds.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_holds.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_holds.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holds.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_holds.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_holds.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_holds.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holds.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holds.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holds.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_holds.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_holds.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holds; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holds.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holds; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holds.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holds; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holds.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holds; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holds.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holds; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holds.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holds; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holds.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holds; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holds.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holds; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_holds.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_holds.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_holds.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_holds.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_holds.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_holds.money_grocery OWNER TO evergreen;

--
-- Name: rejected_holds; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls_holds.rejected_holds OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_holds.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_holds.sql_log OWNER TO evergreen;

SET search_path = m_kcls_holdsall, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_holdsall.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_holdsall.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_holdsall.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text,
    changed boolean
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls_holdsall.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_holdsall.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_holdsall.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_holdsall.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_holdsall.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_holdsall.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_holdsall.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_holdsall.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_holdsall.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_holdsall.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_holdsall.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_holdsall.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_holdsall.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_holdsall.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_holdsall.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_holdsall.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_holdsall.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_holdsall.sql_log OWNER TO evergreen;

SET search_path = m_kcls_holdsall2, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_holdsall2.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_holdsall2.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_holdsall2.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text,
    changed boolean
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls_holdsall2.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_holdsall2.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall2.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall2.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_holdsall2.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_holdsall2.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_holdsall2.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall2.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_holdsall2.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_holdsall2.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_holdsall2.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall2.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall2.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall2.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_holdsall2.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_holdsall2.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall2; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall2.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall2.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall2; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall2.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall2.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall2; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall2.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall2.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall2; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall2.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_holdsall2.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_holdsall2.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_holdsall2.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_holdsall2.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_holdsall2.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_holdsall2.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_holdsall2.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_holdsall2.sql_log OWNER TO evergreen;

SET search_path = m_kcls_holdsall3, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_holdsall3.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_holdsall3.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_holdsall3.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text,
    changed boolean
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls_holdsall3.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_holdsall3.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall3.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall3.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_holdsall3.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_holdsall3.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_holdsall3.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall3.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_holdsall3.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_holdsall3.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_holdsall3.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsall3.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsall3.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsall3.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_holdsall3.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_holdsall3.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall3; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall3.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall3.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall3; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall3.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall3.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall3; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall3.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsall3.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsall3; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsall3.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_holdsall3.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_holdsall3.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_holdsall3.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_holdsall3.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_holdsall3.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_holdsall3.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_holdsall3.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_holdsall3.sql_log OWNER TO evergreen;

SET search_path = m_kcls_holdsfix, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_holdsfix.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_holdsfix.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_holdsfix.action_hold_request OWNER TO evergreen;

--
-- Name: action_hold_request_legacy; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request_legacy (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
)
INHERITS (action_hold_request);


ALTER TABLE m_kcls_holdsfix.action_hold_request_legacy OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_holdsfix.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsfix.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsfix.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_holdsfix.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_holdsfix.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_holdsfix.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsfix.actor_usr_note OWNER TO evergreen;

--
-- Name: all_prod_holds; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE all_prod_holds (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls_holdsfix.all_prod_holds OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_holdsfix.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_holdsfix.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_holdsfix.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_holdsfix.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_holdsfix.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_holdsfix.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_holdsfix.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_holdsfix.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsfix; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsfix.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsfix.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsfix; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsfix.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsfix.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsfix; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsfix.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_holdsfix.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_holdsfix; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_holdsfix.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_holdsfix.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_holdsfix.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: holds_to_delete; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE holds_to_delete (
    id integer
);


ALTER TABLE m_kcls_holdsfix.holds_to_delete OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_holdsfix.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_holdsfix.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_holdsfix.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_holdsfix.money_grocery OWNER TO evergreen;

--
-- Name: rejected_holds; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE rejected_holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls_holdsfix.rejected_holds OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_holdsfix.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_holdsfix.sql_log OWNER TO evergreen;

--
-- Name: to_keep; Type: TABLE; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE TABLE to_keep (
    l_nkey text,
    l_nholdrecnumber text,
    l_npatronnumber text,
    l_bitemhold text,
    l_sitemlocation text,
    l_spickuplocation text,
    l_stitle text,
    l_snormtitle text,
    l_spatronname text,
    l_snormpatronname text,
    l_timestampdateplaced text,
    l_timestampnnadate text,
    l_timestampnnbdate text,
    l_spatronphone text,
    l_spatronemail text,
    l_scallnum text,
    l_sholdposition text,
    l_sitemstatus text,
    l_sitembarcode text,
    l_bonholdshelf text,
    l_sholdnote text,
    l_snormholdnote text,
    l_sholdstatus text,
    l_snormholdstatus text,
    l_slimitlocation text,
    l_slongtitle text,
    l_snormlongtitle text,
    l_slongauthor text,
    l_snormlongauthor text,
    l_ntotalattacheditems text,
    l_ntotalattacheditemspickup text,
    l_nbibrecnum text,
    l_cmaterialtype text
);


ALTER TABLE m_kcls_holdsfix.to_keep OWNER TO evergreen;

SET search_path = m_kcls_items2, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_items2.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_items2.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_items2.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_items2.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_items2.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_items2.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_items2.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_items2.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_items2.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_items2.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_items2.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_items2.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_updated text,
    l_icode text,
    l_internal_use text,
    l_icode1 text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_invda text,
    l_intnote text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_items2.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_items2.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_items2.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_items2.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_items2.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_items2.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_items2.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items2; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items2.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items2; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items2.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items2; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items2.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items2; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items2.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items2; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items2.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items2; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items2.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items2; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items2.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items2; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_items2.config OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls_items2.copy_dupe_barcodes OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes2; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes2 (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls_items2.copy_dupe_barcodes2 OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_items2.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_updated text,
    l_icode text,
    l_internal_use text,
    l_icode1 text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_invda text,
    l_intnote text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    egid bigint,
    x_call_number text
);


ALTER TABLE m_kcls_items2.item_exceptions OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_items2.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_items2.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_items2.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_items2.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_items2.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_items2.sql_log OWNER TO evergreen;

--
-- Name: volumes; Type: TABLE; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE TABLE volumes (
    l_item_id text,
    l_volume text
);


ALTER TABLE m_kcls_items2.volumes OWNER TO evergreen;

SET search_path = m_kcls_items3, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_items3.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_items3.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_items3.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_items3.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_items3.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_items3.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_items3.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_items3.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_items3.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_items3.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_items3.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_items3.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_legacy (
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_updated text,
    l_icode text,
    l_internal_use text,
    l_icode1 text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_invda text,
    l_intnote text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    l_toss text,
    egid bigint,
    x_call_number text
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_items3.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_items3.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_items3.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_items3.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_items3.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_items3.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_items3.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items3; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items3.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items3; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items3.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items3; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items3.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items3; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items3.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items3; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items3.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items3; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_items3.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_items3; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_items3.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_items3; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: calls; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE calls (
    l_item_id text,
    l_call_num text
);


ALTER TABLE m_kcls_items3.calls OWNER TO evergreen;

--
-- Name: cn_to_del; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE cn_to_del (
    id bigint
);


ALTER TABLE m_kcls_items3.cn_to_del OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_items3.config OWNER TO evergreen;

--
-- Name: copy_dupe_barcodes; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE copy_dupe_barcodes (
    barcode text,
    to_fix bigint
);


ALTER TABLE m_kcls_items3.copy_dupe_barcodes OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_items3.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_item_seq integer,
    l_barcode text,
    l_call_num text,
    l_copy_num text,
    l_created text,
    l_updated text,
    l_icode text,
    l_internal_use text,
    l_icode1 text,
    l_icode2 text,
    l_imessage text,
    l_int_note text,
    l_item_id text,
    l_itype text,
    l_invda text,
    l_intnote text,
    l_location text,
    l_lyrcirc text,
    l_message text,
    l_opacmsg text,
    l_price text,
    l_status text,
    l_tot_chkout text,
    l_tot_renew text,
    l_volume text,
    l_ytdcirc text,
    l_toss text,
    egid bigint,
    x_call_number text
);


ALTER TABLE m_kcls_items3.item_exceptions OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_items3.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_items3.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_items3.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_items3.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_items3.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_items3.sql_log OWNER TO evergreen;

SET search_path = m_kcls_ord, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_ord.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_ord.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_ord.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_ord.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_ord.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_ord.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_ord.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_ord.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_ord.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_ord.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_ord.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_ord.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_ord.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_ord.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: item_exceptions; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_exceptions (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    l_iii_bib_id text,
    l_call_no text,
    l_title text,
    l_ord_type text,
    l_ord_status text,
    l_cdate text,
    l_odate text,
    l_rdate text,
    l_location text,
    egid bigint
);


ALTER TABLE m_kcls_ord.item_exceptions OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_ord.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_ord.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_ord.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_ord.money_grocery OWNER TO evergreen;

--
-- Name: on_order_items; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE on_order_items (
    l_iii_bib_id text,
    l_call_no text,
    l_title text,
    l_ord_type text,
    l_ord_status text,
    l_cdate text,
    l_odate text,
    l_rdate text,
    l_location text,
    l_price text,
    egid bigint
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_ord.on_order_items OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_ord.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_ord.sql_log OWNER TO evergreen;

SET search_path = m_kcls_ord2, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_ord2.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_ord2.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_ord2.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_ord2.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord2.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord2.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_ord2.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_ord2.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_ord2.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord2.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_ord2.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_ord2.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_ord2.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord2.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord2.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord2.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_ord2.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_ord2.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord2; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord2.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord2.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord2; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord2.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord2.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord2; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord2.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord2.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord2; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord2.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_ord2.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_ord2.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_ord2.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_ord2.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_ord2.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_ord2.money_grocery OWNER TO evergreen;

--
-- Name: on_order_items; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE on_order_items (
    l_iii_bib_id text,
    l_call_no text,
    l_title text,
    l_ord_type text,
    l_ord_status text,
    l_cdate text,
    l_odate text,
    l_rdate text,
    l_location text,
    l_price text,
    egid bigint
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_ord2.on_order_items OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_ord2.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_ord2.sql_log OWNER TO evergreen;

SET search_path = m_kcls_ord3, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_kcls_ord3.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_kcls_ord3.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_kcls_ord3.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_kcls_ord3.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord3.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord3.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_kcls_ord3.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_kcls_ord3.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_kcls_ord3.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord3.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_kcls_ord3.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_kcls_ord3.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_kcls_ord3.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_kcls_ord3.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_kcls_ord3.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_kcls_ord3.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_kcls_ord3.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_kcls_ord3.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord3; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord3.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord3.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord3; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord3.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord3.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord3; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord3.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_kcls_ord3.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_kcls_ord3; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_kcls_ord3.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: config; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_kcls_ord3.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_kcls_ord3.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_kcls_ord3.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_kcls_ord3.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_kcls_ord3.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_kcls_ord3.money_grocery OWNER TO evergreen;

--
-- Name: on_order_items; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE on_order_items (
    l_iii_bib_id text,
    l_call_no text,
    l_title text,
    l_ord_type text,
    l_ord_status text,
    l_cdate text,
    l_odate text,
    l_rdate text,
    l_location text,
    l_price text,
    egid bigint
)
INHERITS (asset_copy);


ALTER TABLE m_kcls_ord3.on_order_items OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_kcls_ord3.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_kcls_ord3.sql_log OWNER TO evergreen;

SET search_path = m_kcls_xfr, pg_catalog;

--
-- Name: billing_type; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE billing_type (
    id integer,
    name text,
    owner integer,
    default_price numeric(6,2)
);


ALTER TABLE m_kcls_xfr.billing_type OWNER TO evergreen;

--
-- Name: circ_modifier; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE circ_modifier (
    code text,
    name text,
    description text,
    sip2_media_type text,
    magnetic_media boolean,
    avg_wait_time interval
);


ALTER TABLE m_kcls_xfr.circ_modifier OWNER TO evergreen;

--
-- Name: grp_change; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE grp_change (
    from_name text,
    to_name text,
    from_id integer,
    to_id integer
);


ALTER TABLE m_kcls_xfr.grp_change OWNER TO evergreen;

--
-- Name: grp_tree; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE grp_tree (
    id integer,
    name text,
    parent integer,
    usergroup boolean,
    perm_interval interval,
    description text,
    application_perm text
);


ALTER TABLE m_kcls_xfr.grp_tree OWNER TO evergreen;

--
-- Name: org_unit; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit (
    id integer,
    parent_ou integer,
    ou_type integer,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text,
    name text,
    email text,
    phone text,
    opac_visible boolean,
    fiscal_calendar integer
);


ALTER TABLE m_kcls_xfr.org_unit OWNER TO evergreen;

--
-- Name: org_unit_type; Type: TABLE; Schema: m_kcls_xfr; Owner: evergreen; Tablespace: 
--

CREATE TABLE org_unit_type (
    id integer,
    name text,
    opac_label text,
    depth integer,
    parent integer,
    can_have_vols boolean,
    can_have_users boolean
);


ALTER TABLE m_kcls_xfr.org_unit_type OWNER TO evergreen;

SET search_path = m_test, pg_catalog;

--
-- Name: action_circulation; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_test.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_test.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_test.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_test.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_test.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_test.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_test.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_test.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_test.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE actor_usr_note (
    id bigint DEFAULT nextval('actor.usr_note_id_seq'::regclass) NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_test.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_test.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_test.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_test.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_test.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_test.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_test.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_test.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_test.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE base_circ_field_map_id_seq OWNED BY base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE base_copy_location_map_id_seq OWNED BY base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE base_item_dynamic_field_map_id_seq OWNED BY base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE base_profile_map_id_seq OWNED BY base_profile_map.id;


--
-- Name: circhist; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE circhist (
    l_patron_id text,
    l_bib_num text,
    l_item_num text,
    l_checkout date
)
INHERITS (action_circulation);


ALTER TABLE m_test.circhist OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE config (
    key text,
    value text
);


ALTER TABLE m_test.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_test.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_test.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_test.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_test.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_test.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_current (
    sql text
);


ALTER TABLE m_test.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE TABLE sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_test.sql_log OWNER TO evergreen;

SET search_path = metabib, pg_catalog;

--
-- Name: author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE author_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.author_field_entry OWNER TO evergreen;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE author_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.author_field_entry_id_seq OWNER TO evergreen;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE author_field_entry_id_seq OWNED BY author_field_entry.id;


--
-- Name: bib_export_data; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_export_data (
    id bigint NOT NULL,
    bib bigint NOT NULL,
    export_date timestamp with time zone,
    import_date timestamp with time zone
);


ALTER TABLE metabib.bib_export_data OWNER TO evergreen;

--
-- Name: bib_export_data_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE bib_export_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.bib_export_data_id_seq OWNER TO evergreen;

--
-- Name: bib_export_data_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE bib_export_data_id_seq OWNED BY bib_export_data.id;


--
-- Name: browse_author_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_author_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);
ALTER TABLE ONLY browse_author_entry ALTER COLUMN sort_value SET STATISTICS 1000;


ALTER TABLE metabib.browse_author_entry OWNER TO evergreen;

--
-- Name: browse_author_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_author_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_author_entry_def_map OWNER TO evergreen;

--
-- Name: browse_author_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_author_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_author_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_author_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_author_entry_def_map_id_seq OWNED BY browse_author_entry_def_map.id;


--
-- Name: browse_author_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_author_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_author_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_author_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_author_entry_id_seq OWNED BY browse_author_entry.id;


--
-- Name: browse_author_entry_simple_heading_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_author_entry_simple_heading_map (
    id bigint NOT NULL,
    entry bigint,
    simple_heading bigint
);


ALTER TABLE metabib.browse_author_entry_simple_heading_map OWNER TO evergreen;

--
-- Name: browse_author_entry_simple_heading_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_author_entry_simple_heading_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_author_entry_simple_heading_map_id_seq OWNER TO evergreen;

--
-- Name: browse_author_entry_simple_heading_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_author_entry_simple_heading_map_id_seq OWNED BY browse_author_entry_simple_heading_map.id;


--
-- Name: browse_call_number_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_call_number_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);
ALTER TABLE ONLY browse_call_number_entry ALTER COLUMN sort_value SET STATISTICS 1000;


ALTER TABLE metabib.browse_call_number_entry OWNER TO evergreen;

--
-- Name: browse_call_number_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_call_number_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_call_number_entry_def_map OWNER TO evergreen;

--
-- Name: browse_call_number_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_call_number_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_call_number_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_call_number_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_call_number_entry_def_map_id_seq OWNED BY browse_call_number_entry_def_map.id;


--
-- Name: browse_call_number_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_call_number_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_call_number_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_call_number_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_call_number_entry_id_seq OWNED BY browse_call_number_entry.id;


--
-- Name: browse_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);


ALTER TABLE metabib.browse_entry OWNER TO evergreen;

--
-- Name: browse_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_entry_def_map OWNER TO evergreen;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_entry_def_map_id_seq OWNED BY browse_entry_def_map.id;


--
-- Name: browse_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_entry_id_seq OWNED BY browse_entry.id;


--
-- Name: browse_series_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_series_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);
ALTER TABLE ONLY browse_series_entry ALTER COLUMN sort_value SET STATISTICS 1000;


ALTER TABLE metabib.browse_series_entry OWNER TO evergreen;

--
-- Name: browse_series_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_series_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_series_entry_def_map OWNER TO evergreen;

--
-- Name: browse_series_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_series_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_series_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_series_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_series_entry_def_map_id_seq OWNED BY browse_series_entry_def_map.id;


--
-- Name: browse_series_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_series_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_series_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_series_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_series_entry_id_seq OWNED BY browse_series_entry.id;


--
-- Name: browse_series_entry_simple_heading_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_series_entry_simple_heading_map (
    id bigint NOT NULL,
    entry bigint,
    simple_heading bigint
);


ALTER TABLE metabib.browse_series_entry_simple_heading_map OWNER TO evergreen;

--
-- Name: browse_series_entry_simple_heading_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_series_entry_simple_heading_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_series_entry_simple_heading_map_id_seq OWNER TO evergreen;

--
-- Name: browse_series_entry_simple_heading_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_series_entry_simple_heading_map_id_seq OWNED BY browse_series_entry_simple_heading_map.id;


--
-- Name: browse_subject_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_subject_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);
ALTER TABLE ONLY browse_subject_entry ALTER COLUMN sort_value SET STATISTICS 1000;


ALTER TABLE metabib.browse_subject_entry OWNER TO evergreen;

--
-- Name: browse_subject_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_subject_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_subject_entry_def_map OWNER TO evergreen;

--
-- Name: browse_subject_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_subject_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_subject_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_subject_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_subject_entry_def_map_id_seq OWNED BY browse_subject_entry_def_map.id;


--
-- Name: browse_subject_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_subject_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_subject_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_subject_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_subject_entry_id_seq OWNED BY browse_subject_entry.id;


--
-- Name: browse_subject_entry_simple_heading_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_subject_entry_simple_heading_map (
    id bigint NOT NULL,
    entry bigint,
    simple_heading bigint
);


ALTER TABLE metabib.browse_subject_entry_simple_heading_map OWNER TO evergreen;

--
-- Name: browse_subject_entry_simple_heading_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_subject_entry_simple_heading_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_subject_entry_simple_heading_map_id_seq OWNER TO evergreen;

--
-- Name: browse_subject_entry_simple_heading_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_subject_entry_simple_heading_map_id_seq OWNED BY browse_subject_entry_simple_heading_map.id;


--
-- Name: browse_title_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_title_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text
);
ALTER TABLE ONLY browse_title_entry ALTER COLUMN sort_value SET STATISTICS 1000;


ALTER TABLE metabib.browse_title_entry OWNER TO evergreen;

--
-- Name: browse_title_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_title_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_title_entry_def_map OWNER TO evergreen;

--
-- Name: browse_title_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_title_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_title_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_title_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_title_entry_def_map_id_seq OWNED BY browse_title_entry_def_map.id;


--
-- Name: browse_title_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_title_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_title_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_title_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_title_entry_id_seq OWNED BY browse_title_entry.id;


--
-- Name: browse_title_entry_simple_heading_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE browse_title_entry_simple_heading_map (
    id bigint NOT NULL,
    entry bigint,
    simple_heading bigint
);


ALTER TABLE metabib.browse_title_entry_simple_heading_map OWNER TO evergreen;

--
-- Name: browse_title_entry_simple_heading_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE browse_title_entry_simple_heading_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_title_entry_simple_heading_map_id_seq OWNER TO evergreen;

--
-- Name: browse_title_entry_simple_heading_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE browse_title_entry_simple_heading_map_id_seq OWNED BY browse_title_entry_simple_heading_map.id;


--
-- Name: call_number_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE call_number_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.call_number_field_entry OWNER TO evergreen;

--
-- Name: call_number_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE call_number_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.call_number_field_entry_id_seq OWNER TO evergreen;

--
-- Name: call_number_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE call_number_field_entry_id_seq OWNED BY call_number_field_entry.id;


--
-- Name: combined_author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_author_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_author_field_entry OWNER TO evergreen;

--
-- Name: combined_identifier_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_identifier_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_identifier_field_entry OWNER TO evergreen;

--
-- Name: combined_keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_keyword_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_keyword_field_entry OWNER TO evergreen;

--
-- Name: combined_series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_series_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_series_field_entry OWNER TO evergreen;

--
-- Name: combined_subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_subject_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_subject_field_entry OWNER TO evergreen;

--
-- Name: combined_title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE combined_title_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_title_field_entry OWNER TO evergreen;

--
-- Name: facet_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE facet_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.facet_entry OWNER TO evergreen;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE facet_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.facet_entry_id_seq OWNER TO evergreen;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE facet_entry_id_seq OWNED BY facet_entry.id;


--
-- Name: identifier_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE identifier_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.identifier_field_entry OWNER TO evergreen;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE identifier_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.identifier_field_entry_id_seq OWNER TO evergreen;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE identifier_field_entry_id_seq OWNED BY identifier_field_entry.id;


--
-- Name: keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE keyword_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.keyword_field_entry OWNER TO evergreen;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE keyword_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.keyword_field_entry_id_seq OWNER TO evergreen;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE keyword_field_entry_id_seq OWNED BY keyword_field_entry.id;


--
-- Name: language_filter; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE language_filter (
    id bigint NOT NULL,
    source bigint NOT NULL,
    value tsvector
);


ALTER TABLE metabib.language_filter OWNER TO evergreen;

--
-- Name: language_filter_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE language_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.language_filter_id_seq OWNER TO evergreen;

--
-- Name: language_filter_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE language_filter_id_seq OWNED BY language_filter.id;


--
-- Name: metarecord; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE metarecord (
    id bigint NOT NULL,
    fingerprint text NOT NULL,
    master_record bigint,
    mods text
);


ALTER TABLE metabib.metarecord OWNER TO evergreen;

--
-- Name: metarecord_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metarecord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_id_seq OWNER TO evergreen;

--
-- Name: metarecord_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metarecord_id_seq OWNED BY metarecord.id;


--
-- Name: metarecord_source_map; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE metarecord_source_map (
    id bigint NOT NULL,
    metarecord bigint NOT NULL,
    source bigint NOT NULL
);


ALTER TABLE metabib.metarecord_source_map OWNER TO evergreen;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metarecord_source_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_source_map_id_seq OWNER TO evergreen;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metarecord_source_map_id_seq OWNED BY metarecord_source_map.id;


--
-- Name: normalized_author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE normalized_author_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_author_field_entry OWNER TO evergreen;

--
-- Name: normalized_keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE normalized_keyword_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_keyword_field_entry OWNER TO evergreen;

--
-- Name: normalized_series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE normalized_series_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_series_field_entry OWNER TO evergreen;

--
-- Name: normalized_subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE normalized_subject_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_subject_field_entry OWNER TO evergreen;

--
-- Name: normalized_title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE normalized_title_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_title_field_entry OWNER TO evergreen;

--
-- Name: record_attr; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_attr (
    id bigint NOT NULL,
    attrs evergreen.hstore DEFAULT ''::evergreen.hstore NOT NULL
);


ALTER TABLE metabib.record_attr OWNER TO evergreen;

--
-- Name: rec_descriptor; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW rec_descriptor AS
    SELECT record_attr.id, record_attr.id AS record, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_type AS item_type, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_form AS item_form, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).bib_level AS bib_level, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).control_type AS control_type, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).char_encoding AS char_encoding, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).enc_level AS enc_level, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).audience AS audience, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).lit_form AS lit_form, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).type_mat AS type_mat, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).cat_form AS cat_form, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).pub_status AS pub_status, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).item_lang AS item_lang, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).vr_format AS vr_format, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).date1 AS date1, (evergreen.populate_record(NULL::rec_desc_type, record_attr.attrs)).date2 AS date2 FROM record_attr;


ALTER TABLE metabib.rec_descriptor OWNER TO evergreen;

--
-- Name: record_attr_back; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_attr_back (
    id bigint,
    attrs evergreen.hstore
);


ALTER TABLE metabib.record_attr_back OWNER TO evergreen;

--
-- Name: series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE series_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.series_field_entry OWNER TO evergreen;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE series_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.series_field_entry_id_seq OWNER TO evergreen;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE series_field_entry_id_seq OWNED BY series_field_entry.id;


--
-- Name: subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE subject_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.subject_field_entry OWNER TO evergreen;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE subject_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.subject_field_entry_id_seq OWNER TO evergreen;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE subject_field_entry_id_seq OWNED BY subject_field_entry.id;


--
-- Name: title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE TABLE title_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.title_field_entry OWNER TO evergreen;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE title_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.title_field_entry_id_seq OWNER TO evergreen;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE title_field_entry_id_seq OWNED BY title_field_entry.id;


SET search_path = migration_tools, pg_catalog;

--
-- Name: db_object_stash; Type: TABLE; Schema: migration_tools; Owner: evergreen; Tablespace: 
--

CREATE TABLE db_object_stash (
    schema_name name,
    table_name name,
    object_name name,
    object_type text,
    restore_command text,
    CONSTRAINT db_object_stash_object_type_check CHECK ((object_type = ANY (ARRAY['index'::text, 'trigger'::text, 'rule'::text])))
);


ALTER TABLE migration_tools.db_object_stash OWNER TO evergreen;

SET search_path = money, pg_catalog;

--
-- Name: materialized_billable_xact_summary; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE materialized_billable_xact_summary (
    id bigint NOT NULL,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    total_paid numeric,
    last_payment_ts timestamp with time zone,
    last_payment_note text,
    last_payment_type name,
    total_owed numeric,
    last_billing_ts timestamp with time zone,
    last_billing_note text,
    last_billing_type text,
    balance_owed numeric,
    xact_type name
);


ALTER TABLE money.materialized_billable_xact_summary OWNER TO evergreen;

--
-- Name: billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW billable_xact_summary AS
    SELECT materialized_billable_xact_summary.id, materialized_billable_xact_summary.usr, materialized_billable_xact_summary.xact_start, materialized_billable_xact_summary.xact_finish, materialized_billable_xact_summary.total_paid, materialized_billable_xact_summary.last_payment_ts, materialized_billable_xact_summary.last_payment_note, materialized_billable_xact_summary.last_payment_type, materialized_billable_xact_summary.total_owed, materialized_billable_xact_summary.last_billing_ts, materialized_billable_xact_summary.last_billing_note, materialized_billable_xact_summary.last_billing_type, materialized_billable_xact_summary.balance_owed, materialized_billable_xact_summary.xact_type FROM materialized_billable_xact_summary;


ALTER TABLE money.billable_xact_summary OWNER TO evergreen;

--
-- Name: grocery; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE grocery (
    billing_location integer NOT NULL,
    note text
)
INHERITS (billable_xact);


ALTER TABLE money.grocery OWNER TO evergreen;

--
-- Name: billable_xact_summary_location_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW billable_xact_summary_location_view AS
    SELECT m.id, m.usr, m.xact_start, m.xact_finish, m.total_paid, m.last_payment_ts, m.last_payment_note, m.last_payment_type, m.total_owed, m.last_billing_ts, m.last_billing_note, m.last_billing_type, m.balance_owed, m.xact_type, COALESCE(c.circ_lib, g.billing_location, r.pickup_lib) AS billing_location FROM (((materialized_billable_xact_summary m LEFT JOIN action.circulation c ON ((c.id = m.id))) LEFT JOIN grocery g ON ((g.id = m.id))) LEFT JOIN booking.reservation r ON ((r.id = m.id)));


ALTER TABLE money.billable_xact_summary_location_view OWNER TO evergreen;

--
-- Name: payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, c.relname AS payment_type FROM (payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.payment_view OWNER TO evergreen;

--
-- Name: billable_xact_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW billable_xact_with_void_summary AS
    SELECT xact.id, xact.usr, xact.xact_start, xact.xact_finish, sum(credit.amount) AS total_paid, max(credit.payment_ts) AS last_payment_ts, public.last(credit.note) AS last_payment_note, public.last(credit.payment_type) AS last_payment_type, sum(debit.amount) AS total_owed, max(debit.billing_ts) AS last_billing_ts, public.last(debit.note) AS last_billing_note, public.last(debit.billing_type) AS last_billing_type, (COALESCE(sum(debit.amount), (0)::numeric) - COALESCE(sum(credit.amount), (0)::numeric)) AS balance_owed, p.relname AS xact_type FROM (((billable_xact xact JOIN pg_class p ON ((xact.tableoid = p.oid))) LEFT JOIN billing debit ON ((xact.id = debit.xact))) LEFT JOIN payment_view credit ON ((xact.id = credit.xact))) GROUP BY xact.id, xact.usr, xact.xact_start, xact.xact_finish, p.relname ORDER BY max(debit.billing_ts), max(credit.payment_ts);


ALTER TABLE money.billable_xact_with_void_summary OWNER TO evergreen;

--
-- Name: bnm_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE bnm_payment (
    amount_collected numeric(6,2) NOT NULL,
    accepting_usr integer NOT NULL
)
INHERITS (payment);


ALTER TABLE money.bnm_payment OWNER TO evergreen;

--
-- Name: bnm_desk_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE bnm_desk_payment (
    cash_drawer integer
)
INHERITS (bnm_payment);


ALTER TABLE money.bnm_desk_payment OWNER TO evergreen;

--
-- Name: bnm_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW bnm_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, c.relname AS payment_type FROM (bnm_payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.bnm_payment_view OWNER TO evergreen;

--
-- Name: cash_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE cash_payment (
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.cash_payment OWNER TO evergreen;

--
-- Name: cashdrawer_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW cashdrawer_payment_view AS
    SELECT ou.id AS org_unit, ws.id AS cashdrawer, t.payment_type, p.payment_ts, p.amount, p.voided, p.note FROM (((actor.org_unit ou JOIN actor.workstation ws ON ((ou.id = ws.owning_lib))) LEFT JOIN bnm_desk_payment p ON ((ws.id = p.cash_drawer))) LEFT JOIN payment_view t ON ((p.id = t.id)));


ALTER TABLE money.cashdrawer_payment_view OWNER TO evergreen;

--
-- Name: check_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE check_payment (
    check_number text NOT NULL
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.check_payment OWNER TO evergreen;

--
-- Name: collections_tracker; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE collections_tracker (
    id bigint NOT NULL,
    usr integer NOT NULL,
    collector integer NOT NULL,
    location integer NOT NULL,
    enter_time timestamp with time zone
);


ALTER TABLE money.collections_tracker OWNER TO evergreen;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE collections_tracker_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.collections_tracker_id_seq OWNER TO evergreen;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE collections_tracker_id_seq OWNED BY collections_tracker.id;


--
-- Name: credit_card_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE credit_card_payment (
    cc_type text,
    cc_number text,
    cc_processor text,
    expire_month integer,
    expire_year integer,
    approval_code text,
    cc_first_name text,
    cc_last_name text,
    cc_order_number text
)
INHERITS (bnm_desk_payment);


ALTER TABLE money.credit_card_payment OWNER TO evergreen;

--
-- Name: credit_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE credit_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.credit_payment OWNER TO evergreen;

--
-- Name: desk_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW desk_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, p.cash_drawer, c.relname AS payment_type FROM (bnm_desk_payment p JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.desk_payment_view OWNER TO evergreen;

--
-- Name: forgive_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE forgive_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.forgive_payment OWNER TO evergreen;

--
-- Name: goods_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE goods_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.goods_payment OWNER TO evergreen;

--
-- Name: non_drawer_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW non_drawer_payment_view AS
    SELECT p.id, p.xact, p.payment_ts, p.voided, p.amount, p.note, p.amount_collected, p.accepting_usr, c.relname AS payment_type FROM (bnm_payment p JOIN pg_class c ON ((p.tableoid = c.oid))) WHERE (c.relname <> ALL (ARRAY['cash_payment'::name, 'check_payment'::name, 'credit_card_payment'::name]));


ALTER TABLE money.non_drawer_payment_view OWNER TO evergreen;

--
-- Name: open_circ_balance_by_circ_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_circ_balance_by_circ_and_owning_lib AS
    SELECT circ.id, circ.circ_lib, cn.owning_lib, bill.billing_type, sum(bill.amount) AS billed FROM (((action.circulation circ JOIN billing bill ON ((circ.id = bill.xact))) JOIN asset.copy cp ON ((circ.target_copy = cp.id))) JOIN asset.call_number cn ON ((cn.id = cp.call_number))) WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided)) GROUP BY circ.id, circ.circ_lib, cn.owning_lib, bill.billing_type ORDER BY circ.id, circ.circ_lib, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_circ_and_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_circ_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_balance_by_circ_and_owning_lib AS
    SELECT x.circ_lib, x.owning_lib, array_to_string(public.array_accum(DISTINCT x.billing_type), ', '::text) AS billing_types, (sum(x.billed) - sum(COALESCE((SELECT sum(payment.amount) AS paid FROM payment WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance FROM open_circ_balance_by_circ_and_owning_lib x GROUP BY x.circ_lib, x.owning_lib;


ALTER TABLE money.open_balance_by_circ_and_owning_lib OWNER TO evergreen;

--
-- Name: open_circ_balance_by_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_circ_balance_by_owning_lib AS
    SELECT circ.id, cn.owning_lib, bill.billing_type, sum(bill.amount) AS billed FROM (((action.circulation circ JOIN billing bill ON ((circ.id = bill.xact))) JOIN asset.copy cp ON ((circ.target_copy = cp.id))) JOIN asset.call_number cn ON ((cn.id = cp.call_number))) WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided)) GROUP BY circ.id, cn.owning_lib, bill.billing_type ORDER BY circ.id, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_balance_by_owning_lib AS
    SELECT x.owning_lib, array_to_string(public.array_accum(DISTINCT x.billing_type), ', '::text) AS billing_types, (sum(x.billed) - sum(COALESCE((SELECT sum(payment.amount) AS paid FROM payment WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance FROM open_circ_balance_by_owning_lib x GROUP BY x.owning_lib;


ALTER TABLE money.open_balance_by_owning_lib OWNER TO evergreen;

--
-- Name: open_circ_balance_by_usr_home_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_circ_balance_by_usr_home_and_owning_lib AS
    SELECT circ.id, usr.home_ou, cn.owning_lib, bill.billing_type, sum(bill.amount) AS billed FROM ((((action.circulation circ JOIN billing bill ON ((circ.id = bill.xact))) JOIN asset.copy cp ON ((circ.target_copy = cp.id))) JOIN asset.call_number cn ON ((cn.id = cp.call_number))) JOIN actor.usr usr ON ((circ.usr = usr.id))) WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided)) GROUP BY circ.id, usr.home_ou, cn.owning_lib, bill.billing_type ORDER BY circ.id, usr.home_ou, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_usr_home_and_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_usr_home_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_balance_by_usr_home_and_owning_lib AS
    SELECT x.home_ou, x.owning_lib, array_to_string(public.array_accum(DISTINCT x.billing_type), ', '::text) AS billing_types, (sum(x.billed) - sum(COALESCE((SELECT sum(payment.amount) AS paid FROM payment WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance FROM open_circ_balance_by_usr_home_and_owning_lib x GROUP BY x.home_ou, x.owning_lib;


ALTER TABLE money.open_balance_by_usr_home_and_owning_lib OWNER TO evergreen;

--
-- Name: open_billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_billable_xact_summary AS
    SELECT billable_xact_summary_location_view.id, billable_xact_summary_location_view.usr, billable_xact_summary_location_view.xact_start, billable_xact_summary_location_view.xact_finish, billable_xact_summary_location_view.total_paid, billable_xact_summary_location_view.last_payment_ts, billable_xact_summary_location_view.last_payment_note, billable_xact_summary_location_view.last_payment_type, billable_xact_summary_location_view.total_owed, billable_xact_summary_location_view.last_billing_ts, billable_xact_summary_location_view.last_billing_note, billable_xact_summary_location_view.last_billing_type, billable_xact_summary_location_view.balance_owed, billable_xact_summary_location_view.xact_type, billable_xact_summary_location_view.billing_location FROM billable_xact_summary_location_view WHERE (billable_xact_summary_location_view.xact_finish IS NULL);


ALTER TABLE money.open_billable_xact_summary OWNER TO evergreen;

--
-- Name: open_transaction_billing_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_transaction_billing_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.open_transaction_billing_summary OWNER TO evergreen;

--
-- Name: open_transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_transaction_billing_type_summary AS
    SELECT billing.xact, billing.billing_type AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact, billing.billing_type ORDER BY max(billing.billing_ts);


ALTER TABLE money.open_transaction_billing_type_summary OWNER TO evergreen;

--
-- Name: open_transaction_payment_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_transaction_payment_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid FROM payment_view WHERE (payment_view.voided IS FALSE) GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.open_transaction_payment_summary OWNER TO evergreen;

--
-- Name: open_usr_circulation_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_usr_circulation_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary WHERE ((materialized_billable_xact_summary.xact_type = 'circulation'::name) AND (materialized_billable_xact_summary.xact_finish IS NULL)) GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_circulation_summary OWNER TO evergreen;

--
-- Name: open_usr_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW open_usr_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary WHERE (materialized_billable_xact_summary.xact_finish IS NULL) GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_summary OWNER TO evergreen;

--
-- Name: tmp_billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW tmp_billable_xact_summary AS
    SELECT xact.id, xact.usr, xact.xact_start, xact.xact_finish, COALESCE(credit.amount, 0.0) AS total_paid, credit.payment_ts AS last_payment_ts, credit.note AS last_payment_note, credit.payment_type AS last_payment_type, COALESCE(debit.amount, 0.0) AS total_owed, debit.billing_ts AS last_billing_ts, debit.note AS last_billing_note, debit.billing_type AS last_billing_type, (COALESCE(debit.amount, 0.0) - COALESCE(credit.amount, 0.0)) AS balance_owed, p.relname AS xact_type FROM (((billable_xact xact JOIN pg_class p ON ((xact.tableoid = p.oid))) LEFT JOIN (SELECT billing.xact, sum(billing.amount) AS amount, max(billing.billing_ts) AS billing_ts, public.last(billing.note) AS note, public.last(billing.billing_type) AS billing_type FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact) debit ON ((xact.id = debit.xact))) LEFT JOIN (SELECT payment_view.xact, sum(payment_view.amount) AS amount, max(payment_view.payment_ts) AS payment_ts, public.last(payment_view.note) AS note, public.last(payment_view.payment_type) AS payment_type FROM payment_view WHERE (payment_view.voided IS FALSE) GROUP BY payment_view.xact) credit ON ((xact.id = credit.xact))) ORDER BY debit.billing_ts, credit.payment_ts;


ALTER TABLE money.tmp_billable_xact_summary OWNER TO evergreen;

--
-- Name: transaction_billing_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW transaction_billing_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_summary OWNER TO evergreen;

--
-- Name: transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW transaction_billing_type_summary AS
    SELECT billing.xact, billing.billing_type AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed FROM billing WHERE (billing.voided IS FALSE) GROUP BY billing.xact, billing.billing_type ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_type_summary OWNER TO evergreen;

--
-- Name: transaction_billing_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW transaction_billing_with_void_summary AS
    SELECT billing.xact, public.last(billing.billing_type) AS last_billing_type, public.last(billing.note) AS last_billing_note, max(billing.billing_ts) AS last_billing_ts, sum(CASE WHEN billing.voided THEN (0)::numeric ELSE COALESCE(billing.amount, (0)::numeric) END) AS total_owed FROM billing GROUP BY billing.xact ORDER BY max(billing.billing_ts);


ALTER TABLE money.transaction_billing_with_void_summary OWNER TO evergreen;

--
-- Name: transaction_payment_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW transaction_payment_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid FROM payment_view WHERE (payment_view.voided IS FALSE) GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.transaction_payment_summary OWNER TO evergreen;

--
-- Name: transaction_payment_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW transaction_payment_with_void_summary AS
    SELECT payment_view.xact, public.last(payment_view.payment_type) AS last_payment_type, public.last(payment_view.note) AS last_payment_note, max(payment_view.payment_ts) AS last_payment_ts, sum(CASE WHEN payment_view.voided THEN (0)::numeric ELSE COALESCE(payment_view.amount, (0)::numeric) END) AS total_paid FROM payment_view GROUP BY payment_view.xact ORDER BY max(payment_view.payment_ts);


ALTER TABLE money.transaction_payment_with_void_summary OWNER TO evergreen;

--
-- Name: usr_circulation_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW usr_circulation_summary AS
    SELECT billable_xact_summary.usr, sum(billable_xact_summary.total_paid) AS total_paid, sum(billable_xact_summary.total_owed) AS total_owed, sum(billable_xact_summary.balance_owed) AS balance_owed FROM billable_xact_summary WHERE (billable_xact_summary.xact_type = 'circulation'::name) GROUP BY billable_xact_summary.usr;


ALTER TABLE money.usr_circulation_summary OWNER TO evergreen;

--
-- Name: usr_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW usr_summary AS
    SELECT materialized_billable_xact_summary.usr, sum(materialized_billable_xact_summary.total_paid) AS total_paid, sum(materialized_billable_xact_summary.total_owed) AS total_owed, sum(materialized_billable_xact_summary.balance_owed) AS balance_owed FROM materialized_billable_xact_summary GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.usr_summary OWNER TO evergreen;

--
-- Name: work_payment; Type: TABLE; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE TABLE work_payment (
)
INHERITS (bnm_payment);


ALTER TABLE money.work_payment OWNER TO evergreen;

SET search_path = offline, pg_catalog;

--
-- Name: script; Type: TABLE; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE TABLE script (
    id integer NOT NULL,
    session text NOT NULL,
    requestor integer NOT NULL,
    create_time integer NOT NULL,
    workstation text NOT NULL,
    logfile text NOT NULL,
    time_delta integer DEFAULT 0 NOT NULL,
    count integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.script OWNER TO evergreen;

--
-- Name: script_hs19982; Type: TABLE; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE TABLE script_hs19982 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE offline.script_hs19982 OWNER TO evergreen;

--
-- Name: script_id_seq; Type: SEQUENCE; Schema: offline; Owner: evergreen
--

CREATE SEQUENCE script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE offline.script_id_seq OWNER TO evergreen;

--
-- Name: script_id_seq; Type: SEQUENCE OWNED BY; Schema: offline; Owner: evergreen
--

ALTER SEQUENCE script_id_seq OWNED BY script.id;


--
-- Name: session; Type: TABLE; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE TABLE session (
    key text NOT NULL,
    org integer NOT NULL,
    description text,
    creator integer NOT NULL,
    create_time integer NOT NULL,
    in_process integer DEFAULT 0 NOT NULL,
    start_time integer,
    end_time integer,
    num_complete integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.session OWNER TO evergreen;

--
-- Name: session_hs19982; Type: TABLE; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE TABLE session_hs19982 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE offline.session_hs19982 OWNER TO evergreen;

SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE grp_penalty_threshold (
    id integer NOT NULL,
    grp integer NOT NULL,
    org_unit integer NOT NULL,
    penalty integer NOT NULL,
    threshold numeric(8,2) NOT NULL
);


ALTER TABLE permission.grp_penalty_threshold OWNER TO evergreen;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE grp_penalty_threshold_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_penalty_threshold_id_seq OWNER TO evergreen;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE grp_penalty_threshold_id_seq OWNED BY grp_penalty_threshold.id;


--
-- Name: grp_perm_map; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE grp_perm_map (
    id integer NOT NULL,
    grp integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.grp_perm_map OWNER TO evergreen;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE grp_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_perm_map_id_seq OWNER TO evergreen;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE grp_perm_map_id_seq OWNED BY grp_perm_map.id;


--
-- Name: grp_tree_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE grp_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_tree_id_seq OWNER TO evergreen;

--
-- Name: grp_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE grp_tree_id_seq OWNED BY grp_tree.id;


--
-- Name: perm_list; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE perm_list (
    id integer NOT NULL,
    code text NOT NULL,
    description text
);


ALTER TABLE permission.perm_list OWNER TO evergreen;

--
-- Name: perm_list_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE perm_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.perm_list_id_seq OWNER TO evergreen;

--
-- Name: perm_list_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE perm_list_id_seq OWNED BY perm_list.id;


--
-- Name: usr_grp_map; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_grp_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    grp integer NOT NULL
);


ALTER TABLE permission.usr_grp_map OWNER TO evergreen;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE usr_grp_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_grp_map_id_seq OWNER TO evergreen;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE usr_grp_map_id_seq OWNED BY usr_grp_map.id;


--
-- Name: usr_object_perm_map; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_object_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    object_type text NOT NULL,
    object_id text NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_object_perm_map OWNER TO evergreen;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE usr_object_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_object_perm_map_id_seq OWNER TO evergreen;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE usr_object_perm_map_id_seq OWNED BY usr_object_perm_map.id;


--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE usr_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_perm_map_id_seq OWNER TO evergreen;

--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE usr_perm_map_id_seq OWNED BY usr_perm_map.id;


--
-- Name: usr_work_ou_map; Type: TABLE; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_work_ou_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    work_ou integer NOT NULL
);


ALTER TABLE permission.usr_work_ou_map OWNER TO evergreen;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE usr_work_ou_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_work_ou_map_id_seq OWNER TO evergreen;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE usr_work_ou_map_id_seq OWNED BY usr_work_ou_map.id;


SET search_path = prod_staff_users, pg_catalog;

--
-- Name: card; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE card (
    id integer NOT NULL,
    usr integer NOT NULL,
    barcode text NOT NULL,
    active boolean NOT NULL
);


ALTER TABLE prod_staff_users.card OWNER TO evergreen;

--
-- Name: save_source; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE save_source (
    barcode text,
    usrname text,
    fname text,
    lname text,
    passwd text
);


ALTER TABLE prod_staff_users.save_source OWNER TO evergreen;

--
-- Name: save_these; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE save_these (
    id integer
);


ALTER TABLE prod_staff_users.save_these OWNER TO evergreen;

--
-- Name: usr; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr (
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean NOT NULL,
    master_account boolean NOT NULL,
    super_user boolean NOT NULL,
    barred boolean NOT NULL,
    deleted boolean NOT NULL,
    juvenile boolean NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer NOT NULL,
    credit_forward_balance numeric(6,2) NOT NULL,
    last_xact_id text NOT NULL,
    alert_message text,
    create_date timestamp with time zone NOT NULL,
    expire_date timestamp with time zone NOT NULL,
    claims_never_checked_out_count integer NOT NULL
);


ALTER TABLE prod_staff_users.usr OWNER TO evergreen;

--
-- Name: usr_address; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_address (
    id integer NOT NULL,
    valid boolean NOT NULL,
    within_city_limits boolean NOT NULL,
    address_type text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean NOT NULL,
    replaces integer
);


ALTER TABLE prod_staff_users.usr_address OWNER TO evergreen;

--
-- Name: usr_perm_map; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean NOT NULL
);


ALTER TABLE prod_staff_users.usr_perm_map OWNER TO evergreen;

--
-- Name: usr_setting; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_setting (
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL
);


ALTER TABLE prod_staff_users.usr_setting OWNER TO evergreen;

--
-- Name: usr_work_ou_map; Type: TABLE; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

CREATE TABLE usr_work_ou_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    work_ou integer NOT NULL
);


ALTER TABLE prod_staff_users.usr_work_ou_map OWNER TO evergreen;

SET search_path = public, pg_catalog;

--
-- Name: dupes2; Type: TABLE; Schema: public; Owner: evergreen; Tablespace: 
--

CREATE TABLE dupes2 (
    record bigint,
    value text
);


ALTER TABLE public.dupes2 OWNER TO evergreen;

SET search_path = query, pg_catalog;

--
-- Name: bind_variable; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE bind_variable (
    name text NOT NULL,
    type text NOT NULL,
    description text NOT NULL,
    default_value text,
    label text NOT NULL,
    CONSTRAINT bind_variable_type CHECK ((type = ANY (ARRAY['string'::text, 'number'::text, 'string_list'::text, 'number_list'::text])))
);


ALTER TABLE query.bind_variable OWNER TO evergreen;

--
-- Name: case_branch; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE case_branch (
    id integer NOT NULL,
    parent_expr integer NOT NULL,
    seq_no integer NOT NULL,
    condition integer,
    result integer NOT NULL
);


ALTER TABLE query.case_branch OWNER TO evergreen;

--
-- Name: case_branch_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE case_branch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.case_branch_id_seq OWNER TO evergreen;

--
-- Name: case_branch_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE case_branch_id_seq OWNED BY case_branch.id;


--
-- Name: datatype; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE datatype (
    id integer NOT NULL,
    datatype_name text NOT NULL,
    is_numeric boolean DEFAULT false NOT NULL,
    is_composite boolean DEFAULT false NOT NULL,
    CONSTRAINT qdt_comp_not_num CHECK (((is_numeric IS FALSE) OR (is_composite IS FALSE)))
);


ALTER TABLE query.datatype OWNER TO evergreen;

--
-- Name: datatype_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE datatype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.datatype_id_seq OWNER TO evergreen;

--
-- Name: datatype_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE datatype_id_seq OWNED BY datatype.id;


--
-- Name: expression; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE expression (
    id integer NOT NULL,
    type text NOT NULL,
    parenthesize boolean DEFAULT false NOT NULL,
    parent_expr integer,
    seq_no integer DEFAULT 1 NOT NULL,
    literal text,
    table_alias text,
    column_name text,
    left_operand integer,
    operator text,
    right_operand integer,
    function_id integer,
    subquery integer,
    cast_type integer,
    negate boolean DEFAULT false NOT NULL,
    bind_variable text,
    CONSTRAINT expression_type CHECK ((type = ANY (ARRAY['xbet'::text, 'xbind'::text, 'xbool'::text, 'xcase'::text, 'xcast'::text, 'xcol'::text, 'xex'::text, 'xfunc'::text, 'xin'::text, 'xisnull'::text, 'xnull'::text, 'xnum'::text, 'xop'::text, 'xser'::text, 'xstr'::text, 'xsubq'::text])))
);


ALTER TABLE query.expression OWNER TO evergreen;

--
-- Name: expr_xbet; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xbet AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xbet'::text);


ALTER TABLE query.expr_xbet OWNER TO evergreen;

--
-- Name: expr_xbind; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xbind AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.bind_variable FROM expression WHERE (expression.type = 'xbind'::text);


ALTER TABLE query.expr_xbind OWNER TO evergreen;

--
-- Name: expr_xbool; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xbool AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal, expression.negate FROM expression WHERE (expression.type = 'xbool'::text);


ALTER TABLE query.expr_xbool OWNER TO evergreen;

--
-- Name: expr_xcase; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xcase AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xcase'::text);


ALTER TABLE query.expr_xcase OWNER TO evergreen;

--
-- Name: expr_xcast; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xcast AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.cast_type, expression.negate FROM expression WHERE (expression.type = 'xcast'::text);


ALTER TABLE query.expr_xcast OWNER TO evergreen;

--
-- Name: expr_xcol; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xcol AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.table_alias, expression.column_name, expression.negate FROM expression WHERE (expression.type = 'xcol'::text);


ALTER TABLE query.expr_xcol OWNER TO evergreen;

--
-- Name: expr_xex; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xex AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xex'::text);


ALTER TABLE query.expr_xex OWNER TO evergreen;

--
-- Name: expr_xfunc; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xfunc AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.column_name, expression.function_id, expression.negate FROM expression WHERE (expression.type = 'xfunc'::text);


ALTER TABLE query.expr_xfunc OWNER TO evergreen;

--
-- Name: expr_xin; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xin AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xin'::text);


ALTER TABLE query.expr_xin OWNER TO evergreen;

--
-- Name: expr_xisnull; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xisnull AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.negate FROM expression WHERE (expression.type = 'xisnull'::text);


ALTER TABLE query.expr_xisnull OWNER TO evergreen;

--
-- Name: expr_xnull; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xnull AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.negate FROM expression WHERE (expression.type = 'xnull'::text);


ALTER TABLE query.expr_xnull OWNER TO evergreen;

--
-- Name: expr_xnum; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xnum AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal FROM expression WHERE (expression.type = 'xnum'::text);


ALTER TABLE query.expr_xnum OWNER TO evergreen;

--
-- Name: expr_xop; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xop AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.left_operand, expression.operator, expression.right_operand, expression.negate FROM expression WHERE (expression.type = 'xop'::text);


ALTER TABLE query.expr_xop OWNER TO evergreen;

--
-- Name: expr_xser; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xser AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.operator, expression.negate FROM expression WHERE (expression.type = 'xser'::text);


ALTER TABLE query.expr_xser OWNER TO evergreen;

--
-- Name: expr_xstr; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xstr AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.literal FROM expression WHERE (expression.type = 'xstr'::text);


ALTER TABLE query.expr_xstr OWNER TO evergreen;

--
-- Name: expr_xsubq; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW expr_xsubq AS
    SELECT expression.id, expression.parenthesize, expression.parent_expr, expression.seq_no, expression.subquery, expression.negate FROM expression WHERE (expression.type = 'xsubq'::text);


ALTER TABLE query.expr_xsubq OWNER TO evergreen;

--
-- Name: expression_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE expression_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.expression_id_seq OWNER TO evergreen;

--
-- Name: expression_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE expression_id_seq OWNED BY expression.id;


--
-- Name: from_relation; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE from_relation (
    id integer NOT NULL,
    type text NOT NULL,
    table_name text,
    class_name text,
    subquery integer,
    function_call integer,
    table_alias text,
    parent_relation integer,
    seq_no integer DEFAULT 1 NOT NULL,
    join_type text,
    on_clause integer,
    CONSTRAINT good_join_type CHECK (((join_type IS NULL) OR (join_type = ANY (ARRAY['INNER'::text, 'LEFT'::text, 'RIGHT'::text, 'FULL'::text])))),
    CONSTRAINT join_or_core CHECK (((((parent_relation IS NULL) AND (join_type IS NULL)) AND (on_clause IS NULL)) OR (((parent_relation IS NOT NULL) AND (join_type IS NOT NULL)) AND (on_clause IS NOT NULL)))),
    CONSTRAINT relation_type CHECK ((type = ANY (ARRAY['RELATION'::text, 'SUBQUERY'::text, 'FUNCTION'::text])))
);


ALTER TABLE query.from_relation OWNER TO evergreen;

--
-- Name: from_relation_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE from_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.from_relation_id_seq OWNER TO evergreen;

--
-- Name: from_relation_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE from_relation_id_seq OWNED BY from_relation.id;


--
-- Name: function_param_def; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE function_param_def (
    id integer NOT NULL,
    function_id integer NOT NULL,
    seq_no integer NOT NULL,
    datatype integer NOT NULL,
    CONSTRAINT qfpd_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.function_param_def OWNER TO evergreen;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE function_param_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_param_def_id_seq OWNER TO evergreen;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE function_param_def_id_seq OWNED BY function_param_def.id;


--
-- Name: function_sig; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE function_sig (
    id integer NOT NULL,
    function_name text NOT NULL,
    return_type integer,
    is_aggregate boolean DEFAULT false NOT NULL,
    CONSTRAINT qfd_rtn_or_aggr CHECK (((return_type IS NULL) OR (is_aggregate = false)))
);


ALTER TABLE query.function_sig OWNER TO evergreen;

--
-- Name: function_sig_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE function_sig_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_sig_id_seq OWNER TO evergreen;

--
-- Name: function_sig_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE function_sig_id_seq OWNED BY function_sig.id;


--
-- Name: order_by_item; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE order_by_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL
);


ALTER TABLE query.order_by_item OWNER TO evergreen;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE order_by_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.order_by_item_id_seq OWNER TO evergreen;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE order_by_item_id_seq OWNED BY order_by_item.id;


--
-- Name: query_sequence; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE query_sequence (
    id integer NOT NULL,
    parent_query integer NOT NULL,
    seq_no integer NOT NULL,
    child_query integer NOT NULL
);


ALTER TABLE query.query_sequence OWNER TO evergreen;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query_sequence_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.query_sequence_id_seq OWNER TO evergreen;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query_sequence_id_seq OWNED BY query_sequence.id;


--
-- Name: record_column; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_column (
    id integer NOT NULL,
    from_relation integer NOT NULL,
    seq_no integer NOT NULL,
    column_name text NOT NULL,
    column_type integer NOT NULL
);


ALTER TABLE query.record_column OWNER TO evergreen;

--
-- Name: record_column_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE record_column_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.record_column_id_seq OWNER TO evergreen;

--
-- Name: record_column_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE record_column_id_seq OWNED BY record_column.id;


--
-- Name: select_item; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE select_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL,
    column_alias text,
    grouped_by boolean DEFAULT false NOT NULL
);


ALTER TABLE query.select_item OWNER TO evergreen;

--
-- Name: select_item_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE select_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.select_item_id_seq OWNER TO evergreen;

--
-- Name: select_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE select_item_id_seq OWNED BY select_item.id;


--
-- Name: stored_query; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE stored_query (
    id integer NOT NULL,
    type text NOT NULL,
    use_all boolean DEFAULT false NOT NULL,
    use_distinct boolean DEFAULT false NOT NULL,
    from_clause integer,
    where_clause integer,
    having_clause integer,
    limit_count integer,
    offset_count integer,
    CONSTRAINT query_type CHECK ((type = ANY (ARRAY['SELECT'::text, 'UNION'::text, 'INTERSECT'::text, 'EXCEPT'::text])))
);


ALTER TABLE query.stored_query OWNER TO evergreen;

--
-- Name: stored_query_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE stored_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.stored_query_id_seq OWNER TO evergreen;

--
-- Name: stored_query_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE stored_query_id_seq OWNED BY stored_query.id;


--
-- Name: subfield; Type: TABLE; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE TABLE subfield (
    id integer NOT NULL,
    composite_type integer NOT NULL,
    seq_no integer NOT NULL,
    subfield_type integer NOT NULL,
    CONSTRAINT qsf_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.subfield OWNER TO evergreen;

--
-- Name: subfield_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE subfield_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.subfield_id_seq OWNER TO evergreen;

--
-- Name: subfield_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE subfield_id_seq OWNED BY subfield.id;


SET search_path = reporter, pg_catalog;

--
-- Name: circ_type; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW circ_type AS
    SELECT circulation.id, CASE WHEN ((circulation.opac_renewal OR circulation.phone_renewal) OR circulation.desk_renewal) THEN 'RENEWAL'::text ELSE 'CHECKOUT'::text END AS type FROM action.circulation;


ALTER TABLE reporter.circ_type OWNER TO evergreen;

--
-- Name: demographic; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW demographic AS
    SELECT u.id, u.dob, CASE WHEN (u.dob IS NULL) THEN 'Adult'::text WHEN (age(u.dob) > '18 years'::interval) THEN 'Adult'::text ELSE 'Juvenile'::text END AS general_division FROM actor.usr u;


ALTER TABLE reporter.demographic OWNER TO evergreen;

--
-- Name: classic_current_billing_summary; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW classic_current_billing_summary AS
    SELECT x.id, x.usr, bl.shortname AS billing_location_shortname, bl.name AS billing_location_name, x.billing_location, c.barcode, u.home_ou AS usr_home_ou, ul.shortname AS usr_home_ou_shortname, ul.name AS usr_home_ou_name, x.xact_start, x.xact_finish, x.xact_type, x.total_paid, x.total_owed, x.balance_owed, x.last_payment_ts, x.last_payment_note, x.last_payment_type, x.last_billing_ts, x.last_billing_note, x.last_billing_type, paddr.county AS patron_county, paddr.city AS patron_city, paddr.post_code AS patron_zip, g.name AS profile_group, dem.general_division AS demographic_general_division FROM (((((((money.open_billable_xact_summary x JOIN actor.org_unit bl ON ((x.billing_location = bl.id))) JOIN actor.usr u ON ((u.id = x.usr))) JOIN actor.org_unit ul ON ((u.home_ou = ul.id))) JOIN actor.card c ON ((u.card = c.id))) JOIN permission.grp_tree g ON ((u.profile = g.id))) JOIN demographic dem ON ((dem.id = u.id))) JOIN actor.usr_address paddr ON ((paddr.id = u.billing_address)));


ALTER TABLE reporter.classic_current_billing_summary OWNER TO evergreen;

--
-- Name: classic_current_circ; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW classic_current_circ AS
    SELECT cl.shortname AS circ_lib, cl.id AS circ_lib_id, circ.xact_start, circ_type.type AS circ_type, cp.id AS copy_id, cp.circ_modifier, ol.shortname AS owning_lib_name, lm.value AS language, lfm.value AS lit_form, ifm.value AS item_form, itm.value AS item_type, sl.name AS shelving_location, p.id AS patron_id, g.name AS profile_group, dem.general_division AS demographic_general_division, circ.id, cn.id AS call_number, cn.label AS call_number_label, public.call_number_dewey(cn.label) AS dewey, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text)) ELSE NULL::text END AS dewey_block_tens, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text)) ELSE NULL::text END AS dewey_block_hundreds, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN ((btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))) + (9)::double precision), '000'::text))) ELSE NULL::text END AS dewey_range_tens, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN ((btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))) + (99)::double precision), '000'::text))) ELSE NULL::text END AS dewey_range_hundreds, hl.id AS patron_home_lib, hl.shortname AS patron_home_lib_shortname, paddr.county AS patron_county, paddr.city AS patron_city, paddr.post_code AS patron_zip, sc1.stat_cat_entry AS stat_cat_1, sc2.stat_cat_entry AS stat_cat_2, sce1.value AS stat_cat_1_value, sce2.value AS stat_cat_2_value FROM ((((((((((((((((((((action.circulation circ JOIN circ_type circ_type ON ((circ.id = circ_type.id))) JOIN asset.copy cp ON ((cp.id = circ.target_copy))) JOIN asset.copy_location sl ON ((cp.location = sl.id))) JOIN asset.call_number cn ON ((cp.call_number = cn.id))) JOIN actor.org_unit ol ON ((cn.owning_lib = ol.id))) JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record))) JOIN actor.org_unit cl ON ((circ.circ_lib = cl.id))) JOIN actor.usr p ON ((p.id = circ.usr))) JOIN actor.org_unit hl ON ((p.home_ou = hl.id))) JOIN permission.grp_tree g ON ((p.profile = g.id))) JOIN demographic dem ON ((dem.id = p.id))) JOIN actor.usr_address paddr ON ((paddr.id = p.billing_address))) LEFT JOIN config.language_map lm ON ((rd.item_lang = lm.code))) LEFT JOIN config.lit_form_map lfm ON ((rd.lit_form = lfm.code))) LEFT JOIN config.item_form_map ifm ON ((rd.item_form = ifm.code))) LEFT JOIN config.item_type_map itm ON ((rd.item_type = itm.code))) LEFT JOIN asset.stat_cat_entry_copy_map sc1 ON (((sc1.owning_copy = cp.id) AND (sc1.stat_cat = 1)))) LEFT JOIN asset.stat_cat_entry sce1 ON ((sce1.id = sc1.stat_cat_entry))) LEFT JOIN asset.stat_cat_entry_copy_map sc2 ON (((sc2.owning_copy = cp.id) AND (sc2.stat_cat = 2)))) LEFT JOIN asset.stat_cat_entry sce2 ON ((sce2.id = sc2.stat_cat_entry)));


ALTER TABLE reporter.classic_current_circ OWNER TO evergreen;

--
-- Name: materialized_simple_record; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE materialized_simple_record (
    id bigint NOT NULL,
    fingerprint text,
    quality integer,
    tcn_source text,
    tcn_value text,
    title text,
    author text,
    publisher text,
    pubdate text,
    isbn text[],
    issn text[]
);


ALTER TABLE reporter.materialized_simple_record OWNER TO evergreen;

--
-- Name: classic_item_list; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW classic_item_list AS
    SELECT rmsr.title, rmsr.author, rmsr.pubdate, cp.id, cp.price, cp.barcode, cn.label AS call_number_label, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text)) ELSE NULL::text END AS dewey_block_tens, CASE WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text)) ELSE NULL::text END AS dewey_block_hundreds, erfcc.circ_count AS use_count, cp.circ_modifier, sl.name AS shelving_location, sc1.stat_cat_entry AS stat_cat_1, sc2.stat_cat_entry AS stat_cat_2, sce1.value AS stat_cat_1_value, sce2.value AS stat_cat_2_value, cp.edit_date, cp.create_date, ol.shortname AS owning_lib_name, cn.owning_lib, cl.shortname AS circ_lib_name, cl.id AS circ_lib, cp.creator, cp.age_protect, cp.opac_visible, cp.ref, cp.deposit_amount, cp.deleted, rmsr.tcn_value, cp.status, circ.stop_fines, circ.due_date, circ_card.barcode AS patron_barcode, ((circ_u.first_given_name || ' '::text) || circ_u.family_name) AS patron_name FROM (((((((((((((asset.copy cp JOIN extend_reporter.full_circ_count erfcc ON ((cp.id = erfcc.id))) JOIN asset.copy_location sl ON ((cp.location = sl.id))) JOIN asset.call_number cn ON ((cp.call_number = cn.id))) JOIN actor.org_unit ol ON ((cn.owning_lib = ol.id))) JOIN actor.org_unit cl ON ((cp.circ_lib = cl.id))) JOIN materialized_simple_record rmsr ON ((cn.record = rmsr.id))) LEFT JOIN action.circulation circ ON (((circ.target_copy = cp.id) AND (circ.checkin_time IS NULL)))) LEFT JOIN actor.usr circ_u ON ((circ_u.id = circ.usr))) LEFT JOIN actor.card circ_card ON ((circ_u.card = circ_card.id))) LEFT JOIN asset.stat_cat_entry_copy_map sc1 ON (((sc1.owning_copy = cp.id) AND (sc1.stat_cat = 1)))) LEFT JOIN asset.stat_cat_entry sce1 ON ((sce1.id = sc1.stat_cat_entry))) LEFT JOIN asset.stat_cat_entry_copy_map sc2 ON (((sc2.owning_copy = cp.id) AND (sc2.stat_cat = 2)))) LEFT JOIN asset.stat_cat_entry sce2 ON ((sce2.id = sc2.stat_cat_entry)));


ALTER TABLE reporter.classic_item_list OWNER TO evergreen;

--
-- Name: report; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE report (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text DEFAULT ''::text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    template integer NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL,
    recur boolean DEFAULT false NOT NULL,
    recurrence interval
);


ALTER TABLE reporter.report OWNER TO evergreen;

--
-- Name: schedule; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE schedule (
    id integer NOT NULL,
    report integer NOT NULL,
    folder integer NOT NULL,
    runner integer NOT NULL,
    run_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    complete_time timestamp with time zone,
    email text,
    excel_format boolean DEFAULT true NOT NULL,
    html_format boolean DEFAULT true NOT NULL,
    csv_format boolean DEFAULT true NOT NULL,
    chart_pie boolean DEFAULT false NOT NULL,
    chart_bar boolean DEFAULT false NOT NULL,
    chart_line boolean DEFAULT false NOT NULL,
    error_code integer,
    error_text text
);


ALTER TABLE reporter.schedule OWNER TO evergreen;

--
-- Name: currently_running; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW currently_running AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE ((s.start_time IS NOT NULL) AND (s.complete_time IS NULL));


ALTER TABLE reporter.currently_running OWNER TO evergreen;

SET search_path = serial, pg_catalog;

--
-- Name: issuance; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE issuance (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    subscription integer NOT NULL,
    label text,
    date_published timestamp with time zone,
    holding_code text,
    holding_type text,
    holding_link_id integer,
    caption_and_pattern integer,
    CONSTRAINT issuance_holding_code_check CHECK (((holding_code IS NULL) OR evergreen.could_be_serial_holding_code(holding_code))),
    CONSTRAINT valid_holding_type CHECK (((holding_type IS NULL) OR (holding_type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text]))))
);


ALTER TABLE serial.issuance OWNER TO evergreen;

--
-- Name: subscription; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE subscription (
    id integer NOT NULL,
    start_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    record_entry bigint,
    expected_date_offset interval,
    owning_lib integer DEFAULT 1 NOT NULL
);


ALTER TABLE serial.subscription OWNER TO evergreen;

SET search_path = reporter, pg_catalog;

--
-- Name: hold_request_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW hold_request_record AS
    SELECT ahr.id, ahr.target, ahr.hold_type, CASE WHEN (ahr.hold_type = 'T'::text) THEN ahr.target WHEN (ahr.hold_type = 'I'::text) THEN (SELECT ssub.record_entry FROM (serial.subscription ssub JOIN serial.issuance si ON ((si.subscription = ssub.id))) WHERE (si.id = ahr.target)) WHEN (ahr.hold_type = 'V'::text) THEN (SELECT cn.record FROM asset.call_number cn WHERE (cn.id = ahr.target)) WHEN (ahr.hold_type = ANY (ARRAY['C'::text, 'R'::text, 'F'::text])) THEN (SELECT cn.record FROM (asset.call_number cn JOIN asset.copy cp ON ((cn.id = cp.call_number))) WHERE (cp.id = ahr.target)) WHEN (ahr.hold_type = 'M'::text) THEN (SELECT mr.master_record FROM metabib.metarecord mr WHERE (mr.id = ahr.target)) WHEN (ahr.hold_type = 'P'::text) THEN (SELECT bmp.record FROM biblio.monograph_part bmp WHERE (bmp.id = ahr.target)) ELSE NULL::bigint END AS bib_record FROM action.hold_request ahr;


ALTER TABLE reporter.hold_request_record OWNER TO evergreen;

--
-- Name: legacy_cat1; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW legacy_cat1 AS
    SELECT stat_cat_entry.id, stat_cat_entry.owner, stat_cat_entry.value FROM asset.stat_cat_entry WHERE (stat_cat_entry.stat_cat = 1);


ALTER TABLE reporter.legacy_cat1 OWNER TO evergreen;

--
-- Name: legacy_cat2; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW legacy_cat2 AS
    SELECT stat_cat_entry.id, stat_cat_entry.owner, stat_cat_entry.value FROM asset.stat_cat_entry WHERE (stat_cat_entry.stat_cat = 2);


ALTER TABLE reporter.legacy_cat2 OWNER TO evergreen;

--
-- Name: old_super_simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW old_super_simple_record AS
    SELECT r.id, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, public.first(title.value) AS title, public.first(author.value) AS author, array_to_string(public.array_accum(DISTINCT publisher.value), ', '::text) AS publisher, array_to_string(public.array_accum(DISTINCT "substring"(pubdate.value, '\d+'::text)), ', '::text) AS pubdate, public.array_accum(DISTINCT replace("substring"(isbn.value, '^\S+'::text), '-'::text, ''::text)) AS isbn, public.array_accum(DISTINCT regexp_replace(issn.value, '^\S*(\d{4})[-\s](\d{3,4}x?)'::text, '\1 \2'::text)) AS issn FROM ((((((biblio.record_entry r LEFT JOIN metabib.full_rec title ON ((((r.id = title.record) AND (title.tag = '245'::bpchar)) AND (title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec author ON ((((r.id = author.record) AND (author.tag = ANY (ARRAY['100'::bpchar, '110'::bpchar, '111'::bpchar]))) AND (author.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec publisher ON ((((r.id = publisher.record) AND ((publisher.tag = '260'::bpchar) OR ((publisher.tag = '264'::bpchar) AND (publisher.ind2 = '1'::text)))) AND (publisher.subfield = 'b'::text)))) LEFT JOIN metabib.full_rec pubdate ON ((((r.id = pubdate.record) AND ((pubdate.tag = '260'::bpchar) OR ((pubdate.tag = '264'::bpchar) AND (pubdate.ind2 = '1'::text)))) AND (pubdate.subfield = 'c'::text)))) LEFT JOIN metabib.full_rec isbn ON ((((r.id = isbn.record) AND (isbn.tag = ANY (ARRAY['024'::bpchar, '020'::bpchar]))) AND (isbn.subfield = ANY (ARRAY['a'::text, 'z'::text]))))) LEFT JOIN metabib.full_rec issn ON ((((r.id = issn.record) AND (issn.tag = '022'::bpchar)) AND (issn.subfield = 'a'::text)))) GROUP BY r.id, r.fingerprint, r.quality, r.tcn_source, r.tcn_value;


ALTER TABLE reporter.old_super_simple_record OWNER TO evergreen;

--
-- Name: output_folder; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE output_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.output_folder OWNER TO evergreen;

--
-- Name: output_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE output_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.output_folder_id_seq OWNER TO evergreen;

--
-- Name: output_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE output_folder_id_seq OWNED BY output_folder.id;


--
-- Name: overdue_circs; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW overdue_circs AS
    SELECT circulation.id, circulation.usr, circulation.xact_start, circulation.xact_finish, circulation.unrecovered, circulation.target_copy, circulation.circ_lib, circulation.circ_staff, circulation.checkin_staff, circulation.checkin_lib, circulation.renewal_remaining, circulation.due_date, circulation.stop_fines_time, circulation.checkin_time, circulation.create_time, circulation.duration, circulation.fine_interval, circulation.recurring_fine, circulation.max_fine, circulation.phone_renewal, circulation.desk_renewal, circulation.opac_renewal, circulation.duration_rule, circulation.recurring_fine_rule, circulation.max_fine_rule, circulation.stop_fines, circulation.workstation, circulation.checkin_workstation, circulation.checkin_scan_time, circulation.parent_circ FROM action.circulation WHERE (((circulation.checkin_time IS NULL) AND ((circulation.stop_fines <> ALL (ARRAY['LOST'::text, 'CLAIMSRETURNED'::text])) OR (circulation.stop_fines IS NULL))) AND (circulation.due_date < now()));


ALTER TABLE reporter.overdue_circs OWNER TO evergreen;

--
-- Name: overdue_reports; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW overdue_reports AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE ((s.start_time IS NULL) AND (s.run_time < now()));


ALTER TABLE reporter.overdue_reports OWNER TO evergreen;

--
-- Name: pending_reports; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW pending_reports AS
    SELECT s.id, c.barcode AS runner_barcode, r.name, s.run_time, (s.run_time - now()) AS scheduled_wait_time FROM (((schedule s JOIN report r ON ((r.id = s.report))) JOIN actor.usr u ON ((s.runner = u.id))) JOIN actor.card c ON ((c.id = u.card))) WHERE (s.start_time IS NULL);


ALTER TABLE reporter.pending_reports OWNER TO evergreen;

--
-- Name: report_folder; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE report_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.report_folder OWNER TO evergreen;

--
-- Name: report_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE report_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_folder_id_seq OWNER TO evergreen;

--
-- Name: report_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE report_folder_id_seq OWNED BY report_folder.id;


--
-- Name: report_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_id_seq OWNER TO evergreen;

--
-- Name: report_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE report_id_seq OWNED BY report.id;


--
-- Name: schedule_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE schedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.schedule_id_seq OWNER TO evergreen;

--
-- Name: schedule_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE schedule_id_seq OWNED BY schedule.id;


--
-- Name: simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW simple_record AS
    SELECT r.id, s.metarecord, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, title.value AS title, uniform_title.value AS uniform_title, author.value AS author, publisher.value AS publisher, "substring"(pubdate.value, '\d+'::text) AS pubdate, series_title.value AS series_title, series_statement.value AS series_statement, summary.value AS summary, public.array_accum(DISTINCT replace("substring"(isbn.value, '^\S+'::text), '-'::text, ''::text)) AS isbn, public.array_accum(DISTINCT regexp_replace(issn.value, '^\S*(\d{4})[-\s](\d{3,4}x?)'::text, '\1 \2'::text)) AS issn, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '650'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS topic_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '651'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS geographic_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '655'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS genre, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '600'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS name_subject, ARRAY(SELECT DISTINCT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '610'::bpchar) AND (full_rec.subfield = 'a'::text)) AND (full_rec.record = r.id))) AS corporate_subject, ARRAY(SELECT full_rec.value FROM metabib.full_rec WHERE (((full_rec.tag = '856'::bpchar) AND (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text, 'u'::text]))) AND (full_rec.record = r.id)) ORDER BY CASE WHEN (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text])) THEN 0 ELSE 1 END) AS external_uri FROM (((((((((((biblio.record_entry r JOIN metabib.metarecord_source_map s ON ((s.source = r.id))) LEFT JOIN metabib.full_rec uniform_title ON ((((r.id = uniform_title.record) AND (uniform_title.tag = '240'::bpchar)) AND (uniform_title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec title ON ((((r.id = title.record) AND (title.tag = '245'::bpchar)) AND (title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec author ON ((((r.id = author.record) AND (author.tag = '100'::bpchar)) AND (author.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec publisher ON ((((r.id = publisher.record) AND (publisher.tag = '260'::bpchar)) AND (publisher.subfield = 'b'::text)))) LEFT JOIN metabib.full_rec pubdate ON ((((r.id = pubdate.record) AND (pubdate.tag = '260'::bpchar)) AND (pubdate.subfield = 'c'::text)))) LEFT JOIN metabib.full_rec isbn ON ((((r.id = isbn.record) AND (isbn.tag = ANY (ARRAY['024'::bpchar, '020'::bpchar]))) AND (isbn.subfield = ANY (ARRAY['a'::text, 'z'::text]))))) LEFT JOIN metabib.full_rec issn ON ((((r.id = issn.record) AND (issn.tag = '022'::bpchar)) AND (issn.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec series_title ON ((((r.id = series_title.record) AND (series_title.tag = ANY (ARRAY['830'::bpchar, '440'::bpchar]))) AND (series_title.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec series_statement ON ((((r.id = series_statement.record) AND (series_statement.tag = '490'::bpchar)) AND (series_statement.subfield = 'a'::text)))) LEFT JOIN metabib.full_rec summary ON ((((r.id = summary.record) AND (summary.tag = '520'::bpchar)) AND (summary.subfield = 'a'::text)))) GROUP BY r.id, s.metarecord, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, title.value, uniform_title.value, author.value, publisher.value, "substring"(pubdate.value, '\d+'::text), series_title.value, series_statement.value, summary.value;


ALTER TABLE reporter.simple_record OWNER TO evergreen;

--
-- Name: super_simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW super_simple_record AS
    SELECT materialized_simple_record.id, materialized_simple_record.fingerprint, materialized_simple_record.quality, materialized_simple_record.tcn_source, materialized_simple_record.tcn_value, materialized_simple_record.title, materialized_simple_record.author, materialized_simple_record.publisher, materialized_simple_record.pubdate, materialized_simple_record.isbn, materialized_simple_record.issn FROM materialized_simple_record;


ALTER TABLE reporter.super_simple_record OWNER TO evergreen;

--
-- Name: template; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE template (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL
);


ALTER TABLE reporter.template OWNER TO evergreen;

--
-- Name: template_folder; Type: TABLE; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE TABLE template_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer
);


ALTER TABLE reporter.template_folder OWNER TO evergreen;

--
-- Name: template_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE template_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_folder_id_seq OWNER TO evergreen;

--
-- Name: template_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE template_folder_id_seq OWNED BY template_folder.id;


--
-- Name: template_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_id_seq OWNER TO evergreen;

--
-- Name: template_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE template_id_seq OWNED BY template.id;


--
-- Name: xact_billing_totals; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW xact_billing_totals AS
    SELECT b.xact, sum(CASE WHEN b.voided THEN (0)::numeric ELSE b.amount END) AS unvoided, sum(CASE WHEN b.voided THEN b.amount ELSE (0)::numeric END) AS voided, sum(b.amount) AS total FROM money.billing b GROUP BY b.xact;


ALTER TABLE reporter.xact_billing_totals OWNER TO evergreen;

--
-- Name: xact_paid_totals; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW xact_paid_totals AS
    SELECT b.xact, sum(CASE WHEN b.voided THEN (0)::numeric ELSE b.amount END) AS unvoided, sum(CASE WHEN b.voided THEN b.amount ELSE (0)::numeric END) AS voided, sum(b.amount) AS total FROM money.payment b GROUP BY b.xact;


ALTER TABLE reporter.xact_paid_totals OWNER TO evergreen;

SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment; Type: TABLE; Schema: search; Owner: evergreen; Tablespace: 
--

CREATE TABLE relevance_adjustment (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    field integer NOT NULL,
    bump_type text NOT NULL,
    multiplier numeric DEFAULT 1.0 NOT NULL,
    CONSTRAINT relevance_adjustment_bump_type_check CHECK ((bump_type = ANY (ARRAY['word_order'::text, 'first_word'::text, 'full_match'::text])))
);


ALTER TABLE search.relevance_adjustment OWNER TO evergreen;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE; Schema: search; Owner: evergreen
--

CREATE SEQUENCE relevance_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE search.relevance_adjustment_id_seq OWNER TO evergreen;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: search; Owner: evergreen
--

ALTER SEQUENCE relevance_adjustment_id_seq OWNED BY relevance_adjustment.id;


SET search_path = serial, pg_catalog;

--
-- Name: basic_summary; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE basic_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.basic_summary OWNER TO evergreen;

--
-- Name: index_summary; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE index_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.index_summary OWNER TO evergreen;

--
-- Name: supplement_summary; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE supplement_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.supplement_summary OWNER TO evergreen;

--
-- Name: any_summary; Type: VIEW; Schema: serial; Owner: evergreen
--

CREATE VIEW any_summary AS
    (SELECT 'basic'::text AS summary_type, basic_summary.id, basic_summary.distribution, basic_summary.generated_coverage, basic_summary.textual_holdings, basic_summary.show_generated FROM basic_summary UNION SELECT 'index'::text AS summary_type, index_summary.id, index_summary.distribution, index_summary.generated_coverage, index_summary.textual_holdings, index_summary.show_generated FROM index_summary) UNION SELECT 'supplement'::text AS summary_type, supplement_summary.id, supplement_summary.distribution, supplement_summary.generated_coverage, supplement_summary.textual_holdings, supplement_summary.show_generated FROM supplement_summary;


ALTER TABLE serial.any_summary OWNER TO evergreen;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE basic_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.basic_summary_id_seq OWNER TO evergreen;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE basic_summary_id_seq OWNED BY basic_summary.id;


--
-- Name: caption_and_pattern; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE caption_and_pattern (
    id integer NOT NULL,
    type text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT false NOT NULL,
    pattern_code text NOT NULL,
    enum_1 text,
    enum_2 text,
    enum_3 text,
    enum_4 text,
    enum_5 text,
    enum_6 text,
    chron_1 text,
    chron_2 text,
    chron_3 text,
    chron_4 text,
    chron_5 text,
    subscription integer NOT NULL,
    start_date timestamp with time zone DEFAULT now(),
    end_date timestamp with time zone,
    CONSTRAINT cap_type CHECK ((type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text])))
);


ALTER TABLE serial.caption_and_pattern OWNER TO evergreen;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE caption_and_pattern_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.caption_and_pattern_id_seq OWNER TO evergreen;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE caption_and_pattern_id_seq OWNED BY caption_and_pattern.id;


--
-- Name: distribution; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE distribution (
    id integer NOT NULL,
    subscription integer NOT NULL,
    holding_lib integer NOT NULL,
    label text NOT NULL,
    receive_call_number bigint,
    receive_unit_template integer,
    bind_call_number bigint,
    bind_unit_template integer,
    unit_label_prefix text,
    unit_label_suffix text,
    record_entry integer,
    summary_method text,
    display_grouping text DEFAULT 'chron'::text NOT NULL,
    CONSTRAINT distribution_display_grouping_check CHECK ((display_grouping = ANY (ARRAY['enum'::text, 'chron'::text]))),
    CONSTRAINT summary_method_check CHECK (((summary_method IS NULL) OR (summary_method = ANY (ARRAY['add_to_sre'::text, 'merge_with_sre'::text, 'use_sre_only'::text, 'use_sdist_only'::text]))))
);


ALTER TABLE serial.distribution OWNER TO evergreen;

--
-- Name: distribution_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE distribution_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_id_seq OWNER TO evergreen;

--
-- Name: distribution_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE distribution_id_seq OWNED BY distribution.id;


--
-- Name: distribution_note; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE distribution_note (
    id integer NOT NULL,
    distribution integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.distribution_note OWNER TO evergreen;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE distribution_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_note_id_seq OWNER TO evergreen;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE distribution_note_id_seq OWNED BY distribution_note.id;


--
-- Name: index_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE index_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.index_summary_id_seq OWNER TO evergreen;

--
-- Name: index_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE index_summary_id_seq OWNED BY index_summary.id;


--
-- Name: issuance_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE issuance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.issuance_id_seq OWNER TO evergreen;

--
-- Name: issuance_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE issuance_id_seq OWNED BY issuance.id;


--
-- Name: item; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE item (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    issuance integer NOT NULL,
    stream integer NOT NULL,
    unit integer,
    uri integer,
    date_expected timestamp with time zone,
    date_received timestamp with time zone,
    status text DEFAULT 'Expected'::text,
    shadowed boolean DEFAULT false NOT NULL,
    CONSTRAINT value_status_check CHECK ((status = ANY (ARRAY['Bindery'::text, 'Bound'::text, 'Claimed'::text, 'Discarded'::text, 'Expected'::text, 'Not Held'::text, 'Not Published'::text, 'Received'::text])))
);


ALTER TABLE serial.item OWNER TO evergreen;

--
-- Name: item_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_id_seq OWNER TO evergreen;

--
-- Name: item_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE item_id_seq OWNED BY item.id;


--
-- Name: item_note; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.item_note OWNER TO evergreen;

--
-- Name: item_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_note_id_seq OWNER TO evergreen;

--
-- Name: item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE item_note_id_seq OWNED BY item_note.id;


--
-- Name: materialized_holding_code; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE materialized_holding_code (
    id bigint NOT NULL,
    issuance integer NOT NULL,
    subfield character(1),
    value text
);


ALTER TABLE serial.materialized_holding_code OWNER TO evergreen;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE materialized_holding_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.materialized_holding_code_id_seq OWNER TO evergreen;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE materialized_holding_code_id_seq OWNED BY materialized_holding_code.id;


--
-- Name: record_entry; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE record_entry (
    id bigint NOT NULL,
    record bigint,
    owning_lib integer DEFAULT 1 NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    marc text,
    last_xact_id text NOT NULL,
    owner integer
);


ALTER TABLE serial.record_entry OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE record_entry_id_seq OWNED BY record_entry.id;


--
-- Name: routing_list_user; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE routing_list_user (
    id integer NOT NULL,
    stream integer NOT NULL,
    pos integer DEFAULT 1 NOT NULL,
    reader integer,
    department text,
    note text,
    CONSTRAINT reader_or_dept CHECK ((((reader IS NOT NULL) AND (department IS NULL)) OR ((reader IS NULL) AND (department IS NOT NULL))))
);


ALTER TABLE serial.routing_list_user OWNER TO evergreen;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE routing_list_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.routing_list_user_id_seq OWNER TO evergreen;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE routing_list_user_id_seq OWNED BY routing_list_user.id;


--
-- Name: stream; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE stream (
    id integer NOT NULL,
    distribution integer NOT NULL,
    routing_label text
);


ALTER TABLE serial.stream OWNER TO evergreen;

--
-- Name: stream_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE stream_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.stream_id_seq OWNER TO evergreen;

--
-- Name: stream_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE stream_id_seq OWNED BY stream.id;


--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_id_seq OWNER TO evergreen;

--
-- Name: subscription_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE subscription_id_seq OWNED BY subscription.id;


--
-- Name: subscription_note; Type: TABLE; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE TABLE subscription_note (
    id integer NOT NULL,
    subscription integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE serial.subscription_note OWNER TO evergreen;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE subscription_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_note_id_seq OWNER TO evergreen;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE subscription_note_id_seq OWNED BY subscription_note.id;


--
-- Name: supplement_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE supplement_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.supplement_summary_id_seq OWNER TO evergreen;

--
-- Name: supplement_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE supplement_summary_id_seq OWNED BY supplement_summary.id;


SET search_path = sip_temp, pg_catalog;

--
-- Name: user; Type: TABLE; Schema: sip_temp; Owner: evergreen; Tablespace: 
--

CREATE TABLE "user" (
    usrname text,
    passwd text,
    org_unit text
);


ALTER TABLE sip_temp."user" OWNER TO evergreen;

SET search_path = staging, pg_catalog;

--
-- Name: mailing_address_stage; Type: TABLE; Schema: staging; Owner: evergreen; Tablespace: 
--

CREATE TABLE mailing_address_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text DEFAULT 'OK'::text NOT NULL,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.mailing_address_stage OWNER TO evergreen;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE mailing_address_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.mailing_address_stage_row_id_seq OWNER TO evergreen;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE mailing_address_stage_row_id_seq OWNED BY mailing_address_stage.row_id;


--
-- Name: billing_address_stage; Type: TABLE; Schema: staging; Owner: evergreen; Tablespace: 
--

CREATE TABLE billing_address_stage (
    row_id bigint DEFAULT nextval('mailing_address_stage_row_id_seq'::regclass) NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text DEFAULT 'OK'::text NOT NULL,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.billing_address_stage OWNER TO evergreen;

--
-- Name: card_stage; Type: TABLE; Schema: staging; Owner: evergreen; Tablespace: 
--

CREATE TABLE card_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    barcode text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.card_stage OWNER TO evergreen;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE card_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.card_stage_row_id_seq OWNER TO evergreen;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE card_stage_row_id_seq OWNED BY card_stage.row_id;


--
-- Name: statcat_stage; Type: TABLE; Schema: staging; Owner: evergreen; Tablespace: 
--

CREATE TABLE statcat_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    statcat text NOT NULL,
    value text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.statcat_stage OWNER TO evergreen;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE statcat_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.statcat_stage_row_id_seq OWNER TO evergreen;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE statcat_stage_row_id_seq OWNED BY statcat_stage.row_id;


--
-- Name: user_stage; Type: TABLE; Schema: staging; Owner: evergreen; Tablespace: 
--

CREATE TABLE user_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    profile text,
    email text,
    passwd text,
    ident_type integer DEFAULT 3,
    first_given_name text,
    second_given_name text,
    family_name text,
    day_phone text,
    evening_phone text,
    home_ou integer DEFAULT 2,
    dob text,
    complete boolean DEFAULT false
);


ALTER TABLE staging.user_stage OWNER TO evergreen;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE user_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.user_stage_row_id_seq OWNER TO evergreen;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE user_stage_row_id_seq OWNED BY user_stage.row_id;


SET search_path = stats, pg_catalog;

--
-- Name: fleshed_call_number; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW fleshed_call_number AS
    SELECT cn.id, cn.creator, cn.create_date, cn.editor, cn.edit_date, cn.record, cn.owning_lib, cn.label, cn.deleted, cn.label_class, cn.label_sortkey, cn.prefix, cn.suffix, (cn.create_date)::date AS create_date_day, (cn.edit_date)::date AS edit_date_day, date_trunc('hour'::text, cn.create_date) AS create_date_hour, date_trunc('hour'::text, cn.edit_date) AS edit_date_hour, rd.item_lang, rd.item_type, rd.item_form FROM (asset.call_number cn JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record)));


ALTER TABLE stats.fleshed_call_number OWNER TO evergreen;

--
-- Name: fleshed_copy; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW fleshed_copy AS
    SELECT cp.id, cp.circ_lib, cp.creator, cp.call_number, cp.editor, cp.create_date, cp.edit_date, cp.copy_number, cp.status, cp.location, cp.loan_duration, cp.fine_level, cp.age_protect, cp.circulate, cp.deposit, cp.ref, cp.holdable, cp.deposit_amount, cp.price, cp.barcode, cp.circ_modifier, cp.circ_as_type, cp.dummy_title, cp.dummy_author, cp.alert_message, cp.opac_visible, cp.deleted, cp.floating, cp.dummy_isbn, cp.status_changed_time, cp.mint_condition, cp.cost, (cp.create_date)::date AS create_date_day, (cp.edit_date)::date AS edit_date_day, date_trunc('hour'::text, cp.create_date) AS create_date_hour, date_trunc('hour'::text, cp.edit_date) AS edit_date_hour, cn.label AS call_number_label, cn.owning_lib, rd.item_lang, rd.item_type, rd.item_form FROM ((asset.copy cp JOIN asset.call_number cn ON ((cp.call_number = cn.id))) JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record)));


ALTER TABLE stats.fleshed_copy OWNER TO evergreen;

--
-- Name: fleshed_circulation; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW fleshed_circulation AS
    SELECT c.id, c.usr, c.xact_start, c.xact_finish, c.unrecovered, c.target_copy, c.circ_lib, c.circ_staff, c.checkin_staff, c.checkin_lib, c.renewal_remaining, c.due_date, c.stop_fines_time, c.checkin_time, c.create_time, c.duration, c.fine_interval, c.recurring_fine, c.max_fine, c.phone_renewal, c.desk_renewal, c.opac_renewal, c.duration_rule, c.recurring_fine_rule, c.max_fine_rule, c.stop_fines, c.workstation, c.checkin_workstation, c.checkin_scan_time, c.parent_circ, c.grace_period, (c.xact_start)::date AS start_date_day, (c.xact_finish)::date AS finish_date_day, date_trunc('hour'::text, c.xact_start) AS start_date_hour, date_trunc('hour'::text, c.xact_finish) AS finish_date_hour, cp.call_number_label, cp.owning_lib, cp.item_lang, cp.item_type, cp.item_form FROM (action.circulation c JOIN fleshed_copy cp ON ((cp.id = c.target_copy)));


ALTER TABLE stats.fleshed_circulation OWNER TO evergreen;

SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout; Type: TABLE; Schema: unapi; Owner: evergreen; Tablespace: 
--

CREATE TABLE bre_output_layout (
    name text NOT NULL,
    transform text,
    mime_type text NOT NULL,
    feed_top text NOT NULL,
    holdings_element text,
    title_element text,
    description_element text,
    creator_element text,
    update_ts_element text
);


ALTER TABLE unapi.bre_output_layout OWNER TO evergreen;

SET search_path = url_verify, pg_catalog;

--
-- Name: session; Type: TABLE; Schema: url_verify; Owner: evergreen; Tablespace: 
--

CREATE TABLE session (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    container integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    search text NOT NULL
);


ALTER TABLE url_verify.session OWNER TO evergreen;

--
-- Name: session_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.session_id_seq OWNER TO evergreen;

--
-- Name: session_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE session_id_seq OWNED BY session.id;


--
-- Name: url_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_id_seq OWNER TO evergreen;

--
-- Name: url_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_id_seq OWNED BY url.id;


--
-- Name: url_selector; Type: TABLE; Schema: url_verify; Owner: evergreen; Tablespace: 
--

CREATE TABLE url_selector (
    id integer NOT NULL,
    xpath text NOT NULL,
    session integer NOT NULL
);


ALTER TABLE url_verify.url_selector OWNER TO evergreen;

--
-- Name: url_selector_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_selector_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_selector_id_seq OWNER TO evergreen;

--
-- Name: url_selector_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_selector_id_seq OWNED BY url_selector.id;


--
-- Name: url_verification; Type: TABLE; Schema: url_verify; Owner: evergreen; Tablespace: 
--

CREATE TABLE url_verification (
    id integer NOT NULL,
    url integer NOT NULL,
    attempt integer NOT NULL,
    req_time timestamp with time zone DEFAULT now() NOT NULL,
    res_time timestamp with time zone,
    res_code integer,
    res_text text,
    redirect_to integer,
    CONSTRAINT url_verification_res_code_check CHECK (((res_code >= 100) AND (res_code <= 999)))
);


ALTER TABLE url_verify.url_verification OWNER TO evergreen;

--
-- Name: url_verification_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_verification_id_seq OWNER TO evergreen;

--
-- Name: url_verification_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verification_id_seq OWNED BY url_verification.id;


--
-- Name: verification_attempt; Type: TABLE; Schema: url_verify; Owner: evergreen; Tablespace: 
--

CREATE TABLE verification_attempt (
    id integer NOT NULL,
    usr integer NOT NULL,
    session integer NOT NULL,
    start_time timestamp with time zone DEFAULT now() NOT NULL,
    finish_time timestamp with time zone
);


ALTER TABLE url_verify.verification_attempt OWNER TO evergreen;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE verification_attempt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.verification_attempt_id_seq OWNER TO evergreen;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE verification_attempt_id_seq OWNED BY verification_attempt.id;


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE authority_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.authority_attr_definition OWNER TO evergreen;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE authority_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE authority_attr_definition_id_seq OWNED BY authority_attr_definition.id;


--
-- Name: authority_match; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE authority_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 0 NOT NULL,
    match_score integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.authority_match OWNER TO evergreen;

--
-- Name: authority_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE authority_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_match_id_seq OWNER TO evergreen;

--
-- Name: authority_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE authority_match_id_seq OWNED BY authority_match.id;


--
-- Name: queue; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queue (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    complete boolean DEFAULT false NOT NULL,
    match_set integer
);


ALTER TABLE vandelay.queue OWNER TO evergreen;

--
-- Name: authority_queue; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE authority_queue (
    queue_type authority_queue_queue_type DEFAULT 'authority'::authority_queue_queue_type NOT NULL
)
INHERITS (queue);


ALTER TABLE vandelay.authority_queue OWNER TO evergreen;

--
-- Name: bib_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.bib_attr_definition OWNER TO evergreen;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE bib_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE bib_attr_definition_id_seq OWNED BY bib_attr_definition.id;


--
-- Name: bib_match; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 1 NOT NULL,
    match_score integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.bib_match OWNER TO evergreen;

--
-- Name: bib_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE bib_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_match_id_seq OWNER TO evergreen;

--
-- Name: bib_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE bib_match_id_seq OWNED BY bib_match.id;


--
-- Name: bib_queue; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE bib_queue (
    queue_type bib_queue_queue_type DEFAULT 'bib'::bib_queue_queue_type NOT NULL,
    item_attr_def bigint
)
INHERITS (queue);


ALTER TABLE vandelay.bib_queue OWNER TO evergreen;

--
-- Name: import_bib_trash_fields; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE import_bib_trash_fields (
    id bigint NOT NULL,
    field text NOT NULL,
    grp integer NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_fields OWNER TO evergreen;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE import_bib_trash_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_fields_id_seq OWNER TO evergreen;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE import_bib_trash_fields_id_seq OWNED BY import_bib_trash_fields.id;


--
-- Name: import_bib_trash_group; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE import_bib_trash_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    label text NOT NULL,
    always_apply boolean DEFAULT false NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_group OWNER TO evergreen;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE import_bib_trash_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_group_id_seq OWNER TO evergreen;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE import_bib_trash_group_id_seq OWNED BY import_bib_trash_group.id;


--
-- Name: import_error; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE import_error (
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE vandelay.import_error OWNER TO evergreen;

--
-- Name: import_item_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE import_item_attr_definition (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    tag text NOT NULL,
    keep boolean DEFAULT false NOT NULL,
    owning_lib text,
    circ_lib text,
    call_number text,
    copy_number text,
    status text,
    location text,
    circulate text,
    deposit text,
    deposit_amount text,
    ref text,
    holdable text,
    price text,
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible text,
    pub_note_title text,
    pub_note text,
    priv_note_title text,
    priv_note text,
    internal_id text
);


ALTER TABLE vandelay.import_item_attr_definition OWNER TO evergreen;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE import_item_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE import_item_attr_definition_id_seq OWNED BY import_item_attr_definition.id;


--
-- Name: import_item_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE import_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_id_seq OWNER TO evergreen;

--
-- Name: import_item_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE import_item_id_seq OWNED BY import_item.id;


--
-- Name: match_set; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE match_set (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    mtype text DEFAULT 'biblio'::text NOT NULL
);


ALTER TABLE vandelay.match_set OWNER TO evergreen;

--
-- Name: match_set_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE match_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_id_seq OWNER TO evergreen;

--
-- Name: match_set_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE match_set_id_seq OWNED BY match_set.id;


--
-- Name: match_set_point_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE match_set_point_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_point_id_seq OWNER TO evergreen;

--
-- Name: match_set_point_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE match_set_point_id_seq OWNED BY match_set_point.id;


--
-- Name: match_set_quality; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE match_set_quality (
    id integer NOT NULL,
    match_set integer NOT NULL,
    svf text,
    tag text,
    subfield text,
    value text NOT NULL,
    quality integer DEFAULT 1 NOT NULL,
    CONSTRAINT vmsq_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsq_need_a_tag_or_a_ff CHECK ((((tag IS NOT NULL) AND (svf IS NULL)) OR ((tag IS NULL) AND (svf IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_quality OWNER TO evergreen;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE match_set_quality_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_quality_id_seq OWNER TO evergreen;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE match_set_quality_id_seq OWNED BY match_set_quality.id;


--
-- Name: merge_profile; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE merge_profile (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    add_spec text,
    replace_spec text,
    strip_spec text,
    preserve_spec text,
    lwm_ratio numeric,
    CONSTRAINT add_replace_strip_or_preserve CHECK ((((preserve_spec IS NOT NULL) OR (replace_spec IS NOT NULL)) OR ((preserve_spec IS NULL) AND (replace_spec IS NULL))))
);


ALTER TABLE vandelay.merge_profile OWNER TO evergreen;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE merge_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.merge_profile_id_seq OWNER TO evergreen;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE merge_profile_id_seq OWNED BY merge_profile.id;


--
-- Name: queue_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queue_id_seq OWNER TO evergreen;

--
-- Name: queue_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE queue_id_seq OWNED BY queue.id;


--
-- Name: queued_record; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queued_record (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    import_time timestamp with time zone,
    purpose text DEFAULT 'import'::text NOT NULL,
    marc text NOT NULL,
    quality integer DEFAULT 0 NOT NULL,
    CONSTRAINT queued_record_purpose_check CHECK ((purpose = ANY (ARRAY['import'::text, 'overlay'::text])))
);


ALTER TABLE vandelay.queued_record OWNER TO evergreen;

--
-- Name: queued_authority_record; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queued_authority_record (
    queue integer NOT NULL,
    imported_as integer,
    import_error text,
    error_detail text
)
INHERITS (queued_record);


ALTER TABLE vandelay.queued_authority_record OWNER TO evergreen;

--
-- Name: queued_authority_record_attr; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queued_authority_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_authority_record_attr OWNER TO evergreen;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE queued_authority_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_authority_record_attr_id_seq OWNER TO evergreen;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE queued_authority_record_attr_id_seq OWNED BY queued_authority_record_attr.id;


--
-- Name: queued_bib_record; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queued_bib_record (
    queue integer NOT NULL,
    bib_source integer,
    imported_as bigint,
    import_error text,
    error_detail text
)
INHERITS (queued_record);


ALTER TABLE vandelay.queued_bib_record OWNER TO evergreen;

--
-- Name: queued_bib_record_attr; Type: TABLE; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE TABLE queued_bib_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_bib_record_attr OWNER TO evergreen;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE queued_bib_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_bib_record_attr_id_seq OWNER TO evergreen;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE queued_bib_record_attr_id_seq OWNED BY queued_bib_record_attr.id;


--
-- Name: queued_record_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE queued_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_record_id_seq OWNER TO evergreen;

--
-- Name: queued_record_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE queued_record_id_seq OWNED BY queued_record.id;


SET search_path = acq, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY cancel_reason ALTER COLUMN id SET DEFAULT nextval('cancel_reason_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim ALTER COLUMN id SET DEFAULT nextval('claim_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event ALTER COLUMN id SET DEFAULT nextval('claim_event_id_seq'::regclass);


--
-- Name: claim; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event ALTER COLUMN claim SET DEFAULT nextval('claim_event_claim_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event_type ALTER COLUMN id SET DEFAULT nextval('claim_event_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_policy ALTER COLUMN id SET DEFAULT nextval('claim_policy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_policy_action ALTER COLUMN id SET DEFAULT nextval('claim_policy_action_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_type ALTER COLUMN id SET DEFAULT nextval('claim_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula ALTER COLUMN id SET DEFAULT nextval('distribution_formula_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_application ALTER COLUMN id SET DEFAULT nextval('distribution_formula_application_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry ALTER COLUMN id SET DEFAULT nextval('distribution_formula_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY edi_message ALTER COLUMN id SET DEFAULT nextval('edi_message_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY exchange_rate ALTER COLUMN id SET DEFAULT nextval('exchange_rate_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fiscal_calendar ALTER COLUMN id SET DEFAULT nextval('fiscal_calendar_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fiscal_year ALTER COLUMN id SET DEFAULT nextval('fiscal_year_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund ALTER COLUMN id SET DEFAULT nextval('fund_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation ALTER COLUMN id SET DEFAULT nextval('fund_allocation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation_percent ALTER COLUMN id SET DEFAULT nextval('fund_allocation_percent_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_debit ALTER COLUMN id SET DEFAULT nextval('fund_debit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_tag ALTER COLUMN id SET DEFAULT nextval('fund_tag_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_tag_map ALTER COLUMN id SET DEFAULT nextval('fund_tag_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_transfer ALTER COLUMN id SET DEFAULT nextval('fund_transfer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY funding_source ALTER COLUMN id SET DEFAULT nextval('funding_source_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY funding_source_credit ALTER COLUMN id SET DEFAULT nextval('funding_source_credit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice ALTER COLUMN id SET DEFAULT nextval('invoice_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_entry ALTER COLUMN id SET DEFAULT nextval('invoice_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item ALTER COLUMN id SET DEFAULT nextval('invoice_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem ALTER COLUMN id SET DEFAULT nextval('lineitem_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_alert_text ALTER COLUMN id SET DEFAULT nextval('lineitem_alert_text_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_attr ALTER COLUMN id SET DEFAULT nextval('lineitem_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_attr_definition ALTER COLUMN id SET DEFAULT nextval('lineitem_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail ALTER COLUMN id SET DEFAULT nextval('lineitem_detail_id_seq'::regclass);


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_generated_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_generated_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_local_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_local_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_marc_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_marc_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_note ALTER COLUMN id SET DEFAULT nextval('lineitem_note_id_seq'::regclass);


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_provider_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_provider_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_usr_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_usr_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY picklist ALTER COLUMN id SET DEFAULT nextval('picklist_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_item ALTER COLUMN id SET DEFAULT nextval('po_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_note ALTER COLUMN id SET DEFAULT nextval('po_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider ALTER COLUMN id SET DEFAULT nextval('provider_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_address ALTER COLUMN id SET DEFAULT nextval('provider_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_contact ALTER COLUMN id SET DEFAULT nextval('provider_contact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_contact_address ALTER COLUMN id SET DEFAULT nextval('provider_contact_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_holding_subfield_map ALTER COLUMN id SET DEFAULT nextval('provider_holding_subfield_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_note ALTER COLUMN id SET DEFAULT nextval('provider_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order ALTER COLUMN id SET DEFAULT nextval('purchase_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim ALTER COLUMN id SET DEFAULT nextval('serial_claim_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim_event ALTER COLUMN id SET DEFAULT nextval('serial_claim_event_id_seq'::regclass);


--
-- Name: claim; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim_event ALTER COLUMN claim SET DEFAULT nextval('serial_claim_event_claim_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request ALTER COLUMN id SET DEFAULT nextval('user_request_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request_type ALTER COLUMN id SET DEFAULT nextval('user_request_type_id_seq'::regclass);


SET search_path = action, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY archive_actor_stat_cat ALTER COLUMN id SET DEFAULT nextval('archive_actor_stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY archive_asset_stat_cat ALTER COLUMN id SET DEFAULT nextval('archive_asset_stat_cat_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset ALTER COLUMN id SET DEFAULT nextval('fieldset_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset_col_val ALTER COLUMN id SET DEFAULT nextval('fieldset_col_val_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_copy_map ALTER COLUMN id SET DEFAULT nextval('hold_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_notification ALTER COLUMN id SET DEFAULT nextval('hold_notification_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request ALTER COLUMN id SET DEFAULT nextval('hold_request_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request_cancel_cause ALTER COLUMN id SET DEFAULT nextval('hold_request_cancel_cause_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request_note ALTER COLUMN id SET DEFAULT nextval('hold_request_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: persistant_transfer; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY in_house_use ALTER COLUMN id SET DEFAULT nextval('in_house_use_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cat_in_house_use ALTER COLUMN id SET DEFAULT nextval('non_cat_in_house_use_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_circulation ALTER COLUMN id SET DEFAULT nextval('non_cataloged_circulation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY reservation_transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: persistant_transfer; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY reservation_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey ALTER COLUMN id SET DEFAULT nextval('survey_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_answer ALTER COLUMN id SET DEFAULT nextval('survey_answer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_question ALTER COLUMN id SET DEFAULT nextval('survey_question_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_response ALTER COLUMN id SET DEFAULT nextval('survey_response_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy ALTER COLUMN id SET DEFAULT nextval('transit_copy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY unfulfilled_hold_list ALTER COLUMN id SET DEFAULT nextval('unfulfilled_hold_list_id_seq'::regclass);


SET search_path = action_trigger, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY environment ALTER COLUMN id SET DEFAULT nextval('environment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event ALTER COLUMN id SET DEFAULT nextval('event_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition ALTER COLUMN id SET DEFAULT nextval('event_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_output ALTER COLUMN id SET DEFAULT nextval('event_output_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_params ALTER COLUMN id SET DEFAULT nextval('event_params_id_seq'::regclass);


SET search_path = actor, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY address_alert ALTER COLUMN id SET DEFAULT nextval('address_alert_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY card ALTER COLUMN id SET DEFAULT nextval('card_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_address ALTER COLUMN id SET DEFAULT nextval('org_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_lasso ALTER COLUMN id SET DEFAULT nextval('org_lasso_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_lasso_map ALTER COLUMN id SET DEFAULT nextval('org_lasso_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit ALTER COLUMN id SET DEFAULT nextval('org_unit_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_closed ALTER COLUMN id SET DEFAULT nextval('org_unit_closed_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_custom_tree ALTER COLUMN id SET DEFAULT nextval('org_unit_custom_tree_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_custom_tree_node ALTER COLUMN id SET DEFAULT nextval('org_unit_custom_tree_node_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity ALTER COLUMN id SET DEFAULT nextval('org_unit_proximity_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment ALTER COLUMN id SET DEFAULT nextval('org_unit_proximity_adjustment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting ALTER COLUMN id SET DEFAULT nextval('org_unit_setting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_type ALTER COLUMN id SET DEFAULT nextval('org_unit_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_filter_group ALTER COLUMN id SET DEFAULT nextval('search_filter_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_filter_group_entry ALTER COLUMN id SET DEFAULT nextval('search_filter_group_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_query ALTER COLUMN id SET DEFAULT nextval('search_query_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat ALTER COLUMN id SET DEFAULT nextval('stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_default ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_default_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_usr_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_usr_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY toolbar ALTER COLUMN id SET DEFAULT nextval('toolbar_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr ALTER COLUMN id SET DEFAULT nextval('usr_id_seq'::regclass);


--
-- Name: usrgroup; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr ALTER COLUMN usrgroup SET DEFAULT nextval('usr_usrgroup_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_activity ALTER COLUMN id SET DEFAULT nextval('usr_activity_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_address ALTER COLUMN id SET DEFAULT nextval('usr_address_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_note ALTER COLUMN id SET DEFAULT nextval('usr_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_org_unit_opt_in ALTER COLUMN id SET DEFAULT nextval('usr_org_unit_opt_in_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_password_reset ALTER COLUMN id SET DEFAULT nextval('usr_password_reset_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_saved_search ALTER COLUMN id SET DEFAULT nextval('usr_saved_search_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_setting ALTER COLUMN id SET DEFAULT nextval('usr_setting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_standing_penalty ALTER COLUMN id SET DEFAULT nextval('usr_standing_penalty_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY workstation ALTER COLUMN id SET DEFAULT nextval('workstation_id_seq'::regclass);


SET search_path = asset, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number ALTER COLUMN id SET DEFAULT nextval('call_number_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_class ALTER COLUMN id SET DEFAULT nextval('call_number_class_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_note ALTER COLUMN id SET DEFAULT nextval('call_number_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_prefix ALTER COLUMN id SET DEFAULT nextval('call_number_prefix_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_suffix ALTER COLUMN id SET DEFAULT nextval('call_number_suffix_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy ALTER COLUMN id SET DEFAULT nextval('copy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location ALTER COLUMN id SET DEFAULT nextval('copy_location_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_group ALTER COLUMN id SET DEFAULT nextval('copy_location_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_group_map ALTER COLUMN id SET DEFAULT nextval('copy_location_group_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_order ALTER COLUMN id SET DEFAULT nextval('copy_location_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_note ALTER COLUMN id SET DEFAULT nextval('copy_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_part_map ALTER COLUMN id SET DEFAULT nextval('copy_part_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template ALTER COLUMN id SET DEFAULT nextval('copy_template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY opac_visible_copies ALTER COLUMN id SET DEFAULT nextval('opac_visible_copies_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat ALTER COLUMN id SET DEFAULT nextval('stat_cat_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_copy_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_transparency_map ALTER COLUMN id SET DEFAULT nextval('stat_cat_entry_transparency_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY uri ALTER COLUMN id SET DEFAULT nextval('uri_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY uri_call_number_map ALTER COLUMN id SET DEFAULT nextval('uri_call_number_map_id_seq'::regclass);


SET search_path = authority, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority_linking ALTER COLUMN id SET DEFAULT nextval('authority_linking_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY bib_linking ALTER COLUMN id SET DEFAULT nextval('bib_linking_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY browse_axis_authority_field_map ALTER COLUMN id SET DEFAULT nextval('browse_axis_authority_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set ALTER COLUMN id SET DEFAULT nextval('control_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_authority_field ALTER COLUMN id SET DEFAULT nextval('control_set_authority_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_bib_field ALTER COLUMN id SET DEFAULT nextval('control_set_bib_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_bib_field_metabib_field_map ALTER COLUMN id SET DEFAULT nextval('control_set_bib_field_metabib_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY display_5xx_headings ALTER COLUMN id SET DEFAULT nextval('display_5xx_headings_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY full_rec ALTER COLUMN id SET DEFAULT nextval('full_rec_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY rec_descriptor ALTER COLUMN id SET DEFAULT nextval('rec_descriptor_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY record_note ALTER COLUMN id SET DEFAULT nextval('record_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY simple_heading ALTER COLUMN id SET DEFAULT nextval('simple_heading_id_seq'::regclass);


SET search_path = biblio, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY monograph_part ALTER COLUMN id SET DEFAULT nextval('monograph_part_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY peer_bib_copy_map ALTER COLUMN id SET DEFAULT nextval('peer_bib_copy_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY peer_type ALTER COLUMN id SET DEFAULT nextval('peer_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_note ALTER COLUMN id SET DEFAULT nextval('record_note_id_seq'::regclass);


SET search_path = booking, pg_catalog;

--
-- Name: xact_start; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation_attr_value_map ALTER COLUMN id SET DEFAULT nextval('reservation_attr_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource ALTER COLUMN id SET DEFAULT nextval('resource_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr ALTER COLUMN id SET DEFAULT nextval('resource_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_map ALTER COLUMN id SET DEFAULT nextval('resource_attr_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_value ALTER COLUMN id SET DEFAULT nextval('resource_attr_value_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_type ALTER COLUMN id SET DEFAULT nextval('resource_type_id_seq'::regclass);


SET search_path = config, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY barcode_completion ALTER COLUMN id SET DEFAULT nextval('barcode_completion_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY best_hold_order ALTER COLUMN id SET DEFAULT nextval('best_hold_order_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY bib_source ALTER COLUMN id SET DEFAULT nextval('bib_source_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY biblio_fingerprint ALTER COLUMN id SET DEFAULT nextval('biblio_fingerprint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY billing_type ALTER COLUMN id SET DEFAULT nextval('billing_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_group ALTER COLUMN id SET DEFAULT nextval('circ_limit_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_circ_mod_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_copy_loc_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_group_map ALTER COLUMN id SET DEFAULT nextval('circ_limit_set_group_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_circ_mod_test ALTER COLUMN id SET DEFAULT nextval('circ_matrix_circ_mod_test_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_circ_mod_test_map ALTER COLUMN id SET DEFAULT nextval('circ_matrix_circ_mod_test_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_limit_set_map ALTER COLUMN id SET DEFAULT nextval('circ_matrix_limit_set_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('circ_matrix_matchpoint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_weights ALTER COLUMN id SET DEFAULT nextval('circ_matrix_weights_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY coded_value_map ALTER COLUMN id SET DEFAULT nextval('coded_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY copy_status ALTER COLUMN id SET DEFAULT nextval('copy_status_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY filter_dialog_filter_set ALTER COLUMN id SET DEFAULT nextval('filter_dialog_filter_set_id_seq'::regclass);


--
-- Name: enabled; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY global_flag ALTER COLUMN enabled SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hard_due_date ALTER COLUMN id SET DEFAULT nextval('hard_due_date_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hard_due_date_values ALTER COLUMN id SET DEFAULT nextval('hard_due_date_values_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('hold_matrix_matchpoint_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_weights ALTER COLUMN id SET DEFAULT nextval('hold_matrix_weights_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY i18n_core ALTER COLUMN id SET DEFAULT nextval('i18n_core_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY identification_type ALTER COLUMN id SET DEFAULT nextval('identification_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY idl_field_doc ALTER COLUMN id SET DEFAULT nextval('idl_field_doc_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY index_normalizer ALTER COLUMN id SET DEFAULT nextval('index_normalizer_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY marc21_ff_pos_map ALTER COLUMN id SET DEFAULT nextval('marc21_ff_pos_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map ALTER COLUMN id SET DEFAULT nextval('marc21_physical_characteristic_subfield_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map ALTER COLUMN id SET DEFAULT nextval('marc21_physical_characteristic_value_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_class_ts_map ALTER COLUMN id SET DEFAULT nextval('metabib_class_ts_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field ALTER COLUMN id SET DEFAULT nextval('metabib_field_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_index_norm_map ALTER COLUMN id SET DEFAULT nextval('metabib_field_index_norm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_ts_map ALTER COLUMN id SET DEFAULT nextval('metabib_field_ts_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY net_access_level ALTER COLUMN id SET DEFAULT nextval('net_access_level_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_type ALTER COLUMN id SET DEFAULT nextval('non_cataloged_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type_log ALTER COLUMN id SET DEFAULT nextval('org_unit_setting_type_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY patron_message ALTER COLUMN id SET DEFAULT nextval('patron_message_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY record_attr_index_norm_map ALTER COLUMN id SET DEFAULT nextval('record_attr_index_norm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY remote_account ALTER COLUMN id SET DEFAULT nextval('remote_account_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY rule_age_hold_protect ALTER COLUMN id SET DEFAULT nextval('rule_age_hold_protect_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY rule_circ_duration ALTER COLUMN id SET DEFAULT nextval('rule_circ_duration_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY rule_max_fine ALTER COLUMN id SET DEFAULT nextval('rule_max_fine_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY rule_recurring_fine ALTER COLUMN id SET DEFAULT nextval('rule_recurring_fine_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY sms_carrier ALTER COLUMN id SET DEFAULT nextval('sms_carrier_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY standing ALTER COLUMN id SET DEFAULT nextval('standing_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY standing_penalty ALTER COLUMN id SET DEFAULT nextval('standing_penalty_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY usr_activity_type ALTER COLUMN id SET DEFAULT nextval('usr_activity_type_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY weight_assoc ALTER COLUMN id SET DEFAULT nextval('weight_assoc_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_attr ALTER COLUMN id SET DEFAULT nextval('z3950_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_source_credentials ALTER COLUMN id SET DEFAULT nextval('z3950_source_credentials_id_seq'::regclass);


SET search_path = container, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_item ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_note ALTER COLUMN id SET DEFAULT nextval('biblio_record_entry_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_item ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_note ALTER COLUMN id SET DEFAULT nextval('call_number_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket ALTER COLUMN id SET DEFAULT nextval('copy_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_item ALTER COLUMN id SET DEFAULT nextval('copy_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('copy_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_note ALTER COLUMN id SET DEFAULT nextval('copy_bucket_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket ALTER COLUMN id SET DEFAULT nextval('user_bucket_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_item ALTER COLUMN id SET DEFAULT nextval('user_bucket_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('user_bucket_item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_note ALTER COLUMN id SET DEFAULT nextval('user_bucket_note_id_seq'::regclass);


SET search_path = m_enum, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_stat_cat_entry_map ALTER COLUMN id SET DEFAULT nextval('actor_stat_cat_entry_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_stat_cat_map ALTER COLUMN id SET DEFAULT nextval('actor_stat_cat_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN id SET DEFAULT nextval('actor.usr_id_seq'::regclass);


--
-- Name: standing; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN standing SET DEFAULT 1;


--
-- Name: net_access_level; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN net_access_level SET DEFAULT 1;


--
-- Name: active; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: master_account; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN master_account SET DEFAULT false;


--
-- Name: super_user; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN super_user SET DEFAULT false;


--
-- Name: barred; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN barred SET DEFAULT false;


--
-- Name: deleted; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: juvenile; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN juvenile SET DEFAULT false;


--
-- Name: usrgroup; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN usrgroup SET DEFAULT nextval('actor.usr_usrgroup_seq'::regclass);


--
-- Name: claims_returned_count; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_returned_count SET DEFAULT 0;


--
-- Name: credit_forward_balance; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN credit_forward_balance SET DEFAULT 0.00;


--
-- Name: last_xact_id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN last_xact_id SET DEFAULT 'none'::text;


--
-- Name: create_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: expire_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN expire_date SET DEFAULT (now() + '3 years'::interval);


--
-- Name: claims_never_checked_out_count; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_never_checked_out_count SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY card_collisions ALTER COLUMN id SET DEFAULT nextval('card_collisions_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: create_time; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: fine_interval; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: phone_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: desk_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: opac_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY circ ALTER COLUMN opac_renewal SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY holds ALTER COLUMN mint_condition SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY home_location_map ALTER COLUMN id SET DEFAULT nextval('home_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY org_map ALTER COLUMN id SET DEFAULT nextval('org_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY profile_map ALTER COLUMN id SET DEFAULT nextval('profile_map_id_seq'::regclass);


SET search_path = m_kcls, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: fine_interval; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: phone_renewal; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: desk_renewal; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: opac_renewal; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN opac_renewal SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN id SET DEFAULT nextval('actor.usr_id_seq'::regclass);


--
-- Name: standing; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN standing SET DEFAULT 1;


--
-- Name: net_access_level; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN net_access_level SET DEFAULT 1;


--
-- Name: active; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: master_account; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN master_account SET DEFAULT false;


--
-- Name: super_user; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN super_user SET DEFAULT false;


--
-- Name: barred; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN barred SET DEFAULT false;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: juvenile; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN juvenile SET DEFAULT false;


--
-- Name: usrgroup; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN usrgroup SET DEFAULT nextval('actor.usr_usrgroup_seq'::regclass);


--
-- Name: claims_returned_count; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_returned_count SET DEFAULT 0;


--
-- Name: credit_forward_balance; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN credit_forward_balance SET DEFAULT 0.00;


--
-- Name: last_xact_id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN last_xact_id SET DEFAULT 'none'::text;


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: expire_date; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN expire_date SET DEFAULT (now() + '3 years'::interval);


--
-- Name: claims_never_checked_out_count; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_never_checked_out_count SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: seq; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bibs_to_fix ALTER COLUMN seq SET DEFAULT nextval('bibs_to_fix_seq_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bibs_with_938 ALTER COLUMN id SET DEFAULT nextval('bibs_with_938_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_id_seq'::regclass);


--
-- Name: btype; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN btype SET DEFAULT 'misc'::text;


--
-- Name: pub; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN pub SET DEFAULT false;


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag_entry ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_item_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY bookbag_entry ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN id SET DEFAULT nextval('asset.copy_note_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: pub; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN pub SET DEFAULT false;


--
-- Name: job; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY km_move ALTER COLUMN job SET DEFAULT nextval('km_move_job_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY locations ALTER COLUMN id SET DEFAULT nextval('asset.copy_location_id_seq'::regclass);


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY locations ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: hold_verify; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY locations ALTER COLUMN hold_verify SET DEFAULT false;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY locations ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY locations ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY money_grocery_legacy ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_kcls; Owner: evergreen
--

ALTER TABLE ONLY money_grocery_legacy ALTER COLUMN xact_start SET DEFAULT now();


SET search_path = m_kcls2, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_fund_legacy ALTER COLUMN id SET DEFAULT nextval('acq.fund_id_seq'::regclass);


--
-- Name: year; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_fund_legacy ALTER COLUMN year SET DEFAULT date_part('year'::text, now());


--
-- Name: rollover; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_fund_legacy ALTER COLUMN rollover SET DEFAULT false;


--
-- Name: propagate; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_fund_legacy ALTER COLUMN propagate SET DEFAULT true;


--
-- Name: active; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_fund_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_address_legacy ALTER COLUMN id SET DEFAULT nextval('acq.provider_address_id_seq'::regclass);


--
-- Name: valid; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_address_legacy ALTER COLUMN valid SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_contact_legacy ALTER COLUMN id SET DEFAULT nextval('acq.provider_contact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_legacy ALTER COLUMN id SET DEFAULT nextval('acq.provider_id_seq'::regclass);


--
-- Name: active; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: prepayment_required; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY acq_provider_legacy ALTER COLUMN prepayment_required SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: fine_interval; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: phone_renewal; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: desk_renewal; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: opac_renewal; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_circulation_legacy ALTER COLUMN opac_renewal SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN id SET DEFAULT nextval('actor.usr_id_seq'::regclass);


--
-- Name: standing; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN standing SET DEFAULT 1;


--
-- Name: net_access_level; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN net_access_level SET DEFAULT 1;


--
-- Name: active; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: master_account; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN master_account SET DEFAULT false;


--
-- Name: super_user; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN super_user SET DEFAULT false;


--
-- Name: barred; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN barred SET DEFAULT false;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: juvenile; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN juvenile SET DEFAULT false;


--
-- Name: usrgroup; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN usrgroup SET DEFAULT nextval('actor.usr_usrgroup_seq'::regclass);


--
-- Name: claims_returned_count; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_returned_count SET DEFAULT 0;


--
-- Name: credit_forward_balance; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN credit_forward_balance SET DEFAULT 0.00;


--
-- Name: last_xact_id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN last_xact_id SET DEFAULT 'none'::text;


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: expire_date; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN expire_date SET DEFAULT (now() + '3 years'::interval);


--
-- Name: claims_never_checked_out_count; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY actor_usr_legacy ALTER COLUMN claims_never_checked_out_count SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_id_seq'::regclass);


--
-- Name: btype; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN btype SET DEFAULT 'misc'::text;


--
-- Name: pub; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN pub SET DEFAULT false;


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag_entry ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_item_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY bookbag_entry ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN id SET DEFAULT nextval('asset.copy_note_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: pub; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN pub SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY money_grocery_legacy ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_kcls2; Owner: evergreen
--

ALTER TABLE ONLY money_grocery_legacy ALTER COLUMN xact_start SET DEFAULT now();


SET search_path = m_kcls3, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls3; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls3; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls3; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls3; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_call_fix, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_call_fix; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_circhist, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: create_time; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: fine_interval; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: phone_renewal; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: desk_renewal; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: opac_renewal; Type: DEFAULT; Schema: m_kcls_circhist; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN opac_renewal SET DEFAULT false;


SET search_path = m_kcls_gap, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN id SET DEFAULT nextval('asset.copy_note_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: pub; Type: DEFAULT; Schema: m_kcls_gap; Owner: evergreen
--

ALTER TABLE ONLY int_notes ALTER COLUMN pub SET DEFAULT false;


SET search_path = m_kcls_holds, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holds; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_holdsall, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_holdsall2, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall2; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_holdsall3, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsall3; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_holdsfix, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: request_time; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: selection_depth; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: email_notify; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: frozen; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY action_hold_request_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_holdsfix; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_items2, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items2; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_items3, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_items3; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


SET search_path = m_kcls_ord, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_ord; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN mint_condition SET DEFAULT true;


SET search_path = m_kcls_ord2, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_ord2; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN mint_condition SET DEFAULT true;


SET search_path = m_kcls_ord3, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: m_kcls_ord3; Owner: evergreen
--

ALTER TABLE ONLY on_order_items ALTER COLUMN mint_condition SET DEFAULT true;


SET search_path = m_test, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('base_circ_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('base_copy_location_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY base_profile_map ALTER COLUMN id SET DEFAULT nextval('base_profile_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: create_time; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: fine_interval; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: phone_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: desk_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: opac_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY circhist ALTER COLUMN opac_renewal SET DEFAULT false;


SET search_path = metabib, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY author_field_entry ALTER COLUMN id SET DEFAULT nextval('author_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY bib_export_data ALTER COLUMN id SET DEFAULT nextval('bib_export_data_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry ALTER COLUMN id SET DEFAULT nextval('browse_author_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_author_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_simple_heading_map ALTER COLUMN id SET DEFAULT nextval('browse_author_entry_simple_heading_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry ALTER COLUMN id SET DEFAULT nextval('browse_call_number_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_call_number_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry ALTER COLUMN id SET DEFAULT nextval('browse_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry ALTER COLUMN id SET DEFAULT nextval('browse_series_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_series_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_simple_heading_map ALTER COLUMN id SET DEFAULT nextval('browse_series_entry_simple_heading_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry ALTER COLUMN id SET DEFAULT nextval('browse_subject_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_subject_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_simple_heading_map ALTER COLUMN id SET DEFAULT nextval('browse_subject_entry_simple_heading_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry ALTER COLUMN id SET DEFAULT nextval('browse_title_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_def_map ALTER COLUMN id SET DEFAULT nextval('browse_title_entry_def_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_simple_heading_map ALTER COLUMN id SET DEFAULT nextval('browse_title_entry_simple_heading_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY call_number_field_entry ALTER COLUMN id SET DEFAULT nextval('call_number_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY facet_entry ALTER COLUMN id SET DEFAULT nextval('facet_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY identifier_field_entry ALTER COLUMN id SET DEFAULT nextval('identifier_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY keyword_field_entry ALTER COLUMN id SET DEFAULT nextval('keyword_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY language_filter ALTER COLUMN id SET DEFAULT nextval('language_filter_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metarecord ALTER COLUMN id SET DEFAULT nextval('metarecord_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metarecord_source_map ALTER COLUMN id SET DEFAULT nextval('metarecord_source_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY series_field_entry ALTER COLUMN id SET DEFAULT nextval('series_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY subject_field_entry ALTER COLUMN id SET DEFAULT nextval('subject_field_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY title_field_entry ALTER COLUMN id SET DEFAULT nextval('title_field_entry_id_seq'::regclass);


SET search_path = money, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY billable_xact ALTER COLUMN id SET DEFAULT nextval('billable_xact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY billing ALTER COLUMN id SET DEFAULT nextval('billing_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_desk_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY cash_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY cash_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY cash_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY check_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY check_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY check_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY collections_tracker ALTER COLUMN id SET DEFAULT nextval('collections_tracker_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_card_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY credit_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY forgive_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY goods_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY goods_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY goods_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY grocery ALTER COLUMN id SET DEFAULT nextval('billable_xact_id_seq'::regclass);


--
-- Name: xact_start; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY grocery ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY work_payment ALTER COLUMN id SET DEFAULT nextval('payment_id_seq'::regclass);


--
-- Name: payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY work_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY work_payment ALTER COLUMN voided SET DEFAULT false;


SET search_path = offline, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: offline; Owner: evergreen
--

ALTER TABLE ONLY script ALTER COLUMN id SET DEFAULT nextval('script_id_seq'::regclass);


SET search_path = permission, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_penalty_threshold ALTER COLUMN id SET DEFAULT nextval('grp_penalty_threshold_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_perm_map ALTER COLUMN id SET DEFAULT nextval('grp_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_tree ALTER COLUMN id SET DEFAULT nextval('grp_tree_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY perm_list ALTER COLUMN id SET DEFAULT nextval('perm_list_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_grp_map ALTER COLUMN id SET DEFAULT nextval('usr_grp_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_object_perm_map ALTER COLUMN id SET DEFAULT nextval('usr_object_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_perm_map ALTER COLUMN id SET DEFAULT nextval('usr_perm_map_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_work_ou_map ALTER COLUMN id SET DEFAULT nextval('usr_work_ou_map_id_seq'::regclass);


SET search_path = query, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY case_branch ALTER COLUMN id SET DEFAULT nextval('case_branch_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY datatype ALTER COLUMN id SET DEFAULT nextval('datatype_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression ALTER COLUMN id SET DEFAULT nextval('expression_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY from_relation ALTER COLUMN id SET DEFAULT nextval('from_relation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY function_param_def ALTER COLUMN id SET DEFAULT nextval('function_param_def_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY function_sig ALTER COLUMN id SET DEFAULT nextval('function_sig_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY order_by_item ALTER COLUMN id SET DEFAULT nextval('order_by_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query_sequence ALTER COLUMN id SET DEFAULT nextval('query_sequence_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY record_column ALTER COLUMN id SET DEFAULT nextval('record_column_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY select_item ALTER COLUMN id SET DEFAULT nextval('select_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query ALTER COLUMN id SET DEFAULT nextval('stored_query_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY subfield ALTER COLUMN id SET DEFAULT nextval('subfield_id_seq'::regclass);


SET search_path = reporter, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY output_folder ALTER COLUMN id SET DEFAULT nextval('output_folder_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report ALTER COLUMN id SET DEFAULT nextval('report_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report_folder ALTER COLUMN id SET DEFAULT nextval('report_folder_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY schedule ALTER COLUMN id SET DEFAULT nextval('schedule_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template ALTER COLUMN id SET DEFAULT nextval('template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template_folder ALTER COLUMN id SET DEFAULT nextval('template_folder_id_seq'::regclass);


SET search_path = search, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY relevance_adjustment ALTER COLUMN id SET DEFAULT nextval('relevance_adjustment_id_seq'::regclass);


SET search_path = serial, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY basic_summary ALTER COLUMN id SET DEFAULT nextval('basic_summary_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY caption_and_pattern ALTER COLUMN id SET DEFAULT nextval('caption_and_pattern_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution ALTER COLUMN id SET DEFAULT nextval('distribution_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution_note ALTER COLUMN id SET DEFAULT nextval('distribution_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY index_summary ALTER COLUMN id SET DEFAULT nextval('index_summary_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY issuance ALTER COLUMN id SET DEFAULT nextval('issuance_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item ALTER COLUMN id SET DEFAULT nextval('item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item_note ALTER COLUMN id SET DEFAULT nextval('item_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY materialized_holding_code ALTER COLUMN id SET DEFAULT nextval('materialized_holding_code_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY record_entry ALTER COLUMN id SET DEFAULT nextval('record_entry_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY routing_list_user ALTER COLUMN id SET DEFAULT nextval('routing_list_user_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY stream ALTER COLUMN id SET DEFAULT nextval('stream_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription ALTER COLUMN id SET DEFAULT nextval('subscription_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription_note ALTER COLUMN id SET DEFAULT nextval('subscription_note_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY supplement_summary ALTER COLUMN id SET DEFAULT nextval('supplement_summary_id_seq'::regclass);


--
-- Name: create_date; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: edit_date; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: status; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN status SET DEFAULT 0;


--
-- Name: location; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN location SET DEFAULT 1;


--
-- Name: circulate; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: deposit; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: ref; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN ref SET DEFAULT false;


--
-- Name: holdable; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: deposit_amount; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: opac_visible; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: deleted; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: floating; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN floating SET DEFAULT false;


--
-- Name: mint_condition; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit ALTER COLUMN mint_condition SET DEFAULT true;


SET search_path = staging, pg_catalog;

--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY card_stage ALTER COLUMN row_id SET DEFAULT nextval('card_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY mailing_address_stage ALTER COLUMN row_id SET DEFAULT nextval('mailing_address_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY statcat_stage ALTER COLUMN row_id SET DEFAULT nextval('statcat_stage_row_id_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY user_stage ALTER COLUMN row_id SET DEFAULT nextval('user_stage_row_id_seq'::regclass);


SET search_path = url_verify, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY session ALTER COLUMN id SET DEFAULT nextval('session_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url ALTER COLUMN id SET DEFAULT nextval('url_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_selector ALTER COLUMN id SET DEFAULT nextval('url_selector_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verification ALTER COLUMN id SET DEFAULT nextval('url_verification_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY verification_attempt ALTER COLUMN id SET DEFAULT nextval('verification_attempt_id_seq'::regclass);


SET search_path = vandelay, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_attr_definition ALTER COLUMN id SET DEFAULT nextval('authority_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_match ALTER COLUMN id SET DEFAULT nextval('authority_match_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: complete; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_attr_definition ALTER COLUMN id SET DEFAULT nextval('bib_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_match ALTER COLUMN id SET DEFAULT nextval('bib_match_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: complete; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_bib_trash_fields ALTER COLUMN id SET DEFAULT nextval('import_bib_trash_fields_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_bib_trash_group ALTER COLUMN id SET DEFAULT nextval('import_bib_trash_group_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item ALTER COLUMN id SET DEFAULT nextval('import_item_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item_attr_definition ALTER COLUMN id SET DEFAULT nextval('import_item_attr_definition_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set ALTER COLUMN id SET DEFAULT nextval('match_set_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_point ALTER COLUMN id SET DEFAULT nextval('match_set_point_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_quality ALTER COLUMN id SET DEFAULT nextval('match_set_quality_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY merge_profile ALTER COLUMN id SET DEFAULT nextval('merge_profile_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queue ALTER COLUMN id SET DEFAULT nextval('queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: purpose; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: quality; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record_attr ALTER COLUMN id SET DEFAULT nextval('queued_authority_record_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


--
-- Name: create_time; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: purpose; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: quality; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record_attr ALTER COLUMN id SET DEFAULT nextval('queued_bib_record_attr_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_record ALTER COLUMN id SET DEFAULT nextval('queued_record_id_seq'::regclass);


SET search_path = acq, pg_catalog;

--
-- Name: acq_cancel_reason_one_per_org_unit; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT acq_cancel_reason_one_per_org_unit UNIQUE (org_unit, label);


--
-- Name: acq_fy_logical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT acq_fy_logical_key UNIQUE (calendar, year);


--
-- Name: acq_fy_physical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT acq_fy_physical_key UNIQUE (calendar, year_begin);


--
-- Name: acq_lineitem_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_lineitem_history
    ADD CONSTRAINT acq_lineitem_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_purchase_order_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_purchase_order_history
    ADD CONSTRAINT acq_purchase_order_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acqdf_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT acqdf_name_once_per_owner UNIQUE (name, owner);


--
-- Name: acqdfe_lib_once_per_formula; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT acqdfe_lib_once_per_formula UNIQUE (formula, "position");


--
-- Name: acqft_tag_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT acqft_tag_once_per_owner UNIQUE (name, owner);


--
-- Name: acqftm_fund_once_per_tag; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT acqftm_fund_once_per_tag UNIQUE (fund, tag);


--
-- Name: action_sequence; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT action_sequence UNIQUE (claim_policy, action_interval);


--
-- Name: alert_one_code_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT alert_one_code_per_org UNIQUE (code, owning_lib);


--
-- Name: cancel_reason_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT cancel_reason_pkey PRIMARY KEY (id);


--
-- Name: claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_pkey PRIMARY KEY (id);


--
-- Name: claim_event_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT claim_event_type_pkey PRIMARY KEY (id);


--
-- Name: claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_pkey PRIMARY KEY (id);


--
-- Name: claim_policy_action_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_pkey PRIMARY KEY (id);


--
-- Name: claim_policy_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT claim_policy_pkey PRIMARY KEY (id);


--
-- Name: claim_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: claim_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_pkey PRIMARY KEY (id);


--
-- Name: code_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT code_once_per_org_year UNIQUE (org, code, year);


--
-- Name: code_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT code_once_per_owner UNIQUE (code, owner);


--
-- Name: currency_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY currency_type
    ADD CONSTRAINT currency_type_pkey PRIMARY KEY (code);


--
-- Name: debit_attribution_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_application_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT distribution_formula_pkey PRIMARY KEY (id);


--
-- Name: edi_account_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY edi_account
    ADD CONSTRAINT edi_account_pkey PRIMARY KEY (id);


--
-- Name: edi_message_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_pkey PRIMARY KEY (id);


--
-- Name: event_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT event_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: exchange_rate_from_to_once; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_from_to_once UNIQUE (from_currency, to_currency);


--
-- Name: exchange_rate_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_pkey PRIMARY KEY (id);


--
-- Name: fiscal_calendar_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fiscal_calendar
    ADD CONSTRAINT fiscal_calendar_pkey PRIMARY KEY (id);


--
-- Name: fiscal_year_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT fiscal_year_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_percent_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_pkey PRIMARY KEY (id);


--
-- Name: fund_debit_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_pkey PRIMARY KEY (id);


--
-- Name: fund_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_pkey PRIMARY KEY (id);


--
-- Name: fund_tag_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_pkey PRIMARY KEY (id);


--
-- Name: fund_tag_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT fund_tag_pkey PRIMARY KEY (id);


--
-- Name: fund_transfer_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_pkey PRIMARY KEY (id);


--
-- Name: funding_source_code_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_code_key UNIQUE (code);


--
-- Name: funding_source_credit_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY funding_source_credit
    ADD CONSTRAINT funding_source_credit_pkey PRIMARY KEY (id);


--
-- Name: funding_source_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_name_once_per_owner UNIQUE (name, owner);


--
-- Name: funding_source_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_pkey PRIMARY KEY (id);


--
-- Name: inv_ident_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT inv_ident_once_per_provider UNIQUE (provider, inv_ident);


--
-- Name: invoice_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_pkey PRIMARY KEY (id);


--
-- Name: invoice_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_pkey PRIMARY KEY (id);


--
-- Name: invoice_item_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice_item_type
    ADD CONSTRAINT invoice_item_type_pkey PRIMARY KEY (code);


--
-- Name: invoice_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice_method
    ADD CONSTRAINT invoice_method_pkey PRIMARY KEY (code);


--
-- Name: invoice_payment_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice_payment_method
    ADD CONSTRAINT invoice_payment_method_pkey PRIMARY KEY (code);


--
-- Name: invoice_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_pkey PRIMARY KEY (id);


--
-- Name: lineitem_alert_text_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_attr_definition
    ADD CONSTRAINT lineitem_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_attr
    ADD CONSTRAINT lineitem_attr_pkey PRIMARY KEY (id);


--
-- Name: lineitem_detail_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_pkey PRIMARY KEY (id);


--
-- Name: lineitem_generated_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_generated_attr_definition
    ADD CONSTRAINT lineitem_generated_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_local_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_local_attr_definition
    ADD CONSTRAINT lineitem_local_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_marc_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_marc_attr_definition
    ADD CONSTRAINT lineitem_marc_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_pkey PRIMARY KEY (id);


--
-- Name: lineitem_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_pkey PRIMARY KEY (id);


--
-- Name: lineitem_provider_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_usr_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: logical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT logical_key UNIQUE (funding_source, org, fund_code);


--
-- Name: name_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT name_once_per_org UNIQUE (org_unit, name);


--
-- Name: name_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT name_once_per_org_year UNIQUE (org, name, year);


--
-- Name: name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT name_once_per_owner UNIQUE (name, owner);


--
-- Name: name_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT name_once_per_provider UNIQUE (provider, name);


--
-- Name: picklist_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_pkey PRIMARY KEY (id);


--
-- Name: po_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_pkey PRIMARY KEY (id);


--
-- Name: po_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_pkey PRIMARY KEY (id);


--
-- Name: provider_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_address
    ADD CONSTRAINT provider_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_contact_address
    ADD CONSTRAINT provider_contact_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_contact
    ADD CONSTRAINT provider_contact_pkey PRIMARY KEY (id);


--
-- Name: provider_holding_subfield_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: provider_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_name_once_per_owner UNIQUE (name, owner);


--
-- Name: provider_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_pkey PRIMARY KEY (id);


--
-- Name: provider_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_pkey PRIMARY KEY (id);


--
-- Name: purchase_order_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_pkey PRIMARY KEY (id);


--
-- Name: serial_claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_pkey PRIMARY KEY (id);


--
-- Name: serial_claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_pkey PRIMARY KEY (id);


--
-- Name: user_request_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_pkey PRIMARY KEY (id);


--
-- Name: user_request_type_label_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_request_type
    ADD CONSTRAINT user_request_type_label_key UNIQUE (label);


--
-- Name: user_request_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_request_type
    ADD CONSTRAINT user_request_type_pkey PRIMARY KEY (id);


SET search_path = action, pg_catalog;

--
-- Name: aged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY aged_circulation
    ADD CONSTRAINT aged_circulation_pkey PRIMARY KEY (id);


--
-- Name: archive_actor_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY archive_actor_stat_cat
    ADD CONSTRAINT archive_actor_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: archive_asset_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY archive_asset_stat_cat
    ADD CONSTRAINT archive_asset_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: circulation_limit_group_map_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_pkey PRIMARY KEY (circ, limit_group);


--
-- Name: circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_pkey PRIMARY KEY (id);


--
-- Name: copy_once_per_hold; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT copy_once_per_hold UNIQUE (hold, target_copy);


--
-- Name: fieldset_col_once_per_set; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_once_per_set UNIQUE (fieldset, col);


--
-- Name: fieldset_col_val_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_pkey PRIMARY KEY (id);


--
-- Name: fieldset_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_pkey PRIMARY KEY (id);


--
-- Name: hold_copy_map_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT hold_copy_map_pkey PRIMARY KEY (id);


--
-- Name: hold_count_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_count
    ADD CONSTRAINT hold_count_pkey PRIMARY KEY (record_entry_id);


--
-- Name: hold_notification_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_pkey PRIMARY KEY (id);


--
-- Name: hold_request_cancel_cause_label_key; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_label_key UNIQUE (label);


--
-- Name: hold_request_cancel_cause_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_pkey PRIMARY KEY (id);


--
-- Name: hold_request_note_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_request_note
    ADD CONSTRAINT hold_request_note_pkey PRIMARY KEY (id);


--
-- Name: hold_request_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_pkey PRIMARY KEY (id);


--
-- Name: hold_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_pkey PRIMARY KEY (id);


--
-- Name: lib_name_unique; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT lib_name_unique UNIQUE (owning_lib, name);


--
-- Name: non_cat_in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_pkey PRIMARY KEY (id);


--
-- Name: reservation_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: survey_answer_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY survey_answer
    ADD CONSTRAINT survey_answer_pkey PRIMARY KEY (id);


--
-- Name: survey_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY survey
    ADD CONSTRAINT survey_pkey PRIMARY KEY (id);


--
-- Name: survey_question_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY survey_question
    ADD CONSTRAINT survey_question_pkey PRIMARY KEY (id);


--
-- Name: survey_response_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_pkey PRIMARY KEY (id);


--
-- Name: transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_pkey PRIMARY KEY (id);


--
-- Name: unfulfilled_hold_list_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY unfulfilled_hold_list
    ADD CONSTRAINT unfulfilled_hold_list_pkey PRIMARY KEY (id);


SET search_path = action_trigger, pg_catalog;

--
-- Name: cleanup_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY cleanup
    ADD CONSTRAINT cleanup_pkey PRIMARY KEY (module);


--
-- Name: collector_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY collector
    ADD CONSTRAINT collector_pkey PRIMARY KEY (module);


--
-- Name: env_event_label_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT env_event_label_once UNIQUE (event_def, label);


--
-- Name: environment_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_pkey PRIMARY KEY (id);


--
-- Name: ev_def_name_owner_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT ev_def_name_owner_once UNIQUE (owner, name);


--
-- Name: ev_def_owner_hook_val_react_clean_delay_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT ev_def_owner_hook_val_react_clean_delay_once UNIQUE (owner, hook, validator, reactor, delay, delay_field);


--
-- Name: event_definition_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_pkey PRIMARY KEY (id);


--
-- Name: event_output_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_output
    ADD CONSTRAINT event_output_pkey PRIMARY KEY (id);


--
-- Name: event_params_event_def_param_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_event_def_param_once UNIQUE (event_def, param);


--
-- Name: event_params_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_pkey PRIMARY KEY (id);


--
-- Name: event_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: hook_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hook
    ADD CONSTRAINT hook_pkey PRIMARY KEY (key);


--
-- Name: reactor_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY reactor
    ADD CONSTRAINT reactor_pkey PRIMARY KEY (module);


--
-- Name: validator_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY validator
    ADD CONSTRAINT validator_pkey PRIMARY KEY (module);


SET search_path = actor, pg_catalog;

--
-- Name: address_alert_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY address_alert
    ADD CONSTRAINT address_alert_pkey PRIMARY KEY (id);


--
-- Name: aouctn_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT aouctn_once_per_org UNIQUE (tree, org_unit);


--
-- Name: asfg_code_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT asfg_code_once_per_org UNIQUE (owner, code);


--
-- Name: asfg_label_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT asfg_label_once_per_org UNIQUE (owner, label);


--
-- Name: asfge_query_once_per_group; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT asfge_query_once_per_group UNIQUE (grp, query);


--
-- Name: card_barcode_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_barcode_key UNIQUE (barcode);


--
-- Name: card_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: hours_of_operation_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hours_of_operation
    ADD CONSTRAINT hours_of_operation_pkey PRIMARY KEY (id);


--
-- Name: name_once_per_user; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT name_once_per_user UNIQUE (owner, name);


--
-- Name: org_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_address
    ADD CONSTRAINT org_address_pkey PRIMARY KEY (id);


--
-- Name: org_lasso_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_pkey PRIMARY KEY (id);


--
-- Name: org_lasso_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_lasso
    ADD CONSTRAINT org_lasso_name_key UNIQUE (name);


--
-- Name: org_lasso_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_lasso
    ADD CONSTRAINT org_lasso_pkey PRIMARY KEY (id);


--
-- Name: org_unit_closed_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_closed
    ADD CONSTRAINT org_unit_closed_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_node_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_purpose_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_purpose_key UNIQUE (purpose);


--
-- Name: org_unit_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_name_key UNIQUE (name);


--
-- Name: org_unit_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity_adjustment_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_proximity
    ADD CONSTRAINT org_unit_proximity_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_pkey PRIMARY KEY (id);


--
-- Name: org_unit_shortname_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_shortname_key UNIQUE (shortname);


--
-- Name: org_unit_type_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_type
    ADD CONSTRAINT org_unit_type_pkey PRIMARY KEY (id);


--
-- Name: ou_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT ou_once_per_key UNIQUE (org_unit, name);


--
-- Name: sc_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: sc_once_per_usr; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT sc_once_per_usr UNIQUE (target_usr, stat_cat);


--
-- Name: sce_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: sced_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT sced_once_per_owner UNIQUE (stat_cat, owner);


--
-- Name: search_filter_group_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_pkey PRIMARY KEY (id);


--
-- Name: search_filter_group_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT search_filter_group_pkey PRIMARY KEY (id);


--
-- Name: search_query_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY search_query
    ADD CONSTRAINT search_query_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_default_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_usr_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT stat_cat_entry_usr_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: toolbar_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_pkey PRIMARY KEY (id);


--
-- Name: usr_activity_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_pkey PRIMARY KEY (id);


--
-- Name: usr_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_pkey PRIMARY KEY (id);


--
-- Name: usr_card_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_card_key UNIQUE (card);


--
-- Name: usr_note_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_pkey PRIMARY KEY (id);


--
-- Name: usr_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_once_per_key UNIQUE (usr, name);


--
-- Name: usr_opt_in_once_per_org_unit; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_opt_in_once_per_org_unit UNIQUE (usr, org_unit);


--
-- Name: usr_org_unit_opt_in_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_pkey PRIMARY KEY (id);


--
-- Name: usr_password_reset_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_password_reset
    ADD CONSTRAINT usr_password_reset_pkey PRIMARY KEY (id);


--
-- Name: usr_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_pkey PRIMARY KEY (id);


--
-- Name: usr_saved_search_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT usr_saved_search_pkey PRIMARY KEY (id);


--
-- Name: usr_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_pkey PRIMARY KEY (id);


--
-- Name: usr_standing_penalty_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: usr_usrname_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_usrname_key UNIQUE (usrname);


--
-- Name: workstation_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_name_key UNIQUE (name);


--
-- Name: workstation_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_pkey PRIMARY KEY (id);


SET search_path = asset, pg_catalog;

--
-- Name: acl_name_once_per_lib; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT acl_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: acplo_once_per_org; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT acplo_once_per_org UNIQUE (location, org);


--
-- Name: call_number_class_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_class
    ADD CONSTRAINT call_number_class_pkey PRIMARY KEY (id);


--
-- Name: call_number_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT call_number_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_pkey PRIMARY KEY (id);


--
-- Name: call_number_prefix_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_prefix
    ADD CONSTRAINT call_number_prefix_pkey PRIMARY KEY (id);


--
-- Name: call_number_suffix_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_suffix
    ADD CONSTRAINT call_number_suffix_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT copy_location_group_pkey PRIMARY KEY (id);


--
-- Name: copy_location_order_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_pkey PRIMARY KEY (id);


--
-- Name: copy_location_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT copy_location_pkey PRIMARY KEY (id);


--
-- Name: copy_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT copy_note_pkey PRIMARY KEY (id);


--
-- Name: copy_part_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_part_map
    ADD CONSTRAINT copy_part_map_pkey PRIMARY KEY (id);


--
-- Name: copy_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_pkey PRIMARY KEY (id);


--
-- Name: copy_template_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_pkey PRIMARY KEY (id);


--
-- Name: lgroup_once_per_group; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT lgroup_once_per_group UNIQUE (lgroup, location);


--
-- Name: lgroup_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT lgroup_once_per_owner UNIQUE (owner, name);


--
-- Name: opac_visible_copies_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY opac_visible_copies
    ADD CONSTRAINT opac_visible_copies_pkey PRIMARY KEY (id);


--
-- Name: sc_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: sce_once_per_copy; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT sce_once_per_copy UNIQUE (owning_copy, stat_cat);


--
-- Name: sce_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: scte_once_per_trans; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_transparency_map
    ADD CONSTRAINT scte_once_per_trans UNIQUE (owning_transparency, stat_cat);


--
-- Name: stat_cat_entry_copy_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT stat_cat_entry_copy_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_transparency_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_entry_transparency_map
    ADD CONSTRAINT stat_cat_entry_transparency_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: uri_call_number_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_pkey PRIMARY KEY (id);


--
-- Name: uri_cn_once; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_cn_once UNIQUE (uri, call_number);


--
-- Name: uri_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY uri
    ADD CONSTRAINT uri_pkey PRIMARY KEY (id);


SET search_path = auditor, pg_catalog;

--
-- Name: acq_fund_debit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_fund_debit_history
    ADD CONSTRAINT acq_fund_debit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_entry_history
    ADD CONSTRAINT acq_invoice_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_history
    ADD CONSTRAINT acq_invoice_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_item_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_invoice_item_history
    ADD CONSTRAINT acq_invoice_item_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_lineitem_detail_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY acq_lineitem_detail_history
    ADD CONSTRAINT acq_lineitem_detail_history_pkey PRIMARY KEY (audit_id);


--
-- Name: action_trigger_event_definition_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY action_trigger_event_definition_history
    ADD CONSTRAINT action_trigger_event_definition_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_org_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY actor_org_unit_history
    ADD CONSTRAINT actor_org_unit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_address_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY actor_usr_address_history
    ADD CONSTRAINT actor_usr_address_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY actor_usr_history
    ADD CONSTRAINT actor_usr_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_setting_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY actor_usr_setting_history
    ADD CONSTRAINT actor_usr_setting_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_call_number_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY asset_call_number_history
    ADD CONSTRAINT asset_call_number_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_copy_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY asset_copy_history
    ADD CONSTRAINT asset_copy_history_pkey PRIMARY KEY (audit_id);


--
-- Name: biblio_record_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_history
    ADD CONSTRAINT biblio_record_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: serial_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY serial_unit_history
    ADD CONSTRAINT serial_unit_history_pkey PRIMARY KEY (audit_id);


SET search_path = authority, pg_catalog;

--
-- Name: a_bf_mf_map_once; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set_bib_field_metabib_field_map
    ADD CONSTRAINT a_bf_mf_map_once UNIQUE (bib_field, metabib_field);


--
-- Name: authority_linking_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_linking
    ADD CONSTRAINT authority_linking_pkey PRIMARY KEY (id);


--
-- Name: bib_linking_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_pkey PRIMARY KEY (id);


--
-- Name: browse_axis_authority_field_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_pkey PRIMARY KEY (id);


--
-- Name: browse_axis_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_name_key UNIQUE (name);


--
-- Name: browse_axis_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_pkey PRIMARY KEY (code);


--
-- Name: control_set_authority_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_pkey PRIMARY KEY (id);


--
-- Name: control_set_bib_field_metabib_field_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_pkey PRIMARY KEY (id);


--
-- Name: control_set_bib_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_pkey PRIMARY KEY (id);


--
-- Name: control_set_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set
    ADD CONSTRAINT control_set_name_key UNIQUE (name);


--
-- Name: control_set_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY control_set
    ADD CONSTRAINT control_set_pkey PRIMARY KEY (id);


--
-- Name: full_rec_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY full_rec
    ADD CONSTRAINT full_rec_pkey PRIMARY KEY (id);


--
-- Name: rec_descriptor_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rec_descriptor
    ADD CONSTRAINT rec_descriptor_pkey PRIMARY KEY (id);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_note_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


--
-- Name: reference_headings_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY display_5xx_headings
    ADD CONSTRAINT reference_headings_pkey PRIMARY KEY (id);


--
-- Name: simple_heading_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_pkey PRIMARY KEY (id);


--
-- Name: thesaurus_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_name_key UNIQUE (name);


--
-- Name: thesaurus_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_pkey PRIMARY KEY (code);


SET search_path = biblio, pg_catalog;

--
-- Name: monograph_part_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT monograph_part_pkey PRIMARY KEY (id);


--
-- Name: peer_bib_copy_map_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_pkey PRIMARY KEY (id);


--
-- Name: peer_type_name_key; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY peer_type
    ADD CONSTRAINT peer_type_name_key UNIQUE (name);


--
-- Name: peer_type_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY peer_type
    ADD CONSTRAINT peer_type_pkey PRIMARY KEY (id);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_label_unique; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT record_label_unique UNIQUE (record, label);


--
-- Name: record_note_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


SET search_path = booking, pg_catalog;

--
-- Name: br_unique; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT br_unique UNIQUE (owner, barcode);


--
-- Name: bra_name_once_per_type; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT bra_name_once_per_type UNIQUE (resource_type, name);


--
-- Name: bram_one_value_per_attr; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT bram_one_value_per_attr UNIQUE (resource, resource_attr);


--
-- Name: brav_logical_key; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT brav_logical_key UNIQUE (owner, attr, valid_value);


--
-- Name: bravm_logical_key; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT bravm_logical_key UNIQUE (reservation, attr_value);


--
-- Name: brt_name_and_record_once_per_owner; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT brt_name_and_record_once_per_owner UNIQUE (owner, name, record);


--
-- Name: reservation_attr_value_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_pkey PRIMARY KEY (id);


--
-- Name: reservation_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_value_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_pkey PRIMARY KEY (id);


--
-- Name: resource_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_pkey PRIMARY KEY (id);


--
-- Name: resource_type_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_pkey PRIMARY KEY (id);


SET search_path = config, pg_catalog;

--
-- Name: barcode_completion_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY barcode_completion
    ADD CONSTRAINT barcode_completion_pkey PRIMARY KEY (id);


--
-- Name: best_hold_order_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY best_hold_order
    ADD CONSTRAINT best_hold_order_name_key UNIQUE (name);


--
-- Name: best_hold_order_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY best_hold_order
    ADD CONSTRAINT best_hold_order_pkey PRIMARY KEY (id);


--
-- Name: bib_source_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_source
    ADD CONSTRAINT bib_source_pkey PRIMARY KEY (id);


--
-- Name: bib_source_source_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_source
    ADD CONSTRAINT bib_source_source_key UNIQUE (source);


--
-- Name: biblio_fingerprint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_fingerprint
    ADD CONSTRAINT biblio_fingerprint_pkey PRIMARY KEY (id);


--
-- Name: billing_type_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT billing_type_once_per_lib UNIQUE (name, owner);


--
-- Name: billing_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT billing_type_pkey PRIMARY KEY (id);


--
-- Name: cfdfs_name_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT cfdfs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: circ_limit_group_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_group
    ADD CONSTRAINT circ_limit_group_name_key UNIQUE (name);


--
-- Name: circ_limit_group_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_group
    ADD CONSTRAINT circ_limit_group_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_circ_mod_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_copy_loc_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_group_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_name_key UNIQUE (name);


--
-- Name: circ_limit_set_once_per_matchpoint; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_limit_set_once_per_matchpoint UNIQUE (matchpoint, limit_set);


--
-- Name: circ_limit_set_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_circ_mod_test_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_circ_mod_test_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_circ_mod_test
    ADD CONSTRAINT circ_matrix_circ_mod_test_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_limit_set_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_name_key UNIQUE (name);


--
-- Name: circ_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: circ_modifier_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_modifier
    ADD CONSTRAINT circ_modifier_name_key UNIQUE (name);


--
-- Name: circ_modifier_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_modifier
    ADD CONSTRAINT circ_modifier_pkey PRIMARY KEY (code);


--
-- Name: cl_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT cl_once_per_set UNIQUE (limit_set, copy_loc);


--
-- Name: clg_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT clg_once_per_set UNIQUE (limit_set, limit_group);


--
-- Name: cm_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT cm_once_per_set UNIQUE (limit_set, circ_mod);


--
-- Name: cm_once_per_test; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY circ_matrix_circ_mod_test_map
    ADD CONSTRAINT cm_once_per_test UNIQUE (circ_mod_test, circ_mod);


--
-- Name: coded_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY coded_value_map
    ADD CONSTRAINT coded_value_map_pkey PRIMARY KEY (id);


--
-- Name: copy_status_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_status
    ADD CONSTRAINT copy_status_name_key UNIQUE (name);


--
-- Name: copy_status_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_status
    ADD CONSTRAINT copy_status_pkey PRIMARY KEY (id);


--
-- Name: czsc_source_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT czsc_source_once_per_lib UNIQUE (source, owner);


--
-- Name: db_patch_dependencies_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY db_patch_dependencies
    ADD CONSTRAINT db_patch_dependencies_pkey PRIMARY KEY (db_patch);


--
-- Name: filter_dialog_filter_set_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_pkey PRIMARY KEY (id);


--
-- Name: filter_dialog_interface_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY filter_dialog_interface
    ADD CONSTRAINT filter_dialog_interface_pkey PRIMARY KEY (key);


--
-- Name: global_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY global_flag
    ADD CONSTRAINT global_flag_pkey PRIMARY KEY (name);


--
-- Name: hard_due_date_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hard_due_date
    ADD CONSTRAINT hard_due_date_name_key UNIQUE (name);


--
-- Name: hard_due_date_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hard_due_date
    ADD CONSTRAINT hard_due_date_pkey PRIMARY KEY (id);


--
-- Name: hard_due_date_values_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_name_key UNIQUE (name);


--
-- Name: hold_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: i18n_core_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY i18n_core
    ADD CONSTRAINT i18n_core_pkey PRIMARY KEY (id);


--
-- Name: i18n_locale_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY i18n_locale
    ADD CONSTRAINT i18n_locale_name_key UNIQUE (name);


--
-- Name: i18n_locale_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY i18n_locale
    ADD CONSTRAINT i18n_locale_pkey PRIMARY KEY (code);


--
-- Name: identification_type_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY identification_type
    ADD CONSTRAINT identification_type_name_key UNIQUE (name);


--
-- Name: identification_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY identification_type
    ADD CONSTRAINT identification_type_pkey PRIMARY KEY (id);


--
-- Name: idl_field_doc_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY idl_field_doc
    ADD CONSTRAINT idl_field_doc_pkey PRIMARY KEY (id);


--
-- Name: index_normalizer_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY index_normalizer
    ADD CONSTRAINT index_normalizer_name_key UNIQUE (name);


--
-- Name: index_normalizer_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY index_normalizer
    ADD CONSTRAINT index_normalizer_pkey PRIMARY KEY (id);


--
-- Name: internal_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY internal_flag
    ADD CONSTRAINT internal_flag_pkey PRIMARY KEY (name);


--
-- Name: marc21_ff_pos_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY marc21_ff_pos_map
    ADD CONSTRAINT marc21_ff_pos_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_subfield_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_type_map
    ADD CONSTRAINT marc21_physical_characteristic_type_map_pkey PRIMARY KEY (ptype_key);


--
-- Name: marc21_physical_characteristic_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_rec_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY marc21_rec_type_map
    ADD CONSTRAINT marc21_rec_type_map_pkey PRIMARY KEY (code);


--
-- Name: metabib_class_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_class
    ADD CONSTRAINT metabib_class_label_key UNIQUE (label);


--
-- Name: metabib_class_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_class
    ADD CONSTRAINT metabib_class_pkey PRIMARY KEY (name);


--
-- Name: metabib_class_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_search_alias_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_pkey PRIMARY KEY (alias);


--
-- Name: net_access_level_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY net_access_level
    ADD CONSTRAINT net_access_level_name_key UNIQUE (name);


--
-- Name: net_access_level_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY net_access_level
    ADD CONSTRAINT net_access_level_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_type
    ADD CONSTRAINT non_cataloged_type_pkey PRIMARY KEY (id);


--
-- Name: noncat_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY non_cataloged_type
    ADD CONSTRAINT noncat_once_per_lib UNIQUE (owning_lib, name);


--
-- Name: org_unit_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_label_key UNIQUE (label);


--
-- Name: org_unit_setting_type_log_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_pkey PRIMARY KEY (name);


--
-- Name: patron_message_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY patron_message
    ADD CONSTRAINT patron_message_pkey PRIMARY KEY (id);


--
-- Name: record_attr_definition_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_pkey PRIMARY KEY (name);


--
-- Name: record_attr_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: remote_account_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY remote_account
    ADD CONSTRAINT remote_account_pkey PRIMARY KEY (id);


--
-- Name: rule_age_hold_protect_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_name_key UNIQUE (name);


--
-- Name: rule_age_hold_protect_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_pkey PRIMARY KEY (id);


--
-- Name: rule_circ_duration_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_name_key UNIQUE (name);


--
-- Name: rule_circ_duration_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_pkey PRIMARY KEY (id);


--
-- Name: rule_max_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_max_fine
    ADD CONSTRAINT rule_max_fine_name_key UNIQUE (name);


--
-- Name: rule_max_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_max_fine
    ADD CONSTRAINT rule_max_fine_pkey PRIMARY KEY (id);


--
-- Name: rule_recurring_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_name_key UNIQUE (name);


--
-- Name: rule_recurring_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_pkey PRIMARY KEY (id);


--
-- Name: settings_group_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY settings_group
    ADD CONSTRAINT settings_group_label_key UNIQUE (label);


--
-- Name: settings_group_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY settings_group
    ADD CONSTRAINT settings_group_pkey PRIMARY KEY (name);


--
-- Name: sms_carrier_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY sms_carrier
    ADD CONSTRAINT sms_carrier_pkey PRIMARY KEY (id);


--
-- Name: standing_penalty_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY standing_penalty
    ADD CONSTRAINT standing_penalty_name_key UNIQUE (name);


--
-- Name: standing_penalty_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY standing_penalty
    ADD CONSTRAINT standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: standing_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY standing
    ADD CONSTRAINT standing_pkey PRIMARY KEY (id);


--
-- Name: standing_value_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY standing
    ADD CONSTRAINT standing_value_key UNIQUE (value);


--
-- Name: ts_config_list_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY ts_config_list
    ADD CONSTRAINT ts_config_list_pkey PRIMARY KEY (id);


--
-- Name: upgrade_log_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY upgrade_log
    ADD CONSTRAINT upgrade_log_pkey PRIMARY KEY (version);


--
-- Name: usr_activity_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_activity_type
    ADD CONSTRAINT usr_activity_type_pkey PRIMARY KEY (id);


--
-- Name: usr_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_label_key UNIQUE (label);


--
-- Name: usr_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_pkey PRIMARY KEY (name);


--
-- Name: weight_assoc_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_pkey PRIMARY KEY (id);


--
-- Name: xml_transform_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY xml_transform
    ADD CONSTRAINT xml_transform_pkey PRIMARY KEY (name);


--
-- Name: z3950_attr_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z3950_attr_pkey PRIMARY KEY (id);


--
-- Name: z3950_source_credentials_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_pkey PRIMARY KEY (id);


--
-- Name: z3950_source_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT z3950_source_label_key UNIQUE (label);


--
-- Name: z3950_source_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT z3950_source_pkey PRIMARY KEY (name);


--
-- Name: z_code_format_once_per_source; Type: CONSTRAINT; Schema: config; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z_code_format_once_per_source UNIQUE (code, format, source);


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_label_key UNIQUE (label);


--
-- Name: biblio_record_entry_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: breb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT breb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: call_number_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_label_key UNIQUE (label);


--
-- Name: call_number_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: cb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT cb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: cnb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT cnb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: copy_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_label_key UNIQUE (label);


--
-- Name: copy_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: ub_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT ub_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: user_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket_note
    ADD CONSTRAINT user_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket_type
    ADD CONSTRAINT user_bucket_type_label_key UNIQUE (label);


--
-- Name: user_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_bucket_type
    ADD CONSTRAINT user_bucket_type_pkey PRIMARY KEY (code);


SET search_path = extend_reporter, pg_catalog;

--
-- Name: legacy_circ_count_pkey; Type: CONSTRAINT; Schema: extend_reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY legacy_circ_count
    ADD CONSTRAINT legacy_circ_count_pkey PRIMARY KEY (id);


SET search_path = m_enum, pg_catalog;

--
-- Name: bib_map_egid_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_map
    ADD CONSTRAINT bib_map_egid_key UNIQUE (egid);


--
-- Name: bib_map_item_eg_id_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_map
    ADD CONSTRAINT bib_map_item_eg_id_key UNIQUE (item_eg_id);


--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


--
-- Name: org_map_l_library_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY org_map
    ADD CONSTRAINT org_map_l_library_key UNIQUE (l_library);


SET search_path = m_kcls, pg_catalog;

--
-- Name: bibs_to_fix_pkey; Type: CONSTRAINT; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bibs_to_fix
    ADD CONSTRAINT bibs_to_fix_pkey PRIMARY KEY (seq);


--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls2, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls3, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_call_fix, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_circhist, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_gap, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_holds, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_holdsall, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_holdsall2, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_holdsall3, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_holdsfix, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_items2, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_items3, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_ord, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_ord2, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_kcls_ord3, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = m_test, pg_catalog;

--
-- Name: config_key_key; Type: CONSTRAINT; Schema: m_test; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_key_key UNIQUE (key);


SET search_path = metabib, pg_catalog;

--
-- Name: author_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY author_field_entry
    ADD CONSTRAINT author_field_entry_pkey PRIMARY KEY (id);


--
-- Name: bib_export_data_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_export_data
    ADD CONSTRAINT bib_export_data_pkey PRIMARY KEY (id);


--
-- Name: browse_author_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_author_entry_def_map
    ADD CONSTRAINT browse_author_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_author_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_author_entry
    ADD CONSTRAINT browse_author_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_author_entry_simple_heading_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_author_entry_simple_heading_map
    ADD CONSTRAINT browse_author_entry_simple_heading_map_pkey PRIMARY KEY (id);


--
-- Name: browse_author_entry_sort_value_value_key; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_author_entry
    ADD CONSTRAINT browse_author_entry_sort_value_value_key UNIQUE (sort_value);


--
-- Name: browse_call_number_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_call_number_entry_def_map
    ADD CONSTRAINT browse_call_number_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_call_number_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_call_number_entry
    ADD CONSTRAINT browse_call_number_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_call_number_entry_sort_value_value_key; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_call_number_entry
    ADD CONSTRAINT browse_call_number_entry_sort_value_value_key UNIQUE (sort_value);


--
-- Name: browse_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_entry
    ADD CONSTRAINT browse_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_series_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_series_entry_def_map
    ADD CONSTRAINT browse_series_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_series_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_series_entry
    ADD CONSTRAINT browse_series_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_series_entry_simple_heading_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_series_entry_simple_heading_map
    ADD CONSTRAINT browse_series_entry_simple_heading_map_pkey PRIMARY KEY (id);


--
-- Name: browse_series_entry_sort_value_value_key; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_series_entry
    ADD CONSTRAINT browse_series_entry_sort_value_value_key UNIQUE (sort_value);


--
-- Name: browse_subject_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_subject_entry_def_map
    ADD CONSTRAINT browse_subject_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_subject_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_subject_entry
    ADD CONSTRAINT browse_subject_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_subject_entry_simple_heading_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_subject_entry_simple_heading_map
    ADD CONSTRAINT browse_subject_entry_simple_heading_map_pkey PRIMARY KEY (id);


--
-- Name: browse_subject_entry_sort_value_value_key; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_subject_entry
    ADD CONSTRAINT browse_subject_entry_sort_value_value_key UNIQUE (sort_value);


--
-- Name: browse_title_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_title_entry_def_map
    ADD CONSTRAINT browse_title_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_title_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_title_entry
    ADD CONSTRAINT browse_title_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_title_entry_simple_heading_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_title_entry_simple_heading_map
    ADD CONSTRAINT browse_title_entry_simple_heading_map_pkey PRIMARY KEY (id);


--
-- Name: browse_title_entry_sort_value_value_key; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY browse_title_entry
    ADD CONSTRAINT browse_title_entry_sort_value_value_key UNIQUE (sort_value);


--
-- Name: call_number_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY call_number_field_entry
    ADD CONSTRAINT call_number_field_entry_pkey PRIMARY KEY (id);


--
-- Name: facet_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY facet_entry
    ADD CONSTRAINT facet_entry_pkey PRIMARY KEY (id);


--
-- Name: identifier_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT identifier_field_entry_pkey PRIMARY KEY (id);


--
-- Name: keyword_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY keyword_field_entry
    ADD CONSTRAINT keyword_field_entry_pkey PRIMARY KEY (id);


--
-- Name: language_filter_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY language_filter
    ADD CONSTRAINT language_filter_pkey PRIMARY KEY (id);


--
-- Name: metarecord_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metarecord
    ADD CONSTRAINT metarecord_pkey PRIMARY KEY (id);


--
-- Name: metarecord_source_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metarecord_source_map_pkey PRIMARY KEY (id);


--
-- Name: normalized_author_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY normalized_author_field_entry
    ADD CONSTRAINT normalized_author_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_keyword_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY normalized_keyword_field_entry
    ADD CONSTRAINT normalized_keyword_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_series_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY normalized_series_field_entry
    ADD CONSTRAINT normalized_series_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_subject_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY normalized_subject_field_entry
    ADD CONSTRAINT normalized_subject_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_title_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY normalized_title_field_entry
    ADD CONSTRAINT normalized_title_field_entry_pkey PRIMARY KEY (id);


--
-- Name: real_full_rec_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY real_full_rec
    ADD CONSTRAINT real_full_rec_pkey PRIMARY KEY (id);


--
-- Name: record_attr_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_attr
    ADD CONSTRAINT record_attr_pkey PRIMARY KEY (id);


--
-- Name: series_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY series_field_entry
    ADD CONSTRAINT series_field_entry_pkey PRIMARY KEY (id);


--
-- Name: subject_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY subject_field_entry
    ADD CONSTRAINT subject_field_entry_pkey PRIMARY KEY (id);


--
-- Name: title_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY title_field_entry
    ADD CONSTRAINT title_field_entry_pkey PRIMARY KEY (id);


SET search_path = money, pg_catalog;

--
-- Name: billable_xact_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY billable_xact
    ADD CONSTRAINT billable_xact_pkey PRIMARY KEY (id);


--
-- Name: billing_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY billing
    ADD CONSTRAINT billing_pkey PRIMARY KEY (id);


--
-- Name: bnm_desk_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_pkey PRIMARY KEY (id);


--
-- Name: bnm_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bnm_payment
    ADD CONSTRAINT bnm_payment_pkey PRIMARY KEY (id);


--
-- Name: cash_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY cash_payment
    ADD CONSTRAINT cash_payment_pkey PRIMARY KEY (id);


--
-- Name: check_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY check_payment
    ADD CONSTRAINT check_payment_pkey PRIMARY KEY (id);


--
-- Name: collections_tracker_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_pkey PRIMARY KEY (id);


--
-- Name: credit_card_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY credit_card_payment
    ADD CONSTRAINT credit_card_payment_pkey PRIMARY KEY (id);


--
-- Name: credit_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY credit_payment
    ADD CONSTRAINT credit_payment_pkey PRIMARY KEY (id);


--
-- Name: forgive_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY forgive_payment
    ADD CONSTRAINT forgive_payment_pkey PRIMARY KEY (id);


--
-- Name: goods_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY goods_payment
    ADD CONSTRAINT goods_payment_pkey PRIMARY KEY (id);


--
-- Name: grocery_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grocery
    ADD CONSTRAINT grocery_pkey PRIMARY KEY (id);


--
-- Name: materialized_billable_xact_summary_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY materialized_billable_xact_summary
    ADD CONSTRAINT materialized_billable_xact_summary_pkey PRIMARY KEY (id);


--
-- Name: payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY payment
    ADD CONSTRAINT payment_pkey PRIMARY KEY (id);


--
-- Name: work_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY work_payment
    ADD CONSTRAINT work_payment_pkey PRIMARY KEY (id);


SET search_path = offline, pg_catalog;

--
-- Name: script_pkey; Type: CONSTRAINT; Schema: offline; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY script
    ADD CONSTRAINT script_pkey PRIMARY KEY (id);


--
-- Name: session_pkey; Type: CONSTRAINT; Schema: offline; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_pkey PRIMARY KEY (key);


SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_pkey PRIMARY KEY (id);


--
-- Name: grp_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_pkey PRIMARY KEY (id);


--
-- Name: grp_tree_name_key; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_name_key UNIQUE (name);


--
-- Name: grp_tree_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_pkey PRIMARY KEY (id);


--
-- Name: penalty_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT penalty_grp_once UNIQUE (grp, penalty, org_unit);


--
-- Name: perm_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT perm_grp_once UNIQUE (grp, perm);


--
-- Name: perm_list_code_key; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY perm_list
    ADD CONSTRAINT perm_list_code_key UNIQUE (code);


--
-- Name: perm_list_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY perm_list
    ADD CONSTRAINT perm_list_pkey PRIMARY KEY (id);


--
-- Name: perm_usr_obj_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT perm_usr_obj_once UNIQUE (usr, perm, object_type, object_id);


--
-- Name: perm_usr_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT perm_usr_once UNIQUE (usr, perm);


--
-- Name: usr_grp_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_pkey PRIMARY KEY (id);


--
-- Name: usr_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_once UNIQUE (usr, grp);


--
-- Name: usr_object_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_once UNIQUE (usr, work_ou);


SET search_path = prod_staff_users, pg_catalog;

--
-- Name: address_pk; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT address_pk PRIMARY KEY (id);


--
-- Name: card_pkey; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: usr_pkey; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_pkey PRIMARY KEY (id);


SET search_path = query, pg_catalog;

--
-- Name: bind_variable_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bind_variable
    ADD CONSTRAINT bind_variable_pkey PRIMARY KEY (name);


--
-- Name: case_branch_parent_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_parent_seq UNIQUE (parent_expr, seq_no);


--
-- Name: case_branch_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_pkey PRIMARY KEY (id);


--
-- Name: column_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT column_sequence UNIQUE (from_relation, seq_no);


--
-- Name: datatype_datatype_name_key; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY datatype
    ADD CONSTRAINT datatype_datatype_name_key UNIQUE (datatype_name);


--
-- Name: datatype_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY datatype
    ADD CONSTRAINT datatype_pkey PRIMARY KEY (id);


--
-- Name: expression_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_pkey PRIMARY KEY (id);


--
-- Name: from_relation_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_pkey PRIMARY KEY (id);


--
-- Name: function_param_def_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_pkey PRIMARY KEY (id);


--
-- Name: function_sig_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY function_sig
    ADD CONSTRAINT function_sig_pkey PRIMARY KEY (id);


--
-- Name: order_by_item_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_pkey PRIMARY KEY (id);


--
-- Name: order_by_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_sequence UNIQUE (stored_query, seq_no);


--
-- Name: qfpd_function_param_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT qfpd_function_param_seq UNIQUE (function_id, seq_no);


--
-- Name: qsf_datatype_seq_no; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT qsf_datatype_seq_no UNIQUE (composite_type, seq_no);


--
-- Name: query_query_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_query_seq UNIQUE (parent_query, seq_no);


--
-- Name: query_sequence_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_pkey PRIMARY KEY (id);


--
-- Name: record_column_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_pkey PRIMARY KEY (id);


--
-- Name: select_item_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_pkey PRIMARY KEY (id);


--
-- Name: select_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_sequence UNIQUE (stored_query, seq_no);


--
-- Name: stored_query_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_pkey PRIMARY KEY (id);


--
-- Name: subfield_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_pkey PRIMARY KEY (id);


SET search_path = reporter, pg_catalog;

--
-- Name: materialized_simple_record_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY materialized_simple_record
    ADD CONSTRAINT materialized_simple_record_pkey PRIMARY KEY (id);


--
-- Name: output_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_pkey PRIMARY KEY (id);


--
-- Name: report_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_pkey PRIMARY KEY (id);


--
-- Name: report_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_pkey PRIMARY KEY (id);


--
-- Name: schedule_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_pkey PRIMARY KEY (id);


--
-- Name: template_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_pkey PRIMARY KEY (id);


--
-- Name: template_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_pkey PRIMARY KEY (id);


SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment_pkey; Type: CONSTRAINT; Schema: search; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_pkey PRIMARY KEY (id);


SET search_path = serial, pg_catalog;

--
-- Name: bib_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY basic_summary
    ADD CONSTRAINT bib_summary_pkey PRIMARY KEY (id);


--
-- Name: caption_and_pattern_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_pkey PRIMARY KEY (id);


--
-- Name: distribution_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_pkey PRIMARY KEY (id);


--
-- Name: distribution_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_pkey PRIMARY KEY (id);


--
-- Name: index_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY index_summary
    ADD CONSTRAINT index_summary_pkey PRIMARY KEY (id);


--
-- Name: issuance_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_pkey PRIMARY KEY (id);


--
-- Name: item_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_pkey PRIMARY KEY (id);


--
-- Name: item_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_pkey PRIMARY KEY (id);


--
-- Name: materialized_holding_code_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_pkey PRIMARY KEY (id);


--
-- Name: one_pos_per_routing_list; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT one_pos_per_routing_list UNIQUE (stream, pos);


--
-- Name: record_entry_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: routing_list_user_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_pkey PRIMARY KEY (id);


--
-- Name: stream_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY stream
    ADD CONSTRAINT stream_pkey PRIMARY KEY (id);


--
-- Name: subscription_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_pkey PRIMARY KEY (id);


--
-- Name: subscription_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_pkey PRIMARY KEY (id);


--
-- Name: sup_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY supplement_summary
    ADD CONSTRAINT sup_summary_pkey PRIMARY KEY (id);


--
-- Name: unit_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT unit_pkey PRIMARY KEY (id);


SET search_path = staging, pg_catalog;

--
-- Name: billing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY billing_address_stage
    ADD CONSTRAINT billing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: card_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY card_stage
    ADD CONSTRAINT card_stage_pkey PRIMARY KEY (row_id);


--
-- Name: mailing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY mailing_address_stage
    ADD CONSTRAINT mailing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: statcat_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY statcat_stage
    ADD CONSTRAINT statcat_stage_pkey PRIMARY KEY (row_id);


--
-- Name: user_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY user_stage
    ADD CONSTRAINT user_stage_pkey PRIMARY KEY (row_id);


SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout_pkey; Type: CONSTRAINT; Schema: unapi; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bre_output_layout
    ADD CONSTRAINT bre_output_layout_pkey PRIMARY KEY (name);


SET search_path = url_verify, pg_catalog;

--
-- Name: session_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_pkey PRIMARY KEY (id);


--
-- Name: tag_once_per_sess; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT tag_once_per_sess UNIQUE (xpath, session);


--
-- Name: url_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_pkey PRIMARY KEY (id);


--
-- Name: url_selector_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT url_selector_pkey PRIMARY KEY (id);


--
-- Name: url_verification_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_pkey PRIMARY KEY (id);


--
-- Name: uvs_name_once_per_lib; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY session
    ADD CONSTRAINT uvs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: verification_attempt_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_pkey PRIMARY KEY (id);


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_code_key UNIQUE (code);


--
-- Name: authority_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: authority_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_pkey PRIMARY KEY (id);


--
-- Name: authority_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_queue
    ADD CONSTRAINT authority_queue_pkey PRIMARY KEY (id);


--
-- Name: bib_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_code_key UNIQUE (code);


--
-- Name: bib_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: bib_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_pkey PRIMARY KEY (id);


--
-- Name: bib_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT bib_queue_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_fields_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_group_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_pkey PRIMARY KEY (id);


--
-- Name: import_error_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_error
    ADD CONSTRAINT import_error_pkey PRIMARY KEY (code);


--
-- Name: import_item_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: import_item_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_pkey PRIMARY KEY (id);


--
-- Name: match_set_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT match_set_pkey PRIMARY KEY (id);


--
-- Name: match_set_point_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_pkey PRIMARY KEY (id);


--
-- Name: match_set_quality_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_pkey PRIMARY KEY (id);


--
-- Name: merge_profile_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT merge_profile_pkey PRIMARY KEY (id);


--
-- Name: name_once_per_owner_mtype; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT name_once_per_owner_mtype UNIQUE (name, owner, mtype);


--
-- Name: queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_pkey PRIMARY KEY (id);


--
-- Name: queued_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY queued_record
    ADD CONSTRAINT queued_record_pkey PRIMARY KEY (id);


--
-- Name: vand_authority_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY authority_queue
    ADD CONSTRAINT vand_authority_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: vand_bib_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT vand_bib_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: vand_import_bib_trash_fields_once_per; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT vand_import_bib_trash_fields_once_per UNIQUE (grp, field);


--
-- Name: vand_import_bib_trash_grp_owner_label; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT vand_import_bib_trash_grp_owner_label UNIQUE (owner, label);


--
-- Name: vand_import_item_attr_def_idx; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT vand_import_item_attr_def_idx UNIQUE (owner, name);


--
-- Name: vand_merge_prof_owner_name_idx; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen; Tablespace: 
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT vand_merge_prof_owner_name_idx UNIQUE (owner, name);


SET search_path = acq, pg_catalog;

--
-- Name: account_status_remote_file_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX account_status_remote_file_idx ON edi_message USING btree (account, status, remote_file);


--
-- Name: acq_attribution_credit_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_attribution_credit_idx ON debit_attribution USING btree (funding_source_credit);


--
-- Name: acq_attribution_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_attribution_debit_idx ON debit_attribution USING btree (fund_debit);


--
-- Name: acq_lineitem_hist_id_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_lineitem_hist_id_idx ON acq_lineitem_history USING btree (id);


--
-- Name: acq_picklist_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_picklist_creator_idx ON picklist USING btree (creator);


--
-- Name: acq_picklist_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_picklist_editor_idx ON picklist USING btree (editor);


--
-- Name: acq_picklist_owner_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_picklist_owner_idx ON picklist USING btree (owner);


--
-- Name: acq_po_hist_id_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_po_hist_id_idx ON acq_purchase_order_history USING btree (id);


--
-- Name: acq_po_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_po_note_creator_idx ON po_note USING btree (creator);


--
-- Name: acq_po_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_po_note_editor_idx ON po_note USING btree (editor);


--
-- Name: acq_po_org_name_order_date_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_po_org_name_order_date_idx ON purchase_order USING btree (ordering_agency, name, order_date);


--
-- Name: acq_pro_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_pro_note_creator_idx ON provider_note USING btree (creator);


--
-- Name: acq_pro_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_pro_note_editor_idx ON provider_note USING btree (editor);


--
-- Name: acq_pro_note_pro_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acq_pro_note_pro_idx ON provider_note USING btree (provider);


--
-- Name: acqdfa_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acqdfa_creator_idx ON distribution_formula_application USING btree (creator);


--
-- Name: acqdfa_df_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acqdfa_df_idx ON distribution_formula_application USING btree (formula);


--
-- Name: acqdfa_li_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acqdfa_li_idx ON distribution_formula_application USING btree (lineitem);


--
-- Name: acqftr_usr_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX acqftr_usr_idx ON fund_transfer USING btree (transfer_user);


--
-- Name: claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX claim_event_claim_date_idx ON claim_event USING btree (claim, event_date);


--
-- Name: claim_lid_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX claim_lid_idx ON claim USING btree (lineitem_detail);


--
-- Name: fund_alloc_allocator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX fund_alloc_allocator_idx ON fund_allocation USING btree (allocator);


--
-- Name: fund_debit_invoice_entry_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX fund_debit_invoice_entry_idx ON fund_debit USING btree (invoice_entry);


--
-- Name: li_attr_definition_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_attr_definition_idx ON lineitem_attr USING btree (definition);


--
-- Name: li_attr_li_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_attr_li_idx ON lineitem_attr USING btree (lineitem);


--
-- Name: li_attr_value_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_attr_value_idx ON lineitem_attr USING btree (attr_value);


--
-- Name: li_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_creator_idx ON lineitem USING btree (creator);


--
-- Name: li_detail_li_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_detail_li_idx ON lineitem_detail USING btree (lineitem);


--
-- Name: li_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_editor_idx ON lineitem USING btree (editor);


--
-- Name: li_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_note_creator_idx ON lineitem_note USING btree (creator);


--
-- Name: li_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_note_editor_idx ON lineitem_note USING btree (editor);


--
-- Name: li_note_li_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_note_li_idx ON lineitem_note USING btree (lineitem);


--
-- Name: li_pl_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_pl_idx ON lineitem USING btree (picklist);


--
-- Name: li_po_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_po_idx ON lineitem USING btree (purchase_order);


--
-- Name: li_selector_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_selector_idx ON lineitem USING btree (selector);


--
-- Name: li_usr_attr_def_usr_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX li_usr_attr_def_usr_idx ON lineitem_usr_attr_definition USING btree (usr);


--
-- Name: lineitem_detail_fund_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX lineitem_detail_fund_debit_idx ON lineitem_detail USING btree (fund_debit);


--
-- Name: po_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_creator_idx ON purchase_order USING btree (creator);


--
-- Name: po_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_editor_idx ON purchase_order USING btree (editor);


--
-- Name: po_note_po_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_note_po_idx ON po_note USING btree (purchase_order);


--
-- Name: po_owner_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_owner_idx ON purchase_order USING btree (owner);


--
-- Name: po_provider_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_provider_idx ON purchase_order USING btree (provider);


--
-- Name: po_state_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX po_state_idx ON purchase_order USING btree (state);


--
-- Name: serial_claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_claim_event_claim_date_idx ON serial_claim_event USING btree (claim, event_date);


--
-- Name: serial_claim_lid_idx; Type: INDEX; Schema: acq; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_claim_lid_idx ON serial_claim USING btree (item);


SET search_path = action, pg_catalog;

--
-- Name: acm_copy_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX acm_copy_idx ON hold_copy_map USING btree (target_copy);


--
-- Name: action_fieldset_sched_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_fieldset_sched_time_idx ON fieldset USING btree (scheduled_time);


--
-- Name: action_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_in_house_use_staff_idx ON in_house_use USING btree (staff);


--
-- Name: action_non_cat_circ_patron_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_non_cat_circ_patron_idx ON non_cataloged_circulation USING btree (patron);


--
-- Name: action_non_cat_circ_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_non_cat_circ_staff_idx ON non_cataloged_circulation USING btree (staff);


--
-- Name: action_owner_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_owner_idx ON fieldset USING btree (owner);


--
-- Name: action_survey_response_usr_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX action_survey_response_usr_idx ON survey_response USING btree (usr);


--
-- Name: active_hold_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_hold_transit_cp_idx ON hold_transit_copy USING btree (target_copy);


--
-- Name: active_hold_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_hold_transit_dest_idx ON hold_transit_copy USING btree (dest);


--
-- Name: active_hold_transit_hold_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_hold_transit_hold_idx ON hold_transit_copy USING btree (hold);


--
-- Name: active_hold_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_hold_transit_source_idx ON hold_transit_copy USING btree (source);


--
-- Name: active_reservation_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_reservation_transit_cp_idx ON reservation_transit_copy USING btree (target_copy);


--
-- Name: active_reservation_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_reservation_transit_dest_idx ON reservation_transit_copy USING btree (dest);


--
-- Name: active_reservation_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_reservation_transit_source_idx ON reservation_transit_copy USING btree (source);


--
-- Name: active_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_transit_cp_idx ON transit_copy USING btree (target_copy);


--
-- Name: active_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_transit_dest_idx ON transit_copy USING btree (dest);


--
-- Name: active_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX active_transit_source_idx ON transit_copy USING btree (source);


--
-- Name: aged_circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_circ_lib_idx ON aged_circulation USING btree (circ_lib);


--
-- Name: aged_circ_copy_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_copy_circ_lib_idx ON aged_circulation USING btree (copy_circ_lib);


--
-- Name: aged_circ_copy_location_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_copy_location_idx ON aged_circulation USING btree (copy_location);


--
-- Name: aged_circ_copy_owning_lib_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_copy_owning_lib_idx ON aged_circulation USING btree (copy_owning_lib);


--
-- Name: aged_circ_id_target_copy; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_id_target_copy ON aged_circulation USING btree (id, target_copy);


--
-- Name: aged_circ_start_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_start_idx ON aged_circulation USING btree (xact_start);


--
-- Name: aged_circ_target_copy_xact_start_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX aged_circ_target_copy_xact_start_idx ON aged_circulation USING btree (target_copy, xact_start);


--
-- Name: ahn_hold_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX ahn_hold_idx ON hold_notification USING btree (hold);


--
-- Name: ahn_notify_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX ahn_notify_staff_idx ON hold_notification USING btree (notify_staff);


--
-- Name: ahr_target_and_type_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX ahr_target_and_type_idx ON hold_request USING btree (target, hold_type, id);


--
-- Name: ahrn_hold_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX ahrn_hold_idx ON hold_request_note USING btree (hold);


--
-- Name: archived_hold_request_2005_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2005_request_time_idx ON archived_hold_request_2005 USING btree (request_time);


--
-- Name: archived_hold_request_2006_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2006_request_time_idx ON archived_hold_request_2006 USING btree (request_time);


--
-- Name: archived_hold_request_2007_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2007_request_time_idx ON archived_hold_request_2007 USING btree (request_time);


--
-- Name: archived_hold_request_2008_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2008_request_time_idx ON archived_hold_request_2008 USING btree (request_time);


--
-- Name: archived_hold_request_2009_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2009_request_time_idx ON archived_hold_request_2009 USING btree (request_time);


--
-- Name: archived_hold_request_2010_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2010_request_time_idx ON archived_hold_request_2010 USING btree (request_time);


--
-- Name: archived_hold_request_2011_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2011_request_time_idx ON archived_hold_request_2011 USING btree (request_time);


--
-- Name: archived_hold_request_2012_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2012_request_time_idx ON archived_hold_request_2012 USING btree (request_time);


--
-- Name: archived_hold_request_2013_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX archived_hold_request_2013_request_time_idx ON archived_hold_request_2013 USING btree (request_time);


--
-- Name: asv_once_per_owner_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX asv_once_per_owner_idx ON survey USING btree (owner, name);


--
-- Name: cancel_fulfill_target_type_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX cancel_fulfill_target_type_idx ON hold_request USING btree (target, hold_type) WHERE ((cancel_time IS NULL) AND (fulfillment_time IS NULL));


--
-- Name: circ_all_usr_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_all_usr_idx ON circulation USING btree (usr);


--
-- Name: circ_checkin_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_checkin_staff_idx ON circulation USING btree (checkin_staff);


--
-- Name: circ_checkin_time; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_checkin_time ON circulation USING btree (checkin_time) WHERE (checkin_time IS NOT NULL);


--
-- Name: circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_circ_lib_idx ON circulation USING btree (circ_lib);


--
-- Name: circ_circ_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_circ_staff_idx ON circulation USING btree (circ_staff);


--
-- Name: circ_open_date_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_open_date_idx ON circulation USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: circ_open_xacts_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_open_xacts_idx ON circulation USING btree (usr) WHERE (xact_finish IS NULL);


--
-- Name: circ_outstanding_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_outstanding_idx ON circulation USING btree (usr) WHERE (checkin_time IS NULL);


--
-- Name: circ_parent_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX circ_parent_idx ON circulation USING btree (parent_circ) WHERE (parent_circ IS NOT NULL);


--
-- Name: circ_start_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_start_idx ON circulation USING btree (((timezone('us/pacific'::text, xact_start))::date));


--
-- Name: circ_target_copy_id_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_target_copy_id_idx ON circulation USING btree (target_copy, id);


--
-- Name: circ_target_copy_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_target_copy_idx ON circulation USING btree (target_copy);


--
-- Name: circ_target_copy_xact_start_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_target_copy_xact_start_idx ON circulation USING btree (target_copy, xact_start);


--
-- Name: circ_xact_finish_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_xact_finish_idx ON circulation USING btree (xact_finish);


--
-- Name: hold_request_current_copy_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_current_copy_idx ON hold_request USING btree (current_copy);


--
-- Name: hold_request_fulfillment_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_fulfillment_staff_idx ON hold_request USING btree (fulfillment_staff);


--
-- Name: hold_request_pickup_lib_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_pickup_lib_idx ON hold_request USING btree (pickup_lib);


--
-- Name: hold_request_prev_check_time_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_prev_check_time_idx ON hold_request USING btree (prev_check_time);


--
-- Name: hold_request_requestor_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_requestor_idx ON hold_request USING btree (requestor);


--
-- Name: hold_request_target_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_target_idx ON hold_request USING btree (target);


--
-- Name: hold_request_usr_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_request_usr_idx ON hold_request USING btree (usr);


--
-- Name: non_cat_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX non_cat_in_house_use_staff_idx ON non_cat_in_house_use USING btree (staff);


--
-- Name: only_one_concurrent_checkout_per_copy; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX only_one_concurrent_checkout_per_copy ON circulation USING btree (target_copy) WHERE (checkin_time IS NULL);


--
-- Name: uhr_hold_idx; Type: INDEX; Schema: action; Owner: evergreen; Tablespace: 
--

CREATE INDEX uhr_hold_idx ON unfulfilled_hold_list USING btree (hold);


SET search_path = action_trigger, pg_catalog;

--
-- Name: atev_def_state_update_time_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE INDEX atev_def_state_update_time_idx ON event USING btree (event_def, state, update_time);


--
-- Name: atev_target_def_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen; Tablespace: 
--

CREATE INDEX atev_target_def_idx ON event USING btree (target, event_def);


SET search_path = actor, pg_catalog;

--
-- Name: actor_card_barcode_evergreen_lowercase_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_card_barcode_evergreen_lowercase_idx ON card USING btree (evergreen.lowercase(barcode));


--
-- Name: actor_card_barcode_lower_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_card_barcode_lower_idx ON card USING btree (lower(barcode));


--
-- Name: actor_card_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_card_usr_idx ON card USING btree (usr);


--
-- Name: actor_org_address_org_unit_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_address_org_unit_idx ON org_address USING btree (org_unit);


--
-- Name: actor_org_unit_billing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_billing_address_idx ON org_unit USING btree (billing_address);


--
-- Name: actor_org_unit_holds_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_holds_address_idx ON org_unit USING btree (holds_address);


--
-- Name: actor_org_unit_ill_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_ill_address_idx ON org_unit USING btree (ill_address);


--
-- Name: actor_org_unit_mailing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_mailing_address_idx ON org_unit USING btree (mailing_address);


--
-- Name: actor_org_unit_ou_type_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_ou_type_idx ON org_unit USING btree (ou_type);


--
-- Name: actor_org_unit_parent_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_parent_ou_idx ON org_unit USING btree (parent_ou);


--
-- Name: actor_org_unit_setting_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_setting_usr_idx ON org_unit_setting USING btree (org_unit);


--
-- Name: actor_org_unit_type_parent_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_org_unit_type_parent_idx ON org_unit_type USING btree (parent);


--
-- Name: actor_stat_cat_entry_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_stat_cat_entry_usr_idx ON stat_cat_entry_usr_map USING btree (target_usr);


--
-- Name: actor_usr_addr_city_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_city_idx ON usr_address USING btree (evergreen.lowercase(city));


--
-- Name: actor_usr_addr_post_code_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_post_code_idx ON usr_address USING btree (evergreen.lowercase(post_code));


--
-- Name: actor_usr_addr_state_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_state_idx ON usr_address USING btree (evergreen.lowercase(state));


--
-- Name: actor_usr_addr_street1_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_street1_idx ON usr_address USING btree (evergreen.lowercase(street1));


--
-- Name: actor_usr_addr_street2_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_street2_idx ON usr_address USING btree (evergreen.lowercase(street2));


--
-- Name: actor_usr_addr_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_addr_usr_idx ON usr_address USING btree (usr);


--
-- Name: actor_usr_billing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_billing_address_idx ON usr USING btree (billing_address);


--
-- Name: actor_usr_day_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_day_phone_idx ON usr USING btree (evergreen.lowercase(day_phone));


--
-- Name: actor_usr_day_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_day_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(day_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_day_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_day_phone_tpo_idx ON usr USING btree (evergreen.lowercase(day_phone) text_pattern_ops);


--
-- Name: actor_usr_email_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_email_idx ON usr USING btree (evergreen.lowercase(email));


--
-- Name: actor_usr_email_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_email_tpo_idx ON usr USING btree (evergreen.lowercase(email) text_pattern_ops);


--
-- Name: actor_usr_evening_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_evening_phone_idx ON usr USING btree (evergreen.lowercase(evening_phone));


--
-- Name: actor_usr_evening_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_evening_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(evening_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_evening_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_evening_phone_tpo_idx ON usr USING btree (evergreen.lowercase(evening_phone) text_pattern_ops);


--
-- Name: actor_usr_family_name_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_family_name_idx ON usr USING btree (evergreen.lowercase(family_name));


--
-- Name: actor_usr_family_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_family_name_tpo_idx ON usr USING btree (evergreen.lowercase(family_name) text_pattern_ops);


--
-- Name: actor_usr_first_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_first_given_name_idx ON usr USING btree (evergreen.lowercase(first_given_name));


--
-- Name: actor_usr_first_given_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_first_given_name_tpo_idx ON usr USING btree (evergreen.lowercase(first_given_name) text_pattern_ops);


--
-- Name: actor_usr_home_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_home_ou_idx ON usr USING btree (home_ou);


--
-- Name: actor_usr_ident_value2_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_ident_value2_idx ON usr USING btree (evergreen.lowercase(ident_value2));


--
-- Name: actor_usr_ident_value2_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_ident_value2_tpo_idx ON usr USING btree (evergreen.lowercase(ident_value2) text_pattern_ops);


--
-- Name: actor_usr_ident_value_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_ident_value_idx ON usr USING btree (evergreen.lowercase(ident_value));


--
-- Name: actor_usr_ident_value_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_ident_value_tpo_idx ON usr USING btree (evergreen.lowercase(ident_value) text_pattern_ops);


--
-- Name: actor_usr_mailing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_mailing_address_idx ON usr USING btree (mailing_address);


--
-- Name: actor_usr_note_creator_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_note_creator_idx ON usr_note USING btree (creator);


--
-- Name: actor_usr_note_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_note_usr_idx ON usr_note USING btree (usr);


--
-- Name: actor_usr_other_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_other_phone_idx ON usr USING btree (evergreen.lowercase(other_phone));


--
-- Name: actor_usr_other_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_other_phone_idx_numeric ON usr USING btree (evergreen.lowercase(regexp_replace(other_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_other_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_other_phone_tpo_idx ON usr USING btree (evergreen.lowercase(other_phone) text_pattern_ops);


--
-- Name: actor_usr_password_reset_has_been_reset_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_has_been_reset_idx ON usr_password_reset USING btree (has_been_reset);


--
-- Name: actor_usr_password_reset_request_time_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_request_time_idx ON usr_password_reset USING btree (request_time);


--
-- Name: actor_usr_password_reset_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_password_reset_usr_idx ON usr_password_reset USING btree (usr);


--
-- Name: actor_usr_password_reset_uuid_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX actor_usr_password_reset_uuid_idx ON usr_password_reset USING btree (uuid);


--
-- Name: actor_usr_second_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_second_given_name_idx ON usr USING btree (evergreen.lowercase(second_given_name));


--
-- Name: actor_usr_second_given_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_second_given_name_tpo_idx ON usr USING btree (evergreen.lowercase(second_given_name) text_pattern_ops);


--
-- Name: actor_usr_setting_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_setting_usr_idx ON usr_setting USING btree (usr);


--
-- Name: actor_usr_standing_penalty_staff_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_standing_penalty_staff_idx ON usr_standing_penalty USING btree (staff);


--
-- Name: actor_usr_standing_penalty_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_standing_penalty_usr_idx ON usr_standing_penalty USING btree (usr);


--
-- Name: actor_usr_usrgroup_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_usrgroup_idx ON usr USING btree (usrgroup);


--
-- Name: actor_usr_usrname_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX actor_usr_usrname_idx ON usr USING btree (evergreen.lowercase(usrname));


--
-- Name: from_prox_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX from_prox_idx ON org_unit_proximity USING btree (from_org);


--
-- Name: label_once_per_org; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_org ON toolbar USING btree (org, label) WHERE (org IS NOT NULL);


--
-- Name: label_once_per_usr; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_usr ON toolbar USING btree (usr, label) WHERE (usr IS NOT NULL);


--
-- Name: label_once_per_ws; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_ws ON toolbar USING btree (ws, label) WHERE (ws IS NOT NULL);


--
-- Name: ou_lasso_lasso_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX ou_lasso_lasso_ou_idx ON org_lasso_map USING btree (lasso, org_unit);


--
-- Name: ou_lasso_org_unit_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX ou_lasso_org_unit_idx ON org_lasso_map USING btree (org_unit);


--
-- Name: prox_adj_circ_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_circ_lib_idx ON org_unit_proximity_adjustment USING btree (item_circ_lib);


--
-- Name: prox_adj_circ_mod_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_circ_mod_idx ON org_unit_proximity_adjustment USING btree (circ_mod);


--
-- Name: prox_adj_copy_location_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_copy_location_idx ON org_unit_proximity_adjustment USING btree (copy_location);


--
-- Name: prox_adj_once_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX prox_adj_once_idx ON org_unit_proximity_adjustment USING btree ((COALESCE(item_circ_lib, (-1))), (COALESCE(item_owning_lib, (-1))), (COALESCE(copy_location, (-1))), (COALESCE(hold_pickup_lib, (-1))), (COALESCE(hold_request_lib, (-1))), (COALESCE(circ_mod, ''::text)), pos);


--
-- Name: prox_adj_owning_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_owning_lib_idx ON org_unit_proximity_adjustment USING btree (item_owning_lib);


--
-- Name: prox_adj_pickup_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_pickup_lib_idx ON org_unit_proximity_adjustment USING btree (hold_pickup_lib);


--
-- Name: prox_adj_request_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX prox_adj_request_lib_idx ON org_unit_proximity_adjustment USING btree (hold_request_lib);


--
-- Name: user_activity_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX user_activity_usr_idx ON usr_activity USING btree (usr);


--
-- Name: usr_org_unit_opt_in_staff_idx; Type: INDEX; Schema: actor; Owner: evergreen; Tablespace: 
--

CREATE INDEX usr_org_unit_opt_in_staff_idx ON usr_org_unit_opt_in USING btree (staff);


SET search_path = asset, pg_catalog;

--
-- Name: asset_call_number_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_creator_idx ON call_number USING btree (creator);


--
-- Name: asset_call_number_dewey_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_dewey_idx ON call_number USING btree (public.call_number_dewey(label));


--
-- Name: asset_call_number_editor_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_editor_idx ON call_number USING btree (editor);


--
-- Name: asset_call_number_label_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_label_once_per_lib ON call_number USING btree (record, owning_lib, label, prefix, suffix) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: asset_call_number_label_sortkey; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_label_sortkey ON call_number USING btree (public.oils_text_as_bytea(label_sortkey));


--
-- Name: asset_call_number_label_sortkey_browse; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_label_sortkey_browse ON call_number USING btree (public.oils_text_as_bytea(label_sortkey), public.oils_text_as_bytea(label), id, owning_lib) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: asset_call_number_note_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_note_creator_idx ON call_number_note USING btree (creator);


--
-- Name: asset_call_number_prefix_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_prefix_once_per_lib ON call_number_prefix USING btree (label, owning_lib);


--
-- Name: asset_call_number_prefix_sortkey_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_prefix_sortkey_idx ON call_number_prefix USING btree (label_sortkey);


--
-- Name: asset_call_number_record_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_record_idx ON call_number USING btree (record);


--
-- Name: asset_call_number_suffix_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX asset_call_number_suffix_once_per_lib ON call_number_suffix USING btree (label, owning_lib);


--
-- Name: asset_call_number_suffix_sortkey_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_suffix_sortkey_idx ON call_number_suffix USING btree (label_sortkey);


--
-- Name: asset_call_number_upper_label_id_owning_lib_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_call_number_upper_label_id_owning_lib_idx ON call_number USING btree (public.oils_text_as_bytea(label), id, owning_lib);


--
-- Name: asset_copy_note_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_copy_note_creator_idx ON copy_note USING btree (creator);


--
-- Name: asset_copy_note_owning_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_copy_note_owning_copy_idx ON copy_note USING btree (owning_copy);


--
-- Name: asset_uri_call_number_map_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX asset_uri_call_number_map_cn_idx ON uri_call_number_map USING btree (call_number);


--
-- Name: call_number_label_sortkey_owning_lib_not_deleted_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX call_number_label_sortkey_owning_lib_not_deleted_idx ON call_number USING btree (owning_lib, public.oils_text_as_bytea(label_sortkey)) WHERE (deleted = false);


--
-- Name: cn_record_not_deleted; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cn_record_not_deleted ON call_number USING btree (record) WHERE (deleted = false);


--
-- Name: copy_barcode_key; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX copy_barcode_key ON copy USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: copy_circ_lib_status; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX copy_circ_lib_status ON copy USING btree (circ_lib, status);


--
-- Name: copy_part_map_cp_part_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX copy_part_map_cp_part_idx ON copy_part_map USING btree (target_copy, part);


--
-- Name: cp_avail_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_avail_cn_idx ON copy USING btree (call_number);


--
-- Name: cp_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_cn_idx ON copy USING btree (call_number);


--
-- Name: cp_cn_index_not_deleted; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_cn_index_not_deleted ON copy USING btree (call_number) WHERE (deleted = false);


--
-- Name: cp_create_date; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_create_date ON copy USING btree (create_date);


--
-- Name: cp_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_creator_idx ON copy USING btree (creator);


--
-- Name: cp_edit_date; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_edit_date ON copy USING btree (edit_date);


--
-- Name: cp_editor_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX cp_editor_idx ON copy USING btree (editor);


--
-- Name: opac_visible_copies_copy_id_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX opac_visible_copies_copy_id_idx ON opac_visible_copies USING btree (copy_id);


--
-- Name: opac_visible_copies_idx1; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX opac_visible_copies_idx1 ON opac_visible_copies USING btree (record, circ_lib);


--
-- Name: opac_visible_copies_once_per_record_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX opac_visible_copies_once_per_record_idx ON opac_visible_copies USING btree (copy_id, record);


--
-- Name: scecm_owning_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX scecm_owning_copy_idx ON stat_cat_entry_copy_map USING btree (owning_copy);


--
-- Name: tmp_ac_status_idx; Type: INDEX; Schema: asset; Owner: evergreen; Tablespace: 
--

CREATE INDEX tmp_ac_status_idx ON copy USING btree (status);


SET search_path = auditor, pg_catalog;

--
-- Name: aud_actor_usr_address_hist_id_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_actor_usr_address_hist_id_idx ON actor_usr_address_history USING btree (id);


--
-- Name: aud_actor_usr_hist_id_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_actor_usr_hist_id_idx ON actor_usr_history USING btree (id);


--
-- Name: aud_asset_cn_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_asset_cn_hist_creator_idx ON asset_call_number_history USING btree (creator);


--
-- Name: aud_asset_cn_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_asset_cn_hist_editor_idx ON asset_call_number_history USING btree (editor);


--
-- Name: aud_asset_cp_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_asset_cp_hist_creator_idx ON asset_copy_history USING btree (creator);


--
-- Name: aud_asset_cp_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_asset_cp_hist_editor_idx ON asset_copy_history USING btree (editor);


--
-- Name: aud_bib_rec_entry_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_bib_rec_entry_hist_creator_idx ON biblio_record_entry_history USING btree (creator);


--
-- Name: aud_bib_rec_entry_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_bib_rec_entry_hist_editor_idx ON biblio_record_entry_history USING btree (editor);


--
-- Name: aud_serial_unit_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_serial_unit_hist_creator_idx ON serial_unit_history USING btree (creator);


--
-- Name: aud_serial_unit_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen; Tablespace: 
--

CREATE INDEX aud_serial_unit_hist_editor_idx ON serial_unit_history USING btree (editor);


SET search_path = authority, pg_catalog;

--
-- Name: authority_bl_bib_authority_once_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX authority_bl_bib_authority_once_idx ON bib_linking USING btree (authority, bib);


--
-- Name: authority_bl_bib_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_bl_bib_idx ON bib_linking USING btree (bib);


--
-- Name: authority_full_rec_index_vector_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_index_vector_idx ON full_rec USING gist (index_vector);


--
-- Name: authority_full_rec_record_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_record_idx ON full_rec USING btree (record);


--
-- Name: authority_full_rec_sort_value_index; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_sort_value_index ON full_rec USING btree (sort_value);


--
-- Name: authority_full_rec_subfield_a_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_subfield_a_idx ON full_rec USING btree (value) WHERE (subfield = 'a'::text);


--
-- Name: authority_full_rec_tag_part_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_tag_part_idx ON full_rec USING btree ("substring"((tag)::text, 2));


--
-- Name: authority_full_rec_tag_subfield_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_tag_subfield_idx ON full_rec USING btree (tag, subfield);


--
-- Name: authority_full_rec_value_index; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_value_index ON full_rec USING btree (value);


--
-- Name: authority_full_rec_value_tpo_index; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_full_rec_value_tpo_index ON full_rec USING btree (value text_pattern_ops);


--
-- Name: authority_rec_descriptor_record_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_rec_descriptor_record_idx ON rec_descriptor USING btree (record);


--
-- Name: authority_record_deleted_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_deleted_idx ON record_entry USING btree (deleted) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: authority_record_entry_create_date; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_entry_create_date ON record_entry USING btree (create_date);


--
-- Name: authority_record_entry_creator_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: authority_record_entry_editor_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: authority_record_note_creator_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_note_creator_idx ON record_note USING btree (creator);


--
-- Name: authority_record_note_editor_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_note_editor_idx ON record_note USING btree (editor);


--
-- Name: authority_record_note_record_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_record_note_record_idx ON record_note USING btree (record);


--
-- Name: authority_simple_heading_index_vector_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_simple_heading_index_vector_idx ON simple_heading USING gist (index_vector);


--
-- Name: authority_simple_heading_sort_value_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_simple_heading_sort_value_idx ON simple_heading USING btree (sort_value);


--
-- Name: authority_simple_heading_value_idx; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX authority_simple_heading_value_idx ON simple_heading USING btree (value);


--
-- Name: by_heading; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX by_heading ON record_entry USING btree (simple_normalize_heading(marc)) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: by_heading_and_thesaurus; Type: INDEX; Schema: authority; Owner: evergreen; Tablespace: 
--

CREATE INDEX by_heading_and_thesaurus ON record_entry USING btree (normalize_heading(marc)) WHERE ((deleted IS FALSE) OR (deleted = false));


SET search_path = biblio, pg_catalog;

--
-- Name: biblio_record_entry_create_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_entry_create_date_idx ON record_entry USING btree (create_date);


--
-- Name: biblio_record_entry_creator_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: biblio_record_entry_edit_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_entry_edit_date_idx ON record_entry USING btree (edit_date);


--
-- Name: biblio_record_entry_editor_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: biblio_record_entry_fp_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_entry_fp_idx ON record_entry USING btree (fingerprint);


--
-- Name: biblio_record_note_creator_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_note_creator_idx ON record_note USING btree (creator);


--
-- Name: biblio_record_note_editor_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_note_editor_idx ON record_note USING btree (editor);


--
-- Name: biblio_record_note_record_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX biblio_record_note_record_idx ON record_note USING btree (record);


--
-- Name: biblio_record_unique_tcn; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX biblio_record_unique_tcn ON record_entry USING btree (tcn_value) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: peer_bib_copy_map_copy_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX peer_bib_copy_map_copy_idx ON peer_bib_copy_map USING btree (target_copy);


--
-- Name: peer_bib_copy_map_record_idx; Type: INDEX; Schema: biblio; Owner: evergreen; Tablespace: 
--

CREATE INDEX peer_bib_copy_map_record_idx ON peer_bib_copy_map USING btree (peer_record);


SET search_path = config, pg_catalog;

--
-- Name: ccmm_once_per_paramset; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX ccmm_once_per_paramset ON circ_matrix_matchpoint USING btree (org_unit, grp, (COALESCE(circ_modifier, ''::text)), (COALESCE((copy_location)::text, ''::text)), (COALESCE(marc_type, ''::text)), (COALESCE(marc_form, ''::text)), (COALESCE(marc_bib_level, ''::text)), (COALESCE(marc_vr_format, ''::text)), (COALESCE((copy_circ_lib)::text, ''::text)), (COALESCE((copy_owning_lib)::text, ''::text)), (COALESCE((user_home_ou)::text, ''::text)), (COALESCE((ref_flag)::text, ''::text)), (COALESCE((juvenile_flag)::text, ''::text)), (COALESCE((is_renewal)::text, ''::text)), (COALESCE((usr_age_lower_bound)::text, ''::text)), (COALESCE((usr_age_upper_bound)::text, ''::text)), (COALESCE((item_age)::text, ''::text))) WHERE active;


--
-- Name: chmm_once_per_paramset; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX chmm_once_per_paramset ON hold_matrix_matchpoint USING btree ((COALESCE((user_home_ou)::text, ''::text)), (COALESCE((request_ou)::text, ''::text)), (COALESCE((pickup_ou)::text, ''::text)), (COALESCE((item_owning_ou)::text, ''::text)), (COALESCE((item_circ_ou)::text, ''::text)), (COALESCE((usr_grp)::text, ''::text)), (COALESCE((requestor_grp)::text, ''::text)), (COALESCE(circ_modifier, ''::text)), (COALESCE(marc_type, ''::text)), (COALESCE(marc_form, ''::text)), (COALESCE(marc_bib_level, ''::text)), (COALESCE(marc_vr_format, ''::text)), (COALESCE((juvenile_flag)::text, ''::text)), (COALESCE((ref_flag)::text, ''::text)), (COALESCE((item_age)::text, ''::text))) WHERE active;


--
-- Name: config_metabib_field_class_name_idx; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX config_metabib_field_class_name_idx ON metabib_field USING btree (field_class, name);


--
-- Name: cwa_one_active_per_ou; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX cwa_one_active_per_ou ON weight_assoc USING btree (org_unit) WHERE active;


--
-- Name: i18n_identity; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX i18n_identity ON i18n_core USING btree (fq_field, identity_value, translation);


--
-- Name: idl_field_doc_identity; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX idl_field_doc_identity ON idl_field_doc USING btree (fm_class, field, owner);


--
-- Name: unique_wwh; Type: INDEX; Schema: config; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX unique_wwh ON usr_activity_type USING btree ((COALESCE(ewho, ''::text)), (COALESCE(ewhat, ''::text)), (COALESCE(ehow, ''::text)));


SET search_path = container, pg_catalog;

--
-- Name: copy_bucket_item_bucket_idx; Type: INDEX; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE INDEX copy_bucket_item_bucket_idx ON copy_bucket_item USING btree (bucket);


--
-- Name: user_bucket_item_target_user_idx; Type: INDEX; Schema: container; Owner: evergreen; Tablespace: 
--

CREATE INDEX user_bucket_item_target_user_idx ON user_bucket_item USING btree (target_user);


SET search_path = esi, pg_catalog;

--
-- Name: esi_phasefx16756_xacts_id; Type: INDEX; Schema: esi; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX esi_phasefx16756_xacts_id ON phasefx16756_xacts USING btree (id);


SET search_path = esi_14812, pg_catalog;

--
-- Name: fw_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE INDEX fw_item_idx ON fw_items USING btree (item_id);


--
-- Name: nw_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE INDEX nw_item_idx ON nw_items_changed USING btree (id);


--
-- Name: rn_dvd_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE INDEX rn_dvd_idx ON rn_dvds USING btree (id);


--
-- Name: rn_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen; Tablespace: 
--

CREATE INDEX rn_item_idx ON rn_missing_items USING btree (item_id);


SET search_path = m_enum, pg_catalog;

--
-- Name: m_enum_base_copy_location_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_base_copy_location_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_base_copy_location_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_base_copy_location_loc_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_enum_callnum_label_once_per_lib; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_enum_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_enum_callnum_record_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_enum_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_enum_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_enum_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_enum_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_enum_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_enum_copy_barcode_key; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_enum_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_enum_copy_id_key; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_enum_copy_id_key ON asset_copy USING btree (id);


--
-- Name: m_enum_home_location_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_home_location_lf1_idx ON home_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_home_location_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_home_location_lf2_idx ON home_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_home_location_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_home_location_lf3_idx ON home_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_home_location_loc_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_home_location_loc_idx ON home_location_map USING btree (transcribed_location);


--
-- Name: m_enum_item_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_item_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_item_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_item_key_barcode_map_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_item_key_barcode_map_idx ON item_key_barcode_map USING btree (key1, key2, key3);


--
-- Name: m_enum_patron_barcode_key; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_enum_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_enum_patron_usrname_key; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_enum_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: m_enum_unicorn_item_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf1_idx ON item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_unicorn_item_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf2_idx ON item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_unicorn_item_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf3_idx ON item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_user_key_barcode_map_idx; Type: INDEX; Schema: m_enum; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_enum_user_key_barcode_map_idx ON user_key_barcode_map USING btree (key);


SET search_path = m_kcls, pg_catalog;

--
-- Name: copy_id_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX copy_id_idx ON best_avail_copies USING btree (copy_id);


--
-- Name: egid_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX egid_idx ON old2new USING btree (egid);


--
-- Name: gmc_idx1; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX gmc_idx1 ON vols_to_delete USING btree (volume_id);


--
-- Name: hold_id_ix; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_id_ix ON best_avail_copies USING btree (hold_id);


--
-- Name: iii_bib_id1; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id1 ON asset_copy_legacy USING btree (l_iii_bib_id);


--
-- Name: iii_bib_id2; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id2 ON asset_copy_legacy USING btree (l_iii_bib_id, l_item_seq);


--
-- Name: iii_bib_id_old2new; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id_old2new ON old2new USING btree (l_iii_bib_id);


--
-- Name: iii_item_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_item_idx ON asset_copy_legacy USING btree (l_item_id);


--
-- Name: iii_patron_id; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id ON actor_usr_legacy USING btree (l_patron_id);


--
-- Name: iii_patron_id_3; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id_3 ON patron_addr USING btree (l_patron_id);


--
-- Name: iii_patron_id_4; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id_4 ON patron_addr_compressed USING btree (l_patron_id);


--
-- Name: job_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX job_idx ON km_move USING btree (job);


--
-- Name: l_icode2; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_icode2 ON asset_copy_legacy USING btree (l_icode2);


--
-- Name: l_itype; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_itype ON asset_copy_legacy USING btree (l_itype);


--
-- Name: l_location; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_location ON asset_copy_legacy USING btree (l_location);


--
-- Name: m_kcls_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_callnum_record_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_copy_barcode_key; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_patron_barcode_key; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_patron_usrname_key; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: x_bib_id; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_bib_id ON bookbag_entry USING btree (l_bib_id);


--
-- Name: x_date; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_date ON action_circulation_legacy USING btree (x_date);


--
-- Name: x_patron_id; Type: INDEX; Schema: m_kcls; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_patron_id ON bookbag USING btree (x_patron_id);


SET search_path = m_kcls2, pg_catalog;

--
-- Name: id2; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX id2 ON old2new USING btree (l_iii_bib_id);


--
-- Name: id4; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX id4 ON asset_copy_legacy USING btree (substr(l_item_id, 1, 9));


--
-- Name: idx7; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX idx7 ON action_circulation_legacy USING btree ((ARRAY[(usr)::bigint, target_copy, x_date]));


--
-- Name: iii_bib_id1; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id1 ON asset_copy_legacy USING btree (l_iii_bib_id);


--
-- Name: iii_bib_id2; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id2 ON asset_copy_legacy USING btree (l_iii_bib_id, l_item_seq);


--
-- Name: iii_patron_id; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id ON actor_usr_legacy USING btree (l_patron_id);


--
-- Name: iii_patron_id_2; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id_2 ON patron_note USING btree (l_patron_id);


--
-- Name: iii_patron_id_3; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id_3 ON patron_addr USING btree (l_patron_id);


--
-- Name: iii_patron_id_4; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_patron_id_4 ON patron_addr_compressed USING btree (l_patron_id);


--
-- Name: l_icode2; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_icode2 ON asset_copy_legacy USING btree (l_icode2);


--
-- Name: l_itype; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_itype ON asset_copy_legacy USING btree (l_itype);


--
-- Name: l_location; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_location ON asset_copy_legacy USING btree (l_location);


--
-- Name: m_kcls2_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls2_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls2_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls2_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls2_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls2_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls2_callnum_record_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls2_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls2_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls2_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls2_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls2_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls2_copy_barcode_key; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls2_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls2_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls2_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls2_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls2_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls2_patron_barcode_key; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls2_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls2_patron_usrname_key; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls2_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: x_bib_id; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_bib_id ON bookbag_entry USING btree (l_bib_id);


--
-- Name: x_patron_id; Type: INDEX; Schema: m_kcls2; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_patron_id ON bookbag USING btree (x_patron_id);


SET search_path = m_kcls3, pg_catalog;

--
-- Name: m_kcls3_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls3_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls3_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls3_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls3_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls3_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls3_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls3_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls3_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls3_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls3_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls3_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


SET search_path = m_kcls_call_fix, pg_catalog;

--
-- Name: copy_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX copy_idx ON item_calls USING btree (copy_id);


--
-- Name: m_kcls_call_fix_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_call_fix_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_call_fix_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_call_fix_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_call_fix_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_call_fix_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_call_fix_callnum_record_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_call_fix_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_call_fix_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_call_fix_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_call_fix_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_call_fix_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_call_fix_copy_barcode_key; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_call_fix_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_call_fix_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_call_fix_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_call_fix_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_call_fix_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_call_fix_patron_barcode_key; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_call_fix_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_call_fix_patron_usrname_key; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_call_fix_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: orig_cn_idx; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX orig_cn_idx ON item_calls USING btree (orig_call_id);


--
-- Name: orig_cn_idx2; Type: INDEX; Schema: m_kcls_call_fix; Owner: evergreen; Tablespace: 
--

CREATE INDEX orig_cn_idx2 ON cn_with_one_item USING btree (orig_call_id);


SET search_path = m_kcls_circhist, pg_catalog;

--
-- Name: iid_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX iid_idx ON circhist USING btree (id, done);


--
-- Name: m_kcls_circhist_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_circhist_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_circhist_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_circhist_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_circhist_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_circhist_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_circhist_callnum_record_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_circhist_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_circhist_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_circhist_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_circhist_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_circhist_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_circhist_copy_barcode_key; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_circhist_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_circhist_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_circhist_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_circhist_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_circhist_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_circhist_patron_barcode_key; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_circhist_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_circhist_patron_usrname_key; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_circhist_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: x_date; Type: INDEX; Schema: m_kcls_circhist; Owner: evergreen; Tablespace: 
--

CREATE INDEX x_date ON circhist USING btree (x_date);


SET search_path = m_kcls_gap, pg_catalog;

--
-- Name: iii_bib_id1; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id1 ON asset_copy_legacy USING btree (l_iii_bib_id);


--
-- Name: iii_bib_id2; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id2 ON asset_copy_legacy USING btree (l_iii_bib_id, l_item_seq);


--
-- Name: iii_item_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_item_idx ON asset_copy_legacy USING btree (l_item_id);


--
-- Name: l_icode2; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_icode2 ON asset_copy_legacy USING btree (l_icode2);


--
-- Name: l_itype; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_itype ON asset_copy_legacy USING btree (l_itype);


--
-- Name: l_location; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_location ON asset_copy_legacy USING btree (l_location);


--
-- Name: m_kcls_gap_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_gap_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_gap_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_gap_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_gap_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_gap_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_gap_callnum_record_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_gap_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_gap_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_gap_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_gap_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_gap_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_gap_copy_barcode_key; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_gap_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_gap_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_gap_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_gap_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_gap_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_gap_patron_barcode_key; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_gap_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_gap_patron_usrname_key; Type: INDEX; Schema: m_kcls_gap; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_gap_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_holds, pg_catalog;

--
-- Name: m_kcls_holds_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holds_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holds_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holds_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_holds_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holds_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_holds_callnum_record_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_holds_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_holds_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_holds_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_holds_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_holds_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_holds_copy_barcode_key; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holds_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_holds_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holds_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holds_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holds_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holds_patron_barcode_key; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holds_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_holds_patron_usrname_key; Type: INDEX; Schema: m_kcls_holds; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holds_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_holdsall, pg_catalog;

--
-- Name: m_kcls_holdsall_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_holdsall_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_holdsall_callnum_record_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_holdsall_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_holdsall_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_holdsall_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_holdsall_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_holdsall_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_holdsall_copy_barcode_key; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_holdsall_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall_patron_barcode_key; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_holdsall_patron_usrname_key; Type: INDEX; Schema: m_kcls_holdsall; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_holdsall2, pg_catalog;

--
-- Name: m_kcls_holdsall2_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall2_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall2_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall2_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_holdsall2_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall2_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_holdsall2_callnum_record_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_holdsall2_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_holdsall2_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_holdsall2_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_holdsall2_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_holdsall2_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_holdsall2_copy_barcode_key; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall2_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_holdsall2_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall2_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall2_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall2_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall2_patron_barcode_key; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall2_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_holdsall2_patron_usrname_key; Type: INDEX; Schema: m_kcls_holdsall2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall2_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_holdsall3, pg_catalog;

--
-- Name: m_kcls_holdsall3_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall3_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall3_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall3_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_holdsall3_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall3_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_holdsall3_callnum_record_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_holdsall3_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_holdsall3_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_holdsall3_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_holdsall3_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_holdsall3_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_holdsall3_copy_barcode_key; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall3_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_holdsall3_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsall3_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsall3_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsall3_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsall3_patron_barcode_key; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall3_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_holdsall3_patron_usrname_key; Type: INDEX; Schema: m_kcls_holdsall3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsall3_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_holdsfix, pg_catalog;

--
-- Name: hold_id; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX hold_id ON holds_to_delete USING btree (id);


--
-- Name: m_kcls_holdsfix_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsfix_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsfix_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsfix_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_holdsfix_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsfix_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_holdsfix_callnum_record_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_holdsfix_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_holdsfix_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_holdsfix_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_holdsfix_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_holdsfix_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_holdsfix_copy_barcode_key; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsfix_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_holdsfix_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_holdsfix_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_holdsfix_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_holdsfix_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_holdsfix_patron_barcode_key; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsfix_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_holdsfix_patron_usrname_key; Type: INDEX; Schema: m_kcls_holdsfix; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_holdsfix_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_items2, pg_catalog;

--
-- Name: iii_bib_id1; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id1 ON asset_copy_legacy USING btree (l_iii_bib_id);


--
-- Name: iii_item_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_item_idx ON asset_copy_legacy USING btree (l_item_id);


--
-- Name: l_icode2; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_icode2 ON asset_copy_legacy USING btree (l_icode2);


--
-- Name: l_itype; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_itype ON asset_copy_legacy USING btree (l_itype);


--
-- Name: l_location; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_location ON asset_copy_legacy USING btree (l_location);


--
-- Name: m_kcls_items2_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_items2_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_items2_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_items2_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_items2_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items2_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_items2_callnum_record_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_items2_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_items2_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_items2_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_items2_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_items2_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_items2_copy_barcode_key; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items2_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_items2_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_items2_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_items2_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items2_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_items2_patron_barcode_key; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items2_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_items2_patron_usrname_key; Type: INDEX; Schema: m_kcls_items2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items2_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_items3, pg_catalog;

--
-- Name: iii_bib_id1; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_bib_id1 ON asset_copy_legacy USING btree (l_iii_bib_id);


--
-- Name: iii_item_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX iii_item_idx ON asset_copy_legacy USING btree (l_item_id);


--
-- Name: l_icode2; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_icode2 ON asset_copy_legacy USING btree (l_icode2);


--
-- Name: l_itype; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_itype ON asset_copy_legacy USING btree (l_itype);


--
-- Name: l_location; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX l_location ON asset_copy_legacy USING btree (l_location);


--
-- Name: m_kcls_items3_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_items3_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_items3_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_items3_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_items3_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items3_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_items3_callnum_record_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_items3_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_items3_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_items3_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_items3_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_items3_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_items3_copy_barcode_key; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items3_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_items3_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_items3_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_items3_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_items3_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_items3_patron_barcode_key; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items3_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_items3_patron_usrname_key; Type: INDEX; Schema: m_kcls_items3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_items3_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_ord, pg_catalog;

--
-- Name: m_kcls_ord3_idx2; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_idx2 ON on_order_items USING btree (id);


--
-- Name: m_kcls_ord_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_ord_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_ord_callnum_record_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_ord_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_ord_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_ord_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_ord_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_ord_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_ord_copy_barcode_key; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_ord_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord_patron_barcode_key; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_ord_patron_usrname_key; Type: INDEX; Schema: m_kcls_ord; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_kcls_ord2, pg_catalog;

--
-- Name: m_kcls_ord2_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord2_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord2_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord2_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_ord2_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord2_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_ord2_callnum_record_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_ord2_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_ord2_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_ord2_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_ord2_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_ord2_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_ord2_copy_barcode_key; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord2_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_ord2_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord2_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord2_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord2_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord2_patron_barcode_key; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord2_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_ord2_patron_usrname_key; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord2_patron_usrname_key ON actor_usr USING btree (usrname);


--
-- Name: m_kcls_ord3_idx2; Type: INDEX; Schema: m_kcls_ord2; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_idx2 ON on_order_items USING btree (id);


SET search_path = m_kcls_ord3, pg_catalog;

--
-- Name: m_kcls_ord3_base_copy_location_lf1_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord3_base_copy_location_lf2_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord3_base_copy_location_lf3_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord3_base_copy_location_loc_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_kcls_ord3_callnum_label_once_per_lib; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord3_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_kcls_ord3_callnum_record_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_kcls_ord3_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_kcls_ord3_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_kcls_ord3_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_kcls_ord3_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_kcls_ord3_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_kcls_ord3_copy_barcode_key; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord3_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_kcls_ord3_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_idx ON asset_copy USING btree (id);


--
-- Name: m_kcls_ord3_idx2; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_idx2 ON on_order_items USING btree (id);


--
-- Name: m_kcls_ord3_item_dynamic_lf1_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_kcls_ord3_item_dynamic_lf2_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_kcls_ord3_item_dynamic_lf3_idx; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_kcls_ord3_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_kcls_ord3_patron_barcode_key; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord3_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_kcls_ord3_patron_usrname_key; Type: INDEX; Schema: m_kcls_ord3; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_kcls_ord3_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = m_test, pg_catalog;

--
-- Name: m_test_base_copy_location_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_base_copy_location_lf1_idx ON base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_test_base_copy_location_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_base_copy_location_lf2_idx ON base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_test_base_copy_location_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_base_copy_location_lf3_idx ON base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_test_base_copy_location_loc_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_base_copy_location_loc_idx ON base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_test_callnum_label_once_per_lib; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_test_callnum_label_once_per_lib ON asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_test_callnum_record_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_callnum_record_idx ON asset_call_number USING btree (record);


--
-- Name: m_test_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_callnum_upper_label_id_lib_idx ON asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_test_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_circ_dynamic_lf1_idx ON base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_test_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_circ_dynamic_lf2_idx ON base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_test_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_circ_dynamic_lf3_idx ON base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_test_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_circ_dynamic_lf4_idx ON base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_test_copy_barcode_key; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_test_copy_barcode_key ON asset_copy USING btree (barcode);


--
-- Name: m_test_item_dynamic_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_item_dynamic_lf1_idx ON base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_test_item_dynamic_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_item_dynamic_lf2_idx ON base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_test_item_dynamic_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_test_item_dynamic_lf3_idx ON base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_test_patron_barcode_key; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_test_patron_barcode_key ON actor_card USING btree (barcode);


--
-- Name: m_test_patron_usrname_key; Type: INDEX; Schema: m_test; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_test_patron_usrname_key ON actor_usr USING btree (usrname);


SET search_path = metabib, pg_catalog;

--
-- Name: browse_author_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_def_map_def_idx ON browse_author_entry_def_map USING btree (def);


--
-- Name: browse_author_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_def_map_entry_idx ON browse_author_entry_def_map USING btree (entry);


--
-- Name: browse_author_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_def_map_source_idx ON browse_author_entry_def_map USING btree (source);


--
-- Name: browse_author_entry_sh_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_sh_map_entry_idx ON browse_author_entry_simple_heading_map USING btree (entry);


--
-- Name: browse_author_entry_sh_map_sh_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_sh_map_sh_idx ON browse_author_entry_simple_heading_map USING btree (simple_heading);


--
-- Name: browse_author_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_sort_value_idx ON browse_author_entry USING btree (md5((sort_value COLLATE "default")));


--
-- Name: browse_author_entry_sort_value_noamp; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_sort_value_noamp ON browse_author_entry USING btree (public.replace_ampersand(sort_value));


--
-- Name: browse_author_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_author_entry_truncated_sort_value_idx ON browse_author_entry USING btree (truncated_sort_value);


--
-- Name: browse_call_number_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_def_map_def_idx ON browse_call_number_entry_def_map USING btree (def);


--
-- Name: browse_call_number_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_def_map_entry_idx ON browse_call_number_entry_def_map USING btree (entry);


--
-- Name: browse_call_number_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_def_map_source_idx ON browse_call_number_entry_def_map USING btree (source);


--
-- Name: browse_call_number_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_sort_value_idx ON browse_call_number_entry USING btree (md5((sort_value COLLATE "default")));


--
-- Name: browse_call_number_entry_sort_value_noamp; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_sort_value_noamp ON browse_call_number_entry USING btree (public.replace_ampersand(sort_value));


--
-- Name: browse_call_number_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_call_number_entry_truncated_sort_value_idx ON browse_call_number_entry USING btree (truncated_sort_value);


--
-- Name: browse_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_entry_def_map_def_idx ON browse_entry_def_map USING btree (def);


--
-- Name: browse_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_entry_def_map_entry_idx ON browse_entry_def_map USING btree (entry);


--
-- Name: browse_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_entry_def_map_source_idx ON browse_entry_def_map USING btree (source);


--
-- Name: browse_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_entry_truncated_sort_value_idx ON browse_entry USING btree (truncated_sort_value);


--
-- Name: browse_series_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_def_map_def_idx ON browse_series_entry_def_map USING btree (def);


--
-- Name: browse_series_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_def_map_entry_idx ON browse_series_entry_def_map USING btree (entry);


--
-- Name: browse_series_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_def_map_source_idx ON browse_series_entry_def_map USING btree (source);


--
-- Name: browse_series_entry_sh_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_sh_map_entry_idx ON browse_series_entry_simple_heading_map USING btree (entry);


--
-- Name: browse_series_entry_sh_map_sh_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_sh_map_sh_idx ON browse_series_entry_simple_heading_map USING btree (simple_heading);


--
-- Name: browse_series_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_sort_value_idx ON browse_series_entry USING btree (md5((sort_value COLLATE "default")));


--
-- Name: browse_series_entry_sort_value_noamp; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_sort_value_noamp ON browse_series_entry USING btree (public.replace_ampersand(sort_value));


--
-- Name: browse_series_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_series_entry_truncated_sort_value_idx ON browse_series_entry USING btree (truncated_sort_value);


--
-- Name: browse_subject_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_def_map_def_idx ON browse_subject_entry_def_map USING btree (def);


--
-- Name: browse_subject_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_def_map_entry_idx ON browse_subject_entry_def_map USING btree (entry);


--
-- Name: browse_subject_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_def_map_source_idx ON browse_subject_entry_def_map USING btree (source);


--
-- Name: browse_subject_entry_sh_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_sh_map_entry_idx ON browse_subject_entry_simple_heading_map USING btree (entry);


--
-- Name: browse_subject_entry_sh_map_sh_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_sh_map_sh_idx ON browse_subject_entry_simple_heading_map USING btree (simple_heading);


--
-- Name: browse_subject_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_sort_value_idx ON browse_subject_entry USING btree (md5((sort_value COLLATE "default")));


--
-- Name: browse_subject_entry_sort_value_noamp; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_sort_value_noamp ON browse_subject_entry USING btree (public.replace_ampersand(sort_value));


--
-- Name: browse_subject_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_subject_entry_truncated_sort_value_idx ON browse_subject_entry USING btree (truncated_sort_value);


--
-- Name: browse_title_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_def_map_def_idx ON browse_title_entry_def_map USING btree (def);


--
-- Name: browse_title_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_def_map_entry_idx ON browse_title_entry_def_map USING btree (entry);


--
-- Name: browse_title_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_def_map_source_idx ON browse_title_entry_def_map USING btree (source);


--
-- Name: browse_title_entry_sh_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_sh_map_entry_idx ON browse_title_entry_simple_heading_map USING btree (entry);


--
-- Name: browse_title_entry_sh_map_sh_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_sh_map_sh_idx ON browse_title_entry_simple_heading_map USING btree (simple_heading);


--
-- Name: browse_title_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_sort_value_idx ON browse_title_entry USING btree (md5((sort_value COLLATE "default")));


--
-- Name: browse_title_entry_sort_value_noamp; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_sort_value_noamp ON browse_title_entry USING btree (public.replace_ampersand(sort_value));


--
-- Name: browse_title_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX browse_title_entry_truncated_sort_value_idx ON browse_title_entry USING btree (truncated_sort_value);


--
-- Name: fki_normalized_author_to_ author_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX "fki_normalized_author_to_ author_field_entry_FK" ON normalized_author_field_entry USING btree (id);


--
-- Name: fki_normalized_keyword_to_ keyword_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX "fki_normalized_keyword_to_ keyword_field_entry_FK" ON normalized_keyword_field_entry USING btree (id);


--
-- Name: fki_normalized_series_to_ series_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX "fki_normalized_series_to_ series_field_entry_FK" ON normalized_series_field_entry USING btree (id);


--
-- Name: fki_normalized_subject_to_ subject_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX "fki_normalized_subject_to_ subject_field_entry_FK" ON normalized_subject_field_entry USING btree (id);


--
-- Name: fki_normalized_title_to_ title_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX "fki_normalized_title_to_ title_field_entry_FK" ON normalized_title_field_entry USING btree (id);


--
-- Name: full_rec_isbn_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX full_rec_isbn_tpo_idx ON real_full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops) WHERE (tag = ANY (ARRAY['020'::bpchar, '024'::bpchar]));


--
-- Name: full_rec_url_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX full_rec_url_tpo_idx ON real_full_rec USING btree (value text_pattern_ops) WHERE ((tag = '856'::bpchar) AND (subfield = 'u'::text));


--
-- Name: metabib_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_index_vector_idx ON author_field_entry USING gist (index_vector);


--
-- Name: metabib_author_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_source_idx ON author_field_entry USING btree (source);


--
-- Name: metabib_author_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_author_field_entry_value_idx ON author_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_browse_author_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_author_entry_index_vector_idx ON browse_author_entry USING gin (index_vector);


--
-- Name: metabib_browse_call_number_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_call_number_entry_index_vector_idx ON browse_call_number_entry USING gin (index_vector);


--
-- Name: metabib_browse_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_entry_index_vector_idx ON browse_entry USING gin (index_vector);


--
-- Name: metabib_browse_series_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_series_entry_index_vector_idx ON browse_series_entry USING gin (index_vector);


--
-- Name: metabib_browse_subject_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_subject_entry_index_vector_idx ON browse_subject_entry USING gin (index_vector);


--
-- Name: metabib_browse_title_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_browse_title_entry_index_vector_idx ON browse_title_entry USING gin (index_vector);


--
-- Name: metabib_call_number_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_call_number_field_entry_index_vector_idx ON call_number_field_entry USING gist (index_vector);


--
-- Name: metabib_call_number_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_call_number_field_entry_source_idx ON call_number_field_entry USING btree (source);


--
-- Name: metabib_call_number_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_call_number_field_entry_value_idx ON call_number_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_combined_author_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_author_field_entry_fakepk_idx ON combined_author_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_author_field_entry_index_vector_idx ON combined_author_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_author_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_author_field_source_idx ON combined_author_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_identifier_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_identifier_field_entry_fakepk_idx ON combined_identifier_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_identifier_field_entry_index_vector_idx ON combined_identifier_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_identifier_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_identifier_field_source_idx ON combined_identifier_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_keyword_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_keyword_field_entry_fakepk_idx ON combined_keyword_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_keyword_field_entry_index_vector_idx ON combined_keyword_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_keyword_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_keyword_field_source_idx ON combined_keyword_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_series_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_series_field_entry_fakepk_idx ON combined_series_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_series_field_entry_index_vector_idx ON combined_series_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_series_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_series_field_source_idx ON combined_series_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_subject_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_subject_field_entry_fakepk_idx ON combined_subject_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_subject_field_entry_index_vector_idx ON combined_subject_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_subject_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_subject_field_source_idx ON combined_subject_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_title_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX metabib_combined_title_field_entry_fakepk_idx ON combined_title_field_entry USING btree (record, (COALESCE((metabib_field)::text, ''::text)));


--
-- Name: metabib_combined_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_title_field_entry_index_vector_idx ON combined_title_field_entry USING gist (index_vector);


--
-- Name: metabib_combined_title_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_combined_title_field_source_idx ON combined_title_field_entry USING btree (metabib_field);


--
-- Name: metabib_facet_entry_field_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_facet_entry_field_idx ON facet_entry USING btree (field);


--
-- Name: metabib_facet_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_facet_entry_source_idx ON facet_entry USING btree (source);


--
-- Name: metabib_facet_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_facet_entry_value_idx ON facet_entry USING btree ("substring"(value, 1, 1024));


--
-- Name: metabib_full_rec_02x_tag_subfield_lower_substring; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_02x_tag_subfield_lower_substring ON real_full_rec USING btree (tag, subfield, lower("substring"(value, 1, 1024))) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_index_vector_gin; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_index_vector_gin ON real_full_rec USING gin (index_vector);


--
-- Name: metabib_full_rec_isxn_caseless_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_isxn_caseless_idx ON real_full_rec USING btree (lower(value)) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_record_idx ON real_full_rec USING btree (record);


--
-- Name: metabib_full_rec_tag_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_tag_record_idx ON real_full_rec USING btree (tag, record);


--
-- Name: metabib_full_rec_tag_subfield_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_tag_subfield_idx ON real_full_rec USING btree (tag, subfield);


--
-- Name: metabib_full_rec_tnf_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_tnf_idx ON real_full_rec USING btree (record, tag, subfield) WHERE ((tag = 'tnf'::bpchar) AND (subfield = 'a'::text));


--
-- Name: metabib_full_rec_value_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_full_rec_value_tpo_idx ON real_full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops);


--
-- Name: metabib_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_index_vector_idx ON identifier_field_entry USING gist (index_vector);


--
-- Name: metabib_identifier_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_source_idx ON identifier_field_entry USING btree (source);


--
-- Name: metabib_identifier_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_identifier_field_entry_value_idx ON identifier_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_index_vector_idx ON keyword_field_entry USING gist (index_vector);


--
-- Name: metabib_keyword_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_source_idx ON keyword_field_entry USING btree (source);


--
-- Name: metabib_keyword_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_keyword_field_entry_value_idx ON keyword_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_metarecord_fingerprint_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_metarecord_fingerprint_idx ON metarecord USING btree (fingerprint);


--
-- Name: metabib_metarecord_master_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_metarecord_master_record_idx ON metarecord USING btree (master_record);


--
-- Name: metabib_metarecord_source_map_metarecord_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_metarecord_source_map_metarecord_idx ON metarecord_source_map USING btree (metarecord);


--
-- Name: metabib_metarecord_source_map_source_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_metarecord_source_map_source_record_idx ON metarecord_source_map USING btree (source);


--
-- Name: metabib_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_index_vector_idx ON series_field_entry USING gist (index_vector);


--
-- Name: metabib_series_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_source_idx ON series_field_entry USING btree (source);


--
-- Name: metabib_series_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_series_field_entry_value_idx ON series_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_index_vector_idx ON subject_field_entry USING gist (index_vector);


--
-- Name: metabib_subject_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_source_idx ON subject_field_entry USING btree (source);


--
-- Name: metabib_subject_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_subject_field_entry_value_idx ON subject_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_svf_attrs_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_svf_attrs_idx ON record_attr USING gist (attrs);


--
-- Name: metabib_svf_date1_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_svf_date1_idx ON record_attr USING btree (((attrs OPERATOR(evergreen.->) 'date1'::text)));


--
-- Name: metabib_svf_dates_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_svf_dates_idx ON record_attr USING btree (((attrs OPERATOR(evergreen.->) 'date1'::text)), ((attrs OPERATOR(evergreen.->) 'date2'::text)));


--
-- Name: metabib_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_index_vector_idx ON title_field_entry USING gist (index_vector);


--
-- Name: metabib_title_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_source_idx ON title_field_entry USING btree (source);


--
-- Name: metabib_title_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX metabib_title_field_entry_value_idx ON title_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: normalized_author_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_author_field_entry_gist_trgm ON normalized_author_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_author_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_remove_insignificants_author_field_entry_gist_trgm ON normalized_author_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_series_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_remove_insignificants_series_field_entry_gist_trgm ON normalized_series_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_subject_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_remove_insignificants_subject_field_entry_gist_trgm ON normalized_subject_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_title_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_remove_insignificants_title_field_entry_gist_trgm ON normalized_title_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_series_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_series_field_entry_gist_trgm ON normalized_series_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_subject_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_subject_field_entry_gist_trgm ON normalized_subject_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_title_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen; Tablespace: 
--

CREATE INDEX normalized_title_field_entry_gist_trgm ON normalized_title_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


SET search_path = money, pg_catalog;

--
-- Name: circ_open_date_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX circ_open_date_idx ON grocery USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: m_b_time_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_b_time_idx ON billing USING btree (billing_ts);


--
-- Name: m_b_x_open_xacts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_b_x_open_xacts_idx ON billable_xact USING btree (usr);


--
-- Name: m_b_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_b_xact_idx ON billing USING btree (xact);


--
-- Name: m_c_t_collector_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_c_t_collector_idx ON collections_tracker USING btree (collector);


--
-- Name: m_c_t_usr_collector_location_once_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX m_c_t_usr_collector_location_once_idx ON collections_tracker USING btree (usr, collector, location);


--
-- Name: m_g_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_g_usr_idx ON grocery USING btree (usr);


--
-- Name: m_p_time_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_p_time_idx ON payment USING btree (payment_ts);


--
-- Name: m_p_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX m_p_xact_idx ON payment USING btree (xact);


--
-- Name: money_cash_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_cash_id_idx ON cash_payment USING btree (id);


--
-- Name: money_cash_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_cash_payment_accepting_usr_idx ON cash_payment USING btree (accepting_usr);


--
-- Name: money_cash_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_cash_payment_cash_drawer_idx ON cash_payment USING btree (cash_drawer);


--
-- Name: money_cash_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_cash_payment_ts_idx ON cash_payment USING btree (payment_ts);


--
-- Name: money_cash_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_cash_payment_xact_idx ON cash_payment USING btree (xact);


--
-- Name: money_check_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_check_id_idx ON check_payment USING btree (id);


--
-- Name: money_check_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_check_payment_accepting_usr_idx ON check_payment USING btree (accepting_usr);


--
-- Name: money_check_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_check_payment_cash_drawer_idx ON check_payment USING btree (cash_drawer);


--
-- Name: money_check_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_check_payment_ts_idx ON check_payment USING btree (payment_ts);


--
-- Name: money_check_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_check_payment_xact_idx ON check_payment USING btree (xact);


--
-- Name: money_credit_card_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_card_id_idx ON credit_card_payment USING btree (id);


--
-- Name: money_credit_card_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_card_payment_accepting_usr_idx ON credit_card_payment USING btree (accepting_usr);


--
-- Name: money_credit_card_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_card_payment_cash_drawer_idx ON credit_card_payment USING btree (cash_drawer);


--
-- Name: money_credit_card_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_card_payment_ts_idx ON credit_card_payment USING btree (payment_ts);


--
-- Name: money_credit_card_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_card_payment_xact_idx ON credit_card_payment USING btree (xact);


--
-- Name: money_credit_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_id_idx ON credit_payment USING btree (id);


--
-- Name: money_credit_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_payment_accepting_usr_idx ON credit_payment USING btree (accepting_usr);


--
-- Name: money_credit_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_payment_payment_ts_idx ON credit_payment USING btree (payment_ts);


--
-- Name: money_credit_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_credit_payment_xact_idx ON credit_payment USING btree (xact);


--
-- Name: money_forgive_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_forgive_id_idx ON forgive_payment USING btree (id);


--
-- Name: money_forgive_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_forgive_payment_accepting_usr_idx ON forgive_payment USING btree (accepting_usr);


--
-- Name: money_forgive_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_forgive_payment_payment_ts_idx ON forgive_payment USING btree (payment_ts);


--
-- Name: money_forgive_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_forgive_payment_xact_idx ON forgive_payment USING btree (xact);


--
-- Name: money_goods_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_goods_id_idx ON goods_payment USING btree (id);


--
-- Name: money_goods_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_goods_payment_accepting_usr_idx ON goods_payment USING btree (accepting_usr);


--
-- Name: money_goods_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_goods_payment_payment_ts_idx ON goods_payment USING btree (payment_ts);


--
-- Name: money_goods_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_goods_payment_xact_idx ON goods_payment USING btree (xact);


--
-- Name: money_mat_summary_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_mat_summary_usr_idx ON materialized_billable_xact_summary USING btree (usr);


--
-- Name: money_mat_summary_xact_start_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_mat_summary_xact_start_idx ON materialized_billable_xact_summary USING btree (xact_start);


--
-- Name: money_work_id_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_work_id_idx ON work_payment USING btree (id);


--
-- Name: money_work_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_work_payment_accepting_usr_idx ON work_payment USING btree (accepting_usr);


--
-- Name: money_work_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_work_payment_payment_ts_idx ON work_payment USING btree (payment_ts);


--
-- Name: money_work_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX money_work_payment_xact_idx ON work_payment USING btree (xact);


--
-- Name: mous_idx; Type: INDEX; Schema: money; Owner: evergreen; Tablespace: 
--

CREATE INDEX mous_idx ON materialized_billable_xact_summary USING btree (usr) WHERE (xact_finish IS NULL);


SET search_path = offline, pg_catalog;

--
-- Name: offline_script_pkey; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_script_pkey ON script USING btree (id);


--
-- Name: offline_script_session; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_script_session ON script USING btree (session);


--
-- Name: offline_script_ws; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_script_ws ON script USING btree (workstation);


--
-- Name: offline_session_creation; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_session_creation ON session USING btree (create_time);


--
-- Name: offline_session_org; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_session_org ON session USING btree (org);


--
-- Name: offline_session_pkey; Type: INDEX; Schema: offline; Owner: evergreen; Tablespace: 
--

CREATE INDEX offline_session_pkey ON session USING btree (key);


SET search_path = permission, pg_catalog;

--
-- Name: grp_tree_parent_idx; Type: INDEX; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE INDEX grp_tree_parent_idx ON grp_tree USING btree (parent);


--
-- Name: perm_list_code_idx; Type: INDEX; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE INDEX perm_list_code_idx ON perm_list USING btree (code);


--
-- Name: uopm_usr_idx; Type: INDEX; Schema: permission; Owner: evergreen; Tablespace: 
--

CREATE INDEX uopm_usr_idx ON usr_object_perm_map USING btree (usr);


SET search_path = query, pg_catalog;

--
-- Name: from_parent_seq; Type: INDEX; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX from_parent_seq ON from_relation USING btree (parent_relation, seq_no) WHERE (parent_relation IS NOT NULL);


--
-- Name: query_expr_parent_seq; Type: INDEX; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX query_expr_parent_seq ON expression USING btree (parent_expr, seq_no) WHERE (parent_expr IS NOT NULL);


--
-- Name: query_function_sig_name_idx; Type: INDEX; Schema: query; Owner: evergreen; Tablespace: 
--

CREATE INDEX query_function_sig_name_idx ON function_sig USING btree (function_name);


SET search_path = reporter, pg_catalog;

--
-- Name: rpt_output_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_output_fldr_owner_idx ON output_folder USING btree (owner);


--
-- Name: rpt_output_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_output_folder_once_idx ON output_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_output_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_output_folder_once_parent_idx ON output_folder USING btree (name, parent);


--
-- Name: rpt_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_report_folder_once_idx ON report_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_report_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_report_folder_once_parent_idx ON report_folder USING btree (name, parent);


--
-- Name: rpt_rpt_fldr_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_rpt_fldr_idx ON report USING btree (folder);


--
-- Name: rpt_rpt_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_rpt_fldr_owner_idx ON report_folder USING btree (owner);


--
-- Name: rpt_rpt_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_rpt_owner_idx ON report USING btree (owner);


--
-- Name: rpt_sched_folder_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_sched_folder_idx ON schedule USING btree (folder);


--
-- Name: rpt_sched_runner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_sched_runner_idx ON schedule USING btree (runner);


--
-- Name: rpt_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_template_folder_once_idx ON template_folder USING btree (name, owner) WHERE (parent IS NULL);


--
-- Name: rpt_template_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rpt_template_folder_once_parent_idx ON template_folder USING btree (name, parent);


--
-- Name: rpt_tmpl_fldr_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_tmpl_fldr_idx ON template USING btree (folder);


--
-- Name: rpt_tmpl_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_tmpl_fldr_owner_idx ON template_folder USING btree (owner);


--
-- Name: rpt_tmpl_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE INDEX rpt_tmpl_owner_idx ON template USING btree (owner);


--
-- Name: rtp_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rtp_report_folder_once_idx ON report USING btree (name, folder);


--
-- Name: rtp_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX rtp_template_folder_once_idx ON template USING btree (name, folder);


SET search_path = search, pg_catalog;

--
-- Name: bump_once_per_field_idx; Type: INDEX; Schema: search; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX bump_once_per_field_idx ON relevance_adjustment USING btree (field, bump_type);


SET search_path = serial, pg_catalog;

--
-- Name: assist_holdings_display; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX assist_holdings_display ON materialized_holding_code USING btree (issuance, subfield);


--
-- Name: label_once_per_dist; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX label_once_per_dist ON stream USING btree (distribution, routing_label) WHERE (routing_label IS NOT NULL);


--
-- Name: one_dist_per_sre_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX one_dist_per_sre_idx ON distribution USING btree (record_entry);


--
-- Name: serial_basic_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_basic_summary_dist_idx ON basic_summary USING btree (distribution);


--
-- Name: serial_caption_and_pattern_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_caption_and_pattern_sub_idx ON caption_and_pattern USING btree (subscription);


--
-- Name: serial_distribution_holding_lib_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_distribution_holding_lib_idx ON distribution USING btree (holding_lib);


--
-- Name: serial_distribution_note_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_distribution_note_dist_idx ON distribution_note USING btree (distribution);


--
-- Name: serial_distribution_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_distribution_sub_idx ON distribution USING btree (subscription);


--
-- Name: serial_index_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_index_summary_dist_idx ON index_summary USING btree (distribution);


--
-- Name: serial_issuance_caption_and_pattern_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_issuance_caption_and_pattern_idx ON issuance USING btree (caption_and_pattern);


--
-- Name: serial_issuance_date_published_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_issuance_date_published_idx ON issuance USING btree (date_published);


--
-- Name: serial_issuance_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_issuance_sub_idx ON issuance USING btree (subscription);


--
-- Name: serial_item_date_received_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_date_received_idx ON item USING btree (date_received);


--
-- Name: serial_item_issuance_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_issuance_idx ON item USING btree (issuance);


--
-- Name: serial_item_note_item_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_note_item_idx ON item_note USING btree (item);


--
-- Name: serial_item_status_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_status_idx ON item USING btree (status);


--
-- Name: serial_item_stream_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_stream_idx ON item USING btree (stream);


--
-- Name: serial_item_unit_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_unit_idx ON item USING btree (unit);


--
-- Name: serial_item_uri_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_item_uri_idx ON item USING btree (uri);


--
-- Name: serial_record_entry_creator_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_record_entry_creator_idx ON record_entry USING btree (creator);


--
-- Name: serial_record_entry_editor_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_record_entry_editor_idx ON record_entry USING btree (editor);


--
-- Name: serial_record_entry_owning_lib_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_record_entry_owning_lib_idx ON record_entry USING btree (owning_lib, deleted);


--
-- Name: serial_routing_list_user_reader_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_routing_list_user_reader_idx ON routing_list_user USING btree (reader);


--
-- Name: serial_routing_list_user_stream_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_routing_list_user_stream_idx ON routing_list_user USING btree (stream);


--
-- Name: serial_stream_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_stream_dist_idx ON stream USING btree (distribution);


--
-- Name: serial_subscription_owner_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_subscription_owner_idx ON subscription USING btree (owning_lib);


--
-- Name: serial_subscription_record_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_subscription_record_idx ON subscription USING btree (record_entry);


--
-- Name: serial_supplement_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX serial_supplement_summary_dist_idx ON supplement_summary USING btree (distribution);


--
-- Name: unit_avail_cn_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX unit_avail_cn_idx ON unit USING btree (call_number);


--
-- Name: unit_barcode_key; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX unit_barcode_key ON unit USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: unit_cn_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX unit_cn_idx ON unit USING btree (call_number);


--
-- Name: unit_creator_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX unit_creator_idx ON unit USING btree (creator);


--
-- Name: unit_editor_idx; Type: INDEX; Schema: serial; Owner: evergreen; Tablespace: 
--

CREATE INDEX unit_editor_idx ON unit USING btree (editor);


SET search_path = vandelay, pg_catalog;

--
-- Name: queued_authority_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE INDEX queued_authority_record_attr_record_idx ON queued_authority_record_attr USING btree (record);


--
-- Name: queued_authority_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE INDEX queued_authority_record_queue_idx ON queued_authority_record USING btree (queue);


--
-- Name: queued_bib_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE INDEX queued_bib_record_attr_record_idx ON queued_bib_record_attr USING btree (record);


--
-- Name: queued_bib_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE INDEX queued_bib_record_queue_idx ON queued_bib_record USING btree (queue);


--
-- Name: vmsq_def_once_per_set; Type: INDEX; Schema: vandelay; Owner: evergreen; Tablespace: 
--

CREATE UNIQUE INDEX vmsq_def_once_per_set ON match_set_quality USING btree (match_set, (COALESCE(tag, ''::text)), (COALESCE(subfield, ''::text)), (COALESCE(svf, ''::text)), value);


SET search_path = actor, pg_catalog;

--
-- Name: protect_user_delete; Type: RULE; Schema: actor; Owner: evergreen
--

CREATE RULE protect_user_delete AS ON DELETE TO usr DO INSTEAD UPDATE usr SET deleted = true WHERE (old.id = usr.id);


SET search_path = asset, pg_catalog;

--
-- Name: protect_cn_delete; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_cn_delete AS ON DELETE TO call_number DO INSTEAD UPDATE call_number SET deleted = true WHERE (old.id = call_number.id);


--
-- Name: protect_copy_delete; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_copy_delete AS ON DELETE TO copy DO INSTEAD UPDATE copy SET deleted = true WHERE (old.id = copy.id);


SET search_path = authority, pg_catalog;

--
-- Name: protect_authority_rec_delete; Type: RULE; Schema: authority; Owner: evergreen
--

CREATE RULE protect_authority_rec_delete AS ON DELETE TO record_entry DO INSTEAD (UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id); DELETE FROM full_rec WHERE (full_rec.record = old.id); );


SET search_path = biblio, pg_catalog;

--
-- Name: protect_bib_rec_delete; Type: RULE; Schema: biblio; Owner: evergreen
--

CREATE RULE protect_bib_rec_delete AS ON DELETE TO record_entry DO INSTEAD UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id);


SET search_path = metabib, pg_catalog;

--
-- Name: metabib_full_rec_delete_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_delete_rule AS ON DELETE TO full_rec DO INSTEAD DELETE FROM real_full_rec WHERE (real_full_rec.id = old.id);


--
-- Name: metabib_full_rec_insert_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_insert_rule AS ON INSERT TO full_rec DO INSTEAD INSERT INTO real_full_rec (id, record, tag, ind1, ind2, subfield, value, index_vector) VALUES (COALESCE(new.id, nextval('full_rec_id_seq'::regclass)), new.record, new.tag, new.ind1, new.ind2, new.subfield, new.value, new.index_vector);


--
-- Name: metabib_full_rec_update_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_update_rule AS ON UPDATE TO full_rec DO INSTEAD UPDATE real_full_rec SET id = new.id, record = new.record, tag = new.tag, ind1 = new.ind1, ind2 = new.ind2, subfield = new.subfield, value = new.value, index_vector = new.index_vector WHERE (real_full_rec.id = old.id);


SET search_path = money, pg_catalog;

--
-- Name: money_payment_view_update; Type: RULE; Schema: money; Owner: evergreen
--

CREATE RULE money_payment_view_update AS ON UPDATE TO payment_view DO INSTEAD UPDATE payment SET xact = new.xact, payment_ts = new.payment_ts, voided = new.voided, amount = new.amount, note = new.note WHERE (payment.id = new.id);


SET search_path = query, pg_catalog;

--
-- Name: query_expr_string_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_delete_rule AS ON DELETE TO expr_xstr DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_string_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_insert_rule AS ON INSERT TO expr_xstr DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xstr'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: query_expr_string_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_update_rule AS ON UPDATE TO expr_xstr DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal WHERE (expression.id = old.id);


--
-- Name: query_expr_xbet_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_delete_rule AS ON DELETE TO expr_xbet DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbet_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_insert_rule AS ON INSERT TO expr_xbet DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbet'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xbet_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_update_rule AS ON UPDATE TO expr_xbet DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xbind_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_delete_rule AS ON DELETE TO expr_xbind DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbind_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_insert_rule AS ON INSERT TO expr_xbind DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, bind_variable) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbind'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.bind_variable);


--
-- Name: query_expr_xbind_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_update_rule AS ON UPDATE TO expr_xbind DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, bind_variable = new.bind_variable WHERE (expression.id = old.id);


--
-- Name: query_expr_xbool_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_delete_rule AS ON DELETE TO expr_xbool DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xbool_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_insert_rule AS ON INSERT TO expr_xbool DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xbool'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal, COALESCE(new.negate, false));


--
-- Name: query_expr_xbool_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_update_rule AS ON UPDATE TO expr_xbool DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcase_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_delete_rule AS ON DELETE TO expr_xcase DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcase_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_insert_rule AS ON INSERT TO expr_xcase DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcase'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xcase_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_update_rule AS ON UPDATE TO expr_xcase DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcast_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_delete_rule AS ON DELETE TO expr_xcast DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcast_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_insert_rule AS ON INSERT TO expr_xcast DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, cast_type, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcast'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.cast_type, COALESCE(new.negate, false));


--
-- Name: query_expr_xcast_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_update_rule AS ON UPDATE TO expr_xcast DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, cast_type = new.cast_type, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xcol_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_delete_rule AS ON DELETE TO expr_xcol DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xcol_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_insert_rule AS ON INSERT TO expr_xcol DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, table_alias, column_name, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xcol'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.table_alias, new.column_name, COALESCE(new.negate, false));


--
-- Name: query_expr_xcol_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_update_rule AS ON UPDATE TO expr_xcol DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, table_alias = new.table_alias, column_name = new.column_name, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xex_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_delete_rule AS ON DELETE TO expr_xex DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xex_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_insert_rule AS ON INSERT TO expr_xex DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xex'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xex_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_update_rule AS ON UPDATE TO expr_xex DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xfunc_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_delete_rule AS ON DELETE TO expr_xfunc DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xfunc_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_insert_rule AS ON INSERT TO expr_xfunc DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, column_name, function_id, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xfunc'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.column_name, new.function_id, COALESCE(new.negate, false));


--
-- Name: query_expr_xfunc_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_update_rule AS ON UPDATE TO expr_xfunc DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, column_name = new.column_name, function_id = new.function_id, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xin_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_delete_rule AS ON DELETE TO expr_xin DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xin_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_insert_rule AS ON INSERT TO expr_xin DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xin'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xin_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_update_rule AS ON UPDATE TO expr_xin DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xisnull_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_delete_rule AS ON DELETE TO expr_xisnull DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xisnull_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_insert_rule AS ON INSERT TO expr_xisnull DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xisnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xisnull_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_update_rule AS ON UPDATE TO expr_xisnull DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xnull_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_delete_rule AS ON DELETE TO expr_xnull DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xnull_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_insert_rule AS ON INSERT TO expr_xnull DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), COALESCE(new.negate, false));


--
-- Name: query_expr_xnull_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_update_rule AS ON UPDATE TO expr_xnull DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xnum_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_delete_rule AS ON DELETE TO expr_xnum DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xnum_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_insert_rule AS ON INSERT TO expr_xnum DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, literal) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xnum'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: query_expr_xnum_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_update_rule AS ON UPDATE TO expr_xnum DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal WHERE (expression.id = old.id);


--
-- Name: query_expr_xop_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_delete_rule AS ON DELETE TO expr_xop DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xop_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_insert_rule AS ON INSERT TO expr_xop DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, left_operand, operator, right_operand, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xop'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.operator, new.right_operand, COALESCE(new.negate, false));


--
-- Name: query_expr_xop_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_update_rule AS ON UPDATE TO expr_xop DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, operator = new.operator, right_operand = new.right_operand, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xser_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_delete_rule AS ON DELETE TO expr_xser DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xser_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_insert_rule AS ON INSERT TO expr_xser DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, operator, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xser'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.operator, COALESCE(new.negate, false));


--
-- Name: query_expr_xser_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_update_rule AS ON UPDATE TO expr_xser DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, operator = new.operator, negate = new.negate WHERE (expression.id = old.id);


--
-- Name: query_expr_xsubq_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_delete_rule AS ON DELETE TO expr_xsubq DO INSTEAD DELETE FROM expression WHERE (expression.id = old.id);


--
-- Name: query_expr_xsubq_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_insert_rule AS ON INSERT TO expr_xsubq DO INSTEAD INSERT INTO expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate) VALUES (COALESCE((new.id)::bigint, nextval('expression_id_seq'::regclass)), 'xsubq'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: query_expr_xsubq_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_update_rule AS ON UPDATE TO expr_xsubq DO INSTEAD UPDATE expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate WHERE (expression.id = old.id);


SET search_path = serial, pg_catalog;

--
-- Name: protect_mfhd_delete; Type: RULE; Schema: serial; Owner: evergreen
--

CREATE RULE protect_mfhd_delete AS ON DELETE TO record_entry DO INSTEAD UPDATE record_entry SET deleted = true WHERE (old.id = record_entry.id);


--
-- Name: protect_serial_unit_delete; Type: RULE; Schema: serial; Owner: evergreen
--

CREATE RULE protect_serial_unit_delete AS ON DELETE TO unit DO INSTEAD UPDATE unit SET deleted = true WHERE (old.id = unit.id);


SET search_path = acq, pg_catalog;

--
-- Name: acq_fund_alloc_percent_val_trig; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER acq_fund_alloc_percent_val_trig BEFORE INSERT OR UPDATE ON fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE fund_alloc_percent_val();


--
-- Name: acqfap_limit_100_trig; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER acqfap_limit_100_trig AFTER INSERT OR UPDATE ON fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE fap_limit_100();


--
-- Name: audit_acq_fund_debit_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_fund_debit_update_trigger AFTER DELETE OR UPDATE ON fund_debit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_fund_debit_func();


--
-- Name: audit_acq_invoice_entry_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_entry_update_trigger AFTER DELETE OR UPDATE ON invoice_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_entry_func();


--
-- Name: audit_acq_invoice_item_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_item_update_trigger AFTER DELETE OR UPDATE ON invoice_item FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_item_func();


--
-- Name: audit_acq_invoice_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_update_trigger AFTER DELETE OR UPDATE ON invoice FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_func();


--
-- Name: audit_acq_lineitem_detail_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_lineitem_detail_update_trigger AFTER DELETE OR UPDATE ON lineitem_detail FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_lineitem_detail_func();


--
-- Name: audit_acq_lineitem_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_lineitem_update_trigger AFTER DELETE OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE audit_acq_lineitem_func();


--
-- Name: audit_acq_purchase_order_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_purchase_order_update_trigger AFTER DELETE OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE audit_acq_purchase_order_func();


--
-- Name: cleanup_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER cleanup_lineitem_trigger BEFORE DELETE OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE public.cleanup_acq_marc();


--
-- Name: ingest_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER ingest_lineitem_trigger AFTER INSERT OR UPDATE ON lineitem FOR EACH ROW EXECUTE PROCEDURE public.ingest_acq_marc();


--
-- Name: po_name_default_trg; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER po_name_default_trg BEFORE INSERT OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE purchase_order_name_default();


--
-- Name: po_org_name_date_unique_trg; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER po_org_name_date_unique_trg BEFORE INSERT OR UPDATE ON purchase_order FOR EACH ROW EXECUTE PROCEDURE po_org_name_date_unique();


SET search_path = action, pg_catalog;

--
-- Name: action_circulation_aging_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_aging_tgr BEFORE DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE age_circ_on_delete();


--
-- Name: action_circulation_stop_fines_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_stop_fines_tgr BEFORE UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE circulation_claims_returned();


--
-- Name: action_circulation_target_copy_trig; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_target_copy_trig AFTER INSERT OR UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE evergreen.fake_fkey_tgr('target_copy');


--
-- Name: action_survey_response_answer_date_fixup_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_survey_response_answer_date_fixup_tgr BEFORE INSERT ON survey_response FOR EACH ROW EXECUTE PROCEDURE survey_response_answer_date_fixup();


--
-- Name: age_parent_circ; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER age_parent_circ AFTER DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE age_parent_circ_on_delete();


--
-- Name: archive_stat_cats_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER archive_stat_cats_tgr AFTER INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE archive_stat_cats();


--
-- Name: archived_hold_request_insert_triggerer; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER archived_hold_request_insert_triggerer BEFORE INSERT ON archived_hold_request FOR EACH ROW EXECUTE PROCEDURE archived_hold_request_insert_trigger();


--
-- Name: fill_circ_copy_location_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER fill_circ_copy_location_tgr BEFORE INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE fill_circ_copy_location();


--
-- Name: hold_copy_proximity_update_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER hold_copy_proximity_update_tgr BEFORE INSERT OR UPDATE ON hold_copy_map FOR EACH ROW EXECUTE PROCEDURE hold_copy_calculated_proximity_update();


--
-- Name: hold_request_clear_map_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER hold_request_clear_map_tgr AFTER UPDATE ON hold_request FOR EACH ROW WHEN ((((new.cancel_time IS NOT NULL) AND (old.cancel_time IS NULL)) OR ((new.fulfillment_time IS NOT NULL) AND (old.fulfillment_time IS NULL)))) EXECUTE PROCEDURE hold_request_clear_map();


--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('circulation');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


--
-- Name: modify_hold_count_trigger; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER modify_hold_count_trigger AFTER INSERT OR DELETE OR UPDATE ON hold_request FOR EACH ROW EXECUTE PROCEDURE modify_hold_count();


--
-- Name: push_due_date_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER push_due_date_tgr BEFORE INSERT OR UPDATE ON circulation FOR EACH ROW EXECUTE PROCEDURE push_circ_due_time();


SET search_path = action_trigger, pg_catalog;

--
-- Name: audit_action_trigger_event_definition_update_trigger; Type: TRIGGER; Schema: action_trigger; Owner: evergreen
--

CREATE TRIGGER audit_action_trigger_event_definition_update_trigger AFTER DELETE OR UPDATE ON event_definition FOR EACH ROW EXECUTE PROCEDURE auditor.audit_action_trigger_event_definition_func();


SET search_path = actor, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: actor_crypt_pw_insert_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_crypt_pw_insert_trigger BEFORE INSERT ON usr FOR EACH ROW EXECUTE PROCEDURE crypt_pw_insert();


--
-- Name: actor_crypt_pw_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_crypt_pw_update_trigger BEFORE UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE crypt_pw_update();


--
-- Name: actor_ignore_no_default_pickup_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_ignore_no_default_pickup_location BEFORE INSERT OR UPDATE ON usr_setting FOR EACH ROW EXECUTE PROCEDURE ignore_update_default_pickup_location();


--
-- Name: actor_only_kcls_for_default_search_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_only_kcls_for_default_search_location BEFORE INSERT OR UPDATE ON usr_setting FOR EACH ROW EXECUTE PROCEDURE ignore_update_default_search_location();


--
-- Name: actor_org_unit_parent_protect_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_org_unit_parent_protect_trigger BEFORE INSERT OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE org_unit_parent_protect();


--
-- Name: actor_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON stat_cat FOR EACH ROW EXECUTE PROCEDURE stat_cat_check();


--
-- Name: actor_update_default_pickup_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_update_default_pickup_location AFTER INSERT OR UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE create_default_pickup_location();


--
-- Name: au_update_trig; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER au_update_trig BEFORE INSERT OR UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE au_updated();


--
-- Name: audit_actor_org_unit_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_org_unit_update_trigger AFTER DELETE OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_org_unit_func();


--
-- Name: audit_actor_usr_address_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_address_update_trigger AFTER DELETE OR UPDATE ON usr_address FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_address_func();

ALTER TABLE usr_address DISABLE TRIGGER audit_actor_usr_address_update_trigger;


--
-- Name: audit_actor_usr_setting_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_setting_update_trigger AFTER DELETE OR UPDATE ON usr_setting FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_setting_func();


--
-- Name: audit_actor_usr_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_update_trigger AFTER DELETE OR UPDATE ON usr FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_func();


--
-- Name: log_ous_change; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER log_ous_change BEFORE INSERT OR UPDATE ON org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_change_log();


--
-- Name: log_ous_del; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER log_ous_del BEFORE DELETE ON org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_delete_log();


--
-- Name: proximity_update_tgr; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER proximity_update_tgr AFTER INSERT OR DELETE OR UPDATE ON org_unit FOR EACH ROW EXECUTE PROCEDURE org_unit_prox_update();


--
-- Name: remove_transient_usr_activity; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER remove_transient_usr_activity BEFORE INSERT ON usr_activity FOR EACH ROW EXECUTE PROCEDURE usr_activity_transient_trg();


SET search_path = asset, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy_location FOR EACH ROW EXECUTE PROCEDURE cache_copy_visibility();


--
-- Name: acp_created_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER acp_created_trig BEFORE INSERT ON copy FOR EACH ROW EXECUTE PROCEDURE acp_created();


--
-- Name: acp_status_changed_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER acp_status_changed_trig BEFORE UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE acp_status_changed();


--
-- Name: asset_label_sortkey_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_label_sortkey_trigger BEFORE INSERT OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE label_normalizer();


--
-- Name: asset_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON stat_cat FOR EACH ROW EXECUTE PROCEDURE stat_cat_check();


--
-- Name: audit_asset_call_number_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER audit_asset_call_number_update_trigger AFTER DELETE OR UPDATE ON call_number FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_call_number_func();


--
-- Name: audit_asset_copy_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER audit_asset_copy_update_trigger AFTER DELETE OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_copy_func();


--
-- Name: autogenerate_placeholder_barcode; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON copy FOR EACH ROW EXECUTE PROCEDURE autogenerate_placeholder_barcode();


--
-- Name: prefix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER prefix_normalize_tgr BEFORE INSERT OR UPDATE ON call_number_prefix FOR EACH ROW EXECUTE PROCEDURE normalize_affix_sortkey();


--
-- Name: suffix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER suffix_normalize_tgr BEFORE INSERT OR UPDATE ON call_number_suffix FOR EACH ROW EXECUTE PROCEDURE normalize_affix_sortkey();


SET search_path = authority, pg_catalog;

--
-- Name: a_marcxml_is_well_formed; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.check_marcxml_well_formed();


--
-- Name: aaa_auth_ingest_or_delete; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER aaa_auth_ingest_or_delete AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE indexing_ingest_or_delete();


--
-- Name: authority_full_rec_fti_trigger; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER authority_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: authority_simple_heading_fti_trigger; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER authority_simple_heading_fti_trigger BEFORE INSERT OR UPDATE ON simple_heading FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE public.maintain_control_numbers();


--
-- Name: map_thesaurus_to_control_set; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER map_thesaurus_to_control_set BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE map_thesaurus_to_control_set();


SET search_path = biblio, pg_catalog;

--
-- Name: a_marcxml_is_well_formed; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE check_marcxml_well_formed();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR DELETE ON peer_bib_copy_map FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: aaa_indexing_ingest_or_delete; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER aaa_indexing_ingest_or_delete AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE indexing_ingest_or_delete();


--
-- Name: audit_biblio_record_entry_update_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER audit_biblio_record_entry_update_trigger AFTER DELETE OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_biblio_record_entry_func();


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: bbb_simple_rec_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER bbb_simple_rec_trigger AFTER INSERT OR DELETE OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE public.maintain_control_numbers();


--
-- Name: fingerprint_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER fingerprint_tgr BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE fingerprint_trigger('eng', 'BKS');


--
-- Name: insert_hold_row_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER insert_hold_row_trigger AFTER INSERT ON record_entry FOR EACH ROW EXECUTE PROCEDURE action.insert_hold_row();


--
-- Name: language_filter_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER language_filter_trigger AFTER INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE update_language_filter();


--
-- Name: norm_sort_label; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER norm_sort_label BEFORE INSERT OR UPDATE ON monograph_part FOR EACH ROW EXECUTE PROCEDURE normalize_biblio_monograph_part_sortkey();


SET search_path = booking, pg_catalog;

--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('reservation');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


SET search_path = config, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON copy_status FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: create_or_update_code_unknown; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER create_or_update_code_unknown AFTER INSERT OR UPDATE ON coded_value_map FOR EACH ROW EXECUTE PROCEDURE create_or_update_code_unknown();


--
-- Name: no_overlapping_deps; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER no_overlapping_deps BEFORE INSERT OR UPDATE ON db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('deprecates');


--
-- Name: no_overlapping_sups; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER no_overlapping_sups BEFORE INSERT OR UPDATE ON db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('supersedes');


SET search_path = metabib, pg_catalog;

--
-- Name: facet_force_nfc_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER facet_force_nfc_tgr BEFORE INSERT OR UPDATE ON facet_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.facet_force_nfc();


--
-- Name: facet_normalize_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER facet_normalize_tgr BEFORE INSERT OR UPDATE ON facet_entry FOR EACH ROW EXECUTE PROCEDURE facet_normalize_trigger();


--
-- Name: metabib_author_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_author_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON author_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('author');


--
-- Name: metabib_browse_author_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_author_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_author_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_browse_call_number_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_call_number_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_call_number_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_browse_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_browse_series_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_series_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_series_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_browse_subject_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_subject_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_subject_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_browse_title_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_title_entry_fti_trigger BEFORE INSERT OR UPDATE ON browse_title_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_call_number_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_call_number_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON call_number_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('call_number');


--
-- Name: metabib_full_rec_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON real_full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('default');


--
-- Name: metabib_identifier_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_identifier_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON identifier_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('identifier');


--
-- Name: metabib_keyword_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_keyword_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON keyword_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: metabib_series_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_series_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON series_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('series');


--
-- Name: metabib_subject_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_subject_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON subject_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('subject');


--
-- Name: metabib_title_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_title_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON title_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('title');


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON subject_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE subject_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON author_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE author_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON title_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE title_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON keyword_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE keyword_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON series_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE series_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON call_number_field_entry FOR EACH ROW EXECUTE PROCEDURE normalized_field_entry_view();

ALTER TABLE call_number_field_entry DISABLE TRIGGER normalize_field_entry;


SET search_path = money, pg_catalog;

--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_add();


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('bnm_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('forgive_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('work_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('credit_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('goods_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('bnm_desk_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('credit_card_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('cash_payment');


--
-- Name: mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_add('check_payment');


--
-- Name: mat_summary_change_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_update();


--
-- Name: mat_summary_create_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_create('grocery');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_del();


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('bnm_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('forgive_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('work_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('credit_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('goods_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('bnm_desk_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('credit_card_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('cash_payment');


--
-- Name: mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_del('check_payment');


--
-- Name: mat_summary_remove_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON grocery FOR EACH ROW EXECUTE PROCEDURE mat_summary_delete();


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON billing FOR EACH ROW EXECUTE PROCEDURE materialized_summary_billing_update();


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON bnm_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('bnm_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON forgive_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('forgive_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON work_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('work_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON credit_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('credit_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON goods_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('goods_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('bnm_desk_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON credit_card_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('credit_card_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON cash_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('cash_payment');


--
-- Name: mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON check_payment FOR EACH ROW EXECUTE PROCEDURE materialized_summary_payment_update('check_payment');


SET search_path = permission, pg_catalog;

--
-- Name: maintain_perm_i18n_tgr; Type: TRIGGER; Schema: permission; Owner: evergreen
--

CREATE TRIGGER maintain_perm_i18n_tgr AFTER UPDATE ON perm_list FOR EACH ROW EXECUTE PROCEDURE public.oils_i18n_id_tracking('ppl');


SET search_path = serial, pg_catalog;

--
-- Name: a_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER a_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: audit_serial_unit_update_trigger; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER audit_serial_unit_update_trigger AFTER DELETE OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_serial_unit_func();


--
-- Name: autogenerate_placeholder_barcode; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.autogenerate_placeholder_barcode();


--
-- Name: b_maintain_901; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: c_maintain_control_numbers; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON record_entry FOR EACH ROW EXECUTE PROCEDURE public.maintain_control_numbers();


--
-- Name: materialize_holding_code; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER materialize_holding_code AFTER INSERT OR UPDATE ON issuance FOR EACH ROW EXECUTE PROCEDURE materialize_holding_code();


--
-- Name: sunit_created_trig; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER sunit_created_trig BEFORE INSERT ON unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_created();


--
-- Name: sunit_status_changed_trig; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER sunit_status_changed_trig BEFORE UPDATE ON unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_status_changed();


SET search_path = url_verify, pg_catalog;

--
-- Name: ingest_url_tgr; Type: TRIGGER; Schema: url_verify; Owner: evergreen
--

CREATE TRIGGER ingest_url_tgr BEFORE INSERT ON url FOR EACH ROW EXECUTE PROCEDURE ingest_url();


SET search_path = vandelay, pg_catalog;

--
-- Name: cleanup_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER cleanup_authority_trigger BEFORE DELETE OR UPDATE ON queued_authority_record FOR EACH ROW EXECUTE PROCEDURE cleanup_authority_marc();


--
-- Name: cleanup_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER cleanup_bib_trigger BEFORE DELETE OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE cleanup_bib_marc();


--
-- Name: ingest_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_authority_trigger AFTER INSERT OR UPDATE ON queued_authority_record FOR EACH ROW EXECUTE PROCEDURE ingest_authority_marc();


--
-- Name: ingest_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_bib_trigger AFTER INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE ingest_bib_marc();


--
-- Name: ingest_item_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_item_trigger AFTER INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE ingest_bib_items();


--
-- Name: zz_match_auth_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER zz_match_auth_trigger BEFORE INSERT OR UPDATE ON queued_authority_record FOR EACH ROW EXECUTE PROCEDURE match_auth_record();


--
-- Name: zz_match_bibs_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER zz_match_bibs_trigger BEFORE INSERT OR UPDATE ON queued_bib_record FOR EACH ROW EXECUTE PROCEDURE match_bib_record();


SET search_path = acq, pg_catalog;

--
-- Name: acq_lineitem_history_queued_record_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq_lineitem_history
    ADD CONSTRAINT acq_lineitem_history_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_bib_record(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: cancel_reason_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY cancel_reason
    ADD CONSTRAINT cancel_reason_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event
    ADD CONSTRAINT claim_event_type_fkey FOREIGN KEY (type) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_event_type
    ADD CONSTRAINT claim_event_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_lineitem_detail_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_lineitem_detail_fkey FOREIGN KEY (lineitem_detail) REFERENCES lineitem_detail(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action_action_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_action_fkey FOREIGN KEY (action) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_policy_action
    ADD CONSTRAINT claim_policy_action_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES claim_policy(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_policy
    ADD CONSTRAINT claim_policy_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim
    ADD CONSTRAINT claim_type_fkey FOREIGN KEY (type) REFERENCES claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY claim_type
    ADD CONSTRAINT claim_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY debit_attribution
    ADD CONSTRAINT debit_attribution_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_formula_fkey FOREIGN KEY (formula) REFERENCES distribution_formula(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code);


--
-- Name: distribution_formula_entry_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_formula_fkey FOREIGN KEY (formula) REFERENCES distribution_formula(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id);


--
-- Name: distribution_formula_entry_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id);


--
-- Name: distribution_formula_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY distribution_formula
    ADD CONSTRAINT distribution_formula_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_account_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY edi_account
    ADD CONSTRAINT edi_account_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message_account_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_account_fkey FOREIGN KEY (account) REFERENCES edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY edi_message
    ADD CONSTRAINT edi_message_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate_from_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_from_currency_fkey FOREIGN KEY (from_currency) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate_to_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY exchange_rate
    ADD CONSTRAINT exchange_rate_to_currency_fkey FOREIGN KEY (to_currency) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fiscal_year_calendar_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fiscal_year
    ADD CONSTRAINT fiscal_year_calendar_fkey FOREIGN KEY (calendar) REFERENCES fiscal_calendar(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation
    ADD CONSTRAINT fund_allocation_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_invoice_entry_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_invoice_entry_fkey FOREIGN KEY (invoice_entry) REFERENCES invoice_entry(id) ON DELETE SET NULL;


--
-- Name: fund_debit_origin_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_origin_currency_type_fkey FOREIGN KEY (origin_currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit_xfer_destination_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_debit
    ADD CONSTRAINT fund_debit_xfer_destination_fkey FOREIGN KEY (xfer_destination) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund
    ADD CONSTRAINT fund_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map_tag_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_tag_map
    ADD CONSTRAINT fund_tag_map_tag_fkey FOREIGN KEY (tag) REFERENCES fund_tag(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_tag
    ADD CONSTRAINT fund_tag_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_dest_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_dest_fund_fkey FOREIGN KEY (dest_fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_src_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_src_fund_fkey FOREIGN KEY (src_fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer_transfer_user_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY fund_transfer
    ADD CONSTRAINT fund_transfer_transfer_user_fkey FOREIGN KEY (transfer_user) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_credit_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY funding_source_credit
    ADD CONSTRAINT funding_source_credit_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY funding_source
    ADD CONSTRAINT funding_source_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_entry_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_invoice_fkey FOREIGN KEY (invoice) REFERENCES invoice(id) ON DELETE CASCADE;


--
-- Name: invoice_entry_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_entry_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_entry
    ADD CONSTRAINT invoice_entry_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id);


--
-- Name: invoice_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES invoice_item_type(code);


--
-- Name: invoice_item_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_invoice_fkey FOREIGN KEY (invoice) REFERENCES invoice(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: invoice_item_po_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_po_item_fkey FOREIGN KEY (po_item) REFERENCES po_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT invoice_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_payment_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_payment_method_fkey FOREIGN KEY (payment_method) REFERENCES invoice_payment_method(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id);


--
-- Name: invoice_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.org_unit(id);


--
-- Name: invoice_recv_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_recv_method_fkey FOREIGN KEY (recv_method) REFERENCES invoice_method(code);


--
-- Name: invoice_shipper_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT invoice_shipper_fkey FOREIGN KEY (shipper) REFERENCES provider(id);


--
-- Name: lineitem_alert_text_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_attr_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_attr
    ADD CONSTRAINT lineitem_attr_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_detail
    ADD CONSTRAINT lineitem_detail_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_eg_bib_id_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_eg_bib_id_fkey FOREIGN KEY (eg_bib_id) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_alert_text_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_alert_text_fkey FOREIGN KEY (alert_text) REFERENCES lineitem_alert_text(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_note
    ADD CONSTRAINT lineitem_note_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_picklist_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_picklist_fkey FOREIGN KEY (picklist) REFERENCES picklist(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_provider_attr_definition_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_queued_record_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_bib_record(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_selector_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem
    ADD CONSTRAINT lineitem_selector_fkey FOREIGN KEY (selector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_usr_attr_definition_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY picklist
    ADD CONSTRAINT picklist_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_fund_fkey FOREIGN KEY (fund) REFERENCES fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES invoice_item_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_item
    ADD CONSTRAINT po_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY po_note
    ADD CONSTRAINT po_note_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_address_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_address
    ADD CONSTRAINT provider_address_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact_address_contact_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_contact_address
    ADD CONSTRAINT provider_contact_address_contact_fkey FOREIGN KEY (contact) REFERENCES provider_contact(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_contact
    ADD CONSTRAINT provider_contact_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_default_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_default_claim_policy_fkey FOREIGN KEY (default_claim_policy) REFERENCES claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_edi_default_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_edi_default_fkey FOREIGN KEY (edi_default) REFERENCES edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_holding_subfield_map_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider_note
    ADD CONSTRAINT provider_note_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY provider
    ADD CONSTRAINT provider_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_ordering_agency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_ordering_agency_fkey FOREIGN KEY (ordering_agency) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY purchase_order
    ADD CONSTRAINT purchase_order_provider_fkey FOREIGN KEY (provider) REFERENCES provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES serial_claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim_event
    ADD CONSTRAINT serial_claim_event_type_fkey FOREIGN KEY (type) REFERENCES claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_item_fkey FOREIGN KEY (item) REFERENCES serial.item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY serial_claim
    ADD CONSTRAINT serial_claim_type_fkey FOREIGN KEY (type) REFERENCES claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_request_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_request_eg_bib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_eg_bib_fkey FOREIGN KEY (eg_bib) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


--
-- Name: user_request_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES lineitem(id) ON DELETE CASCADE;


--
-- Name: user_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id);


--
-- Name: user_request_request_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_request_type_fkey FOREIGN KEY (request_type) REFERENCES user_request_type(id);


--
-- Name: user_request_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY user_request
    ADD CONSTRAINT user_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id);


SET search_path = action, pg_catalog;

--
-- Name: action_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT action_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: action_circulation_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT action_circulation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: artc_tc_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT artc_tc_fkey FOREIGN KEY (target_copy) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_checkin_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_checkin_workstation_fkey FOREIGN KEY (checkin_workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_copy_location_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_circ_fkey FOREIGN KEY (circ) REFERENCES circulation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES config.circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_parent_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_parent_circ_fkey FOREIGN KEY (parent_circ) REFERENCES circulation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY circulation
    ADD CONSTRAINT circulation_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_col_val_fieldset_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_fieldset_fkey FOREIGN KEY (fieldset) REFERENCES fieldset(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_owning_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_stored_query_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY fieldset
    ADD CONSTRAINT fieldset_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES query.stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_copy_map_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_copy_map
    ADD CONSTRAINT hold_copy_map_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_count_record_entry_id_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_count
    ADD CONSTRAINT hold_count_record_entry_id_fkey FOREIGN KEY (record_entry_id) REFERENCES biblio.record_entry(id) ON UPDATE RESTRICT ON DELETE CASCADE DEFERRABLE;


--
-- Name: hold_notification_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_notification_notify_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_notification
    ADD CONSTRAINT hold_notification_notify_staff_fkey FOREIGN KEY (notify_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_cancel_cause_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_cancel_cause_fkey FOREIGN KEY (cancel_cause) REFERENCES hold_request_cancel_cause(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_current_shelf_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_current_shelf_lib_fkey FOREIGN KEY (current_shelf_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_fulfillment_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_fulfillment_lib_fkey FOREIGN KEY (fulfillment_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_fulfillment_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_fulfillment_staff_fkey FOREIGN KEY (fulfillment_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_note_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request_note
    ADD CONSTRAINT hold_request_note_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_request_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_requestor_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_requestor_fkey FOREIGN KEY (requestor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_sms_carrier_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_sms_carrier_fkey FOREIGN KEY (sms_carrier) REFERENCES config.sms_carrier(id);


--
-- Name: hold_request_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_request
    ADD CONSTRAINT hold_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_transit_copy_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_hold_fkey FOREIGN KEY (hold) REFERENCES hold_request(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY in_house_use
    ADD CONSTRAINT in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_patron_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_patron_fkey FOREIGN KEY (patron) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_transit_copy_reservation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_reservation_fkey FOREIGN KEY (reservation) REFERENCES booking.reservation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_answer_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_answer
    ADD CONSTRAINT survey_answer_question_fkey FOREIGN KEY (question) REFERENCES survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey
    ADD CONSTRAINT survey_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_question_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_question
    ADD CONSTRAINT survey_question_survey_fkey FOREIGN KEY (survey) REFERENCES survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_answer_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_answer_fkey FOREIGN KEY (answer) REFERENCES survey_answer(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_question_fkey FOREIGN KEY (question) REFERENCES survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY survey_response
    ADD CONSTRAINT survey_response_survey_fkey FOREIGN KEY (survey) REFERENCES survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_copy_status_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_copy_status_fkey FOREIGN KEY (copy_status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_dest_fkey FOREIGN KEY (dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_prev_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_prev_dest_fkey FOREIGN KEY (prev_dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_prev_hop_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_prev_hop_fkey FOREIGN KEY (prev_hop) REFERENCES transit_copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy_source_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY transit_copy
    ADD CONSTRAINT transit_copy_source_fkey FOREIGN KEY (source) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = action_trigger, pg_catalog;

--
-- Name: environment_collector_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_collector_fkey FOREIGN KEY (collector) REFERENCES collector(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: environment_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY environment
    ADD CONSTRAINT environment_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_async_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_async_output_fkey FOREIGN KEY (async_output) REFERENCES event_output(id);


--
-- Name: event_definition_cleanup_failure_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_cleanup_failure_fkey FOREIGN KEY (cleanup_failure) REFERENCES cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_cleanup_success_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_cleanup_success_fkey FOREIGN KEY (cleanup_success) REFERENCES cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_hook_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_hook_fkey FOREIGN KEY (hook) REFERENCES hook(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_opt_in_setting_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_opt_in_setting_fkey FOREIGN KEY (opt_in_setting) REFERENCES config.usr_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_owner_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_reactor_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_reactor_fkey FOREIGN KEY (reactor) REFERENCES reactor(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition_validator_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_definition
    ADD CONSTRAINT event_definition_validator_fkey FOREIGN KEY (validator) REFERENCES validator(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_error_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_error_output_fkey FOREIGN KEY (error_output) REFERENCES event_output(id);


--
-- Name: event_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_params_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event_params
    ADD CONSTRAINT event_params_event_def_fkey FOREIGN KEY (event_def) REFERENCES event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_template_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_template_output_fkey FOREIGN KEY (template_output) REFERENCES event_output(id);


SET search_path = actor, pg_catalog;

--
-- Name: actor_org_unit_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_holds_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_holds_address_fkey FOREIGN KEY (holds_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_ill_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_ill_address_fkey FOREIGN KEY (ill_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT actor_org_unit_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_org_unit_proximity_adjustment_circ_mod_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT actor_org_unit_proximity_adjustment_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES config.circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_sceum_sc_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_sceum_tu_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_tu_fkey FOREIGN KEY (target_usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_entry_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_entry_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_stat_cat_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT actor_stat_cat_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_home_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_home_ou_fkey FOREIGN KEY (home_ou) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: actor_usr_profile_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT actor_usr_profile_fkey FOREIGN KEY (profile) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: address_alert_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY address_alert
    ADD CONSTRAINT address_alert_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: card_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hours_of_operation_id_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY hours_of_operation
    ADD CONSTRAINT hours_of_operation_id_fkey FOREIGN KEY (id) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_address_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_address
    ADD CONSTRAINT org_address_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map_lasso_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_lasso_fkey FOREIGN KEY (lasso) REFERENCES org_lasso(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_lasso_map
    ADD CONSTRAINT org_lasso_map_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_closed_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_closed
    ADD CONSTRAINT org_unit_closed_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_parent_node_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_parent_node_fkey FOREIGN KEY (parent_node) REFERENCES org_unit_custom_tree_node(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node_tree_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_tree_fkey FOREIGN KEY (tree) REFERENCES org_unit_custom_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_fiscal_calendar_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_fiscal_calendar_fkey FOREIGN KEY (fiscal_calendar) REFERENCES acq.fiscal_calendar(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_ou_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_ou_type_fkey FOREIGN KEY (ou_type) REFERENCES org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_parent_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit
    ADD CONSTRAINT org_unit_parent_ou_fkey FOREIGN KEY (parent_ou) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_proximity_adjustment_copy_location_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id);


--
-- Name: org_unit_proximity_adjustment_hold_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_pickup_lib_fkey FOREIGN KEY (hold_pickup_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_hold_request_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_request_lib_fkey FOREIGN KEY (hold_request_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_item_circ_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_circ_lib_fkey FOREIGN KEY (item_circ_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_proximity_adjustment_item_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_owning_lib_fkey FOREIGN KEY (item_owning_lib) REFERENCES org_unit(id);


--
-- Name: org_unit_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_name_fkey FOREIGN KEY (name) REFERENCES config.org_unit_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting
    ADD CONSTRAINT org_unit_setting_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_type_parent_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY org_unit_type
    ADD CONSTRAINT org_unit_type_parent_fkey FOREIGN KEY (parent) REFERENCES org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry_grp_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_grp_fkey FOREIGN KEY (grp) REFERENCES search_filter_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry_query_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_query_fkey FOREIGN KEY (query) REFERENCES search_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY search_filter_group
    ADD CONSTRAINT search_filter_group_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_owner_fkey FOREIGN KEY (owner) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_stat_cat_entry_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_entry_fkey FOREIGN KEY (stat_cat_entry) REFERENCES stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: toolbar_org_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_org_fkey FOREIGN KEY (org) REFERENCES org_unit(id) ON DELETE CASCADE;


--
-- Name: toolbar_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE;


--
-- Name: toolbar_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY toolbar
    ADD CONSTRAINT toolbar_ws_fkey FOREIGN KEY (ws) REFERENCES workstation(id) ON DELETE CASCADE;


--
-- Name: usr_activity_etype_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_etype_fkey FOREIGN KEY (etype) REFERENCES config.usr_activity_type(id) ON DELETE CASCADE;


--
-- Name: usr_activity_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_activity
    ADD CONSTRAINT usr_activity_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE SET NULL;


--
-- Name: usr_address_replaces_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_replaces_fkey FOREIGN KEY (replaces) REFERENCES usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_ident_type2_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_ident_type2_fkey FOREIGN KEY (ident_type2) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_ident_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_ident_type_fkey FOREIGN KEY (ident_type) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_net_access_level_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_net_access_level_fkey FOREIGN KEY (net_access_level) REFERENCES config.net_access_level(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_note_creator_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_creator_fkey FOREIGN KEY (creator) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_note_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_note
    ADD CONSTRAINT usr_note_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_opt_in_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_opt_in_ws_fkey FOREIGN KEY (opt_in_ws) REFERENCES workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_staff_fkey FOREIGN KEY (staff) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_password_reset_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_password_reset
    ADD CONSTRAINT usr_password_reset_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_saved_search_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_saved_search
    ADD CONSTRAINT usr_saved_search_owner_fkey FOREIGN KEY (owner) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_name_fkey FOREIGN KEY (name) REFERENCES config.usr_setting_type(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_standing_fkey FOREIGN KEY (standing) REFERENCES config.standing(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_staff_fkey FOREIGN KEY (staff) REFERENCES usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_standing_penalty_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_standing_penalty_fkey FOREIGN KEY (standing_penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: workstation_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY workstation
    ADD CONSTRAINT workstation_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES org_unit(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = asset, pg_catalog;

--
-- Name: a_sc_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT a_sc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sc_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sc_sce_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sce_fkey FOREIGN KEY (stat_cat_entry) REFERENCES stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sce_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT a_sce_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: a_sce_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat_entry
    ADD CONSTRAINT a_sce_sc_fkey FOREIGN KEY (stat_cat) REFERENCES stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT asset_call_number_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_note_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_note
    ADD CONSTRAINT asset_call_number_note_record_fkey FOREIGN KEY (call_number) REFERENCES call_number(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_call_number_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT asset_call_number_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_call_number_fkey FOREIGN KEY (call_number) REFERENCES call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT asset_copy_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_note_copy_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT asset_copy_note_copy_fkey FOREIGN KEY (owning_copy) REFERENCES copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: asset_copy_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_note
    ADD CONSTRAINT asset_copy_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_label_class_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_label_class_fkey FOREIGN KEY (label_class) REFERENCES call_number_class(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_prefix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_prefix_fkey FOREIGN KEY (prefix) REFERENCES call_number_prefix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_prefix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_prefix
    ADD CONSTRAINT call_number_prefix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: call_number_suffix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number
    ADD CONSTRAINT call_number_suffix_fkey FOREIGN KEY (suffix) REFERENCES call_number_suffix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_suffix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY call_number_suffix
    ADD CONSTRAINT call_number_suffix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: circ_mod_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT circ_mod_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map_lgroup_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_lgroup_fkey FOREIGN KEY (lgroup) REFERENCES copy_location_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_group
    ADD CONSTRAINT copy_location_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order_org_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location_order
    ADD CONSTRAINT copy_location_order_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_location
    ADD CONSTRAINT copy_location_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_part_map_part_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_part_map
    ADD CONSTRAINT copy_part_map_part_fkey FOREIGN KEY (part) REFERENCES biblio.monograph_part(id) ON DELETE CASCADE;


--
-- Name: copy_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy
    ADD CONSTRAINT copy_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_location_fkey FOREIGN KEY (location) REFERENCES copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY copy_template
    ADD CONSTRAINT copy_template_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: uri_call_number_map_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_call_number_fkey FOREIGN KEY (call_number) REFERENCES call_number(id);


--
-- Name: uri_call_number_map_uri_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_uri_fkey FOREIGN KEY (uri) REFERENCES uri(id);


SET search_path = authority, pg_catalog;

--
-- Name: authority_linking_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority_linking
    ADD CONSTRAINT authority_linking_field_fkey FOREIGN KEY (field) REFERENCES control_set_authority_field(id);


--
-- Name: authority_linking_source_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority_linking
    ADD CONSTRAINT authority_linking_source_fkey FOREIGN KEY (source) REFERENCES record_entry(id);


--
-- Name: authority_linking_target_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority_linking
    ADD CONSTRAINT authority_linking_target_fkey FOREIGN KEY (target) REFERENCES record_entry(id);


--
-- Name: bib_linking_authority_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_authority_fkey FOREIGN KEY (authority) REFERENCES record_entry(id);


--
-- Name: bib_linking_bib_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY bib_linking
    ADD CONSTRAINT bib_linking_bib_fkey FOREIGN KEY (bib) REFERENCES biblio.record_entry(id);


--
-- Name: browse_axis_authority_field_map_axis_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_axis_fkey FOREIGN KEY (axis) REFERENCES browse_axis(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis_authority_field_map_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_field_fkey FOREIGN KEY (field) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis_sorter_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY browse_axis
    ADD CONSTRAINT browse_axis_sorter_fkey FOREIGN KEY (sorter) REFERENCES config.record_attr_definition(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field_main_entry_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_main_entry_fkey FOREIGN KEY (main_entry) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_authority_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_authority_field_fkey FOREIGN KEY (authority_field) REFERENCES control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_metabib_field_map_bib_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_bib_field_fkey FOREIGN KEY (bib_field) REFERENCES control_set_bib_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_metabib_field_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES config.metabib_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT record_note_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: simple_heading_atag_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_atag_fkey FOREIGN KEY (atag) REFERENCES control_set_authority_field(id);


--
-- Name: simple_heading_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY simple_heading
    ADD CONSTRAINT simple_heading_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id);


--
-- Name: thesaurus_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY thesaurus
    ADD CONSTRAINT thesaurus_control_set_fkey FOREIGN KEY (control_set) REFERENCES control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = biblio, pg_catalog;

--
-- Name: biblio_record_entry_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_owner_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT biblio_record_entry_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_note_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY record_note
    ADD CONSTRAINT biblio_record_note_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: monograph_part_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY monograph_part
    ADD CONSTRAINT monograph_part_record_fkey FOREIGN KEY (record) REFERENCES record_entry(id);


--
-- Name: peer_bib_copy_map_peer_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_record_fkey FOREIGN KEY (peer_record) REFERENCES record_entry(id);


--
-- Name: peer_bib_copy_map_peer_type_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_type_fkey FOREIGN KEY (peer_type) REFERENCES peer_type(id);


SET search_path = booking, pg_catalog;

--
-- Name: booking_reservation_usr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT booking_reservation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map_attr_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_attr_value_fkey FOREIGN KEY (attr_value) REFERENCES resource_attr_value(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map_reservation_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_reservation_fkey FOREIGN KEY (reservation) REFERENCES reservation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_capture_staff_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_capture_staff_fkey FOREIGN KEY (capture_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_current_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_current_resource_fkey FOREIGN KEY (current_resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_request_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_target_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_target_resource_fkey FOREIGN KEY (target_resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_target_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY reservation
    ADD CONSTRAINT reservation_target_resource_type_fkey FOREIGN KEY (target_resource_type) REFERENCES resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_resource_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_attr_fkey FOREIGN KEY (resource_attr) REFERENCES resource_attr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_fkey FOREIGN KEY (resource) REFERENCES resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_map
    ADD CONSTRAINT resource_attr_map_value_fkey FOREIGN KEY (value) REFERENCES resource_attr_value(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr
    ADD CONSTRAINT resource_attr_resource_type_fkey FOREIGN KEY (resource_type) REFERENCES resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_attr_fkey FOREIGN KEY (attr) REFERENCES resource_attr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_attr_value
    ADD CONSTRAINT resource_attr_value_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT resource_type_fkey FOREIGN KEY (type) REFERENCES resource_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type_record_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY resource_type
    ADD CONSTRAINT resource_type_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = config, pg_catalog;

--
-- Name: barcode_completion_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY barcode_completion
    ADD CONSTRAINT barcode_completion_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_circ_mod_map_circ_mod_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES circ_modifier(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_circ_mod_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map_copy_loc_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_copy_loc_fkey FOREIGN KEY (copy_loc) REFERENCES asset.copy_location(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_limit_set
    ADD CONSTRAINT circ_limit_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test_map_circ_mod_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES circ_modifier(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test_map_circ_mod_test_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_circ_mod_test_fkey FOREIGN KEY (circ_mod_test) REFERENCES circ_matrix_circ_mod_test(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test_matchpoint_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_circ_mod_test
    ADD CONSTRAINT circ_matrix_circ_mod_test_matchpoint_fkey FOREIGN KEY (matchpoint) REFERENCES circ_matrix_matchpoint(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map_matchpoint_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_matchpoint_fkey FOREIGN KEY (matchpoint) REFERENCES circ_matrix_matchpoint(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_circ_lib_fkey FOREIGN KEY (copy_circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_location_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_copy_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_owning_lib_fkey FOREIGN KEY (copy_owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_duration_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_duration_rule_fkey FOREIGN KEY (duration_rule) REFERENCES rule_circ_duration(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES hard_due_date(id);


--
-- Name: circ_matrix_matchpoint_max_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_max_fine_rule_fkey FOREIGN KEY (max_fine_rule) REFERENCES rule_max_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_recurring_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_recurring_fine_rule_fkey FOREIGN KEY (recurring_fine_rule) REFERENCES rule_recurring_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: coded_value_map_ctype_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY coded_value_map
    ADD CONSTRAINT coded_value_map_ctype_fkey FOREIGN KEY (ctype) REFERENCES record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_billing_type_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY billing_type
    ADD CONSTRAINT config_billing_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: config_remote_account_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY remote_account
    ADD CONSTRAINT config_remote_account_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set_creator_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set_interface_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_interface_fkey FOREIGN KEY (interface) REFERENCES filter_dialog_interface(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hard_due_date_values_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES hard_due_date(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_age_hold_protect_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_age_hold_protect_rule_fkey FOREIGN KEY (age_hold_protect_rule) REFERENCES rule_age_hold_protect(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_item_circ_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_circ_ou_fkey FOREIGN KEY (item_circ_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_item_owning_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_owning_ou_fkey FOREIGN KEY (item_owning_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_pickup_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pickup_ou_fkey FOREIGN KEY (pickup_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_request_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_request_ou_fkey FOREIGN KEY (request_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_requestor_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_requestor_grp_fkey FOREIGN KEY (requestor_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_transit_range_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_transit_range_fkey FOREIGN KEY (transit_range) REFERENCES actor.org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint_usr_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_usr_grp_fkey FOREIGN KEY (usr_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: i18n_core_translation_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY i18n_core
    ADD CONSTRAINT i18n_core_translation_fkey FOREIGN KEY (translation) REFERENCES i18n_locale(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: idl_field_doc_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY idl_field_doc
    ADD CONSTRAINT idl_field_doc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: marc21_physical_characteristic_subfield_map_ptype_key_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_ptype_key_fkey FOREIGN KEY (ptype_key) REFERENCES marc21_physical_characteristic_type_map(ptype_key) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: marc21_physical_characteristic_value_map_ptype_subfield_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_ptype_subfield_fkey FOREIGN KEY (ptype_subfield) REFERENCES marc21_physical_characteristic_subfield_map(id);


--
-- Name: metabib_class_ts_map_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_class_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES ts_config_list(id);


--
-- Name: metabib_field_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_field_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field
    ADD CONSTRAINT metabib_field_format_fkey FOREIGN KEY (format) REFERENCES xml_transform(name);


--
-- Name: metabib_field_index_norm_map_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_field_fkey FOREIGN KEY (field) REFERENCES metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_ts_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES metabib_field(id);


--
-- Name: metabib_field_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES ts_config_list(id);


--
-- Name: metabib_search_alias_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_class_fkey FOREIGN KEY (field_class) REFERENCES metabib_class(name);


--
-- Name: metabib_search_alias_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_fkey FOREIGN KEY (field) REFERENCES metabib_field(id);


--
-- Name: org_unit_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES settings_group(name);


--
-- Name: org_unit_setting_type_log_field_name_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_field_name_fkey FOREIGN KEY (field_name) REFERENCES org_unit_setting_type(name);


--
-- Name: org_unit_setting_type_log_org_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id);


--
-- Name: record_attr_definition_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_format_fkey FOREIGN KEY (format) REFERENCES xml_transform(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_definition_phys_char_sf_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY record_attr_definition
    ADD CONSTRAINT record_attr_definition_phys_char_sf_fkey FOREIGN KEY (phys_char_sf) REFERENCES marc21_physical_characteristic_subfield_map(id);


--
-- Name: record_attr_index_norm_map_attr_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_attr_fkey FOREIGN KEY (attr) REFERENCES record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: update_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT update_perm_fkey FOREIGN KEY (update_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY usr_setting_type
    ADD CONSTRAINT usr_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES settings_group(name);


--
-- Name: view_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY org_unit_setting_type
    ADD CONSTRAINT view_perm_fkey FOREIGN KEY (view_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_circ_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_circ_weights_fkey FOREIGN KEY (circ_weights) REFERENCES circ_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_hold_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_hold_weights_fkey FOREIGN KEY (hold_weights) REFERENCES hold_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY weight_assoc
    ADD CONSTRAINT weight_assoc_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_attr_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_attr
    ADD CONSTRAINT z3950_attr_source_fkey FOREIGN KEY (source) REFERENCES z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_source_credentials_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: z3950_source_credentials_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_source_fkey FOREIGN KEY (source) REFERENCES z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_source_use_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY z3950_source
    ADD CONSTRAINT z3950_source_use_perm_fkey FOREIGN KEY (use_perm) REFERENCES permission.perm_list(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES biblio_record_entry_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES biblio_record_entry_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_target_biblio_record_entry_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_target_biblio_record_entry_fkey FOREIGN KEY (target_biblio_record_entry) REFERENCES biblio.record_entry(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES call_number_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES call_number_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_target_call_number_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_target_call_number_fkey FOREIGN KEY (target_call_number) REFERENCES asset.call_number(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY call_number_bucket
    ADD CONSTRAINT call_number_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES copy_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES copy_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_target_copy_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_target_copy_fkey FOREIGN KEY (target_copy) REFERENCES asset.copy(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY copy_bucket
    ADD CONSTRAINT copy_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES user_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES user_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_target_user_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_item
    ADD CONSTRAINT user_bucket_item_target_user_fkey FOREIGN KEY (target_user) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket_note
    ADD CONSTRAINT user_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY user_bucket
    ADD CONSTRAINT user_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = metabib, pg_catalog;

--
-- Name: bib_export_data_bib_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY bib_export_data
    ADD CONSTRAINT bib_export_data_bib_fkey FOREIGN KEY (bib) REFERENCES biblio.record_entry(id);


--
-- Name: browse_author_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_def_map
    ADD CONSTRAINT browse_author_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_author_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_def_map
    ADD CONSTRAINT browse_author_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_author_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_def_map
    ADD CONSTRAINT browse_author_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_author_entry(id);


--
-- Name: browse_author_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_def_map
    ADD CONSTRAINT browse_author_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_author_entry_simple_heading_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_simple_heading_map
    ADD CONSTRAINT browse_author_entry_simple_heading_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_author_entry(id);


--
-- Name: browse_author_entry_simple_heading_map_simple_heading_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_author_entry_simple_heading_map
    ADD CONSTRAINT browse_author_entry_simple_heading_map_simple_heading_fkey FOREIGN KEY (simple_heading) REFERENCES authority.simple_heading(id) ON DELETE CASCADE;


--
-- Name: browse_call_number_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry_def_map
    ADD CONSTRAINT browse_call_number_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_call_number_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry_def_map
    ADD CONSTRAINT browse_call_number_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_call_number_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry_def_map
    ADD CONSTRAINT browse_call_number_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_call_number_entry(id);


--
-- Name: browse_call_number_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_call_number_entry_def_map
    ADD CONSTRAINT browse_call_number_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_entry(id);


--
-- Name: browse_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_series_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_def_map
    ADD CONSTRAINT browse_series_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_series_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_def_map
    ADD CONSTRAINT browse_series_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_series_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_def_map
    ADD CONSTRAINT browse_series_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_series_entry(id);


--
-- Name: browse_series_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_def_map
    ADD CONSTRAINT browse_series_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_series_entry_simple_heading_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_simple_heading_map
    ADD CONSTRAINT browse_series_entry_simple_heading_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_series_entry(id);


--
-- Name: browse_series_entry_simple_heading_map_simple_heading_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_series_entry_simple_heading_map
    ADD CONSTRAINT browse_series_entry_simple_heading_map_simple_heading_fkey FOREIGN KEY (simple_heading) REFERENCES authority.simple_heading(id) ON DELETE CASCADE;


--
-- Name: browse_subject_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_def_map
    ADD CONSTRAINT browse_subject_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_subject_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_def_map
    ADD CONSTRAINT browse_subject_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_subject_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_def_map
    ADD CONSTRAINT browse_subject_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_subject_entry(id);


--
-- Name: browse_subject_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_def_map
    ADD CONSTRAINT browse_subject_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_subject_entry_simple_heading_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_simple_heading_map
    ADD CONSTRAINT browse_subject_entry_simple_heading_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_subject_entry(id);


--
-- Name: browse_subject_entry_simple_heading_map_simple_heading_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_subject_entry_simple_heading_map
    ADD CONSTRAINT browse_subject_entry_simple_heading_map_simple_heading_fkey FOREIGN KEY (simple_heading) REFERENCES authority.simple_heading(id) ON DELETE CASCADE;


--
-- Name: browse_title_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_def_map
    ADD CONSTRAINT browse_title_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_title_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_def_map
    ADD CONSTRAINT browse_title_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id);


--
-- Name: browse_title_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_def_map
    ADD CONSTRAINT browse_title_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_title_entry(id);


--
-- Name: browse_title_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_def_map
    ADD CONSTRAINT browse_title_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_title_entry_simple_heading_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_simple_heading_map
    ADD CONSTRAINT browse_title_entry_simple_heading_map_entry_fkey FOREIGN KEY (entry) REFERENCES browse_title_entry(id);


--
-- Name: browse_title_entry_simple_heading_map_simple_heading_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY browse_title_entry_simple_heading_map
    ADD CONSTRAINT browse_title_entry_simple_heading_map_simple_heading_fkey FOREIGN KEY (simple_heading) REFERENCES authority.simple_heading(id) ON DELETE CASCADE;


--
-- Name: metabib_identifier_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_identifier_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_master_record_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metarecord
    ADD CONSTRAINT metabib_metarecord_master_record_fkey FOREIGN KEY (master_record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_source_map_metarecord_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_metarecord_fkey FOREIGN KEY (metarecord) REFERENCES metarecord(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_metarecord_source_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: normalized_author_to_ author_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY normalized_author_field_entry
    ADD CONSTRAINT "normalized_author_to_ author_field_entry_FK" FOREIGN KEY (id) REFERENCES author_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_keyword_to_ keyword_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY normalized_keyword_field_entry
    ADD CONSTRAINT "normalized_keyword_to_ keyword_field_entry_FK" FOREIGN KEY (id) REFERENCES keyword_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_series_to_ series_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY normalized_series_field_entry
    ADD CONSTRAINT "normalized_series_to_ series_field_entry_FK" FOREIGN KEY (id) REFERENCES series_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_subject_to_ subject_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY normalized_subject_field_entry
    ADD CONSTRAINT "normalized_subject_to_ subject_field_entry_FK" FOREIGN KEY (id) REFERENCES subject_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_title_to_ title_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY normalized_title_field_entry
    ADD CONSTRAINT "normalized_title_to_ title_field_entry_FK" FOREIGN KEY (id) REFERENCES title_field_entry(id) ON DELETE CASCADE;


--
-- Name: record_attr_id_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY record_attr
    ADD CONSTRAINT record_attr_id_fkey FOREIGN KEY (id) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


--
-- Name: source; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY language_filter
    ADD CONSTRAINT source FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


SET search_path = money, pg_catalog;

--
-- Name: billing_btype_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY billing
    ADD CONSTRAINT billing_btype_fkey FOREIGN KEY (btype) REFERENCES config.billing_type(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bnm_desk_payment_cash_drawer_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_cash_drawer_fkey FOREIGN KEY (cash_drawer) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_collector_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_collector_fkey FOREIGN KEY (collector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_location_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_location_fkey FOREIGN KEY (location) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY collections_tracker
    ADD CONSTRAINT collections_tracker_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: money_billable_xact_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY billable_xact
    ADD CONSTRAINT money_billable_xact_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold_org_unit_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold_penalty_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_penalty_fkey FOREIGN KEY (penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_perm_map
    ADD CONSTRAINT grp_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree_parent_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY grp_tree
    ADD CONSTRAINT grp_tree_parent_fkey FOREIGN KEY (parent) REFERENCES grp_tree(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_grp_fkey FOREIGN KEY (grp) REFERENCES grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_grp_map
    ADD CONSTRAINT usr_grp_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map_work_ou_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_work_ou_fkey FOREIGN KEY (work_ou) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = prod_staff_users, pg_catalog;

--
-- Name: card_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY card
    ADD CONSTRAINT card_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address_replaces_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_replaces_fkey FOREIGN KEY (replaces) REFERENCES usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr_address
    ADD CONSTRAINT usr_address_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_billing_address_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_card_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_card_fkey FOREIGN KEY (card) REFERENCES card(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_mailing_address_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr
    ADD CONSTRAINT usr_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr_perm_map
    ADD CONSTRAINT usr_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr_setting
    ADD CONSTRAINT usr_setting_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_usr_fkey FOREIGN KEY (usr) REFERENCES usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = query, pg_catalog;

--
-- Name: case_branch_condition_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_condition_fkey FOREIGN KEY (condition) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch_result_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY case_branch
    ADD CONSTRAINT case_branch_result_fkey FOREIGN KEY (result) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_bind_variable_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_bind_variable_fkey FOREIGN KEY (bind_variable) REFERENCES bind_variable(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_cast_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_cast_type_fkey FOREIGN KEY (cast_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_function_id_fkey FOREIGN KEY (function_id) REFERENCES function_sig(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_left_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_left_operand_fkey FOREIGN KEY (left_operand) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_right_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_right_operand_fkey FOREIGN KEY (right_operand) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY expression
    ADD CONSTRAINT expression_subquery_fkey FOREIGN KEY (subquery) REFERENCES stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_function_call_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_function_call_fkey FOREIGN KEY (function_call) REFERENCES expression(id);


--
-- Name: from_relation_on_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_on_clause_fkey FOREIGN KEY (on_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_parent_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_parent_relation_fkey FOREIGN KEY (parent_relation) REFERENCES from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY from_relation
    ADD CONSTRAINT from_relation_subquery_fkey FOREIGN KEY (subquery) REFERENCES stored_query(id);


--
-- Name: function_param_def_datatype_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_datatype_fkey FOREIGN KEY (datatype) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_param_def_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY function_param_def
    ADD CONSTRAINT function_param_def_function_id_fkey FOREIGN KEY (function_id) REFERENCES function_sig(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_sig_return_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY function_sig
    ADD CONSTRAINT function_sig_return_type_fkey FOREIGN KEY (return_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_expression_fkey FOREIGN KEY (expression) REFERENCES expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY order_by_item
    ADD CONSTRAINT order_by_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence_child_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_child_query_fkey FOREIGN KEY (child_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence_parent_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query_sequence
    ADD CONSTRAINT query_sequence_parent_query_fkey FOREIGN KEY (parent_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column_column_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_column_type_fkey FOREIGN KEY (column_type) REFERENCES datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column_from_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY record_column
    ADD CONSTRAINT record_column_from_relation_fkey FOREIGN KEY (from_relation) REFERENCES from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_expression_fkey FOREIGN KEY (expression) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY select_item
    ADD CONSTRAINT select_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_from_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_from_clause_fkey FOREIGN KEY (from_clause) REFERENCES from_relation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_having_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_having_clause_fkey FOREIGN KEY (having_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_limit_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_limit_count_fkey FOREIGN KEY (limit_count) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_offset_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_offset_count_fkey FOREIGN KEY (offset_count) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query_where_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY stored_query
    ADD CONSTRAINT stored_query_where_clause_fkey FOREIGN KEY (where_clause) REFERENCES expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield_composite_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_composite_type_fkey FOREIGN KEY (composite_type) REFERENCES datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield_subfield_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY subfield
    ADD CONSTRAINT subfield_subfield_type_fkey FOREIGN KEY (subfield_type) REFERENCES datatype(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = reporter, pg_catalog;

--
-- Name: output_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_parent_fkey FOREIGN KEY (parent) REFERENCES output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY output_folder
    ADD CONSTRAINT output_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_folder_fkey FOREIGN KEY (folder) REFERENCES report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_parent_fkey FOREIGN KEY (parent) REFERENCES report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report_folder
    ADD CONSTRAINT report_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_template_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_template_fkey FOREIGN KEY (template) REFERENCES template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_folder_fkey FOREIGN KEY (folder) REFERENCES output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_report_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_report_fkey FOREIGN KEY (report) REFERENCES report(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule_runner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY schedule
    ADD CONSTRAINT schedule_runner_fkey FOREIGN KEY (runner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_folder_fkey FOREIGN KEY (folder) REFERENCES template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_parent_fkey FOREIGN KEY (parent) REFERENCES template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template_folder
    ADD CONSTRAINT template_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY template
    ADD CONSTRAINT template_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment_field_fkey; Type: FK CONSTRAINT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = serial, pg_catalog;

--
-- Name: bib_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY basic_summary
    ADD CONSTRAINT bib_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: caption_and_pattern_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_bind_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_bind_call_number_fkey FOREIGN KEY (bind_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_bind_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_bind_unit_template_fkey FOREIGN KEY (bind_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_holding_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_holding_lib_fkey FOREIGN KEY (holding_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution_note
    ADD CONSTRAINT distribution_note_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_receive_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_receive_call_number_fkey FOREIGN KEY (receive_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_receive_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_receive_unit_template_fkey FOREIGN KEY (receive_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY distribution
    ADD CONSTRAINT distribution_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: index_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY index_summary
    ADD CONSTRAINT index_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_caption_and_pattern_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_caption_and_pattern_fkey FOREIGN KEY (caption_and_pattern) REFERENCES caption_and_pattern(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY issuance
    ADD CONSTRAINT issuance_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_issuance_fkey FOREIGN KEY (issuance) REFERENCES issuance(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note_item_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item_note
    ADD CONSTRAINT item_note_item_fkey FOREIGN KEY (item) REFERENCES item(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_stream_fkey FOREIGN KEY (stream) REFERENCES stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_unit_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_unit_fkey FOREIGN KEY (unit) REFERENCES unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_uri_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY item
    ADD CONSTRAINT item_uri_fkey FOREIGN KEY (uri) REFERENCES asset.uri(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: materialized_holding_code_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_issuance_fkey FOREIGN KEY (issuance) REFERENCES issuance(id) ON DELETE CASCADE;


--
-- Name: record_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry_record_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY record_entry
    ADD CONSTRAINT record_entry_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user_reader_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_reader_fkey FOREIGN KEY (reader) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY routing_list_user
    ADD CONSTRAINT routing_list_user_stream_fkey FOREIGN KEY (stream) REFERENCES stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_call_number_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_unit_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT serial_unit_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stream_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY stream
    ADD CONSTRAINT stream_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription_note
    ADD CONSTRAINT subscription_note_subscription_fkey FOREIGN KEY (subscription) REFERENCES subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: sup_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY supplement_summary
    ADD CONSTRAINT sup_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = unapi, pg_catalog;

--
-- Name: bre_output_layout_transform_fkey; Type: FK CONSTRAINT; Schema: unapi; Owner: evergreen
--

ALTER TABLE ONLY bre_output_layout
    ADD CONSTRAINT bre_output_layout_transform_fkey FOREIGN KEY (transform) REFERENCES config.xml_transform(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


SET search_path = url_verify, pg_catalog;

--
-- Name: session_container_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_container_fkey FOREIGN KEY (container) REFERENCES container.biblio_record_entry_bucket(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_creator_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_owning_lib_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY session
    ADD CONSTRAINT session_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_item_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_item_fkey FOREIGN KEY (item) REFERENCES container.biblio_record_entry_bucket_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_redirect_from_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_redirect_from_fkey FOREIGN KEY (redirect_from) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_selector_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_selector
    ADD CONSTRAINT url_selector_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_url_selector_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url
    ADD CONSTRAINT url_url_selector_fkey FOREIGN KEY (url_selector) REFERENCES url_selector(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_attempt_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_attempt_fkey FOREIGN KEY (attempt) REFERENCES verification_attempt(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_redirect_to_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_redirect_to_fkey FOREIGN KEY (redirect_to) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification_url_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verification
    ADD CONSTRAINT url_verification_url_fkey FOREIGN KEY (url) REFERENCES url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_session_fkey FOREIGN KEY (session) REFERENCES session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt_usr_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY verification_attempt
    ADD CONSTRAINT verification_attempt_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: authority_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY authority_match
    ADD CONSTRAINT authority_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES queued_authority_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_match
    ADD CONSTRAINT bib_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_queue_item_attr_def_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY bib_queue
    ADD CONSTRAINT bib_queue_item_attr_def_fkey FOREIGN KEY (item_attr_def) REFERENCES import_item_attr_definition(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_bib_trash_fields_grp_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_grp_fkey FOREIGN KEY (grp) REFERENCES import_bib_trash_group(id);


--
-- Name: import_bib_trash_group_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: import_item_attr_definition_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_definition_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_definition_fkey FOREIGN KEY (definition) REFERENCES import_item_attr_definition(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES asset.copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY import_item
    ADD CONSTRAINT import_item_record_fkey FOREIGN KEY (record) REFERENCES queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: match_set_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set
    ADD CONSTRAINT match_set_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: match_set_point_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_point_parent_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_parent_fkey FOREIGN KEY (parent) REFERENCES match_set_point(id);


--
-- Name: match_set_point_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_point
    ADD CONSTRAINT match_set_point_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: match_set_quality_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_quality_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY match_set_quality
    ADD CONSTRAINT match_set_quality_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: merge_profile_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY merge_profile
    ADD CONSTRAINT merge_profile_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_match_set_fkey FOREIGN KEY (match_set) REFERENCES match_set(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queue
    ADD CONSTRAINT queue_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_field_fkey FOREIGN KEY (field) REFERENCES authority_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_record_fkey FOREIGN KEY (record) REFERENCES queued_authority_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_authority_record
    ADD CONSTRAINT queued_authority_record_queue_fkey FOREIGN KEY (queue) REFERENCES authority_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_field_fkey FOREIGN KEY (field) REFERENCES bib_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_record_fkey FOREIGN KEY (record) REFERENCES queued_bib_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_bib_source_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_bib_source_fkey FOREIGN KEY (bib_source) REFERENCES config.bib_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY queued_bib_record
    ADD CONSTRAINT queued_bib_record_queue_fkey FOREIGN KEY (queue) REFERENCES bib_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: acq; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA acq FROM PUBLIC;
REVOKE ALL ON SCHEMA acq FROM evergreen;
GRANT ALL ON SCHEMA acq TO evergreen;
GRANT USAGE ON SCHEMA acq TO bbonner;


--
-- Name: action; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA action FROM PUBLIC;
REVOKE ALL ON SCHEMA action FROM evergreen;
GRANT ALL ON SCHEMA action TO evergreen;
GRANT USAGE ON SCHEMA action TO bbonner;
GRANT USAGE ON SCHEMA action TO biblio;


--
-- Name: action_trigger; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA action_trigger FROM PUBLIC;
REVOKE ALL ON SCHEMA action_trigger FROM evergreen;
GRANT ALL ON SCHEMA action_trigger TO evergreen;
GRANT USAGE ON SCHEMA action_trigger TO bbonner;


--
-- Name: actor; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA actor FROM PUBLIC;
REVOKE ALL ON SCHEMA actor FROM evergreen;
GRANT ALL ON SCHEMA actor TO evergreen;
GRANT USAGE ON SCHEMA actor TO bbonner;
GRANT USAGE ON SCHEMA actor TO biblio;


--
-- Name: asset; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA asset FROM PUBLIC;
REVOKE ALL ON SCHEMA asset FROM evergreen;
GRANT ALL ON SCHEMA asset TO evergreen;
GRANT USAGE ON SCHEMA asset TO bbonner;
GRANT USAGE ON SCHEMA asset TO biblio;


--
-- Name: auditor; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA auditor FROM PUBLIC;
REVOKE ALL ON SCHEMA auditor FROM evergreen;
GRANT ALL ON SCHEMA auditor TO evergreen;
GRANT USAGE ON SCHEMA auditor TO bbonner;


--
-- Name: authority; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA authority FROM PUBLIC;
REVOKE ALL ON SCHEMA authority FROM evergreen;
GRANT ALL ON SCHEMA authority TO evergreen;
GRANT USAGE ON SCHEMA authority TO bbonner;
GRANT USAGE ON SCHEMA authority TO biblio;


--
-- Name: biblio; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA biblio FROM PUBLIC;
REVOKE ALL ON SCHEMA biblio FROM evergreen;
GRANT ALL ON SCHEMA biblio TO evergreen;
GRANT USAGE ON SCHEMA biblio TO bbonner;
GRANT USAGE ON SCHEMA biblio TO biblio;


--
-- Name: booking; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA booking FROM PUBLIC;
REVOKE ALL ON SCHEMA booking FROM evergreen;
GRANT ALL ON SCHEMA booking TO evergreen;
GRANT USAGE ON SCHEMA booking TO bbonner;


--
-- Name: collectionhq; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA collectionhq FROM PUBLIC;
REVOKE ALL ON SCHEMA collectionhq FROM evergreen;
GRANT ALL ON SCHEMA collectionhq TO evergreen;
GRANT ALL ON SCHEMA collectionhq TO bbonner;


--
-- Name: config; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA config FROM PUBLIC;
REVOKE ALL ON SCHEMA config FROM evergreen;
GRANT ALL ON SCHEMA config TO evergreen;
GRANT USAGE ON SCHEMA config TO bbonner;
GRANT USAGE ON SCHEMA config TO biblio;


--
-- Name: container; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA container FROM PUBLIC;
REVOKE ALL ON SCHEMA container FROM evergreen;
GRANT ALL ON SCHEMA container TO evergreen;
GRANT USAGE ON SCHEMA container TO bbonner;


--
-- Name: envisionware; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA envisionware FROM PUBLIC;
REVOKE ALL ON SCHEMA envisionware FROM evergreen;
GRANT ALL ON SCHEMA envisionware TO evergreen;
GRANT USAGE ON SCHEMA envisionware TO bbonner;


--
-- Name: esi; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA esi FROM PUBLIC;
REVOKE ALL ON SCHEMA esi FROM evergreen;
GRANT ALL ON SCHEMA esi TO evergreen;
GRANT USAGE ON SCHEMA esi TO bbonner;


--
-- Name: esi_14812; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA esi_14812 FROM PUBLIC;
REVOKE ALL ON SCHEMA esi_14812 FROM evergreen;
GRANT ALL ON SCHEMA esi_14812 TO evergreen;
GRANT USAGE ON SCHEMA esi_14812 TO bbonner;


--
-- Name: evergreen; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA evergreen FROM PUBLIC;
REVOKE ALL ON SCHEMA evergreen FROM evergreen;
GRANT ALL ON SCHEMA evergreen TO evergreen;
GRANT USAGE ON SCHEMA evergreen TO bbonner;


--
-- Name: extend_reporter; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA extend_reporter FROM PUBLIC;
REVOKE ALL ON SCHEMA extend_reporter FROM evergreen;
GRANT ALL ON SCHEMA extend_reporter TO evergreen;
GRANT USAGE ON SCHEMA extend_reporter TO bbonner;


--
-- Name: m_kcls; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls FROM evergreen;
GRANT ALL ON SCHEMA m_kcls TO evergreen;
GRANT USAGE ON SCHEMA m_kcls TO bbonner;


--
-- Name: m_kcls2; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls2 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls2 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls2 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls2 TO bbonner;


--
-- Name: m_kcls3; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls3 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls3 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls3 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls3 TO bbonner;


--
-- Name: m_kcls_call_fix; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_call_fix FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_call_fix FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_call_fix TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_call_fix TO bbonner;


--
-- Name: m_kcls_circhist; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_circhist FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_circhist FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_circhist TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_circhist TO bbonner;


--
-- Name: m_kcls_gap; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_gap FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_gap FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_gap TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_gap TO bbonner;


--
-- Name: m_kcls_holds; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_holds FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_holds FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_holds TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_holds TO bbonner;


--
-- Name: m_kcls_holdsall; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_holdsall FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_holdsall FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_holdsall TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_holdsall TO bbonner;


--
-- Name: m_kcls_holdsall2; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_holdsall2 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_holdsall2 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_holdsall2 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_holdsall2 TO bbonner;


--
-- Name: m_kcls_holdsall3; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_holdsall3 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_holdsall3 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_holdsall3 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_holdsall3 TO bbonner;


--
-- Name: m_kcls_holdsfix; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_holdsfix FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_holdsfix FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_holdsfix TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_holdsfix TO bbonner;


--
-- Name: m_kcls_items2; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_items2 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_items2 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_items2 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_items2 TO bbonner;


--
-- Name: m_kcls_items3; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_items3 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_items3 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_items3 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_items3 TO bbonner;


--
-- Name: m_kcls_ord; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_ord FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_ord FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_ord TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_ord TO bbonner;


--
-- Name: m_kcls_ord2; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_ord2 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_ord2 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_ord2 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_ord2 TO bbonner;


--
-- Name: m_kcls_ord3; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_ord3 FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_ord3 FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_ord3 TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_ord3 TO bbonner;


--
-- Name: m_kcls_xfr; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_kcls_xfr FROM PUBLIC;
REVOKE ALL ON SCHEMA m_kcls_xfr FROM evergreen;
GRANT ALL ON SCHEMA m_kcls_xfr TO evergreen;
GRANT USAGE ON SCHEMA m_kcls_xfr TO bbonner;


--
-- Name: m_test; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA m_test FROM PUBLIC;
REVOKE ALL ON SCHEMA m_test FROM evergreen;
GRANT ALL ON SCHEMA m_test TO evergreen;
GRANT USAGE ON SCHEMA m_test TO bbonner;


--
-- Name: metabib; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA metabib FROM PUBLIC;
REVOKE ALL ON SCHEMA metabib FROM evergreen;
GRANT ALL ON SCHEMA metabib TO evergreen;
GRANT ALL ON SCHEMA metabib TO bbonner;
GRANT USAGE ON SCHEMA metabib TO biblio;


--
-- Name: migration_tools; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA migration_tools FROM PUBLIC;
REVOKE ALL ON SCHEMA migration_tools FROM evergreen;
GRANT ALL ON SCHEMA migration_tools TO evergreen;
GRANT USAGE ON SCHEMA migration_tools TO bbonner;


--
-- Name: money; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA money FROM PUBLIC;
REVOKE ALL ON SCHEMA money FROM evergreen;
GRANT ALL ON SCHEMA money TO evergreen;
GRANT USAGE ON SCHEMA money TO bbonner;
GRANT USAGE ON SCHEMA money TO biblio;


--
-- Name: offline; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA offline FROM PUBLIC;
REVOKE ALL ON SCHEMA offline FROM evergreen;
GRANT ALL ON SCHEMA offline TO evergreen;
GRANT USAGE ON SCHEMA offline TO bbonner;


--
-- Name: permission; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA permission FROM PUBLIC;
REVOKE ALL ON SCHEMA permission FROM evergreen;
GRANT ALL ON SCHEMA permission TO evergreen;
GRANT USAGE ON SCHEMA permission TO bbonner;


--
-- Name: prod_staff_users; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA prod_staff_users FROM PUBLIC;
REVOKE ALL ON SCHEMA prod_staff_users FROM evergreen;
GRANT ALL ON SCHEMA prod_staff_users TO evergreen;
GRANT USAGE ON SCHEMA prod_staff_users TO bbonner;


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- Name: query; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA query FROM PUBLIC;
REVOKE ALL ON SCHEMA query FROM evergreen;
GRANT ALL ON SCHEMA query TO evergreen;
GRANT USAGE ON SCHEMA query TO bbonner;


--
-- Name: reporter; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA reporter FROM PUBLIC;
REVOKE ALL ON SCHEMA reporter FROM evergreen;
GRANT ALL ON SCHEMA reporter TO evergreen;
GRANT USAGE ON SCHEMA reporter TO bbonner;


--
-- Name: search; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA search FROM PUBLIC;
REVOKE ALL ON SCHEMA search FROM evergreen;
GRANT ALL ON SCHEMA search TO evergreen;
GRANT USAGE ON SCHEMA search TO bbonner;


--
-- Name: serial; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA serial FROM PUBLIC;
REVOKE ALL ON SCHEMA serial FROM evergreen;
GRANT ALL ON SCHEMA serial TO evergreen;
GRANT USAGE ON SCHEMA serial TO bbonner;


--
-- Name: sip_temp; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA sip_temp FROM PUBLIC;
REVOKE ALL ON SCHEMA sip_temp FROM evergreen;
GRANT ALL ON SCHEMA sip_temp TO evergreen;
GRANT USAGE ON SCHEMA sip_temp TO bbonner;


--
-- Name: staging; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA staging FROM PUBLIC;
REVOKE ALL ON SCHEMA staging FROM evergreen;
GRANT ALL ON SCHEMA staging TO evergreen;
GRANT USAGE ON SCHEMA staging TO bbonner;


--
-- Name: stats; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA stats FROM PUBLIC;
REVOKE ALL ON SCHEMA stats FROM evergreen;
GRANT ALL ON SCHEMA stats TO evergreen;
GRANT USAGE ON SCHEMA stats TO bbonner;


--
-- Name: unapi; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA unapi FROM PUBLIC;
REVOKE ALL ON SCHEMA unapi FROM evergreen;
GRANT ALL ON SCHEMA unapi TO evergreen;
GRANT USAGE ON SCHEMA unapi TO bbonner;


--
-- Name: vandelay; Type: ACL; Schema: -; Owner: evergreen
--

REVOKE ALL ON SCHEMA vandelay FROM PUBLIC;
REVOKE ALL ON SCHEMA vandelay FROM evergreen;
GRANT ALL ON SCHEMA vandelay TO evergreen;
GRANT USAGE ON SCHEMA vandelay TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: circ_matrix_matchpoint; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_matrix_matchpoint FROM PUBLIC;
REVOKE ALL ON TABLE circ_matrix_matchpoint FROM evergreen;
GRANT ALL ON TABLE circ_matrix_matchpoint TO evergreen;
GRANT ALL ON TABLE circ_matrix_matchpoint TO bbonner;


SET search_path = money, pg_catalog;

--
-- Name: billable_xact; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE billable_xact FROM PUBLIC;
REVOKE ALL ON TABLE billable_xact FROM evergreen;
GRANT ALL ON TABLE billable_xact TO evergreen;
GRANT ALL ON TABLE billable_xact TO bbonner;


--
-- Name: billable_xact_id_seq; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON SEQUENCE billable_xact_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE billable_xact_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE billable_xact_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE billable_xact_id_seq TO bbonner;


SET search_path = action, pg_catalog;

--
-- Name: circulation; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE circulation FROM PUBLIC;
REVOKE ALL ON TABLE circulation FROM evergreen;
GRANT ALL ON TABLE circulation TO evergreen;
GRANT ALL ON TABLE circulation TO bbonner;
GRANT SELECT ON TABLE circulation TO biblio;


SET search_path = actor, pg_catalog;

--
-- Name: usr; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr FROM PUBLIC;
REVOKE ALL ON TABLE usr FROM evergreen;
GRANT ALL ON TABLE usr TO evergreen;
GRANT SELECT,UPDATE ON TABLE usr TO bbonner;
GRANT SELECT ON TABLE usr TO biblio;


SET search_path = asset, pg_catalog;

--
-- Name: copy; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy FROM PUBLIC;
REVOKE ALL ON TABLE copy FROM evergreen;
GRANT ALL ON TABLE copy TO evergreen;
GRANT ALL ON TABLE copy TO bbonner;
GRANT SELECT ON TABLE copy TO biblio;


SET search_path = action, pg_catalog;

--
-- Name: hold_request; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_request FROM PUBLIC;
REVOKE ALL ON TABLE hold_request FROM evergreen;
GRANT ALL ON TABLE hold_request TO evergreen;
GRANT ALL ON TABLE hold_request TO bbonner;
GRANT SELECT ON TABLE hold_request TO biblio;


SET search_path = actor, pg_catalog;

--
-- Name: address_alert; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE address_alert FROM PUBLIC;
REVOKE ALL ON TABLE address_alert FROM evergreen;
GRANT ALL ON TABLE address_alert TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE address_alert TO bbonner;


--
-- Name: usr_standing_penalty; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_standing_penalty FROM PUBLIC;
REVOKE ALL ON TABLE usr_standing_penalty FROM evergreen;
GRANT ALL ON TABLE usr_standing_penalty TO evergreen;
GRANT SELECT,DELETE ON TABLE usr_standing_penalty TO bbonner;


--
-- Name: usr_activity; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_activity FROM PUBLIC;
REVOKE ALL ON TABLE usr_activity FROM evergreen;
GRANT ALL ON TABLE usr_activity TO evergreen;
GRANT ALL ON TABLE usr_activity TO bbonner;


--
-- Name: org_unit; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit FROM PUBLIC;
REVOKE ALL ON TABLE org_unit FROM evergreen;
GRANT ALL ON TABLE org_unit TO evergreen;
GRANT ALL ON TABLE org_unit TO bbonner;
GRANT SELECT ON TABLE org_unit TO biblio;


--
-- Name: org_unit_setting; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_setting FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_setting FROM evergreen;
GRANT ALL ON TABLE org_unit_setting TO evergreen;
GRANT SELECT ON TABLE org_unit_setting TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: usr_activity_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE usr_activity_type FROM PUBLIC;
REVOKE ALL ON TABLE usr_activity_type FROM evergreen;
GRANT ALL ON TABLE usr_activity_type TO evergreen;
GRANT ALL ON TABLE usr_activity_type TO bbonner;


SET search_path = authority, pg_catalog;

--
-- Name: full_rec; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE full_rec FROM PUBLIC;
REVOKE ALL ON TABLE full_rec FROM evergreen;
GRANT ALL ON TABLE full_rec TO evergreen;
GRANT ALL ON TABLE full_rec TO bbonner;


SET search_path = biblio, pg_catalog;

--
-- Name: check_marcxml_well_formed(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION check_marcxml_well_formed() FROM PUBLIC;
REVOKE ALL ON FUNCTION check_marcxml_well_formed() FROM evergreen;
GRANT ALL ON FUNCTION check_marcxml_well_formed() TO evergreen;
GRANT ALL ON FUNCTION check_marcxml_well_formed() TO PUBLIC;
GRANT ALL ON FUNCTION check_marcxml_well_formed() TO bbonner;


--
-- Name: extract_fingerprint(text); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_fingerprint(marc text) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_fingerprint(marc text) FROM evergreen;
GRANT ALL ON FUNCTION extract_fingerprint(marc text) TO evergreen;
GRANT ALL ON FUNCTION extract_fingerprint(marc text) TO PUBLIC;
GRANT ALL ON FUNCTION extract_fingerprint(marc text) TO bbonner;


--
-- Name: extract_languages(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_languages(bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_languages(bigint) FROM evergreen;
GRANT ALL ON FUNCTION extract_languages(bigint) TO evergreen;
GRANT ALL ON FUNCTION extract_languages(bigint) TO PUBLIC;
GRANT ALL ON FUNCTION extract_languages(bigint) TO bbonner;


--
-- Name: extract_located_uris(bigint, text, integer); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) FROM evergreen;
GRANT ALL ON FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) TO evergreen;
GRANT ALL ON FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION extract_located_uris(bib_id bigint, marcxml text, editor_id integer) TO bbonner;


--
-- Name: extract_metabib_field_entry(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_metabib_field_entry(bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_metabib_field_entry(bigint) FROM evergreen;
GRANT ALL ON FUNCTION extract_metabib_field_entry(bigint) TO evergreen;
GRANT ALL ON FUNCTION extract_metabib_field_entry(bigint) TO PUBLIC;
GRANT ALL ON FUNCTION extract_metabib_field_entry(bigint) TO bbonner;


--
-- Name: extract_metabib_field_entry(bigint, text); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) FROM evergreen;
GRANT ALL ON FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) TO evergreen;
GRANT ALL ON FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) TO PUBLIC;
GRANT ALL ON FUNCTION extract_metabib_field_entry(rid bigint, default_joiner text) TO bbonner;


--
-- Name: extract_quality(text, text, text); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION extract_quality(marc text, best_lang text, best_type text) FROM PUBLIC;
REVOKE ALL ON FUNCTION extract_quality(marc text, best_lang text, best_type text) FROM evergreen;
GRANT ALL ON FUNCTION extract_quality(marc text, best_lang text, best_type text) TO evergreen;
GRANT ALL ON FUNCTION extract_quality(marc text, best_lang text, best_type text) TO PUBLIC;
GRANT ALL ON FUNCTION extract_quality(marc text, best_lang text, best_type text) TO bbonner;


--
-- Name: fingerprint_trigger(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION fingerprint_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION fingerprint_trigger() FROM evergreen;
GRANT ALL ON FUNCTION fingerprint_trigger() TO evergreen;
GRANT ALL ON FUNCTION fingerprint_trigger() TO PUBLIC;
GRANT ALL ON FUNCTION fingerprint_trigger() TO bbonner;


SET search_path = metabib, pg_catalog;

--
-- Name: full_rec_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE full_rec_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE full_rec_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE full_rec_id_seq TO evergreen;
GRANT ALL ON SEQUENCE full_rec_id_seq TO bbonner;


--
-- Name: real_full_rec; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE real_full_rec FROM PUBLIC;
REVOKE ALL ON TABLE real_full_rec FROM evergreen;
GRANT ALL ON TABLE real_full_rec TO evergreen;
GRANT ALL ON TABLE real_full_rec TO bbonner;
GRANT SELECT ON TABLE real_full_rec TO biblio;


--
-- Name: full_rec; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE full_rec FROM PUBLIC;
REVOKE ALL ON TABLE full_rec FROM evergreen;
GRANT ALL ON TABLE full_rec TO evergreen;
GRANT ALL ON TABLE full_rec TO bbonner;


SET search_path = biblio, pg_catalog;

--
-- Name: flatten_marc(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION flatten_marc(rid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION flatten_marc(rid bigint) FROM evergreen;
GRANT ALL ON FUNCTION flatten_marc(rid bigint) TO evergreen;
GRANT ALL ON FUNCTION flatten_marc(rid bigint) TO PUBLIC;
GRANT ALL ON FUNCTION flatten_marc(rid bigint) TO bbonner;


--
-- Name: indexing_ingest_or_delete(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION indexing_ingest_or_delete() FROM PUBLIC;
REVOKE ALL ON FUNCTION indexing_ingest_or_delete() FROM evergreen;
GRANT ALL ON FUNCTION indexing_ingest_or_delete() TO evergreen;
GRANT ALL ON FUNCTION indexing_ingest_or_delete() TO PUBLIC;
GRANT ALL ON FUNCTION indexing_ingest_or_delete() TO bbonner;


--
-- Name: map_authority_linking(bigint, text); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION map_authority_linking(bibid bigint, marc text) FROM PUBLIC;
REVOKE ALL ON FUNCTION map_authority_linking(bibid bigint, marc text) FROM evergreen;
GRANT ALL ON FUNCTION map_authority_linking(bibid bigint, marc text) TO evergreen;
GRANT ALL ON FUNCTION map_authority_linking(bibid bigint, marc text) TO PUBLIC;
GRANT ALL ON FUNCTION map_authority_linking(bibid bigint, marc text) TO bbonner;


--
-- Name: marc21_extract_all_fixed_fields(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION marc21_extract_all_fixed_fields(rid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION marc21_extract_all_fixed_fields(rid bigint) FROM evergreen;
GRANT ALL ON FUNCTION marc21_extract_all_fixed_fields(rid bigint) TO evergreen;
GRANT ALL ON FUNCTION marc21_extract_all_fixed_fields(rid bigint) TO PUBLIC;
GRANT ALL ON FUNCTION marc21_extract_all_fixed_fields(rid bigint) TO bbonner;


--
-- Name: marc21_extract_fixed_field(bigint, text); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION marc21_extract_fixed_field(rid bigint, ff text) FROM PUBLIC;
REVOKE ALL ON FUNCTION marc21_extract_fixed_field(rid bigint, ff text) FROM evergreen;
GRANT ALL ON FUNCTION marc21_extract_fixed_field(rid bigint, ff text) TO evergreen;
GRANT ALL ON FUNCTION marc21_extract_fixed_field(rid bigint, ff text) TO PUBLIC;
GRANT ALL ON FUNCTION marc21_extract_fixed_field(rid bigint, ff text) TO bbonner;


--
-- Name: marc21_physical_characteristics(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION marc21_physical_characteristics(rid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION marc21_physical_characteristics(rid bigint) FROM evergreen;
GRANT ALL ON FUNCTION marc21_physical_characteristics(rid bigint) TO evergreen;
GRANT ALL ON FUNCTION marc21_physical_characteristics(rid bigint) TO PUBLIC;
GRANT ALL ON FUNCTION marc21_physical_characteristics(rid bigint) TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: marc21_rec_type_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE marc21_rec_type_map FROM PUBLIC;
REVOKE ALL ON TABLE marc21_rec_type_map FROM evergreen;
GRANT ALL ON TABLE marc21_rec_type_map TO evergreen;
GRANT ALL ON TABLE marc21_rec_type_map TO bbonner;


SET search_path = biblio, pg_catalog;

--
-- Name: marc21_record_type(bigint); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION marc21_record_type(rid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION marc21_record_type(rid bigint) FROM evergreen;
GRANT ALL ON FUNCTION marc21_record_type(rid bigint) TO evergreen;
GRANT ALL ON FUNCTION marc21_record_type(rid bigint) TO PUBLIC;
GRANT ALL ON FUNCTION marc21_record_type(rid bigint) TO bbonner;


--
-- Name: next_autogen_tcn_value(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION next_autogen_tcn_value() FROM PUBLIC;
REVOKE ALL ON FUNCTION next_autogen_tcn_value() FROM evergreen;
GRANT ALL ON FUNCTION next_autogen_tcn_value() TO evergreen;
GRANT ALL ON FUNCTION next_autogen_tcn_value() TO PUBLIC;
GRANT ALL ON FUNCTION next_autogen_tcn_value() TO bbonner;


--
-- Name: normalize_biblio_monograph_part_sortkey(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION normalize_biblio_monograph_part_sortkey() FROM PUBLIC;
REVOKE ALL ON FUNCTION normalize_biblio_monograph_part_sortkey() FROM evergreen;
GRANT ALL ON FUNCTION normalize_biblio_monograph_part_sortkey() TO evergreen;
GRANT ALL ON FUNCTION normalize_biblio_monograph_part_sortkey() TO PUBLIC;
GRANT ALL ON FUNCTION normalize_biblio_monograph_part_sortkey() TO bbonner;


--
-- Name: update_language_filter(); Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON FUNCTION update_language_filter() FROM PUBLIC;
REVOKE ALL ON FUNCTION update_language_filter() FROM evergreen;
GRANT ALL ON FUNCTION update_language_filter() TO evergreen;
GRANT ALL ON FUNCTION update_language_filter() TO PUBLIC;
GRANT ALL ON FUNCTION update_language_filter() TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: create_or_update_code_unknown(); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION create_or_update_code_unknown() FROM PUBLIC;
REVOKE ALL ON FUNCTION create_or_update_code_unknown() FROM evergreen;
GRANT ALL ON FUNCTION create_or_update_code_unknown() TO evergreen;
GRANT ALL ON FUNCTION create_or_update_code_unknown() TO PUBLIC;
GRANT ALL ON FUNCTION create_or_update_code_unknown() TO bbonner;


--
-- Name: interval_to_seconds(interval); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION interval_to_seconds(interval_val interval) FROM PUBLIC;
REVOKE ALL ON FUNCTION interval_to_seconds(interval_val interval) FROM evergreen;
GRANT ALL ON FUNCTION interval_to_seconds(interval_val interval) TO evergreen;
GRANT ALL ON FUNCTION interval_to_seconds(interval_val interval) TO PUBLIC;
GRANT ALL ON FUNCTION interval_to_seconds(interval_val interval) TO bbonner;


--
-- Name: interval_to_seconds(text); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION interval_to_seconds(interval_string text) FROM PUBLIC;
REVOKE ALL ON FUNCTION interval_to_seconds(interval_string text) FROM evergreen;
GRANT ALL ON FUNCTION interval_to_seconds(interval_string text) TO evergreen;
GRANT ALL ON FUNCTION interval_to_seconds(interval_string text) TO PUBLIC;
GRANT ALL ON FUNCTION interval_to_seconds(interval_string text) TO bbonner;


--
-- Name: update_coded_value_map(text, text, text, text, boolean, text, boolean, boolean); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) FROM evergreen;
GRANT ALL ON FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) TO evergreen;
GRANT ALL ON FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) TO PUBLIC;
GRANT ALL ON FUNCTION update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) TO bbonner;


--
-- Name: update_hard_due_dates(); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION update_hard_due_dates() FROM PUBLIC;
REVOKE ALL ON FUNCTION update_hard_due_dates() FROM evergreen;
GRANT ALL ON FUNCTION update_hard_due_dates() TO evergreen;
GRANT ALL ON FUNCTION update_hard_due_dates() TO PUBLIC;
GRANT ALL ON FUNCTION update_hard_due_dates() TO bbonner;


--
-- Name: z3950_source_credentials_apply(text, integer, text, text); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) FROM PUBLIC;
REVOKE ALL ON FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) FROM evergreen;
GRANT ALL ON FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) TO evergreen;
GRANT ALL ON FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) TO PUBLIC;
GRANT ALL ON FUNCTION z3950_source_credentials_apply(src text, org integer, uname text, passwd text) TO bbonner;


--
-- Name: z3950_source_credentials; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE z3950_source_credentials FROM PUBLIC;
REVOKE ALL ON TABLE z3950_source_credentials FROM evergreen;
GRANT ALL ON TABLE z3950_source_credentials TO evergreen;
GRANT ALL ON TABLE z3950_source_credentials TO bbonner;


--
-- Name: z3950_source_credentials_lookup(text, integer); Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON FUNCTION z3950_source_credentials_lookup(source text, owner integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION z3950_source_credentials_lookup(source text, owner integer) FROM evergreen;
GRANT ALL ON FUNCTION z3950_source_credentials_lookup(source text, owner integer) TO evergreen;
GRANT ALL ON FUNCTION z3950_source_credentials_lookup(source text, owner integer) TO PUBLIC;
GRANT ALL ON FUNCTION z3950_source_credentials_lookup(source text, owner integer) TO bbonner;


SET search_path = metabib, pg_catalog;

--
-- Name: autosuggest_prepare_tsquery(text); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION autosuggest_prepare_tsquery(orig text) FROM PUBLIC;
REVOKE ALL ON FUNCTION autosuggest_prepare_tsquery(orig text) FROM evergreen;
GRANT ALL ON FUNCTION autosuggest_prepare_tsquery(orig text) TO evergreen;
GRANT ALL ON FUNCTION autosuggest_prepare_tsquery(orig text) TO PUBLIC;
GRANT ALL ON FUNCTION autosuggest_prepare_tsquery(orig text) TO bbonner;


--
-- Name: browse_normalize(text, integer); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION browse_normalize(facet_text text, mapped_field integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION browse_normalize(facet_text text, mapped_field integer) FROM evergreen;
GRANT ALL ON FUNCTION browse_normalize(facet_text text, mapped_field integer) TO evergreen;
GRANT ALL ON FUNCTION browse_normalize(facet_text text, mapped_field integer) TO PUBLIC;
GRANT ALL ON FUNCTION browse_normalize(facet_text text, mapped_field integer) TO bbonner;


--
-- Name: facet_normalize_trigger(); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION facet_normalize_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION facet_normalize_trigger() FROM evergreen;
GRANT ALL ON FUNCTION facet_normalize_trigger() TO evergreen;
GRANT ALL ON FUNCTION facet_normalize_trigger() TO PUBLIC;
GRANT ALL ON FUNCTION facet_normalize_trigger() TO bbonner;


--
-- Name: normalized_field_entry_view(); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION normalized_field_entry_view() FROM PUBLIC;
REVOKE ALL ON FUNCTION normalized_field_entry_view() FROM evergreen;
GRANT ALL ON FUNCTION normalized_field_entry_view() TO evergreen;
GRANT ALL ON FUNCTION normalized_field_entry_view() TO PUBLIC;
GRANT ALL ON FUNCTION normalized_field_entry_view() TO bbonner;


--
-- Name: reingest_metabib_field_entries(bigint, boolean, boolean, boolean); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) FROM evergreen;
GRANT ALL ON FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) TO evergreen;
GRANT ALL ON FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) TO PUBLIC;
GRANT ALL ON FUNCTION reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) TO bbonner;


--
-- Name: reingest_metabib_full_rec(bigint); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION reingest_metabib_full_rec(bib_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION reingest_metabib_full_rec(bib_id bigint) FROM evergreen;
GRANT ALL ON FUNCTION reingest_metabib_full_rec(bib_id bigint) TO evergreen;
GRANT ALL ON FUNCTION reingest_metabib_full_rec(bib_id bigint) TO PUBLIC;
GRANT ALL ON FUNCTION reingest_metabib_full_rec(bib_id bigint) TO bbonner;


--
-- Name: remap_metarecord_for_bib(bigint, text); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) FROM PUBLIC;
REVOKE ALL ON FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) FROM evergreen;
GRANT ALL ON FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) TO evergreen;
GRANT ALL ON FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) TO PUBLIC;
GRANT ALL ON FUNCTION remap_metarecord_for_bib(bib_id bigint, fp text) TO bbonner;


--
-- Name: search_class_to_registered_components(text); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION search_class_to_registered_components(search_class text) FROM PUBLIC;
REVOKE ALL ON FUNCTION search_class_to_registered_components(search_class text) FROM evergreen;
GRANT ALL ON FUNCTION search_class_to_registered_components(search_class text) TO evergreen;
GRANT ALL ON FUNCTION search_class_to_registered_components(search_class text) TO PUBLIC;
GRANT ALL ON FUNCTION search_class_to_registered_components(search_class text) TO bbonner;


--
-- Name: suggest_browse_entries(text, text, text, integer, integer, integer); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) FROM evergreen;
GRANT ALL ON FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) TO evergreen;
GRANT ALL ON FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) TO PUBLIC;
GRANT ALL ON FUNCTION suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) TO bbonner;


--
-- Name: update_combined_index_vectors(bigint); Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON FUNCTION update_combined_index_vectors(bib_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION update_combined_index_vectors(bib_id bigint) FROM evergreen;
GRANT ALL ON FUNCTION update_combined_index_vectors(bib_id bigint) TO evergreen;
GRANT ALL ON FUNCTION update_combined_index_vectors(bib_id bigint) TO PUBLIC;
GRANT ALL ON FUNCTION update_combined_index_vectors(bib_id bigint) TO bbonner;


SET search_path = permission, pg_catalog;

--
-- Name: grp_tree; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE grp_tree FROM PUBLIC;
REVOKE ALL ON TABLE grp_tree FROM evergreen;
GRANT ALL ON TABLE grp_tree TO evergreen;
GRANT ALL ON TABLE grp_tree TO bbonner;


--
-- Name: usr_perm_map; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE usr_perm_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_perm_map FROM evergreen;
GRANT ALL ON TABLE usr_perm_map TO evergreen;
GRANT SELECT ON TABLE usr_perm_map TO bbonner;


SET search_path = reporter, pg_catalog;

--
-- Name: disable_materialized_simple_record_trigger(); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION disable_materialized_simple_record_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION disable_materialized_simple_record_trigger() FROM evergreen;
GRANT ALL ON FUNCTION disable_materialized_simple_record_trigger() TO evergreen;
GRANT ALL ON FUNCTION disable_materialized_simple_record_trigger() TO PUBLIC;
GRANT ALL ON FUNCTION disable_materialized_simple_record_trigger() TO bbonner;


--
-- Name: enable_materialized_simple_record_trigger(); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION enable_materialized_simple_record_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION enable_materialized_simple_record_trigger() FROM evergreen;
GRANT ALL ON FUNCTION enable_materialized_simple_record_trigger() TO evergreen;
GRANT ALL ON FUNCTION enable_materialized_simple_record_trigger() TO PUBLIC;
GRANT ALL ON FUNCTION enable_materialized_simple_record_trigger() TO bbonner;


--
-- Name: refresh_materialized_simple_record(); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION refresh_materialized_simple_record() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_materialized_simple_record() FROM evergreen;
GRANT ALL ON FUNCTION refresh_materialized_simple_record() TO evergreen;
GRANT ALL ON FUNCTION refresh_materialized_simple_record() TO PUBLIC;
GRANT ALL ON FUNCTION refresh_materialized_simple_record() TO bbonner;


--
-- Name: simple_rec_delete(bigint); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION simple_rec_delete(r_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION simple_rec_delete(r_id bigint) FROM evergreen;
GRANT ALL ON FUNCTION simple_rec_delete(r_id bigint) TO evergreen;
GRANT ALL ON FUNCTION simple_rec_delete(r_id bigint) TO PUBLIC;
GRANT ALL ON FUNCTION simple_rec_delete(r_id bigint) TO bbonner;


--
-- Name: simple_rec_trigger(); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION simple_rec_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION simple_rec_trigger() FROM evergreen;
GRANT ALL ON FUNCTION simple_rec_trigger() TO evergreen;
GRANT ALL ON FUNCTION simple_rec_trigger() TO PUBLIC;
GRANT ALL ON FUNCTION simple_rec_trigger() TO bbonner;


--
-- Name: simple_rec_update(bigint); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION simple_rec_update(r_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION simple_rec_update(r_id bigint) FROM evergreen;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint) TO evergreen;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint) TO PUBLIC;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint) TO bbonner;


--
-- Name: simple_rec_update(bigint, boolean); Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON FUNCTION simple_rec_update(r_id bigint, deleted boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION simple_rec_update(r_id bigint, deleted boolean) FROM evergreen;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint, deleted boolean) TO evergreen;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint, deleted boolean) TO PUBLIC;
GRANT ALL ON FUNCTION simple_rec_update(r_id bigint, deleted boolean) TO bbonner;


SET search_path = vandelay, pg_catalog;

--
-- Name: import_item; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE import_item FROM PUBLIC;
REVOKE ALL ON TABLE import_item FROM evergreen;
GRANT ALL ON TABLE import_item TO evergreen;
GRANT SELECT ON TABLE import_item TO bbonner;


SET search_path = acq, pg_catalog;

--
-- Name: acq_lineitem_history; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE acq_lineitem_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_lineitem_history FROM evergreen;
GRANT ALL ON TABLE acq_lineitem_history TO evergreen;
GRANT ALL ON TABLE acq_lineitem_history TO bbonner;


--
-- Name: lineitem; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem FROM PUBLIC;
REVOKE ALL ON TABLE lineitem FROM evergreen;
GRANT ALL ON TABLE lineitem TO evergreen;
GRANT ALL ON TABLE lineitem TO bbonner;


--
-- Name: acq_lineitem_lifecycle; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE acq_lineitem_lifecycle FROM PUBLIC;
REVOKE ALL ON TABLE acq_lineitem_lifecycle FROM evergreen;
GRANT ALL ON TABLE acq_lineitem_lifecycle TO evergreen;
GRANT SELECT ON TABLE acq_lineitem_lifecycle TO bbonner;


--
-- Name: acq_lineitem_pkey_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_lineitem_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_lineitem_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_lineitem_pkey_seq TO evergreen;
GRANT USAGE ON SEQUENCE acq_lineitem_pkey_seq TO bbonner;


--
-- Name: acq_purchase_order_history; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE acq_purchase_order_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_purchase_order_history FROM evergreen;
GRANT ALL ON TABLE acq_purchase_order_history TO evergreen;
GRANT ALL ON TABLE acq_purchase_order_history TO bbonner;


--
-- Name: purchase_order; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE purchase_order FROM PUBLIC;
REVOKE ALL ON TABLE purchase_order FROM evergreen;
GRANT ALL ON TABLE purchase_order TO evergreen;
GRANT ALL ON TABLE purchase_order TO bbonner;


--
-- Name: acq_purchase_order_lifecycle; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE acq_purchase_order_lifecycle FROM PUBLIC;
REVOKE ALL ON TABLE acq_purchase_order_lifecycle FROM evergreen;
GRANT ALL ON TABLE acq_purchase_order_lifecycle TO evergreen;
GRANT SELECT ON TABLE acq_purchase_order_lifecycle TO bbonner;


--
-- Name: acq_purchase_order_pkey_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_purchase_order_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_purchase_order_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_purchase_order_pkey_seq TO evergreen;
GRANT USAGE ON SEQUENCE acq_purchase_order_pkey_seq TO bbonner;


--
-- Name: fund; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund FROM PUBLIC;
REVOKE ALL ON TABLE fund FROM evergreen;
GRANT ALL ON TABLE fund TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE fund TO bbonner;


--
-- Name: fund_allocation; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_allocation FROM PUBLIC;
REVOKE ALL ON TABLE fund_allocation FROM evergreen;
GRANT ALL ON TABLE fund_allocation TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE fund_allocation TO bbonner;


--
-- Name: funding_source; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE funding_source FROM PUBLIC;
REVOKE ALL ON TABLE funding_source FROM evergreen;
GRANT ALL ON TABLE funding_source TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE funding_source TO bbonner;


--
-- Name: all_fund_allocation_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE all_fund_allocation_total FROM PUBLIC;
REVOKE ALL ON TABLE all_fund_allocation_total FROM evergreen;
GRANT ALL ON TABLE all_fund_allocation_total TO evergreen;
GRANT SELECT ON TABLE all_fund_allocation_total TO bbonner;


--
-- Name: fund_debit; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_debit FROM PUBLIC;
REVOKE ALL ON TABLE fund_debit FROM evergreen;
GRANT ALL ON TABLE fund_debit TO evergreen;
GRANT ALL ON TABLE fund_debit TO bbonner;


--
-- Name: all_fund_combined_balance; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE all_fund_combined_balance FROM PUBLIC;
REVOKE ALL ON TABLE all_fund_combined_balance FROM evergreen;
GRANT ALL ON TABLE all_fund_combined_balance TO evergreen;
GRANT SELECT ON TABLE all_fund_combined_balance TO bbonner;


--
-- Name: all_fund_encumbrance_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE all_fund_encumbrance_total FROM PUBLIC;
REVOKE ALL ON TABLE all_fund_encumbrance_total FROM evergreen;
GRANT ALL ON TABLE all_fund_encumbrance_total TO evergreen;
GRANT SELECT ON TABLE all_fund_encumbrance_total TO bbonner;


--
-- Name: all_fund_spent_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE all_fund_spent_total FROM PUBLIC;
REVOKE ALL ON TABLE all_fund_spent_total FROM evergreen;
GRANT ALL ON TABLE all_fund_spent_total TO evergreen;
GRANT SELECT ON TABLE all_fund_spent_total TO bbonner;


--
-- Name: all_fund_spent_balance; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE all_fund_spent_balance FROM PUBLIC;
REVOKE ALL ON TABLE all_fund_spent_balance FROM evergreen;
GRANT ALL ON TABLE all_fund_spent_balance TO evergreen;
GRANT SELECT ON TABLE all_fund_spent_balance TO bbonner;


--
-- Name: cancel_reason; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE cancel_reason FROM PUBLIC;
REVOKE ALL ON TABLE cancel_reason FROM evergreen;
GRANT ALL ON TABLE cancel_reason TO evergreen;
GRANT ALL ON TABLE cancel_reason TO bbonner;


--
-- Name: cancel_reason_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE cancel_reason_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE cancel_reason_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE cancel_reason_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE cancel_reason_id_seq TO bbonner;


--
-- Name: claim; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim FROM PUBLIC;
REVOKE ALL ON TABLE claim FROM evergreen;
GRANT ALL ON TABLE claim TO evergreen;
GRANT SELECT ON TABLE claim TO bbonner;


--
-- Name: claim_event; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim_event FROM PUBLIC;
REVOKE ALL ON TABLE claim_event FROM evergreen;
GRANT ALL ON TABLE claim_event TO evergreen;
GRANT SELECT ON TABLE claim_event TO bbonner;


--
-- Name: claim_event_claim_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_event_claim_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_event_claim_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_event_claim_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_event_claim_seq TO bbonner;


--
-- Name: claim_event_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_event_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_event_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_event_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_event_id_seq TO bbonner;


--
-- Name: claim_event_type; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim_event_type FROM PUBLIC;
REVOKE ALL ON TABLE claim_event_type FROM evergreen;
GRANT ALL ON TABLE claim_event_type TO evergreen;
GRANT SELECT ON TABLE claim_event_type TO bbonner;


--
-- Name: claim_event_type_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_event_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_event_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_event_type_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_event_type_id_seq TO bbonner;


--
-- Name: claim_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_id_seq TO bbonner;


--
-- Name: claim_policy; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim_policy FROM PUBLIC;
REVOKE ALL ON TABLE claim_policy FROM evergreen;
GRANT ALL ON TABLE claim_policy TO evergreen;
GRANT SELECT ON TABLE claim_policy TO bbonner;


--
-- Name: claim_policy_action; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim_policy_action FROM PUBLIC;
REVOKE ALL ON TABLE claim_policy_action FROM evergreen;
GRANT ALL ON TABLE claim_policy_action TO evergreen;
GRANT SELECT ON TABLE claim_policy_action TO bbonner;


--
-- Name: claim_policy_action_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_policy_action_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_policy_action_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_policy_action_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_policy_action_id_seq TO bbonner;


--
-- Name: claim_policy_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_policy_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_policy_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_policy_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_policy_id_seq TO bbonner;


--
-- Name: claim_type; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE claim_type FROM PUBLIC;
REVOKE ALL ON TABLE claim_type FROM evergreen;
GRANT ALL ON TABLE claim_type TO evergreen;
GRANT SELECT ON TABLE claim_type TO bbonner;


--
-- Name: claim_type_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE claim_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE claim_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE claim_type_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE claim_type_id_seq TO bbonner;


--
-- Name: currency_type; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE currency_type FROM PUBLIC;
REVOKE ALL ON TABLE currency_type FROM evergreen;
GRANT ALL ON TABLE currency_type TO evergreen;
GRANT SELECT ON TABLE currency_type TO bbonner;


--
-- Name: debit_attribution; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE debit_attribution FROM PUBLIC;
REVOKE ALL ON TABLE debit_attribution FROM evergreen;
GRANT ALL ON TABLE debit_attribution TO evergreen;
GRANT SELECT ON TABLE debit_attribution TO bbonner;


--
-- Name: distribution_formula; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE distribution_formula FROM PUBLIC;
REVOKE ALL ON TABLE distribution_formula FROM evergreen;
GRANT ALL ON TABLE distribution_formula TO evergreen;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE distribution_formula TO bbonner;


--
-- Name: distribution_formula_application; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE distribution_formula_application FROM PUBLIC;
REVOKE ALL ON TABLE distribution_formula_application FROM evergreen;
GRANT ALL ON TABLE distribution_formula_application TO evergreen;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE distribution_formula_application TO bbonner;


--
-- Name: distribution_formula_application_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE distribution_formula_application_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE distribution_formula_application_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE distribution_formula_application_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE distribution_formula_application_id_seq TO bbonner;


--
-- Name: distribution_formula_entry; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE distribution_formula_entry FROM PUBLIC;
REVOKE ALL ON TABLE distribution_formula_entry FROM evergreen;
GRANT ALL ON TABLE distribution_formula_entry TO evergreen;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE distribution_formula_entry TO bbonner;


--
-- Name: distribution_formula_entry_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE distribution_formula_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE distribution_formula_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE distribution_formula_entry_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE distribution_formula_entry_id_seq TO bbonner;


--
-- Name: distribution_formula_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE distribution_formula_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE distribution_formula_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE distribution_formula_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE distribution_formula_id_seq TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: remote_account; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE remote_account FROM PUBLIC;
REVOKE ALL ON TABLE remote_account FROM evergreen;
GRANT ALL ON TABLE remote_account TO evergreen;
GRANT ALL ON TABLE remote_account TO bbonner;


--
-- Name: remote_account_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE remote_account_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE remote_account_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE remote_account_id_seq TO evergreen;
GRANT ALL ON SEQUENCE remote_account_id_seq TO bbonner;


SET search_path = acq, pg_catalog;

--
-- Name: edi_account; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE edi_account FROM PUBLIC;
REVOKE ALL ON TABLE edi_account FROM evergreen;
GRANT ALL ON TABLE edi_account TO evergreen;
GRANT SELECT ON TABLE edi_account TO bbonner;


--
-- Name: edi_message; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE edi_message FROM PUBLIC;
REVOKE ALL ON TABLE edi_message FROM evergreen;
GRANT ALL ON TABLE edi_message TO evergreen;
GRANT ALL ON TABLE edi_message TO bbonner;


--
-- Name: edi_message_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE edi_message_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE edi_message_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE edi_message_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE edi_message_id_seq TO bbonner;


--
-- Name: exchange_rate; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE exchange_rate FROM PUBLIC;
REVOKE ALL ON TABLE exchange_rate FROM evergreen;
GRANT ALL ON TABLE exchange_rate TO evergreen;
GRANT SELECT ON TABLE exchange_rate TO bbonner;


--
-- Name: exchange_rate_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE exchange_rate_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE exchange_rate_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE exchange_rate_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE exchange_rate_id_seq TO bbonner;


--
-- Name: fiscal_calendar; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fiscal_calendar FROM PUBLIC;
REVOKE ALL ON TABLE fiscal_calendar FROM evergreen;
GRANT ALL ON TABLE fiscal_calendar TO evergreen;
GRANT SELECT ON TABLE fiscal_calendar TO bbonner;


--
-- Name: fiscal_calendar_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fiscal_calendar_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fiscal_calendar_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fiscal_calendar_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fiscal_calendar_id_seq TO bbonner;


--
-- Name: fiscal_year; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fiscal_year FROM PUBLIC;
REVOKE ALL ON TABLE fiscal_year FROM evergreen;
GRANT ALL ON TABLE fiscal_year TO evergreen;
GRANT SELECT ON TABLE fiscal_year TO bbonner;


--
-- Name: fiscal_year_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fiscal_year_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fiscal_year_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fiscal_year_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fiscal_year_id_seq TO bbonner;


--
-- Name: fund_allocation_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_allocation_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_allocation_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_allocation_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_allocation_id_seq TO bbonner;


--
-- Name: fund_allocation_percent; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_allocation_percent FROM PUBLIC;
REVOKE ALL ON TABLE fund_allocation_percent FROM evergreen;
GRANT ALL ON TABLE fund_allocation_percent TO evergreen;
GRANT SELECT ON TABLE fund_allocation_percent TO bbonner;


--
-- Name: fund_allocation_percent_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_allocation_percent_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_allocation_percent_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_allocation_percent_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_allocation_percent_id_seq TO bbonner;


--
-- Name: fund_allocation_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_allocation_total FROM PUBLIC;
REVOKE ALL ON TABLE fund_allocation_total FROM evergreen;
GRANT ALL ON TABLE fund_allocation_total TO evergreen;
GRANT SELECT ON TABLE fund_allocation_total TO bbonner;


--
-- Name: fund_debit_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_debit_total FROM PUBLIC;
REVOKE ALL ON TABLE fund_debit_total FROM evergreen;
GRANT ALL ON TABLE fund_debit_total TO evergreen;
GRANT SELECT ON TABLE fund_debit_total TO bbonner;


--
-- Name: fund_combined_balance; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_combined_balance FROM PUBLIC;
REVOKE ALL ON TABLE fund_combined_balance FROM evergreen;
GRANT ALL ON TABLE fund_combined_balance TO evergreen;
GRANT SELECT ON TABLE fund_combined_balance TO bbonner;


--
-- Name: fund_debit_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_debit_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_debit_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_debit_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_debit_id_seq TO bbonner;


--
-- Name: fund_encumbrance_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_encumbrance_total FROM PUBLIC;
REVOKE ALL ON TABLE fund_encumbrance_total FROM evergreen;
GRANT ALL ON TABLE fund_encumbrance_total TO evergreen;
GRANT SELECT ON TABLE fund_encumbrance_total TO bbonner;


--
-- Name: fund_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_id_seq TO bbonner;


--
-- Name: fund_spent_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_spent_total FROM PUBLIC;
REVOKE ALL ON TABLE fund_spent_total FROM evergreen;
GRANT ALL ON TABLE fund_spent_total TO evergreen;
GRANT SELECT ON TABLE fund_spent_total TO bbonner;


--
-- Name: fund_spent_balance; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_spent_balance FROM PUBLIC;
REVOKE ALL ON TABLE fund_spent_balance FROM evergreen;
GRANT ALL ON TABLE fund_spent_balance TO evergreen;
GRANT SELECT ON TABLE fund_spent_balance TO bbonner;


--
-- Name: fund_tag; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_tag FROM PUBLIC;
REVOKE ALL ON TABLE fund_tag FROM evergreen;
GRANT ALL ON TABLE fund_tag TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE fund_tag TO bbonner;


--
-- Name: fund_tag_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_tag_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_tag_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_tag_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_tag_id_seq TO bbonner;


--
-- Name: fund_tag_map; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_tag_map FROM PUBLIC;
REVOKE ALL ON TABLE fund_tag_map FROM evergreen;
GRANT ALL ON TABLE fund_tag_map TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE fund_tag_map TO bbonner;


--
-- Name: fund_tag_map_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_tag_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_tag_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_tag_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_tag_map_id_seq TO bbonner;


--
-- Name: fund_transfer; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE fund_transfer FROM PUBLIC;
REVOKE ALL ON TABLE fund_transfer FROM evergreen;
GRANT ALL ON TABLE fund_transfer TO evergreen;
GRANT SELECT ON TABLE fund_transfer TO bbonner;


--
-- Name: fund_transfer_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fund_transfer_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fund_transfer_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fund_transfer_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fund_transfer_id_seq TO bbonner;


--
-- Name: funding_source_allocation_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE funding_source_allocation_total FROM PUBLIC;
REVOKE ALL ON TABLE funding_source_allocation_total FROM evergreen;
GRANT ALL ON TABLE funding_source_allocation_total TO evergreen;
GRANT SELECT ON TABLE funding_source_allocation_total TO bbonner;


--
-- Name: funding_source_credit; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE funding_source_credit FROM PUBLIC;
REVOKE ALL ON TABLE funding_source_credit FROM evergreen;
GRANT ALL ON TABLE funding_source_credit TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE funding_source_credit TO bbonner;


--
-- Name: funding_source_credit_total; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE funding_source_credit_total FROM PUBLIC;
REVOKE ALL ON TABLE funding_source_credit_total FROM evergreen;
GRANT ALL ON TABLE funding_source_credit_total TO evergreen;
GRANT SELECT ON TABLE funding_source_credit_total TO bbonner;


--
-- Name: funding_source_balance; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE funding_source_balance FROM PUBLIC;
REVOKE ALL ON TABLE funding_source_balance FROM evergreen;
GRANT ALL ON TABLE funding_source_balance TO evergreen;
GRANT SELECT ON TABLE funding_source_balance TO bbonner;


--
-- Name: funding_source_credit_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE funding_source_credit_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE funding_source_credit_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE funding_source_credit_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE funding_source_credit_id_seq TO bbonner;


--
-- Name: funding_source_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE funding_source_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE funding_source_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE funding_source_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE funding_source_id_seq TO bbonner;


--
-- Name: invoice; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice FROM PUBLIC;
REVOKE ALL ON TABLE invoice FROM evergreen;
GRANT ALL ON TABLE invoice TO evergreen;
GRANT SELECT ON TABLE invoice TO bbonner;


--
-- Name: invoice_entry; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice_entry FROM PUBLIC;
REVOKE ALL ON TABLE invoice_entry FROM evergreen;
GRANT ALL ON TABLE invoice_entry TO evergreen;
GRANT SELECT ON TABLE invoice_entry TO bbonner;


--
-- Name: invoice_entry_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE invoice_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE invoice_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE invoice_entry_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE invoice_entry_id_seq TO bbonner;


--
-- Name: invoice_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE invoice_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE invoice_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE invoice_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE invoice_id_seq TO bbonner;


--
-- Name: invoice_item; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice_item FROM PUBLIC;
REVOKE ALL ON TABLE invoice_item FROM evergreen;
GRANT ALL ON TABLE invoice_item TO evergreen;
GRANT SELECT ON TABLE invoice_item TO bbonner;


--
-- Name: invoice_item_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE invoice_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE invoice_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE invoice_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE invoice_item_id_seq TO bbonner;


--
-- Name: invoice_item_type; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice_item_type FROM PUBLIC;
REVOKE ALL ON TABLE invoice_item_type FROM evergreen;
GRANT ALL ON TABLE invoice_item_type TO evergreen;
GRANT SELECT ON TABLE invoice_item_type TO bbonner;


--
-- Name: invoice_method; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice_method FROM PUBLIC;
REVOKE ALL ON TABLE invoice_method FROM evergreen;
GRANT ALL ON TABLE invoice_method TO evergreen;
GRANT SELECT ON TABLE invoice_method TO bbonner;


--
-- Name: invoice_payment_method; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE invoice_payment_method FROM PUBLIC;
REVOKE ALL ON TABLE invoice_payment_method FROM evergreen;
GRANT ALL ON TABLE invoice_payment_method TO evergreen;
GRANT SELECT ON TABLE invoice_payment_method TO bbonner;


--
-- Name: lineitem_alert_text; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_alert_text FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_alert_text FROM evergreen;
GRANT ALL ON TABLE lineitem_alert_text TO evergreen;
GRANT SELECT ON TABLE lineitem_alert_text TO bbonner;


--
-- Name: lineitem_alert_text_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_alert_text_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_alert_text_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_alert_text_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_alert_text_id_seq TO bbonner;


--
-- Name: lineitem_attr; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_attr FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_attr FROM evergreen;
GRANT ALL ON TABLE lineitem_attr TO evergreen;
GRANT ALL ON TABLE lineitem_attr TO bbonner;


--
-- Name: lineitem_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_attr_definition TO bbonner;


--
-- Name: lineitem_attr_definition_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_attr_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_attr_definition_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_attr_definition_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_attr_definition_id_seq TO bbonner;


--
-- Name: lineitem_attr_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_attr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_attr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_attr_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_attr_id_seq TO bbonner;


--
-- Name: lineitem_detail; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_detail FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_detail FROM evergreen;
GRANT ALL ON TABLE lineitem_detail TO evergreen;
GRANT SELECT,UPDATE ON TABLE lineitem_detail TO bbonner;


--
-- Name: lineitem_detail_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_detail_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_detail_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_detail_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_detail_id_seq TO bbonner;


--
-- Name: lineitem_generated_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_generated_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_generated_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_generated_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_generated_attr_definition TO bbonner;


--
-- Name: lineitem_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_id_seq TO bbonner;


--
-- Name: lineitem_local_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_local_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_local_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_local_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_local_attr_definition TO bbonner;


--
-- Name: lineitem_marc_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_marc_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_marc_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_marc_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_marc_attr_definition TO bbonner;


--
-- Name: lineitem_note; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_note FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_note FROM evergreen;
GRANT ALL ON TABLE lineitem_note TO evergreen;
GRANT SELECT ON TABLE lineitem_note TO bbonner;


--
-- Name: lineitem_note_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE lineitem_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lineitem_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE lineitem_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE lineitem_note_id_seq TO bbonner;


--
-- Name: lineitem_provider_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_provider_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_provider_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_provider_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_provider_attr_definition TO bbonner;


--
-- Name: lineitem_usr_attr_definition; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE lineitem_usr_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE lineitem_usr_attr_definition FROM evergreen;
GRANT ALL ON TABLE lineitem_usr_attr_definition TO evergreen;
GRANT SELECT ON TABLE lineitem_usr_attr_definition TO bbonner;


--
-- Name: ordered_funding_source_credit; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE ordered_funding_source_credit FROM PUBLIC;
REVOKE ALL ON TABLE ordered_funding_source_credit FROM evergreen;
GRANT ALL ON TABLE ordered_funding_source_credit TO evergreen;
GRANT SELECT ON TABLE ordered_funding_source_credit TO bbonner;


--
-- Name: picklist; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE picklist FROM PUBLIC;
REVOKE ALL ON TABLE picklist FROM evergreen;
GRANT ALL ON TABLE picklist TO evergreen;
GRANT ALL ON TABLE picklist TO bbonner;


--
-- Name: picklist_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE picklist_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE picklist_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE picklist_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE picklist_id_seq TO bbonner;


--
-- Name: po_item; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE po_item FROM PUBLIC;
REVOKE ALL ON TABLE po_item FROM evergreen;
GRANT ALL ON TABLE po_item TO evergreen;
GRANT SELECT ON TABLE po_item TO bbonner;


--
-- Name: po_item_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE po_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE po_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE po_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE po_item_id_seq TO bbonner;


--
-- Name: po_note; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE po_note FROM PUBLIC;
REVOKE ALL ON TABLE po_note FROM evergreen;
GRANT ALL ON TABLE po_note TO evergreen;
GRANT SELECT ON TABLE po_note TO bbonner;


--
-- Name: po_note_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE po_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE po_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE po_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE po_note_id_seq TO bbonner;


--
-- Name: provider; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider FROM PUBLIC;
REVOKE ALL ON TABLE provider FROM evergreen;
GRANT ALL ON TABLE provider TO evergreen;
GRANT ALL ON TABLE provider TO bbonner;


--
-- Name: provider_address; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider_address FROM PUBLIC;
REVOKE ALL ON TABLE provider_address FROM evergreen;
GRANT ALL ON TABLE provider_address TO evergreen;
GRANT ALL ON TABLE provider_address TO bbonner;


--
-- Name: provider_address_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_address_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_address_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_address_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_address_id_seq TO bbonner;


--
-- Name: provider_contact; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider_contact FROM PUBLIC;
REVOKE ALL ON TABLE provider_contact FROM evergreen;
GRANT ALL ON TABLE provider_contact TO evergreen;
GRANT ALL ON TABLE provider_contact TO bbonner;


--
-- Name: provider_contact_address; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider_contact_address FROM PUBLIC;
REVOKE ALL ON TABLE provider_contact_address FROM evergreen;
GRANT ALL ON TABLE provider_contact_address TO evergreen;
GRANT ALL ON TABLE provider_contact_address TO bbonner;


--
-- Name: provider_contact_address_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_contact_address_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_contact_address_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_contact_address_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_contact_address_id_seq TO bbonner;


--
-- Name: provider_contact_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_contact_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_contact_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_contact_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_contact_id_seq TO bbonner;


--
-- Name: provider_holding_subfield_map; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider_holding_subfield_map FROM PUBLIC;
REVOKE ALL ON TABLE provider_holding_subfield_map FROM evergreen;
GRANT ALL ON TABLE provider_holding_subfield_map TO evergreen;
GRANT SELECT ON TABLE provider_holding_subfield_map TO bbonner;


--
-- Name: provider_holding_subfield_map_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_holding_subfield_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_holding_subfield_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_holding_subfield_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_holding_subfield_map_id_seq TO bbonner;


--
-- Name: provider_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_id_seq TO bbonner;


--
-- Name: provider_note; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE provider_note FROM PUBLIC;
REVOKE ALL ON TABLE provider_note FROM evergreen;
GRANT ALL ON TABLE provider_note TO evergreen;
GRANT ALL ON TABLE provider_note TO bbonner;


--
-- Name: provider_note_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE provider_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE provider_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE provider_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE provider_note_id_seq TO bbonner;


--
-- Name: purchase_order_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE purchase_order_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE purchase_order_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE purchase_order_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE purchase_order_id_seq TO bbonner;


--
-- Name: serial_claim; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE serial_claim FROM PUBLIC;
REVOKE ALL ON TABLE serial_claim FROM evergreen;
GRANT ALL ON TABLE serial_claim TO evergreen;
GRANT SELECT ON TABLE serial_claim TO bbonner;


--
-- Name: serial_claim_event; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE serial_claim_event FROM PUBLIC;
REVOKE ALL ON TABLE serial_claim_event FROM evergreen;
GRANT ALL ON TABLE serial_claim_event TO evergreen;
GRANT SELECT ON TABLE serial_claim_event TO bbonner;


--
-- Name: serial_claim_event_claim_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE serial_claim_event_claim_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE serial_claim_event_claim_seq FROM evergreen;
GRANT ALL ON SEQUENCE serial_claim_event_claim_seq TO evergreen;
GRANT USAGE ON SEQUENCE serial_claim_event_claim_seq TO bbonner;


--
-- Name: serial_claim_event_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE serial_claim_event_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE serial_claim_event_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE serial_claim_event_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE serial_claim_event_id_seq TO bbonner;


--
-- Name: serial_claim_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE serial_claim_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE serial_claim_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE serial_claim_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE serial_claim_id_seq TO bbonner;


--
-- Name: user_request; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE user_request FROM PUBLIC;
REVOKE ALL ON TABLE user_request FROM evergreen;
GRANT ALL ON TABLE user_request TO evergreen;
GRANT SELECT ON TABLE user_request TO bbonner;


--
-- Name: user_request_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_request_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_request_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_request_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_request_id_seq TO bbonner;


--
-- Name: user_request_type; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON TABLE user_request_type FROM PUBLIC;
REVOKE ALL ON TABLE user_request_type FROM evergreen;
GRANT ALL ON TABLE user_request_type TO evergreen;
GRANT SELECT ON TABLE user_request_type TO bbonner;


--
-- Name: user_request_type_id_seq; Type: ACL; Schema: acq; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_request_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_request_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_request_type_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_request_type_id_seq TO bbonner;


SET search_path = action, pg_catalog;

--
-- Name: aged_circulation; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE aged_circulation FROM PUBLIC;
REVOKE ALL ON TABLE aged_circulation FROM evergreen;
GRANT ALL ON TABLE aged_circulation TO evergreen;
GRANT SELECT ON TABLE aged_circulation TO bbonner;


SET search_path = actor, pg_catalog;

--
-- Name: usr_address; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_address FROM PUBLIC;
REVOKE ALL ON TABLE usr_address FROM evergreen;
GRANT ALL ON TABLE usr_address TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE usr_address TO bbonner;


SET search_path = asset, pg_catalog;

--
-- Name: call_number; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE call_number FROM PUBLIC;
REVOKE ALL ON TABLE call_number FROM evergreen;
GRANT ALL ON TABLE call_number TO evergreen;
GRANT ALL ON TABLE call_number TO bbonner;
GRANT SELECT ON TABLE call_number TO biblio;


SET search_path = action, pg_catalog;

--
-- Name: all_circulation; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE all_circulation FROM PUBLIC;
REVOKE ALL ON TABLE all_circulation FROM evergreen;
GRANT ALL ON TABLE all_circulation TO evergreen;
GRANT SELECT ON TABLE all_circulation TO bbonner;


--
-- Name: archived_hold_request_2005; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2005 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2005 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2005 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2005 TO bbonner;


--
-- Name: archived_hold_request_2006; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2006 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2006 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2006 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2006 TO bbonner;


--
-- Name: archived_hold_request_2007; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2007 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2007 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2007 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2007 TO bbonner;


--
-- Name: archived_hold_request_2008; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2008 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2008 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2008 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2008 TO bbonner;


--
-- Name: archived_hold_request_2009; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2009 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2009 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2009 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2009 TO bbonner;


--
-- Name: archived_hold_request_2010; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2010 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2010 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2010 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2010 TO bbonner;


--
-- Name: archived_hold_request_2011; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2011 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2011 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2011 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2011 TO bbonner;


--
-- Name: archived_hold_request_2012; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2012 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2012 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2012 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2012 TO bbonner;


--
-- Name: archived_hold_request_2013; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE archived_hold_request_2013 FROM PUBLIC;
REVOKE ALL ON TABLE archived_hold_request_2013 FROM evergreen;
GRANT ALL ON TABLE archived_hold_request_2013 TO evergreen;
GRANT SELECT ON TABLE archived_hold_request_2013 TO bbonner;


--
-- Name: billable_circulations; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE billable_circulations FROM PUBLIC;
REVOKE ALL ON TABLE billable_circulations FROM evergreen;
GRANT ALL ON TABLE billable_circulations TO evergreen;
GRANT SELECT ON TABLE billable_circulations TO bbonner;


--
-- Name: fieldset; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE fieldset FROM PUBLIC;
REVOKE ALL ON TABLE fieldset FROM evergreen;
GRANT ALL ON TABLE fieldset TO evergreen;
GRANT SELECT ON TABLE fieldset TO bbonner;


--
-- Name: fieldset_col_val; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE fieldset_col_val FROM PUBLIC;
REVOKE ALL ON TABLE fieldset_col_val FROM evergreen;
GRANT ALL ON TABLE fieldset_col_val TO evergreen;
GRANT SELECT ON TABLE fieldset_col_val TO bbonner;


--
-- Name: fieldset_col_val_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fieldset_col_val_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fieldset_col_val_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fieldset_col_val_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fieldset_col_val_id_seq TO bbonner;


--
-- Name: fieldset_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE fieldset_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE fieldset_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE fieldset_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE fieldset_id_seq TO bbonner;


--
-- Name: hold_copy_map; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE hold_copy_map FROM evergreen;
GRANT ALL ON TABLE hold_copy_map TO evergreen;
GRANT ALL ON TABLE hold_copy_map TO bbonner;
GRANT SELECT ON TABLE hold_copy_map TO biblio;


--
-- Name: hold_copy_map_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_copy_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_copy_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_copy_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE hold_copy_map_id_seq TO bbonner;


--
-- Name: hold_count; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_count FROM PUBLIC;
REVOKE ALL ON TABLE hold_count FROM evergreen;
GRANT ALL ON TABLE hold_count TO evergreen;
GRANT ALL ON TABLE hold_count TO bbonner;


--
-- Name: hold_notification; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE hold_notification FROM evergreen;
GRANT ALL ON TABLE hold_notification TO evergreen;
GRANT SELECT ON TABLE hold_notification TO bbonner;


--
-- Name: hold_notification_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_notification_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_notification_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_notification_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE hold_notification_id_seq TO bbonner;


--
-- Name: hold_request_cancel_cause; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_request_cancel_cause FROM PUBLIC;
REVOKE ALL ON TABLE hold_request_cancel_cause FROM evergreen;
GRANT ALL ON TABLE hold_request_cancel_cause TO evergreen;
GRANT SELECT ON TABLE hold_request_cancel_cause TO bbonner;


--
-- Name: hold_request_cancel_cause_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_request_cancel_cause_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_request_cancel_cause_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_request_cancel_cause_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE hold_request_cancel_cause_id_seq TO bbonner;


--
-- Name: hold_request_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_request_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_request_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_request_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE hold_request_id_seq TO bbonner;


--
-- Name: hold_request_note; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_request_note FROM PUBLIC;
REVOKE ALL ON TABLE hold_request_note FROM evergreen;
GRANT ALL ON TABLE hold_request_note TO evergreen;
GRANT ALL ON TABLE hold_request_note TO bbonner;


--
-- Name: hold_request_note_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_request_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_request_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_request_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE hold_request_note_id_seq TO bbonner;


--
-- Name: transit_copy; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE transit_copy FROM PUBLIC;
REVOKE ALL ON TABLE transit_copy FROM evergreen;
GRANT ALL ON TABLE transit_copy TO evergreen;
GRANT SELECT,DELETE,UPDATE ON TABLE transit_copy TO bbonner;


--
-- Name: hold_transit_copy; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE hold_transit_copy FROM PUBLIC;
REVOKE ALL ON TABLE hold_transit_copy FROM evergreen;
GRANT ALL ON TABLE hold_transit_copy TO evergreen;
GRANT ALL ON TABLE hold_transit_copy TO bbonner;


--
-- Name: in_house_use; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE in_house_use FROM PUBLIC;
REVOKE ALL ON TABLE in_house_use FROM evergreen;
GRANT ALL ON TABLE in_house_use TO evergreen;
GRANT SELECT ON TABLE in_house_use TO bbonner;


--
-- Name: in_house_use_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE in_house_use_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE in_house_use_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE in_house_use_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE in_house_use_id_seq TO bbonner;


--
-- Name: non_cat_in_house_use; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE non_cat_in_house_use FROM PUBLIC;
REVOKE ALL ON TABLE non_cat_in_house_use FROM evergreen;
GRANT ALL ON TABLE non_cat_in_house_use TO evergreen;
GRANT SELECT ON TABLE non_cat_in_house_use TO bbonner;


--
-- Name: non_cat_in_house_use_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE non_cat_in_house_use_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE non_cat_in_house_use_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE non_cat_in_house_use_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE non_cat_in_house_use_id_seq TO bbonner;


--
-- Name: non_cataloged_circulation; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE non_cataloged_circulation FROM PUBLIC;
REVOKE ALL ON TABLE non_cataloged_circulation FROM evergreen;
GRANT ALL ON TABLE non_cataloged_circulation TO evergreen;
GRANT SELECT ON TABLE non_cataloged_circulation TO bbonner;


--
-- Name: non_cataloged_circulation_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE non_cataloged_circulation_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE non_cataloged_circulation_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE non_cataloged_circulation_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE non_cataloged_circulation_id_seq TO bbonner;


--
-- Name: open_circulation; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE open_circulation FROM PUBLIC;
REVOKE ALL ON TABLE open_circulation FROM evergreen;
GRANT ALL ON TABLE open_circulation TO evergreen;
GRANT SELECT ON TABLE open_circulation TO bbonner;


--
-- Name: reservation_transit_copy; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE reservation_transit_copy FROM PUBLIC;
REVOKE ALL ON TABLE reservation_transit_copy FROM evergreen;
GRANT ALL ON TABLE reservation_transit_copy TO evergreen;
GRANT SELECT ON TABLE reservation_transit_copy TO bbonner;


--
-- Name: survey; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE survey FROM PUBLIC;
REVOKE ALL ON TABLE survey FROM evergreen;
GRANT ALL ON TABLE survey TO evergreen;
GRANT SELECT ON TABLE survey TO bbonner;


--
-- Name: survey_answer; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE survey_answer FROM PUBLIC;
REVOKE ALL ON TABLE survey_answer FROM evergreen;
GRANT ALL ON TABLE survey_answer TO evergreen;
GRANT SELECT ON TABLE survey_answer TO bbonner;


--
-- Name: survey_answer_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE survey_answer_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE survey_answer_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE survey_answer_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE survey_answer_id_seq TO bbonner;


--
-- Name: survey_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE survey_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE survey_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE survey_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE survey_id_seq TO bbonner;


--
-- Name: survey_question; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE survey_question FROM PUBLIC;
REVOKE ALL ON TABLE survey_question FROM evergreen;
GRANT ALL ON TABLE survey_question TO evergreen;
GRANT SELECT ON TABLE survey_question TO bbonner;


--
-- Name: survey_question_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE survey_question_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE survey_question_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE survey_question_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE survey_question_id_seq TO bbonner;


--
-- Name: survey_response; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE survey_response FROM PUBLIC;
REVOKE ALL ON TABLE survey_response FROM evergreen;
GRANT ALL ON TABLE survey_response TO evergreen;
GRANT SELECT ON TABLE survey_response TO bbonner;


--
-- Name: survey_response_group_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE survey_response_group_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE survey_response_group_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE survey_response_group_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE survey_response_group_id_seq TO bbonner;


--
-- Name: survey_response_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE survey_response_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE survey_response_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE survey_response_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE survey_response_id_seq TO bbonner;


--
-- Name: transit_copy_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE transit_copy_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE transit_copy_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE transit_copy_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE transit_copy_id_seq TO bbonner;


--
-- Name: unfulfilled_hold_list; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE unfulfilled_hold_list FROM PUBLIC;
REVOKE ALL ON TABLE unfulfilled_hold_list FROM evergreen;
GRANT ALL ON TABLE unfulfilled_hold_list TO evergreen;
GRANT SELECT ON TABLE unfulfilled_hold_list TO bbonner;


--
-- Name: unfulfilled_hold_loops; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE unfulfilled_hold_loops FROM PUBLIC;
REVOKE ALL ON TABLE unfulfilled_hold_loops FROM evergreen;
GRANT ALL ON TABLE unfulfilled_hold_loops TO evergreen;
GRANT SELECT ON TABLE unfulfilled_hold_loops TO bbonner;


--
-- Name: unfulfilled_hold_min_loop; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE unfulfilled_hold_min_loop FROM PUBLIC;
REVOKE ALL ON TABLE unfulfilled_hold_min_loop FROM evergreen;
GRANT ALL ON TABLE unfulfilled_hold_min_loop TO evergreen;
GRANT SELECT ON TABLE unfulfilled_hold_min_loop TO bbonner;


--
-- Name: unfulfilled_hold_innermost_loop; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE unfulfilled_hold_innermost_loop FROM PUBLIC;
REVOKE ALL ON TABLE unfulfilled_hold_innermost_loop FROM evergreen;
GRANT ALL ON TABLE unfulfilled_hold_innermost_loop TO evergreen;
GRANT SELECT ON TABLE unfulfilled_hold_innermost_loop TO bbonner;


--
-- Name: unfulfilled_hold_list_id_seq; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON SEQUENCE unfulfilled_hold_list_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE unfulfilled_hold_list_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE unfulfilled_hold_list_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE unfulfilled_hold_list_id_seq TO bbonner;


--
-- Name: unfulfilled_hold_max_loop; Type: ACL; Schema: action; Owner: evergreen
--

REVOKE ALL ON TABLE unfulfilled_hold_max_loop FROM PUBLIC;
REVOKE ALL ON TABLE unfulfilled_hold_max_loop FROM evergreen;
GRANT ALL ON TABLE unfulfilled_hold_max_loop TO evergreen;
GRANT SELECT ON TABLE unfulfilled_hold_max_loop TO bbonner;


SET search_path = action_trigger, pg_catalog;

--
-- Name: cleanup; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE cleanup FROM PUBLIC;
REVOKE ALL ON TABLE cleanup FROM evergreen;
GRANT ALL ON TABLE cleanup TO evergreen;
GRANT SELECT ON TABLE cleanup TO bbonner;


--
-- Name: collector; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE collector FROM PUBLIC;
REVOKE ALL ON TABLE collector FROM evergreen;
GRANT ALL ON TABLE collector TO evergreen;
GRANT SELECT ON TABLE collector TO bbonner;


--
-- Name: environment; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE environment FROM PUBLIC;
REVOKE ALL ON TABLE environment FROM evergreen;
GRANT ALL ON TABLE environment TO evergreen;
GRANT SELECT ON TABLE environment TO bbonner;


--
-- Name: environment_id_seq; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON SEQUENCE environment_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE environment_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE environment_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE environment_id_seq TO bbonner;


--
-- Name: event; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE event FROM PUBLIC;
REVOKE ALL ON TABLE event FROM evergreen;
GRANT ALL ON TABLE event TO evergreen;
GRANT SELECT,UPDATE ON TABLE event TO bbonner;


--
-- Name: event_definition; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE event_definition FROM PUBLIC;
REVOKE ALL ON TABLE event_definition FROM evergreen;
GRANT ALL ON TABLE event_definition TO evergreen;
GRANT SELECT ON TABLE event_definition TO bbonner;


--
-- Name: event_definition_id_seq; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON SEQUENCE event_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE event_definition_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE event_definition_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE event_definition_id_seq TO bbonner;


--
-- Name: event_id_seq; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON SEQUENCE event_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE event_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE event_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE event_id_seq TO bbonner;


--
-- Name: event_output; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE event_output FROM PUBLIC;
REVOKE ALL ON TABLE event_output FROM evergreen;
GRANT ALL ON TABLE event_output TO evergreen;
GRANT SELECT,INSERT,UPDATE ON TABLE event_output TO bbonner;


--
-- Name: event_output_id_seq; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON SEQUENCE event_output_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE event_output_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE event_output_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE event_output_id_seq TO bbonner;


--
-- Name: event_params; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE event_params FROM PUBLIC;
REVOKE ALL ON TABLE event_params FROM evergreen;
GRANT ALL ON TABLE event_params TO evergreen;
GRANT SELECT ON TABLE event_params TO bbonner;


--
-- Name: event_params_id_seq; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON SEQUENCE event_params_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE event_params_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE event_params_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE event_params_id_seq TO bbonner;


--
-- Name: hook; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE hook FROM PUBLIC;
REVOKE ALL ON TABLE hook FROM evergreen;
GRANT ALL ON TABLE hook TO evergreen;
GRANT SELECT ON TABLE hook TO bbonner;


--
-- Name: reactor; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE reactor FROM PUBLIC;
REVOKE ALL ON TABLE reactor FROM evergreen;
GRANT ALL ON TABLE reactor TO evergreen;
GRANT SELECT ON TABLE reactor TO bbonner;


--
-- Name: validator; Type: ACL; Schema: action_trigger; Owner: evergreen
--

REVOKE ALL ON TABLE validator FROM PUBLIC;
REVOKE ALL ON TABLE validator FROM evergreen;
GRANT ALL ON TABLE validator TO evergreen;
GRANT SELECT ON TABLE validator TO bbonner;


SET search_path = actor, pg_catalog;

--
-- Name: card; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE card FROM PUBLIC;
REVOKE ALL ON TABLE card FROM evergreen;
GRANT ALL ON TABLE card TO evergreen;
GRANT ALL ON TABLE card TO bbonner;
GRANT SELECT ON TABLE card TO biblio;


--
-- Name: card_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE card_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE card_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE card_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE card_id_seq TO bbonner;


--
-- Name: hours_of_operation; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE hours_of_operation FROM PUBLIC;
REVOKE ALL ON TABLE hours_of_operation FROM evergreen;
GRANT ALL ON TABLE hours_of_operation TO evergreen;
GRANT SELECT ON TABLE hours_of_operation TO bbonner;


--
-- Name: org_address; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_address FROM PUBLIC;
REVOKE ALL ON TABLE org_address FROM evergreen;
GRANT ALL ON TABLE org_address TO evergreen;
GRANT SELECT ON TABLE org_address TO bbonner;


--
-- Name: org_address_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_address_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_address_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_address_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_address_id_seq TO bbonner;


--
-- Name: org_lasso; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_lasso FROM PUBLIC;
REVOKE ALL ON TABLE org_lasso FROM evergreen;
GRANT ALL ON TABLE org_lasso TO evergreen;
GRANT SELECT ON TABLE org_lasso TO bbonner;


--
-- Name: org_lasso_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_lasso_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_lasso_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_lasso_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_lasso_id_seq TO bbonner;


--
-- Name: org_lasso_map; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_lasso_map FROM PUBLIC;
REVOKE ALL ON TABLE org_lasso_map FROM evergreen;
GRANT ALL ON TABLE org_lasso_map TO evergreen;
GRANT SELECT ON TABLE org_lasso_map TO bbonner;


--
-- Name: org_lasso_map_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_lasso_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_lasso_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_lasso_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_lasso_map_id_seq TO bbonner;


--
-- Name: org_unit_closed; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_closed FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_closed FROM evergreen;
GRANT ALL ON TABLE org_unit_closed TO evergreen;
GRANT SELECT ON TABLE org_unit_closed TO bbonner;


--
-- Name: org_unit_closed_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_closed_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_closed_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_closed_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_unit_closed_id_seq TO bbonner;


--
-- Name: org_unit_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_unit_id_seq TO bbonner;


--
-- Name: org_unit_proximity; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_proximity FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_proximity FROM evergreen;
GRANT ALL ON TABLE org_unit_proximity TO evergreen;
GRANT SELECT ON TABLE org_unit_proximity TO bbonner;


--
-- Name: org_unit_proximity_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_proximity_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_proximity_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_proximity_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_unit_proximity_id_seq TO bbonner;


--
-- Name: org_unit_setting_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_setting_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_setting_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_setting_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_unit_setting_id_seq TO bbonner;


--
-- Name: org_unit_type; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_type FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_type FROM evergreen;
GRANT ALL ON TABLE org_unit_type TO evergreen;
GRANT SELECT ON TABLE org_unit_type TO bbonner;
GRANT SELECT ON TABLE org_unit_type TO biblio;


--
-- Name: org_unit_type_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_type_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE org_unit_type_id_seq TO bbonner;


--
-- Name: stat_cat; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat FROM evergreen;
GRANT ALL ON TABLE stat_cat TO evergreen;
GRANT SELECT ON TABLE stat_cat TO bbonner;


--
-- Name: stat_cat_entry; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE stat_cat_entry TO evergreen;
GRANT ALL ON TABLE stat_cat_entry TO bbonner;


--
-- Name: stat_cat_entry_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE stat_cat_entry_id_seq TO bbonner;


--
-- Name: stat_cat_entry_usr_map; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE stat_cat_entry_usr_map TO evergreen;
GRANT SELECT,DELETE ON TABLE stat_cat_entry_usr_map TO bbonner;


--
-- Name: stat_cat_entry_usr_map_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_entry_usr_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_entry_usr_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_usr_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE stat_cat_entry_usr_map_id_seq TO bbonner;


--
-- Name: stat_cat_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE stat_cat_id_seq TO bbonner;


--
-- Name: usr_address_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_address_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_address_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_address_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_address_id_seq TO bbonner;


--
-- Name: usr_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_id_seq TO bbonner;


--
-- Name: usr_note; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_note FROM PUBLIC;
REVOKE ALL ON TABLE usr_note FROM evergreen;
GRANT ALL ON TABLE usr_note TO evergreen;
GRANT ALL ON TABLE usr_note TO bbonner;


--
-- Name: usr_note_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_note_id_seq TO bbonner;


--
-- Name: usr_org_unit_opt_in; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_org_unit_opt_in FROM PUBLIC;
REVOKE ALL ON TABLE usr_org_unit_opt_in FROM evergreen;
GRANT ALL ON TABLE usr_org_unit_opt_in TO evergreen;
GRANT SELECT ON TABLE usr_org_unit_opt_in TO bbonner;


--
-- Name: usr_org_unit_opt_in_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_org_unit_opt_in_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_org_unit_opt_in_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_org_unit_opt_in_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_org_unit_opt_in_id_seq TO bbonner;


--
-- Name: usr_password_reset; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_password_reset FROM PUBLIC;
REVOKE ALL ON TABLE usr_password_reset FROM evergreen;
GRANT ALL ON TABLE usr_password_reset TO evergreen;
GRANT SELECT ON TABLE usr_password_reset TO bbonner;


--
-- Name: usr_password_reset_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_password_reset_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_password_reset_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_password_reset_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_password_reset_id_seq TO bbonner;


--
-- Name: usr_saved_search; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_saved_search FROM PUBLIC;
REVOKE ALL ON TABLE usr_saved_search FROM evergreen;
GRANT ALL ON TABLE usr_saved_search TO evergreen;
GRANT SELECT ON TABLE usr_saved_search TO bbonner;


--
-- Name: usr_saved_search_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_saved_search_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_saved_search_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_saved_search_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_saved_search_id_seq TO bbonner;


--
-- Name: usr_setting; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE usr_setting FROM PUBLIC;
REVOKE ALL ON TABLE usr_setting FROM evergreen;
GRANT ALL ON TABLE usr_setting TO evergreen;
GRANT ALL ON TABLE usr_setting TO bbonner;


--
-- Name: usr_setting_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_setting_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_setting_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_setting_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_setting_id_seq TO bbonner;


--
-- Name: usr_standing_penalty_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_standing_penalty_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_standing_penalty_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_standing_penalty_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_standing_penalty_id_seq TO bbonner;


--
-- Name: usr_usrgroup_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_usrgroup_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_usrgroup_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_usrgroup_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_usrgroup_seq TO bbonner;


--
-- Name: workstation; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON TABLE workstation FROM PUBLIC;
REVOKE ALL ON TABLE workstation FROM evergreen;
GRANT ALL ON TABLE workstation TO evergreen;
GRANT SELECT ON TABLE workstation TO bbonner;


--
-- Name: workstation_id_seq; Type: ACL; Schema: actor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE workstation_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE workstation_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE workstation_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE workstation_id_seq TO bbonner;


SET search_path = asset, pg_catalog;

--
-- Name: call_number_class; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_class FROM PUBLIC;
REVOKE ALL ON TABLE call_number_class FROM evergreen;
GRANT ALL ON TABLE call_number_class TO evergreen;
GRANT ALL ON TABLE call_number_class TO bbonner;


--
-- Name: call_number_class_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_class_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_class_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_class_id_seq TO evergreen;
GRANT ALL ON SEQUENCE call_number_class_id_seq TO bbonner;


--
-- Name: call_number_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_id_seq TO evergreen;
GRANT ALL ON SEQUENCE call_number_id_seq TO bbonner;


--
-- Name: call_number_note; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_note FROM PUBLIC;
REVOKE ALL ON TABLE call_number_note FROM evergreen;
GRANT ALL ON TABLE call_number_note TO evergreen;
GRANT ALL ON TABLE call_number_note TO bbonner;


--
-- Name: call_number_note_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_note_id_seq TO evergreen;
GRANT ALL ON SEQUENCE call_number_note_id_seq TO bbonner;


--
-- Name: call_number_prefix; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_prefix FROM PUBLIC;
REVOKE ALL ON TABLE call_number_prefix FROM evergreen;
GRANT ALL ON TABLE call_number_prefix TO evergreen;
GRANT ALL ON TABLE call_number_prefix TO bbonner;


--
-- Name: call_number_prefix_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_prefix_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_prefix_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_prefix_id_seq TO evergreen;
GRANT ALL ON SEQUENCE call_number_prefix_id_seq TO bbonner;


--
-- Name: call_number_suffix; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_suffix FROM PUBLIC;
REVOKE ALL ON TABLE call_number_suffix FROM evergreen;
GRANT ALL ON TABLE call_number_suffix TO evergreen;
GRANT ALL ON TABLE call_number_suffix TO bbonner;


--
-- Name: call_number_suffix_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_suffix_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_suffix_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_suffix_id_seq TO evergreen;
GRANT ALL ON SEQUENCE call_number_suffix_id_seq TO bbonner;


--
-- Name: copy_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_id_seq TO bbonner;


--
-- Name: copy_location; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_location FROM PUBLIC;
REVOKE ALL ON TABLE copy_location FROM evergreen;
GRANT ALL ON TABLE copy_location TO evergreen;
GRANT ALL ON TABLE copy_location TO bbonner;
GRANT SELECT ON TABLE copy_location TO biblio;


--
-- Name: copy_location_group; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_location_group FROM PUBLIC;
REVOKE ALL ON TABLE copy_location_group FROM evergreen;
GRANT ALL ON TABLE copy_location_group TO evergreen;
GRANT ALL ON TABLE copy_location_group TO bbonner;


--
-- Name: copy_location_group_map; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_location_group_map FROM PUBLIC;
REVOKE ALL ON TABLE copy_location_group_map FROM evergreen;
GRANT ALL ON TABLE copy_location_group_map TO evergreen;
GRANT ALL ON TABLE copy_location_group_map TO bbonner;


--
-- Name: copy_location_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_location_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_location_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_location_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_location_id_seq TO bbonner;


--
-- Name: copy_location_order; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_location_order FROM PUBLIC;
REVOKE ALL ON TABLE copy_location_order FROM evergreen;
GRANT ALL ON TABLE copy_location_order TO evergreen;
GRANT ALL ON TABLE copy_location_order TO bbonner;


--
-- Name: copy_location_order_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_location_order_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_location_order_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_location_order_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_location_order_id_seq TO bbonner;


--
-- Name: copy_note; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_note FROM PUBLIC;
REVOKE ALL ON TABLE copy_note FROM evergreen;
GRANT ALL ON TABLE copy_note TO evergreen;
GRANT ALL ON TABLE copy_note TO bbonner;


--
-- Name: copy_note_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_note_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_note_id_seq TO bbonner;


--
-- Name: copy_part_map; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_part_map FROM PUBLIC;
REVOKE ALL ON TABLE copy_part_map FROM evergreen;
GRANT ALL ON TABLE copy_part_map TO evergreen;
GRANT ALL ON TABLE copy_part_map TO bbonner;


--
-- Name: copy_part_map_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_part_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_part_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_part_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_part_map_id_seq TO bbonner;


--
-- Name: copy_template; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE copy_template FROM PUBLIC;
REVOKE ALL ON TABLE copy_template FROM evergreen;
GRANT ALL ON TABLE copy_template TO evergreen;
GRANT ALL ON TABLE copy_template TO bbonner;


--
-- Name: copy_template_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_template_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_template_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_template_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_template_id_seq TO bbonner;


--
-- Name: opac_visible_copies; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE opac_visible_copies FROM PUBLIC;
REVOKE ALL ON TABLE opac_visible_copies FROM evergreen;
GRANT ALL ON TABLE opac_visible_copies TO evergreen;
GRANT ALL ON TABLE opac_visible_copies TO bbonner;


--
-- Name: opac_visible_copies_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE opac_visible_copies_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE opac_visible_copies_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE opac_visible_copies_id_seq TO evergreen;
GRANT ALL ON SEQUENCE opac_visible_copies_id_seq TO bbonner;


--
-- Name: stat_cat; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat FROM evergreen;
GRANT ALL ON TABLE stat_cat TO evergreen;
GRANT ALL ON TABLE stat_cat TO bbonner;


--
-- Name: stat_cat_entry; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE stat_cat_entry TO evergreen;
GRANT ALL ON TABLE stat_cat_entry TO bbonner;


--
-- Name: stat_cat_entry_copy_map; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE stat_cat_entry_copy_map TO evergreen;
GRANT ALL ON TABLE stat_cat_entry_copy_map TO bbonner;


--
-- Name: stat_cat_entry_copy_map_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_entry_copy_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_entry_copy_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_copy_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_copy_map_id_seq TO bbonner;


--
-- Name: stat_cat_entry_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_id_seq TO bbonner;


--
-- Name: stat_cat_entry_transparency_map; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE stat_cat_entry_transparency_map FROM PUBLIC;
REVOKE ALL ON TABLE stat_cat_entry_transparency_map FROM evergreen;
GRANT ALL ON TABLE stat_cat_entry_transparency_map TO evergreen;
GRANT ALL ON TABLE stat_cat_entry_transparency_map TO bbonner;


--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_entry_transparency_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_entry_transparency_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_transparency_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE stat_cat_entry_transparency_map_id_seq TO bbonner;


--
-- Name: stat_cat_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stat_cat_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stat_cat_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stat_cat_id_seq TO evergreen;
GRANT ALL ON SEQUENCE stat_cat_id_seq TO bbonner;


--
-- Name: uri; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE uri FROM PUBLIC;
REVOKE ALL ON TABLE uri FROM evergreen;
GRANT ALL ON TABLE uri TO evergreen;
GRANT ALL ON TABLE uri TO bbonner;


--
-- Name: uri_call_number_map; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON TABLE uri_call_number_map FROM PUBLIC;
REVOKE ALL ON TABLE uri_call_number_map FROM evergreen;
GRANT ALL ON TABLE uri_call_number_map TO evergreen;
GRANT ALL ON TABLE uri_call_number_map TO bbonner;


--
-- Name: uri_call_number_map_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE uri_call_number_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE uri_call_number_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE uri_call_number_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE uri_call_number_map_id_seq TO bbonner;


--
-- Name: uri_id_seq; Type: ACL; Schema: asset; Owner: evergreen
--

REVOKE ALL ON SEQUENCE uri_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE uri_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE uri_id_seq TO evergreen;
GRANT ALL ON SEQUENCE uri_id_seq TO bbonner;


SET search_path = auditor, pg_catalog;

--
-- Name: acq_fund_debit_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE acq_fund_debit_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_fund_debit_history FROM evergreen;
GRANT ALL ON TABLE acq_fund_debit_history TO evergreen;
GRANT ALL ON TABLE acq_fund_debit_history TO bbonner;


--
-- Name: acq_fund_debit_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_fund_debit_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_fund_debit_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_fund_debit_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE acq_fund_debit_pkey_seq TO bbonner;


--
-- Name: acq_invoice_entry_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE acq_invoice_entry_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_invoice_entry_history FROM evergreen;
GRANT ALL ON TABLE acq_invoice_entry_history TO evergreen;
GRANT ALL ON TABLE acq_invoice_entry_history TO bbonner;


--
-- Name: acq_invoice_entry_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_invoice_entry_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_invoice_entry_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_invoice_entry_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE acq_invoice_entry_pkey_seq TO bbonner;


--
-- Name: acq_invoice_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE acq_invoice_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_invoice_history FROM evergreen;
GRANT ALL ON TABLE acq_invoice_history TO evergreen;
GRANT ALL ON TABLE acq_invoice_history TO bbonner;


--
-- Name: acq_invoice_item_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE acq_invoice_item_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_invoice_item_history FROM evergreen;
GRANT ALL ON TABLE acq_invoice_item_history TO evergreen;
GRANT ALL ON TABLE acq_invoice_item_history TO bbonner;


--
-- Name: acq_invoice_item_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_invoice_item_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_invoice_item_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_invoice_item_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE acq_invoice_item_pkey_seq TO bbonner;


--
-- Name: acq_invoice_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_invoice_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_invoice_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_invoice_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE acq_invoice_pkey_seq TO bbonner;


--
-- Name: acq_lineitem_detail_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE acq_lineitem_detail_history FROM PUBLIC;
REVOKE ALL ON TABLE acq_lineitem_detail_history FROM evergreen;
GRANT ALL ON TABLE acq_lineitem_detail_history TO evergreen;
GRANT ALL ON TABLE acq_lineitem_detail_history TO bbonner;


--
-- Name: acq_lineitem_detail_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE acq_lineitem_detail_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE acq_lineitem_detail_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE acq_lineitem_detail_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE acq_lineitem_detail_pkey_seq TO bbonner;


--
-- Name: action_trigger_event_definition_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE action_trigger_event_definition_history FROM PUBLIC;
REVOKE ALL ON TABLE action_trigger_event_definition_history FROM evergreen;
GRANT ALL ON TABLE action_trigger_event_definition_history TO evergreen;
GRANT ALL ON TABLE action_trigger_event_definition_history TO bbonner;


--
-- Name: action_trigger_event_definition_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE action_trigger_event_definition_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE action_trigger_event_definition_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE action_trigger_event_definition_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE action_trigger_event_definition_pkey_seq TO bbonner;


--
-- Name: actor_org_unit_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE actor_org_unit_history FROM PUBLIC;
REVOKE ALL ON TABLE actor_org_unit_history FROM evergreen;
GRANT ALL ON TABLE actor_org_unit_history TO evergreen;
GRANT ALL ON TABLE actor_org_unit_history TO bbonner;


--
-- Name: actor_org_unit_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE actor_org_unit_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE actor_org_unit_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE actor_org_unit_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE actor_org_unit_pkey_seq TO bbonner;


--
-- Name: actor_usr_address_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address_history FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address_history FROM evergreen;
GRANT ALL ON TABLE actor_usr_address_history TO evergreen;
GRANT ALL ON TABLE actor_usr_address_history TO bbonner;


--
-- Name: actor_usr_address_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE actor_usr_address_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE actor_usr_address_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE actor_usr_address_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE actor_usr_address_pkey_seq TO bbonner;


--
-- Name: actor_usr_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_history FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_history FROM evergreen;
GRANT ALL ON TABLE actor_usr_history TO evergreen;
GRANT ALL ON TABLE actor_usr_history TO bbonner;


--
-- Name: actor_usr_lifecycle; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_lifecycle FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_lifecycle FROM evergreen;
GRANT ALL ON TABLE actor_usr_lifecycle TO evergreen;
GRANT ALL ON TABLE actor_usr_lifecycle TO bbonner;


--
-- Name: actor_usr_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE actor_usr_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE actor_usr_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE actor_usr_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE actor_usr_pkey_seq TO bbonner;


--
-- Name: actor_usr_setting_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_setting_history FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_setting_history FROM evergreen;
GRANT ALL ON TABLE actor_usr_setting_history TO evergreen;
GRANT ALL ON TABLE actor_usr_setting_history TO bbonner;


--
-- Name: actor_usr_setting_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE actor_usr_setting_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE actor_usr_setting_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE actor_usr_setting_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE actor_usr_setting_pkey_seq TO bbonner;


--
-- Name: asset_call_number_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number_history FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number_history FROM evergreen;
GRANT ALL ON TABLE asset_call_number_history TO evergreen;
GRANT ALL ON TABLE asset_call_number_history TO bbonner;


--
-- Name: asset_call_number_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE asset_call_number_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE asset_call_number_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE asset_call_number_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE asset_call_number_pkey_seq TO bbonner;


--
-- Name: asset_copy_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_history FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_history FROM evergreen;
GRANT ALL ON TABLE asset_copy_history TO evergreen;
GRANT ALL ON TABLE asset_copy_history TO bbonner;


--
-- Name: asset_copy_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE asset_copy_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE asset_copy_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE asset_copy_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE asset_copy_pkey_seq TO bbonner;


--
-- Name: biblio_record_entry_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_history FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_history FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_history TO evergreen;
GRANT ALL ON TABLE biblio_record_entry_history TO bbonner;


SET search_path = biblio, pg_catalog;

--
-- Name: record_entry; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON TABLE record_entry FROM PUBLIC;
REVOKE ALL ON TABLE record_entry FROM evergreen;
GRANT ALL ON TABLE record_entry TO evergreen;
GRANT ALL ON TABLE record_entry TO bbonner;
GRANT SELECT ON TABLE record_entry TO biblio;


SET search_path = auditor, pg_catalog;

--
-- Name: biblio_record_entry_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_record_entry_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_record_entry_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_pkey_seq TO bbonner;


--
-- Name: serial_unit_history; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON TABLE serial_unit_history FROM PUBLIC;
REVOKE ALL ON TABLE serial_unit_history FROM evergreen;
GRANT ALL ON TABLE serial_unit_history TO evergreen;
GRANT ALL ON TABLE serial_unit_history TO bbonner;


SET search_path = serial, pg_catalog;

--
-- Name: unit; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE unit FROM PUBLIC;
REVOKE ALL ON TABLE unit FROM evergreen;
GRANT ALL ON TABLE unit TO evergreen;
GRANT SELECT ON TABLE unit TO bbonner;


SET search_path = auditor, pg_catalog;

--
-- Name: serial_unit_pkey_seq; Type: ACL; Schema: auditor; Owner: evergreen
--

REVOKE ALL ON SEQUENCE serial_unit_pkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE serial_unit_pkey_seq FROM evergreen;
GRANT ALL ON SEQUENCE serial_unit_pkey_seq TO evergreen;
GRANT ALL ON SEQUENCE serial_unit_pkey_seq TO bbonner;


SET search_path = authority, pg_catalog;

--
-- Name: bib_linking; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE bib_linking FROM PUBLIC;
REVOKE ALL ON TABLE bib_linking FROM evergreen;
GRANT ALL ON TABLE bib_linking TO evergreen;
GRANT ALL ON TABLE bib_linking TO bbonner;
GRANT SELECT ON TABLE bib_linking TO biblio;


--
-- Name: bib_linking_id_seq; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bib_linking_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bib_linking_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE bib_linking_id_seq TO evergreen;
GRANT ALL ON SEQUENCE bib_linking_id_seq TO bbonner;


--
-- Name: full_rec_id_seq; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON SEQUENCE full_rec_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE full_rec_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE full_rec_id_seq TO evergreen;
GRANT ALL ON SEQUENCE full_rec_id_seq TO bbonner;


--
-- Name: rec_descriptor; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE rec_descriptor FROM PUBLIC;
REVOKE ALL ON TABLE rec_descriptor FROM evergreen;
GRANT ALL ON TABLE rec_descriptor TO evergreen;
GRANT ALL ON TABLE rec_descriptor TO bbonner;


--
-- Name: rec_descriptor_id_seq; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON SEQUENCE rec_descriptor_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rec_descriptor_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE rec_descriptor_id_seq TO evergreen;
GRANT ALL ON SEQUENCE rec_descriptor_id_seq TO bbonner;


--
-- Name: record_entry; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE record_entry FROM PUBLIC;
REVOKE ALL ON TABLE record_entry FROM evergreen;
GRANT ALL ON TABLE record_entry TO evergreen;
GRANT ALL ON TABLE record_entry TO bbonner;
GRANT SELECT ON TABLE record_entry TO biblio;


--
-- Name: record_entry_id_seq; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE record_entry_id_seq TO bbonner;


--
-- Name: record_note; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE record_note FROM PUBLIC;
REVOKE ALL ON TABLE record_note FROM evergreen;
GRANT ALL ON TABLE record_note TO evergreen;
GRANT ALL ON TABLE record_note TO bbonner;


--
-- Name: record_note_id_seq; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_note_id_seq TO evergreen;
GRANT ALL ON SEQUENCE record_note_id_seq TO bbonner;


--
-- Name: tracing_links; Type: ACL; Schema: authority; Owner: evergreen
--

REVOKE ALL ON TABLE tracing_links FROM PUBLIC;
REVOKE ALL ON TABLE tracing_links FROM evergreen;
GRANT ALL ON TABLE tracing_links TO evergreen;
GRANT ALL ON TABLE tracing_links TO bbonner;


SET search_path = biblio, pg_catalog;

--
-- Name: autogen_tcn_value_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE autogen_tcn_value_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE autogen_tcn_value_seq FROM evergreen;
GRANT ALL ON SEQUENCE autogen_tcn_value_seq TO evergreen;
GRANT ALL ON SEQUENCE autogen_tcn_value_seq TO bbonner;


--
-- Name: monograph_part; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON TABLE monograph_part FROM PUBLIC;
REVOKE ALL ON TABLE monograph_part FROM evergreen;
GRANT ALL ON TABLE monograph_part TO evergreen;
GRANT ALL ON TABLE monograph_part TO bbonner;


--
-- Name: monograph_part_id_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE monograph_part_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE monograph_part_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE monograph_part_id_seq TO evergreen;
GRANT ALL ON SEQUENCE monograph_part_id_seq TO bbonner;


--
-- Name: peer_bib_copy_map; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON TABLE peer_bib_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE peer_bib_copy_map FROM evergreen;
GRANT ALL ON TABLE peer_bib_copy_map TO evergreen;
GRANT ALL ON TABLE peer_bib_copy_map TO bbonner;


--
-- Name: peer_bib_copy_map_id_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE peer_bib_copy_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE peer_bib_copy_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE peer_bib_copy_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE peer_bib_copy_map_id_seq TO bbonner;


--
-- Name: peer_type; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON TABLE peer_type FROM PUBLIC;
REVOKE ALL ON TABLE peer_type FROM evergreen;
GRANT ALL ON TABLE peer_type TO evergreen;
GRANT ALL ON TABLE peer_type TO bbonner;


--
-- Name: peer_type_id_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE peer_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE peer_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE peer_type_id_seq TO evergreen;
GRANT ALL ON SEQUENCE peer_type_id_seq TO bbonner;


--
-- Name: record_entry_id_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE record_entry_id_seq TO bbonner;


--
-- Name: record_note; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON TABLE record_note FROM PUBLIC;
REVOKE ALL ON TABLE record_note FROM evergreen;
GRANT ALL ON TABLE record_note TO evergreen;
GRANT ALL ON TABLE record_note TO bbonner;


--
-- Name: record_note_id_seq; Type: ACL; Schema: biblio; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_note_id_seq TO evergreen;
GRANT ALL ON SEQUENCE record_note_id_seq TO bbonner;


SET search_path = booking, pg_catalog;

--
-- Name: reservation; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE reservation FROM PUBLIC;
REVOKE ALL ON TABLE reservation FROM evergreen;
GRANT ALL ON TABLE reservation TO evergreen;
GRANT SELECT ON TABLE reservation TO bbonner;


--
-- Name: reservation_attr_value_map; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE reservation_attr_value_map FROM PUBLIC;
REVOKE ALL ON TABLE reservation_attr_value_map FROM evergreen;
GRANT ALL ON TABLE reservation_attr_value_map TO evergreen;
GRANT SELECT ON TABLE reservation_attr_value_map TO bbonner;


--
-- Name: reservation_attr_value_map_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE reservation_attr_value_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE reservation_attr_value_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE reservation_attr_value_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE reservation_attr_value_map_id_seq TO bbonner;


--
-- Name: resource; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE resource FROM PUBLIC;
REVOKE ALL ON TABLE resource FROM evergreen;
GRANT ALL ON TABLE resource TO evergreen;
GRANT SELECT ON TABLE resource TO bbonner;


--
-- Name: resource_attr; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE resource_attr FROM PUBLIC;
REVOKE ALL ON TABLE resource_attr FROM evergreen;
GRANT ALL ON TABLE resource_attr TO evergreen;
GRANT SELECT ON TABLE resource_attr TO bbonner;


--
-- Name: resource_attr_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE resource_attr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE resource_attr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE resource_attr_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE resource_attr_id_seq TO bbonner;


--
-- Name: resource_attr_map; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE resource_attr_map FROM PUBLIC;
REVOKE ALL ON TABLE resource_attr_map FROM evergreen;
GRANT ALL ON TABLE resource_attr_map TO evergreen;
GRANT SELECT ON TABLE resource_attr_map TO bbonner;


--
-- Name: resource_attr_map_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE resource_attr_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE resource_attr_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE resource_attr_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE resource_attr_map_id_seq TO bbonner;


--
-- Name: resource_attr_value; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE resource_attr_value FROM PUBLIC;
REVOKE ALL ON TABLE resource_attr_value FROM evergreen;
GRANT ALL ON TABLE resource_attr_value TO evergreen;
GRANT SELECT ON TABLE resource_attr_value TO bbonner;


--
-- Name: resource_attr_value_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE resource_attr_value_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE resource_attr_value_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE resource_attr_value_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE resource_attr_value_id_seq TO bbonner;


--
-- Name: resource_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE resource_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE resource_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE resource_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE resource_id_seq TO bbonner;


--
-- Name: resource_type; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON TABLE resource_type FROM PUBLIC;
REVOKE ALL ON TABLE resource_type FROM evergreen;
GRANT ALL ON TABLE resource_type TO evergreen;
GRANT SELECT ON TABLE resource_type TO bbonner;


--
-- Name: resource_type_id_seq; Type: ACL; Schema: booking; Owner: evergreen
--

REVOKE ALL ON SEQUENCE resource_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE resource_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE resource_type_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE resource_type_id_seq TO bbonner;


SET search_path = config, pg_catalog;

--
-- Name: coded_value_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE coded_value_map FROM PUBLIC;
REVOKE ALL ON TABLE coded_value_map FROM evergreen;
GRANT ALL ON TABLE coded_value_map TO evergreen;
GRANT ALL ON TABLE coded_value_map TO bbonner;


--
-- Name: audience_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE audience_map FROM PUBLIC;
REVOKE ALL ON TABLE audience_map FROM evergreen;
GRANT ALL ON TABLE audience_map TO evergreen;
GRANT ALL ON TABLE audience_map TO bbonner;


--
-- Name: backup_circ_limit_set; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE backup_circ_limit_set FROM PUBLIC;
REVOKE ALL ON TABLE backup_circ_limit_set FROM evergreen;
GRANT ALL ON TABLE backup_circ_limit_set TO evergreen;
GRANT ALL ON TABLE backup_circ_limit_set TO bbonner;


--
-- Name: backup_circ_limit_set_circ_mod_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE backup_circ_limit_set_circ_mod_map FROM PUBLIC;
REVOKE ALL ON TABLE backup_circ_limit_set_circ_mod_map FROM evergreen;
GRANT ALL ON TABLE backup_circ_limit_set_circ_mod_map TO evergreen;
GRANT ALL ON TABLE backup_circ_limit_set_circ_mod_map TO bbonner;


--
-- Name: backup_circ_limit_set_group_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE backup_circ_limit_set_group_map FROM PUBLIC;
REVOKE ALL ON TABLE backup_circ_limit_set_group_map FROM evergreen;
GRANT ALL ON TABLE backup_circ_limit_set_group_map TO evergreen;
GRANT ALL ON TABLE backup_circ_limit_set_group_map TO bbonner;


--
-- Name: backup_circ_matrix_limit_set_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE backup_circ_matrix_limit_set_map FROM PUBLIC;
REVOKE ALL ON TABLE backup_circ_matrix_limit_set_map FROM evergreen;
GRANT ALL ON TABLE backup_circ_matrix_limit_set_map TO evergreen;
GRANT ALL ON TABLE backup_circ_matrix_limit_set_map TO bbonner;


--
-- Name: backup_circ_matrix_matchpoint; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE backup_circ_matrix_matchpoint FROM PUBLIC;
REVOKE ALL ON TABLE backup_circ_matrix_matchpoint FROM evergreen;
GRANT ALL ON TABLE backup_circ_matrix_matchpoint TO evergreen;
GRANT ALL ON TABLE backup_circ_matrix_matchpoint TO bbonner;


--
-- Name: barcode_completion; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE barcode_completion FROM PUBLIC;
REVOKE ALL ON TABLE barcode_completion FROM evergreen;
GRANT ALL ON TABLE barcode_completion TO evergreen;
GRANT ALL ON TABLE barcode_completion TO bbonner;


--
-- Name: barcode_completion_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE barcode_completion_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE barcode_completion_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE barcode_completion_id_seq TO evergreen;
GRANT ALL ON SEQUENCE barcode_completion_id_seq TO bbonner;


--
-- Name: best_hold_order; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE best_hold_order FROM PUBLIC;
REVOKE ALL ON TABLE best_hold_order FROM evergreen;
GRANT ALL ON TABLE best_hold_order TO evergreen;
GRANT ALL ON TABLE best_hold_order TO bbonner;


--
-- Name: best_hold_order_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE best_hold_order_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE best_hold_order_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE best_hold_order_id_seq TO evergreen;
GRANT ALL ON SEQUENCE best_hold_order_id_seq TO bbonner;


--
-- Name: bib_level_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE bib_level_map FROM PUBLIC;
REVOKE ALL ON TABLE bib_level_map FROM evergreen;
GRANT ALL ON TABLE bib_level_map TO evergreen;
GRANT ALL ON TABLE bib_level_map TO bbonner;


--
-- Name: bib_source; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE bib_source FROM PUBLIC;
REVOKE ALL ON TABLE bib_source FROM evergreen;
GRANT ALL ON TABLE bib_source TO evergreen;
GRANT ALL ON TABLE bib_source TO bbonner;


--
-- Name: bib_source_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bib_source_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bib_source_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE bib_source_id_seq TO evergreen;
GRANT ALL ON SEQUENCE bib_source_id_seq TO bbonner;


--
-- Name: biblio_fingerprint; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_fingerprint FROM PUBLIC;
REVOKE ALL ON TABLE biblio_fingerprint FROM evergreen;
GRANT ALL ON TABLE biblio_fingerprint TO evergreen;
GRANT ALL ON TABLE biblio_fingerprint TO bbonner;


--
-- Name: biblio_fingerprint_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_fingerprint_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_fingerprint_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_fingerprint_id_seq TO evergreen;
GRANT ALL ON SEQUENCE biblio_fingerprint_id_seq TO bbonner;


--
-- Name: billing_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE billing_type FROM PUBLIC;
REVOKE ALL ON TABLE billing_type FROM evergreen;
GRANT ALL ON TABLE billing_type TO evergreen;
GRANT ALL ON TABLE billing_type TO bbonner;


--
-- Name: billing_type_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE billing_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE billing_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE billing_type_id_seq TO evergreen;
GRANT ALL ON SEQUENCE billing_type_id_seq TO bbonner;


--
-- Name: circ_limit_group; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_limit_group FROM PUBLIC;
REVOKE ALL ON TABLE circ_limit_group FROM evergreen;
GRANT ALL ON TABLE circ_limit_group TO evergreen;
GRANT ALL ON TABLE circ_limit_group TO bbonner;


--
-- Name: circ_limit_group_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_limit_group_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_limit_group_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_limit_group_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_limit_group_id_seq TO bbonner;


--
-- Name: circ_limit_set; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_limit_set FROM PUBLIC;
REVOKE ALL ON TABLE circ_limit_set FROM evergreen;
GRANT ALL ON TABLE circ_limit_set TO evergreen;
GRANT ALL ON TABLE circ_limit_set TO bbonner;


--
-- Name: circ_limit_set_circ_mod_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_limit_set_circ_mod_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_limit_set_circ_mod_map FROM evergreen;
GRANT ALL ON TABLE circ_limit_set_circ_mod_map TO evergreen;
GRANT ALL ON TABLE circ_limit_set_circ_mod_map TO bbonner;


--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_limit_set_circ_mod_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_limit_set_circ_mod_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_circ_mod_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_circ_mod_map_id_seq TO bbonner;


--
-- Name: circ_limit_set_copy_loc_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_limit_set_copy_loc_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_limit_set_copy_loc_map FROM evergreen;
GRANT ALL ON TABLE circ_limit_set_copy_loc_map TO evergreen;
GRANT ALL ON TABLE circ_limit_set_copy_loc_map TO bbonner;


--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_limit_set_copy_loc_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_limit_set_copy_loc_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_copy_loc_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_copy_loc_map_id_seq TO bbonner;


--
-- Name: circ_limit_set_group_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_limit_set_group_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_limit_set_group_map FROM evergreen;
GRANT ALL ON TABLE circ_limit_set_group_map TO evergreen;
GRANT ALL ON TABLE circ_limit_set_group_map TO bbonner;


--
-- Name: circ_limit_set_group_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_limit_set_group_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_limit_set_group_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_group_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_group_map_id_seq TO bbonner;


--
-- Name: circ_limit_set_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_limit_set_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_limit_set_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_limit_set_id_seq TO bbonner;


--
-- Name: circ_matrix_circ_mod_test; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_matrix_circ_mod_test FROM PUBLIC;
REVOKE ALL ON TABLE circ_matrix_circ_mod_test FROM evergreen;
GRANT ALL ON TABLE circ_matrix_circ_mod_test TO evergreen;
GRANT ALL ON TABLE circ_matrix_circ_mod_test TO bbonner;


--
-- Name: circ_matrix_circ_mod_test_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_matrix_circ_mod_test_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_matrix_circ_mod_test_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_matrix_circ_mod_test_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_matrix_circ_mod_test_id_seq TO bbonner;


--
-- Name: circ_matrix_circ_mod_test_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_matrix_circ_mod_test_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_matrix_circ_mod_test_map FROM evergreen;
GRANT ALL ON TABLE circ_matrix_circ_mod_test_map TO evergreen;
GRANT ALL ON TABLE circ_matrix_circ_mod_test_map TO bbonner;


--
-- Name: circ_matrix_circ_mod_test_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_matrix_circ_mod_test_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_matrix_circ_mod_test_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_matrix_circ_mod_test_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_matrix_circ_mod_test_map_id_seq TO bbonner;


--
-- Name: circ_matrix_limit_set_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_matrix_limit_set_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_matrix_limit_set_map FROM evergreen;
GRANT ALL ON TABLE circ_matrix_limit_set_map TO evergreen;
GRANT ALL ON TABLE circ_matrix_limit_set_map TO bbonner;


--
-- Name: circ_matrix_limit_set_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_matrix_limit_set_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_matrix_limit_set_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_matrix_limit_set_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_matrix_limit_set_map_id_seq TO bbonner;


--
-- Name: circ_matrix_matchpoint_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_matrix_matchpoint_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_matrix_matchpoint_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_matrix_matchpoint_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_matrix_matchpoint_id_seq TO bbonner;


--
-- Name: circ_matrix_weights; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_matrix_weights FROM PUBLIC;
REVOKE ALL ON TABLE circ_matrix_weights FROM evergreen;
GRANT ALL ON TABLE circ_matrix_weights TO evergreen;
GRANT ALL ON TABLE circ_matrix_weights TO bbonner;


--
-- Name: circ_matrix_weights_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE circ_matrix_weights_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE circ_matrix_weights_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE circ_matrix_weights_id_seq TO evergreen;
GRANT ALL ON SEQUENCE circ_matrix_weights_id_seq TO bbonner;


--
-- Name: circ_modifier; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE circ_modifier FROM PUBLIC;
REVOKE ALL ON TABLE circ_modifier FROM evergreen;
GRANT ALL ON TABLE circ_modifier TO evergreen;
GRANT ALL ON TABLE circ_modifier TO bbonner;
GRANT SELECT ON TABLE circ_modifier TO biblio;


--
-- Name: coded_value_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE coded_value_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE coded_value_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE coded_value_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE coded_value_map_id_seq TO bbonner;


--
-- Name: copy_status; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE copy_status FROM PUBLIC;
REVOKE ALL ON TABLE copy_status FROM evergreen;
GRANT ALL ON TABLE copy_status TO evergreen;
GRANT ALL ON TABLE copy_status TO bbonner;
GRANT SELECT ON TABLE copy_status TO biblio;


--
-- Name: copy_status_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_status_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_status_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_status_id_seq TO evergreen;
GRANT ALL ON SEQUENCE copy_status_id_seq TO bbonner;


--
-- Name: db_patch_dependencies; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE db_patch_dependencies FROM PUBLIC;
REVOKE ALL ON TABLE db_patch_dependencies FROM evergreen;
GRANT ALL ON TABLE db_patch_dependencies TO evergreen;
GRANT ALL ON TABLE db_patch_dependencies TO bbonner;


--
-- Name: filter_dialog_filter_set; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE filter_dialog_filter_set FROM PUBLIC;
REVOKE ALL ON TABLE filter_dialog_filter_set FROM evergreen;
GRANT ALL ON TABLE filter_dialog_filter_set TO evergreen;
GRANT ALL ON TABLE filter_dialog_filter_set TO bbonner;


--
-- Name: filter_dialog_filter_set_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE filter_dialog_filter_set_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE filter_dialog_filter_set_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE filter_dialog_filter_set_id_seq TO evergreen;
GRANT ALL ON SEQUENCE filter_dialog_filter_set_id_seq TO bbonner;


--
-- Name: filter_dialog_interface; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE filter_dialog_interface FROM PUBLIC;
REVOKE ALL ON TABLE filter_dialog_interface FROM evergreen;
GRANT ALL ON TABLE filter_dialog_interface TO evergreen;
GRANT ALL ON TABLE filter_dialog_interface TO bbonner;


--
-- Name: internal_flag; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE internal_flag FROM PUBLIC;
REVOKE ALL ON TABLE internal_flag FROM evergreen;
GRANT ALL ON TABLE internal_flag TO evergreen;
GRANT ALL ON TABLE internal_flag TO bbonner;


--
-- Name: global_flag; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE global_flag FROM PUBLIC;
REVOKE ALL ON TABLE global_flag FROM evergreen;
GRANT ALL ON TABLE global_flag TO evergreen;
GRANT ALL ON TABLE global_flag TO bbonner;


--
-- Name: hard_due_date; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE hard_due_date FROM PUBLIC;
REVOKE ALL ON TABLE hard_due_date FROM evergreen;
GRANT ALL ON TABLE hard_due_date TO evergreen;
GRANT ALL ON TABLE hard_due_date TO bbonner;


--
-- Name: hard_due_date_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hard_due_date_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hard_due_date_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hard_due_date_id_seq TO evergreen;
GRANT ALL ON SEQUENCE hard_due_date_id_seq TO bbonner;


--
-- Name: hard_due_date_values; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE hard_due_date_values FROM PUBLIC;
REVOKE ALL ON TABLE hard_due_date_values FROM evergreen;
GRANT ALL ON TABLE hard_due_date_values TO evergreen;
GRANT ALL ON TABLE hard_due_date_values TO bbonner;


--
-- Name: hard_due_date_values_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hard_due_date_values_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hard_due_date_values_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hard_due_date_values_id_seq TO evergreen;
GRANT ALL ON SEQUENCE hard_due_date_values_id_seq TO bbonner;


--
-- Name: hold_matrix_matchpoint; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE hold_matrix_matchpoint FROM PUBLIC;
REVOKE ALL ON TABLE hold_matrix_matchpoint FROM evergreen;
GRANT ALL ON TABLE hold_matrix_matchpoint TO evergreen;
GRANT ALL ON TABLE hold_matrix_matchpoint TO bbonner;


--
-- Name: hold_matrix_matchpoint_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_matrix_matchpoint_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_matrix_matchpoint_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_matrix_matchpoint_id_seq TO evergreen;
GRANT ALL ON SEQUENCE hold_matrix_matchpoint_id_seq TO bbonner;


--
-- Name: hold_matrix_weights; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE hold_matrix_weights FROM PUBLIC;
REVOKE ALL ON TABLE hold_matrix_weights FROM evergreen;
GRANT ALL ON TABLE hold_matrix_weights TO evergreen;
GRANT ALL ON TABLE hold_matrix_weights TO bbonner;


--
-- Name: hold_matrix_weights_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE hold_matrix_weights_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE hold_matrix_weights_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE hold_matrix_weights_id_seq TO evergreen;
GRANT ALL ON SEQUENCE hold_matrix_weights_id_seq TO bbonner;


--
-- Name: i18n_core; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE i18n_core FROM PUBLIC;
REVOKE ALL ON TABLE i18n_core FROM evergreen;
GRANT ALL ON TABLE i18n_core TO evergreen;
GRANT ALL ON TABLE i18n_core TO bbonner;


--
-- Name: i18n_core_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE i18n_core_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE i18n_core_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE i18n_core_id_seq TO evergreen;
GRANT ALL ON SEQUENCE i18n_core_id_seq TO bbonner;


--
-- Name: i18n_locale; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE i18n_locale FROM PUBLIC;
REVOKE ALL ON TABLE i18n_locale FROM evergreen;
GRANT ALL ON TABLE i18n_locale TO evergreen;
GRANT ALL ON TABLE i18n_locale TO bbonner;


--
-- Name: identification_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE identification_type FROM PUBLIC;
REVOKE ALL ON TABLE identification_type FROM evergreen;
GRANT ALL ON TABLE identification_type TO evergreen;
GRANT ALL ON TABLE identification_type TO bbonner;


--
-- Name: identification_type_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE identification_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE identification_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE identification_type_id_seq TO evergreen;
GRANT ALL ON SEQUENCE identification_type_id_seq TO bbonner;


--
-- Name: idl_field_doc; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE idl_field_doc FROM PUBLIC;
REVOKE ALL ON TABLE idl_field_doc FROM evergreen;
GRANT ALL ON TABLE idl_field_doc TO evergreen;
GRANT ALL ON TABLE idl_field_doc TO bbonner;


--
-- Name: idl_field_doc_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE idl_field_doc_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE idl_field_doc_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE idl_field_doc_id_seq TO evergreen;
GRANT ALL ON SEQUENCE idl_field_doc_id_seq TO bbonner;


--
-- Name: index_normalizer; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE index_normalizer FROM PUBLIC;
REVOKE ALL ON TABLE index_normalizer FROM evergreen;
GRANT ALL ON TABLE index_normalizer TO evergreen;
GRANT ALL ON TABLE index_normalizer TO bbonner;


--
-- Name: index_normalizer_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE index_normalizer_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE index_normalizer_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE index_normalizer_id_seq TO evergreen;
GRANT ALL ON SEQUENCE index_normalizer_id_seq TO bbonner;


--
-- Name: item_form_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE item_form_map FROM PUBLIC;
REVOKE ALL ON TABLE item_form_map FROM evergreen;
GRANT ALL ON TABLE item_form_map TO evergreen;
GRANT ALL ON TABLE item_form_map TO bbonner;


--
-- Name: item_type_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE item_type_map FROM PUBLIC;
REVOKE ALL ON TABLE item_type_map FROM evergreen;
GRANT ALL ON TABLE item_type_map TO evergreen;
GRANT ALL ON TABLE item_type_map TO bbonner;


--
-- Name: language_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE language_map FROM PUBLIC;
REVOKE ALL ON TABLE language_map FROM evergreen;
GRANT ALL ON TABLE language_map TO evergreen;
GRANT ALL ON TABLE language_map TO bbonner;


--
-- Name: lit_form_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE lit_form_map FROM PUBLIC;
REVOKE ALL ON TABLE lit_form_map FROM evergreen;
GRANT ALL ON TABLE lit_form_map TO evergreen;
GRANT ALL ON TABLE lit_form_map TO bbonner;


--
-- Name: marc21_ff_pos_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE marc21_ff_pos_map FROM PUBLIC;
REVOKE ALL ON TABLE marc21_ff_pos_map FROM evergreen;
GRANT ALL ON TABLE marc21_ff_pos_map TO evergreen;
GRANT ALL ON TABLE marc21_ff_pos_map TO bbonner;


--
-- Name: marc21_ff_pos_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE marc21_ff_pos_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE marc21_ff_pos_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE marc21_ff_pos_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE marc21_ff_pos_map_id_seq TO bbonner;


--
-- Name: marc21_physical_characteristic_subfield_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE marc21_physical_characteristic_subfield_map FROM PUBLIC;
REVOKE ALL ON TABLE marc21_physical_characteristic_subfield_map FROM evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_subfield_map TO evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_subfield_map TO bbonner;


--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE marc21_physical_characteristic_subfield_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE marc21_physical_characteristic_subfield_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE marc21_physical_characteristic_subfield_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE marc21_physical_characteristic_subfield_map_id_seq TO bbonner;


--
-- Name: marc21_physical_characteristic_type_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE marc21_physical_characteristic_type_map FROM PUBLIC;
REVOKE ALL ON TABLE marc21_physical_characteristic_type_map FROM evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_type_map TO evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_type_map TO bbonner;


--
-- Name: marc21_physical_characteristic_value_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE marc21_physical_characteristic_value_map FROM PUBLIC;
REVOKE ALL ON TABLE marc21_physical_characteristic_value_map FROM evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_value_map TO evergreen;
GRANT ALL ON TABLE marc21_physical_characteristic_value_map TO bbonner;


--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE marc21_physical_characteristic_value_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE marc21_physical_characteristic_value_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE marc21_physical_characteristic_value_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE marc21_physical_characteristic_value_map_id_seq TO bbonner;


--
-- Name: metabib_class; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_class FROM PUBLIC;
REVOKE ALL ON TABLE metabib_class FROM evergreen;
GRANT ALL ON TABLE metabib_class TO evergreen;
GRANT ALL ON TABLE metabib_class TO bbonner;


--
-- Name: metabib_class_ts_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_class_ts_map FROM PUBLIC;
REVOKE ALL ON TABLE metabib_class_ts_map FROM evergreen;
GRANT ALL ON TABLE metabib_class_ts_map TO evergreen;
GRANT ALL ON TABLE metabib_class_ts_map TO bbonner;


--
-- Name: metabib_class_ts_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metabib_class_ts_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabib_class_ts_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metabib_class_ts_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metabib_class_ts_map_id_seq TO bbonner;


--
-- Name: metabib_field; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_field FROM PUBLIC;
REVOKE ALL ON TABLE metabib_field FROM evergreen;
GRANT ALL ON TABLE metabib_field TO evergreen;
GRANT ALL ON TABLE metabib_field TO bbonner;


--
-- Name: metabib_field_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metabib_field_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabib_field_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metabib_field_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metabib_field_id_seq TO bbonner;


--
-- Name: metabib_field_index_norm_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_field_index_norm_map FROM PUBLIC;
REVOKE ALL ON TABLE metabib_field_index_norm_map FROM evergreen;
GRANT ALL ON TABLE metabib_field_index_norm_map TO evergreen;
GRANT ALL ON TABLE metabib_field_index_norm_map TO bbonner;


--
-- Name: metabib_field_index_norm_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metabib_field_index_norm_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabib_field_index_norm_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metabib_field_index_norm_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metabib_field_index_norm_map_id_seq TO bbonner;


--
-- Name: metabib_field_ts_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_field_ts_map FROM PUBLIC;
REVOKE ALL ON TABLE metabib_field_ts_map FROM evergreen;
GRANT ALL ON TABLE metabib_field_ts_map TO evergreen;
GRANT ALL ON TABLE metabib_field_ts_map TO bbonner;


--
-- Name: metabib_field_ts_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metabib_field_ts_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabib_field_ts_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metabib_field_ts_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metabib_field_ts_map_id_seq TO bbonner;


--
-- Name: metabib_search_alias; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_search_alias FROM PUBLIC;
REVOKE ALL ON TABLE metabib_search_alias FROM evergreen;
GRANT ALL ON TABLE metabib_search_alias TO evergreen;
GRANT ALL ON TABLE metabib_search_alias TO bbonner;


--
-- Name: net_access_level; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE net_access_level FROM PUBLIC;
REVOKE ALL ON TABLE net_access_level FROM evergreen;
GRANT ALL ON TABLE net_access_level TO evergreen;
GRANT ALL ON TABLE net_access_level TO bbonner;


--
-- Name: net_access_level_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE net_access_level_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE net_access_level_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE net_access_level_id_seq TO evergreen;
GRANT ALL ON SEQUENCE net_access_level_id_seq TO bbonner;


--
-- Name: non_cataloged_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE non_cataloged_type FROM PUBLIC;
REVOKE ALL ON TABLE non_cataloged_type FROM evergreen;
GRANT ALL ON TABLE non_cataloged_type TO evergreen;
GRANT ALL ON TABLE non_cataloged_type TO bbonner;


--
-- Name: non_cataloged_type_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE non_cataloged_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE non_cataloged_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE non_cataloged_type_id_seq TO evergreen;
GRANT ALL ON SEQUENCE non_cataloged_type_id_seq TO bbonner;


--
-- Name: org_unit_setting_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_setting_type FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_setting_type FROM evergreen;
GRANT ALL ON TABLE org_unit_setting_type TO evergreen;
GRANT ALL ON TABLE org_unit_setting_type TO bbonner;


--
-- Name: org_unit_setting_type_log; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_setting_type_log FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_setting_type_log FROM evergreen;
GRANT ALL ON TABLE org_unit_setting_type_log TO evergreen;
GRANT ALL ON TABLE org_unit_setting_type_log TO bbonner;


--
-- Name: org_unit_setting_type_log_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE org_unit_setting_type_log_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE org_unit_setting_type_log_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE org_unit_setting_type_log_id_seq TO evergreen;
GRANT ALL ON SEQUENCE org_unit_setting_type_log_id_seq TO bbonner;


--
-- Name: patron_message; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE patron_message FROM PUBLIC;
REVOKE ALL ON TABLE patron_message FROM evergreen;
GRANT ALL ON TABLE patron_message TO evergreen;
GRANT ALL ON TABLE patron_message TO bbonner;


--
-- Name: patron_message_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE patron_message_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE patron_message_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE patron_message_id_seq TO evergreen;
GRANT ALL ON SEQUENCE patron_message_id_seq TO bbonner;


--
-- Name: record_attr_definition; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE record_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE record_attr_definition FROM evergreen;
GRANT ALL ON TABLE record_attr_definition TO evergreen;
GRANT ALL ON TABLE record_attr_definition TO bbonner;


--
-- Name: record_attr_index_norm_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE record_attr_index_norm_map FROM PUBLIC;
REVOKE ALL ON TABLE record_attr_index_norm_map FROM evergreen;
GRANT ALL ON TABLE record_attr_index_norm_map TO evergreen;
GRANT ALL ON TABLE record_attr_index_norm_map TO bbonner;


--
-- Name: record_attr_index_norm_map_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_attr_index_norm_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_attr_index_norm_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_attr_index_norm_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE record_attr_index_norm_map_id_seq TO bbonner;


--
-- Name: rule_age_hold_protect; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE rule_age_hold_protect FROM PUBLIC;
REVOKE ALL ON TABLE rule_age_hold_protect FROM evergreen;
GRANT ALL ON TABLE rule_age_hold_protect TO evergreen;
GRANT ALL ON TABLE rule_age_hold_protect TO bbonner;


--
-- Name: rule_age_hold_protect_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE rule_age_hold_protect_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rule_age_hold_protect_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE rule_age_hold_protect_id_seq TO evergreen;
GRANT ALL ON SEQUENCE rule_age_hold_protect_id_seq TO bbonner;


--
-- Name: rule_circ_duration; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE rule_circ_duration FROM PUBLIC;
REVOKE ALL ON TABLE rule_circ_duration FROM evergreen;
GRANT ALL ON TABLE rule_circ_duration TO evergreen;
GRANT ALL ON TABLE rule_circ_duration TO bbonner;
GRANT SELECT ON TABLE rule_circ_duration TO biblio;


--
-- Name: rule_circ_duration_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE rule_circ_duration_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rule_circ_duration_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE rule_circ_duration_id_seq TO evergreen;
GRANT ALL ON SEQUENCE rule_circ_duration_id_seq TO bbonner;


--
-- Name: rule_max_fine; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE rule_max_fine FROM PUBLIC;
REVOKE ALL ON TABLE rule_max_fine FROM evergreen;
GRANT ALL ON TABLE rule_max_fine TO evergreen;
GRANT ALL ON TABLE rule_max_fine TO bbonner;


--
-- Name: rule_max_fine_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE rule_max_fine_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rule_max_fine_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE rule_max_fine_id_seq TO evergreen;
GRANT ALL ON SEQUENCE rule_max_fine_id_seq TO bbonner;


--
-- Name: rule_recurring_fine; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE rule_recurring_fine FROM PUBLIC;
REVOKE ALL ON TABLE rule_recurring_fine FROM evergreen;
GRANT ALL ON TABLE rule_recurring_fine TO evergreen;
GRANT ALL ON TABLE rule_recurring_fine TO bbonner;


--
-- Name: rule_recurring_fine_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE rule_recurring_fine_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rule_recurring_fine_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE rule_recurring_fine_id_seq TO evergreen;
GRANT ALL ON SEQUENCE rule_recurring_fine_id_seq TO bbonner;


--
-- Name: settings_group; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE settings_group FROM PUBLIC;
REVOKE ALL ON TABLE settings_group FROM evergreen;
GRANT ALL ON TABLE settings_group TO evergreen;
GRANT ALL ON TABLE settings_group TO bbonner;


--
-- Name: sms_carrier; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE sms_carrier FROM PUBLIC;
REVOKE ALL ON TABLE sms_carrier FROM evergreen;
GRANT ALL ON TABLE sms_carrier TO evergreen;
GRANT ALL ON TABLE sms_carrier TO bbonner;


--
-- Name: sms_carrier_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE sms_carrier_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE sms_carrier_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE sms_carrier_id_seq TO evergreen;
GRANT ALL ON SEQUENCE sms_carrier_id_seq TO bbonner;


--
-- Name: standing; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE standing FROM PUBLIC;
REVOKE ALL ON TABLE standing FROM evergreen;
GRANT ALL ON TABLE standing TO evergreen;
GRANT ALL ON TABLE standing TO bbonner;


--
-- Name: standing_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE standing_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE standing_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE standing_id_seq TO evergreen;
GRANT ALL ON SEQUENCE standing_id_seq TO bbonner;


--
-- Name: standing_penalty; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE standing_penalty FROM PUBLIC;
REVOKE ALL ON TABLE standing_penalty FROM evergreen;
GRANT ALL ON TABLE standing_penalty TO evergreen;
GRANT ALL ON TABLE standing_penalty TO bbonner;


--
-- Name: standing_penalty_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE standing_penalty_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE standing_penalty_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE standing_penalty_id_seq TO evergreen;
GRANT ALL ON SEQUENCE standing_penalty_id_seq TO bbonner;


--
-- Name: ts_config_list; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE ts_config_list FROM PUBLIC;
REVOKE ALL ON TABLE ts_config_list FROM evergreen;
GRANT ALL ON TABLE ts_config_list TO evergreen;
GRANT ALL ON TABLE ts_config_list TO bbonner;


--
-- Name: upgrade_log; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE upgrade_log FROM PUBLIC;
REVOKE ALL ON TABLE upgrade_log FROM evergreen;
GRANT ALL ON TABLE upgrade_log TO evergreen;
GRANT ALL ON TABLE upgrade_log TO bbonner;


--
-- Name: usr_activity_type_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_activity_type_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_activity_type_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_activity_type_id_seq TO evergreen;
GRANT ALL ON SEQUENCE usr_activity_type_id_seq TO bbonner;


--
-- Name: usr_setting_type; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE usr_setting_type FROM PUBLIC;
REVOKE ALL ON TABLE usr_setting_type FROM evergreen;
GRANT ALL ON TABLE usr_setting_type TO evergreen;
GRANT ALL ON TABLE usr_setting_type TO bbonner;


--
-- Name: videorecording_format_map; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE videorecording_format_map FROM PUBLIC;
REVOKE ALL ON TABLE videorecording_format_map FROM evergreen;
GRANT ALL ON TABLE videorecording_format_map TO evergreen;
GRANT ALL ON TABLE videorecording_format_map TO bbonner;


--
-- Name: weight_assoc; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE weight_assoc FROM PUBLIC;
REVOKE ALL ON TABLE weight_assoc FROM evergreen;
GRANT ALL ON TABLE weight_assoc TO evergreen;
GRANT ALL ON TABLE weight_assoc TO bbonner;


--
-- Name: weight_assoc_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE weight_assoc_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE weight_assoc_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE weight_assoc_id_seq TO evergreen;
GRANT ALL ON SEQUENCE weight_assoc_id_seq TO bbonner;


--
-- Name: xml_transform; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE xml_transform FROM PUBLIC;
REVOKE ALL ON TABLE xml_transform FROM evergreen;
GRANT ALL ON TABLE xml_transform TO evergreen;
GRANT ALL ON TABLE xml_transform TO bbonner;


--
-- Name: xml_transform_back; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE xml_transform_back FROM PUBLIC;
REVOKE ALL ON TABLE xml_transform_back FROM evergreen;
GRANT ALL ON TABLE xml_transform_back TO evergreen;
GRANT ALL ON TABLE xml_transform_back TO bbonner;


--
-- Name: z3950_attr; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE z3950_attr FROM PUBLIC;
REVOKE ALL ON TABLE z3950_attr FROM evergreen;
GRANT ALL ON TABLE z3950_attr TO evergreen;
GRANT ALL ON TABLE z3950_attr TO bbonner;


--
-- Name: z3950_attr_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE z3950_attr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE z3950_attr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE z3950_attr_id_seq TO evergreen;
GRANT ALL ON SEQUENCE z3950_attr_id_seq TO bbonner;


--
-- Name: z3950_source; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON TABLE z3950_source FROM PUBLIC;
REVOKE ALL ON TABLE z3950_source FROM evergreen;
GRANT ALL ON TABLE z3950_source TO evergreen;
GRANT ALL ON TABLE z3950_source TO bbonner;


--
-- Name: z3950_source_credentials_id_seq; Type: ACL; Schema: config; Owner: evergreen
--

REVOKE ALL ON SEQUENCE z3950_source_credentials_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE z3950_source_credentials_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE z3950_source_credentials_id_seq TO evergreen;
GRANT ALL ON SEQUENCE z3950_source_credentials_id_seq TO bbonner;


SET search_path = container, pg_catalog;

--
-- Name: biblio_record_entry_bucket; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_bucket FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_bucket FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_bucket TO evergreen;
GRANT SELECT ON TABLE biblio_record_entry_bucket TO bbonner;


--
-- Name: biblio_record_entry_bucket_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_bucket_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE biblio_record_entry_bucket_id_seq TO bbonner;


--
-- Name: biblio_record_entry_bucket_item; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_bucket_item FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_bucket_item TO evergreen;
GRANT SELECT ON TABLE biblio_record_entry_bucket_item TO bbonner;


--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_bucket_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE biblio_record_entry_bucket_item_id_seq TO bbonner;


--
-- Name: biblio_record_entry_bucket_item_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_bucket_item_note FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_bucket_item_note FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_bucket_item_note TO evergreen;
GRANT SELECT ON TABLE biblio_record_entry_bucket_item_note TO bbonner;


--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_item_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_item_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_bucket_item_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE biblio_record_entry_bucket_item_note_id_seq TO bbonner;


--
-- Name: biblio_record_entry_bucket_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_bucket_note FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_bucket_note FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_bucket_note TO evergreen;
GRANT SELECT ON TABLE biblio_record_entry_bucket_note TO bbonner;


--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE biblio_record_entry_bucket_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE biblio_record_entry_bucket_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE biblio_record_entry_bucket_note_id_seq TO bbonner;


--
-- Name: biblio_record_entry_bucket_type; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE biblio_record_entry_bucket_type FROM PUBLIC;
REVOKE ALL ON TABLE biblio_record_entry_bucket_type FROM evergreen;
GRANT ALL ON TABLE biblio_record_entry_bucket_type TO evergreen;
GRANT SELECT ON TABLE biblio_record_entry_bucket_type TO bbonner;


--
-- Name: call_number_bucket; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_bucket FROM PUBLIC;
REVOKE ALL ON TABLE call_number_bucket FROM evergreen;
GRANT ALL ON TABLE call_number_bucket TO evergreen;
GRANT SELECT ON TABLE call_number_bucket TO bbonner;


--
-- Name: call_number_bucket_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_bucket_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_bucket_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_bucket_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE call_number_bucket_id_seq TO bbonner;


--
-- Name: call_number_bucket_item; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE call_number_bucket_item FROM evergreen;
GRANT ALL ON TABLE call_number_bucket_item TO evergreen;
GRANT SELECT ON TABLE call_number_bucket_item TO bbonner;


--
-- Name: call_number_bucket_item_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_bucket_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_bucket_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_bucket_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE call_number_bucket_item_id_seq TO bbonner;


--
-- Name: call_number_bucket_item_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_bucket_item_note FROM PUBLIC;
REVOKE ALL ON TABLE call_number_bucket_item_note FROM evergreen;
GRANT ALL ON TABLE call_number_bucket_item_note TO evergreen;
GRANT SELECT ON TABLE call_number_bucket_item_note TO bbonner;


--
-- Name: call_number_bucket_item_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_bucket_item_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_bucket_item_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_bucket_item_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE call_number_bucket_item_note_id_seq TO bbonner;


--
-- Name: call_number_bucket_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_bucket_note FROM PUBLIC;
REVOKE ALL ON TABLE call_number_bucket_note FROM evergreen;
GRANT ALL ON TABLE call_number_bucket_note TO evergreen;
GRANT SELECT ON TABLE call_number_bucket_note TO bbonner;


--
-- Name: call_number_bucket_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE call_number_bucket_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE call_number_bucket_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE call_number_bucket_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE call_number_bucket_note_id_seq TO bbonner;


--
-- Name: call_number_bucket_type; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_bucket_type FROM PUBLIC;
REVOKE ALL ON TABLE call_number_bucket_type FROM evergreen;
GRANT ALL ON TABLE call_number_bucket_type TO evergreen;
GRANT SELECT ON TABLE call_number_bucket_type TO bbonner;


--
-- Name: copy_bucket; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE copy_bucket FROM PUBLIC;
REVOKE ALL ON TABLE copy_bucket FROM evergreen;
GRANT ALL ON TABLE copy_bucket TO evergreen;
GRANT SELECT ON TABLE copy_bucket TO bbonner;


--
-- Name: copy_bucket_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_bucket_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_bucket_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_bucket_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE copy_bucket_id_seq TO bbonner;


--
-- Name: copy_bucket_item; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE copy_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE copy_bucket_item FROM evergreen;
GRANT ALL ON TABLE copy_bucket_item TO evergreen;
GRANT ALL ON TABLE copy_bucket_item TO bbonner;


--
-- Name: copy_bucket_item_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_bucket_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_bucket_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_bucket_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE copy_bucket_item_id_seq TO bbonner;


--
-- Name: copy_bucket_item_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE copy_bucket_item_note FROM PUBLIC;
REVOKE ALL ON TABLE copy_bucket_item_note FROM evergreen;
GRANT ALL ON TABLE copy_bucket_item_note TO evergreen;
GRANT SELECT ON TABLE copy_bucket_item_note TO bbonner;


--
-- Name: copy_bucket_item_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_bucket_item_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_bucket_item_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_bucket_item_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE copy_bucket_item_note_id_seq TO bbonner;


--
-- Name: copy_bucket_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE copy_bucket_note FROM PUBLIC;
REVOKE ALL ON TABLE copy_bucket_note FROM evergreen;
GRANT ALL ON TABLE copy_bucket_note TO evergreen;
GRANT SELECT ON TABLE copy_bucket_note TO bbonner;


--
-- Name: copy_bucket_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE copy_bucket_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE copy_bucket_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE copy_bucket_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE copy_bucket_note_id_seq TO bbonner;


--
-- Name: copy_bucket_type; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE copy_bucket_type FROM PUBLIC;
REVOKE ALL ON TABLE copy_bucket_type FROM evergreen;
GRANT ALL ON TABLE copy_bucket_type TO evergreen;
GRANT SELECT ON TABLE copy_bucket_type TO bbonner;


--
-- Name: user_bucket; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE user_bucket FROM PUBLIC;
REVOKE ALL ON TABLE user_bucket FROM evergreen;
GRANT ALL ON TABLE user_bucket TO evergreen;
GRANT SELECT ON TABLE user_bucket TO bbonner;


--
-- Name: user_bucket_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_bucket_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_bucket_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_bucket_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_bucket_id_seq TO bbonner;


--
-- Name: user_bucket_item; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE user_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE user_bucket_item FROM evergreen;
GRANT ALL ON TABLE user_bucket_item TO evergreen;
GRANT SELECT ON TABLE user_bucket_item TO bbonner;


--
-- Name: user_bucket_item_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_bucket_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_bucket_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_bucket_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_bucket_item_id_seq TO bbonner;


--
-- Name: user_bucket_item_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE user_bucket_item_note FROM PUBLIC;
REVOKE ALL ON TABLE user_bucket_item_note FROM evergreen;
GRANT ALL ON TABLE user_bucket_item_note TO evergreen;
GRANT SELECT ON TABLE user_bucket_item_note TO bbonner;


--
-- Name: user_bucket_item_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_bucket_item_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_bucket_item_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_bucket_item_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_bucket_item_note_id_seq TO bbonner;


--
-- Name: user_bucket_note; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE user_bucket_note FROM PUBLIC;
REVOKE ALL ON TABLE user_bucket_note FROM evergreen;
GRANT ALL ON TABLE user_bucket_note TO evergreen;
GRANT SELECT ON TABLE user_bucket_note TO bbonner;


--
-- Name: user_bucket_note_id_seq; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_bucket_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_bucket_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_bucket_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_bucket_note_id_seq TO bbonner;


--
-- Name: user_bucket_type; Type: ACL; Schema: container; Owner: evergreen
--

REVOKE ALL ON TABLE user_bucket_type FROM PUBLIC;
REVOKE ALL ON TABLE user_bucket_type FROM evergreen;
GRANT ALL ON TABLE user_bucket_type TO evergreen;
GRANT SELECT ON TABLE user_bucket_type TO bbonner;


SET search_path = envisionware, pg_catalog;

--
-- Name: users_made_no_access; Type: ACL; Schema: envisionware; Owner: evergreen
--

REVOKE ALL ON TABLE users_made_no_access FROM PUBLIC;
REVOKE ALL ON TABLE users_made_no_access FROM evergreen;
GRANT ALL ON TABLE users_made_no_access TO evergreen;
GRANT ALL ON TABLE users_made_no_access TO bbonner;


SET search_path = esi, pg_catalog;

--
-- Name: backroom_items; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE backroom_items FROM PUBLIC;
REVOKE ALL ON TABLE backroom_items FROM evergreen;
GRANT ALL ON TABLE backroom_items TO evergreen;
GRANT SELECT ON TABLE backroom_items TO bbonner;


--
-- Name: cleanupvolumes2; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE cleanupvolumes2 FROM PUBLIC;
REVOKE ALL ON TABLE cleanupvolumes2 FROM evergreen;
GRANT ALL ON TABLE cleanupvolumes2 TO evergreen;
GRANT ALL ON TABLE cleanupvolumes2 TO bbonner;


--
-- Name: needsoverduephone; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE needsoverduephone FROM PUBLIC;
REVOKE ALL ON TABLE needsoverduephone FROM evergreen;
GRANT ALL ON TABLE needsoverduephone TO evergreen;
GRANT SELECT ON TABLE needsoverduephone TO bbonner;


--
-- Name: phasefx16756_xacts; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE phasefx16756_xacts FROM PUBLIC;
REVOKE ALL ON TABLE phasefx16756_xacts FROM evergreen;
GRANT ALL ON TABLE phasefx16756_xacts TO evergreen;
GRANT SELECT ON TABLE phasefx16756_xacts TO bbonner;


--
-- Name: saved_inactive_patron_cards; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE saved_inactive_patron_cards FROM PUBLIC;
REVOKE ALL ON TABLE saved_inactive_patron_cards FROM evergreen;
GRANT ALL ON TABLE saved_inactive_patron_cards TO evergreen;
GRANT ALL ON TABLE saved_inactive_patron_cards TO bbonner;


--
-- Name: steve092711oldholdnotices; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steve092711oldholdnotices FROM PUBLIC;
REVOKE ALL ON TABLE steve092711oldholdnotices FROM evergreen;
GRANT ALL ON TABLE steve092711oldholdnotices TO evergreen;
GRANT SELECT ON TABLE steve092711oldholdnotices TO bbonner;


--
-- Name: steve17090funddebit; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steve17090funddebit FROM PUBLIC;
REVOKE ALL ON TABLE steve17090funddebit FROM evergreen;
GRANT ALL ON TABLE steve17090funddebit TO evergreen;
GRANT SELECT ON TABLE steve17090funddebit TO bbonner;


--
-- Name: steve17090lineitems; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steve17090lineitems FROM PUBLIC;
REVOKE ALL ON TABLE steve17090lineitems FROM evergreen;
GRANT ALL ON TABLE steve17090lineitems TO evergreen;
GRANT SELECT ON TABLE steve17090lineitems TO bbonner;


--
-- Name: steve17090lineitemsdetails; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steve17090lineitemsdetails FROM PUBLIC;
REVOKE ALL ON TABLE steve17090lineitemsdetails FROM evergreen;
GRANT ALL ON TABLE steve17090lineitemsdetails TO evergreen;
GRANT SELECT ON TABLE steve17090lineitemsdetails TO bbonner;


--
-- Name: steve2371665holds; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steve2371665holds FROM PUBLIC;
REVOKE ALL ON TABLE steve2371665holds FROM evergreen;
GRANT ALL ON TABLE steve2371665holds TO evergreen;
GRANT SELECT ON TABLE steve2371665holds TO bbonner;


--
-- Name: steve2759532holds; Type: ACL; Schema: esi; Owner: postgres
--

REVOKE ALL ON TABLE steve2759532holds FROM PUBLIC;
REVOKE ALL ON TABLE steve2759532holds FROM postgres;
GRANT ALL ON TABLE steve2759532holds TO postgres;
GRANT SELECT ON TABLE steve2759532holds TO bbonner;


--
-- Name: steveaction_collector; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_collector FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_collector FROM evergreen;
GRANT ALL ON TABLE steveaction_collector TO evergreen;
GRANT SELECT ON TABLE steveaction_collector TO bbonner;


--
-- Name: steveaction_def; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_def FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_def FROM evergreen;
GRANT ALL ON TABLE steveaction_def TO evergreen;
GRANT SELECT ON TABLE steveaction_def TO bbonner;


--
-- Name: steveaction_environment; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_environment FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_environment FROM evergreen;
GRANT ALL ON TABLE steveaction_environment TO evergreen;
GRANT SELECT ON TABLE steveaction_environment TO bbonner;


--
-- Name: steveaction_hook; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_hook FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_hook FROM evergreen;
GRANT ALL ON TABLE steveaction_hook TO evergreen;
GRANT SELECT ON TABLE steveaction_hook TO bbonner;


--
-- Name: steveaction_params; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_params FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_params FROM evergreen;
GRANT ALL ON TABLE steveaction_params TO evergreen;
GRANT SELECT ON TABLE steveaction_params TO bbonner;


--
-- Name: steveaction_reactor; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_reactor FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_reactor FROM evergreen;
GRANT ALL ON TABLE steveaction_reactor TO evergreen;
GRANT SELECT ON TABLE steveaction_reactor TO bbonner;


--
-- Name: steveaction_validator; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveaction_validator FROM PUBLIC;
REVOKE ALL ON TABLE steveaction_validator FROM evergreen;
GRANT ALL ON TABLE steveaction_validator TO evergreen;
GRANT SELECT ON TABLE steveaction_validator TO bbonner;


--
-- Name: steveholdprintingorig; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveholdprintingorig FROM PUBLIC;
REVOKE ALL ON TABLE steveholdprintingorig FROM evergreen;
GRANT ALL ON TABLE steveholdprintingorig TO evergreen;
GRANT SELECT ON TABLE steveholdprintingorig TO bbonner;


--
-- Name: steveholdprintingorigtakeone; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveholdprintingorigtakeone FROM PUBLIC;
REVOKE ALL ON TABLE steveholdprintingorigtakeone FROM evergreen;
GRANT ALL ON TABLE steveholdprintingorigtakeone TO evergreen;
GRANT SELECT ON TABLE steveholdprintingorigtakeone TO bbonner;


--
-- Name: steveholdprintingorigtakethree; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveholdprintingorigtakethree FROM PUBLIC;
REVOKE ALL ON TABLE steveholdprintingorigtakethree FROM evergreen;
GRANT ALL ON TABLE steveholdprintingorigtakethree TO evergreen;
GRANT SELECT ON TABLE steveholdprintingorigtakethree TO bbonner;


--
-- Name: steveholdprintingorigtaketwo; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveholdprintingorigtaketwo FROM PUBLIC;
REVOKE ALL ON TABLE steveholdprintingorigtaketwo FROM evergreen;
GRANT ALL ON TABLE steveholdprintingorigtaketwo TO evergreen;
GRANT SELECT ON TABLE steveholdprintingorigtaketwo TO bbonner;


--
-- Name: steveholdprintingorigtesting; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveholdprintingorigtesting FROM PUBLIC;
REVOKE ALL ON TABLE steveholdprintingorigtesting FROM evergreen;
GRANT ALL ON TABLE steveholdprintingorigtesting TO evergreen;
GRANT SELECT ON TABLE steveholdprintingorigtesting TO bbonner;


--
-- Name: steveoverdueprintorig; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveoverdueprintorig FROM PUBLIC;
REVOKE ALL ON TABLE steveoverdueprintorig FROM evergreen;
GRANT ALL ON TABLE steveoverdueprintorig TO evergreen;
GRANT SELECT ON TABLE steveoverdueprintorig TO bbonner;


--
-- Name: steveoverdueprintorigtesting; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveoverdueprintorigtesting FROM PUBLIC;
REVOKE ALL ON TABLE steveoverdueprintorigtesting FROM evergreen;
GRANT ALL ON TABLE steveoverdueprintorigtesting TO evergreen;
GRANT SELECT ON TABLE steveoverdueprintorigtesting TO bbonner;


--
-- Name: stevepenalties14512; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevepenalties14512 FROM PUBLIC;
REVOKE ALL ON TABLE stevepenalties14512 FROM evergreen;
GRANT ALL ON TABLE stevepenalties14512 TO evergreen;
GRANT SELECT ON TABLE stevepenalties14512 TO bbonner;


--
-- Name: stevestandingorg14512; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevestandingorg14512 FROM PUBLIC;
REVOKE ALL ON TABLE stevestandingorg14512 FROM evergreen;
GRANT ALL ON TABLE stevestandingorg14512 TO evergreen;
GRANT SELECT ON TABLE stevestandingorg14512 TO bbonner;


--
-- Name: stevetestadd; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevetestadd FROM PUBLIC;
REVOKE ALL ON TABLE stevetestadd FROM evergreen;
GRANT ALL ON TABLE stevetestadd TO evergreen;
GRANT SELECT ON TABLE stevetestadd TO bbonner;


--
-- Name: stevetestsettings; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevetestsettings FROM PUBLIC;
REVOKE ALL ON TABLE stevetestsettings FROM evergreen;
GRANT ALL ON TABLE stevetestsettings TO evergreen;
GRANT SELECT ON TABLE stevetestsettings TO bbonner;


--
-- Name: stevetransitupdate; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevetransitupdate FROM PUBLIC;
REVOKE ALL ON TABLE stevetransitupdate FROM evergreen;
GRANT ALL ON TABLE stevetransitupdate TO evergreen;
GRANT SELECT ON TABLE stevetransitupdate TO bbonner;


--
-- Name: stevetransitupdate2; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE stevetransitupdate2 FROM PUBLIC;
REVOKE ALL ON TABLE stevetransitupdate2 FROM evergreen;
GRANT ALL ON TABLE stevetransitupdate2 TO evergreen;
GRANT SELECT ON TABLE stevetransitupdate2 TO bbonner;


--
-- Name: steveusrsettingbackup; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE steveusrsettingbackup FROM PUBLIC;
REVOKE ALL ON TABLE steveusrsettingbackup FROM evergreen;
GRANT ALL ON TABLE steveusrsettingbackup TO evergreen;
GRANT SELECT ON TABLE steveusrsettingbackup TO bbonner;


--
-- Name: templatestoconvert; Type: ACL; Schema: esi; Owner: evergreen
--

REVOKE ALL ON TABLE templatestoconvert FROM PUBLIC;
REVOKE ALL ON TABLE templatestoconvert FROM evergreen;
GRANT ALL ON TABLE templatestoconvert TO evergreen;
GRANT SELECT ON TABLE templatestoconvert TO bbonner;


SET search_path = esi_14812, pg_catalog;

--
-- Name: fw_items; Type: ACL; Schema: esi_14812; Owner: evergreen
--

REVOKE ALL ON TABLE fw_items FROM PUBLIC;
REVOKE ALL ON TABLE fw_items FROM evergreen;
GRANT ALL ON TABLE fw_items TO evergreen;
GRANT SELECT ON TABLE fw_items TO bbonner;


--
-- Name: nw_items_changed; Type: ACL; Schema: esi_14812; Owner: evergreen
--

REVOKE ALL ON TABLE nw_items_changed FROM PUBLIC;
REVOKE ALL ON TABLE nw_items_changed FROM evergreen;
GRANT ALL ON TABLE nw_items_changed TO evergreen;
GRANT SELECT ON TABLE nw_items_changed TO bbonner;


--
-- Name: rn_dvds; Type: ACL; Schema: esi_14812; Owner: evergreen
--

REVOKE ALL ON TABLE rn_dvds FROM PUBLIC;
REVOKE ALL ON TABLE rn_dvds FROM evergreen;
GRANT ALL ON TABLE rn_dvds TO evergreen;
GRANT SELECT ON TABLE rn_dvds TO bbonner;


--
-- Name: rn_missing_items; Type: ACL; Schema: esi_14812; Owner: evergreen
--

REVOKE ALL ON TABLE rn_missing_items FROM PUBLIC;
REVOKE ALL ON TABLE rn_missing_items FROM evergreen;
GRANT ALL ON TABLE rn_missing_items TO evergreen;
GRANT SELECT ON TABLE rn_missing_items TO bbonner;


SET search_path = extend_reporter, pg_catalog;

--
-- Name: cdr; Type: ACL; Schema: extend_reporter; Owner: postgres
--

REVOKE ALL ON TABLE cdr FROM PUBLIC;
REVOKE ALL ON TABLE cdr FROM postgres;
GRANT ALL ON TABLE cdr TO postgres;
GRANT SELECT ON TABLE cdr TO kclsreporter2;
GRANT SELECT ON TABLE cdr TO kclsreporter;
GRANT ALL ON TABLE cdr TO evergreen;


--
-- Name: legacy_circ_count; Type: ACL; Schema: extend_reporter; Owner: evergreen
--

REVOKE ALL ON TABLE legacy_circ_count FROM PUBLIC;
REVOKE ALL ON TABLE legacy_circ_count FROM evergreen;
GRANT ALL ON TABLE legacy_circ_count TO evergreen;
GRANT SELECT ON TABLE legacy_circ_count TO bbonner;


--
-- Name: full_circ_count; Type: ACL; Schema: extend_reporter; Owner: evergreen
--

REVOKE ALL ON TABLE full_circ_count FROM PUBLIC;
REVOKE ALL ON TABLE full_circ_count FROM evergreen;
GRANT ALL ON TABLE full_circ_count TO evergreen;
GRANT SELECT ON TABLE full_circ_count TO bbonner;


--
-- Name: global_bibs_by_holding_update; Type: ACL; Schema: extend_reporter; Owner: evergreen
--

REVOKE ALL ON TABLE global_bibs_by_holding_update FROM PUBLIC;
REVOKE ALL ON TABLE global_bibs_by_holding_update FROM evergreen;
GRANT ALL ON TABLE global_bibs_by_holding_update TO evergreen;
GRANT SELECT ON TABLE global_bibs_by_holding_update TO bbonner;


SET search_path = money, pg_catalog;

--
-- Name: billing; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE billing FROM PUBLIC;
REVOKE ALL ON TABLE billing FROM evergreen;
GRANT ALL ON TABLE billing TO evergreen;
GRANT ALL ON TABLE billing TO bbonner;


--
-- Name: billing_id_seq; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON SEQUENCE billing_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE billing_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE billing_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE billing_id_seq TO bbonner;


--
-- Name: payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE payment FROM PUBLIC;
REVOKE ALL ON TABLE payment FROM evergreen;
GRANT ALL ON TABLE payment TO evergreen;
GRANT SELECT ON TABLE payment TO bbonner;


--
-- Name: payment_id_seq; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON SEQUENCE payment_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE payment_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE payment_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE payment_id_seq TO bbonner;


SET search_path = m_kcls, pg_catalog;

--
-- Name: acq_provider_address_bkp; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_address_bkp FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_address_bkp FROM evergreen;
GRANT ALL ON TABLE acq_provider_address_bkp TO evergreen;
GRANT SELECT ON TABLE acq_provider_address_bkp TO bbonner;


--
-- Name: acq_provider_address_new; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_address_new FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_address_new FROM evergreen;
GRANT ALL ON TABLE acq_provider_address_new TO evergreen;
GRANT SELECT ON TABLE acq_provider_address_new TO bbonner;


--
-- Name: action_circulation; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_circulation_legacy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation_legacy FROM evergreen;
GRANT ALL ON TABLE action_circulation_legacy TO evergreen;
GRANT SELECT ON TABLE action_circulation_legacy TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_dupe_barcodes; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE actor_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE actor_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE actor_dupe_barcodes TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_legacy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_legacy FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_legacy FROM evergreen;
GRANT ALL ON TABLE actor_usr_legacy TO evergreen;
GRANT SELECT ON TABLE actor_usr_legacy TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: actor_usr_setting; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_setting FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_setting FROM evergreen;
GRANT ALL ON TABLE actor_usr_setting TO evergreen;
GRANT SELECT ON TABLE actor_usr_setting TO bbonner;


--
-- Name: actor_usr_standing_penalty; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_standing_penalty FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_standing_penalty FROM evergreen;
GRANT ALL ON TABLE actor_usr_standing_penalty TO evergreen;
GRANT SELECT ON TABLE actor_usr_standing_penalty TO bbonner;


--
-- Name: alert_messages; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE alert_messages FROM PUBLIC;
REVOKE ALL ON TABLE alert_messages FROM evergreen;
GRANT ALL ON TABLE alert_messages TO evergreen;
GRANT SELECT ON TABLE alert_messages TO bbonner;


--
-- Name: appropriations; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE appropriations FROM PUBLIC;
REVOKE ALL ON TABLE appropriations FROM evergreen;
GRANT ALL ON TABLE appropriations TO evergreen;
GRANT SELECT ON TABLE appropriations TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_legacy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_legacy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_legacy FROM evergreen;
GRANT ALL ON TABLE asset_copy_legacy TO evergreen;
GRANT SELECT ON TABLE asset_copy_legacy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: auths_to_del; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE auths_to_del FROM PUBLIC;
REVOKE ALL ON TABLE auths_to_del FROM evergreen;
GRANT ALL ON TABLE auths_to_del TO evergreen;
GRANT SELECT ON TABLE auths_to_del TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: best_avail_copies; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE best_avail_copies FROM PUBLIC;
REVOKE ALL ON TABLE best_avail_copies FROM evergreen;
GRANT ALL ON TABLE best_avail_copies TO evergreen;
GRANT SELECT ON TABLE best_avail_copies TO bbonner;


--
-- Name: bibs_to_fix; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE bibs_to_fix FROM PUBLIC;
REVOKE ALL ON TABLE bibs_to_fix FROM evergreen;
GRANT ALL ON TABLE bibs_to_fix TO evergreen;
GRANT SELECT ON TABLE bibs_to_fix TO bbonner;


--
-- Name: bibs_to_fix_seq_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bibs_to_fix_seq_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bibs_to_fix_seq_seq FROM evergreen;
GRANT ALL ON SEQUENCE bibs_to_fix_seq_seq TO evergreen;
GRANT USAGE ON SEQUENCE bibs_to_fix_seq_seq TO bbonner;


--
-- Name: bibs_with_938; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE bibs_with_938 FROM PUBLIC;
REVOKE ALL ON TABLE bibs_with_938 FROM evergreen;
GRANT ALL ON TABLE bibs_with_938 TO evergreen;
GRANT SELECT ON TABLE bibs_with_938 TO bbonner;


--
-- Name: bibs_with_938_id_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bibs_with_938_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bibs_with_938_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE bibs_with_938_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE bibs_with_938_id_seq TO bbonner;


--
-- Name: bibs_with_crossed_d; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE bibs_with_crossed_d FROM PUBLIC;
REVOKE ALL ON TABLE bibs_with_crossed_d FROM evergreen;
GRANT ALL ON TABLE bibs_with_crossed_d TO evergreen;
GRANT SELECT ON TABLE bibs_with_crossed_d TO bbonner;


--
-- Name: container_biblio_record_entry_bucket; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE container_biblio_record_entry_bucket FROM PUBLIC;
REVOKE ALL ON TABLE container_biblio_record_entry_bucket FROM evergreen;
GRANT ALL ON TABLE container_biblio_record_entry_bucket TO evergreen;
GRANT SELECT ON TABLE container_biblio_record_entry_bucket TO bbonner;


--
-- Name: bookbag; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE bookbag FROM PUBLIC;
REVOKE ALL ON TABLE bookbag FROM evergreen;
GRANT ALL ON TABLE bookbag TO evergreen;
GRANT SELECT ON TABLE bookbag TO bbonner;


--
-- Name: container_biblio_record_entry_bucket_item; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE container_biblio_record_entry_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE container_biblio_record_entry_bucket_item FROM evergreen;
GRANT ALL ON TABLE container_biblio_record_entry_bucket_item TO evergreen;
GRANT SELECT ON TABLE container_biblio_record_entry_bucket_item TO bbonner;


--
-- Name: bookbag_entry; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE bookbag_entry FROM PUBLIC;
REVOKE ALL ON TABLE bookbag_entry FROM evergreen;
GRANT ALL ON TABLE bookbag_entry TO evergreen;
GRANT SELECT ON TABLE bookbag_entry TO bbonner;


--
-- Name: circ_rule_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE circ_rule_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_rule_map FROM evergreen;
GRANT ALL ON TABLE circ_rule_map TO evergreen;
GRANT SELECT ON TABLE circ_rule_map TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: copy_dupe_barcodes; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes TO bbonner;


--
-- Name: copy_dupe_barcodes2; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes2 FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes2 FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes2 TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes2 TO bbonner;


--
-- Name: cp_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE cp_map FROM PUBLIC;
REVOKE ALL ON TABLE cp_map FROM evergreen;
GRANT ALL ON TABLE cp_map TO evergreen;
GRANT SELECT ON TABLE cp_map TO bbonner;


--
-- Name: dist_formulas; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE dist_formulas FROM PUBLIC;
REVOKE ALL ON TABLE dist_formulas FROM evergreen;
GRANT ALL ON TABLE dist_formulas TO evergreen;
GRANT SELECT ON TABLE dist_formulas TO bbonner;


--
-- Name: dist_formulas2; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE dist_formulas2 FROM PUBLIC;
REVOKE ALL ON TABLE dist_formulas2 FROM evergreen;
GRANT ALL ON TABLE dist_formulas2 TO evergreen;
GRANT SELECT ON TABLE dist_formulas2 TO bbonner;


--
-- Name: dob_1900; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE dob_1900 FROM PUBLIC;
REVOKE ALL ON TABLE dob_1900 FROM evergreen;
GRANT ALL ON TABLE dob_1900 TO evergreen;
GRANT SELECT ON TABLE dob_1900 TO bbonner;


--
-- Name: eres_tcns; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE eres_tcns FROM PUBLIC;
REVOKE ALL ON TABLE eres_tcns FROM evergreen;
GRANT ALL ON TABLE eres_tcns TO evergreen;
GRANT SELECT ON TABLE eres_tcns TO bbonner;


--
-- Name: event_def_restore; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE event_def_restore FROM PUBLIC;
REVOKE ALL ON TABLE event_def_restore FROM evergreen;
GRANT ALL ON TABLE event_def_restore TO evergreen;
GRANT SELECT ON TABLE event_def_restore TO bbonner;


--
-- Name: event_def_restore2; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE event_def_restore2 FROM PUBLIC;
REVOKE ALL ON TABLE event_def_restore2 FROM evergreen;
GRANT ALL ON TABLE event_def_restore2 TO evergreen;
GRANT SELECT ON TABLE event_def_restore2 TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: fund_all; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE fund_all FROM PUBLIC;
REVOKE ALL ON TABLE fund_all FROM evergreen;
GRANT ALL ON TABLE fund_all TO evergreen;
GRANT SELECT ON TABLE fund_all TO bbonner;


--
-- Name: int_notes; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE int_notes FROM PUBLIC;
REVOKE ALL ON TABLE int_notes FROM evergreen;
GRANT ALL ON TABLE int_notes TO evergreen;
GRANT SELECT ON TABLE int_notes TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: item_status_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE item_status_map FROM PUBLIC;
REVOKE ALL ON TABLE item_status_map FROM evergreen;
GRANT ALL ON TABLE item_status_map TO evergreen;
GRANT SELECT ON TABLE item_status_map TO bbonner;


--
-- Name: jan21_pos; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE jan21_pos FROM PUBLIC;
REVOKE ALL ON TABLE jan21_pos FROM evergreen;
GRANT ALL ON TABLE jan21_pos TO evergreen;
GRANT SELECT ON TABLE jan21_pos TO bbonner;


--
-- Name: km_move; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE km_move FROM PUBLIC;
REVOKE ALL ON TABLE km_move FROM evergreen;
GRANT ALL ON TABLE km_move TO evergreen;
GRANT SELECT ON TABLE km_move TO bbonner;


--
-- Name: km_move_job_seq; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON SEQUENCE km_move_job_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE km_move_job_seq FROM evergreen;
GRANT ALL ON SEQUENCE km_move_job_seq TO evergreen;
GRANT USAGE ON SEQUENCE km_move_job_seq TO bbonner;


--
-- Name: legacy_circ_count; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE legacy_circ_count FROM PUBLIC;
REVOKE ALL ON TABLE legacy_circ_count FROM evergreen;
GRANT ALL ON TABLE legacy_circ_count TO evergreen;
GRANT SELECT ON TABLE legacy_circ_count TO bbonner;


--
-- Name: locations; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE locations FROM PUBLIC;
REVOKE ALL ON TABLE locations FROM evergreen;
GRANT ALL ON TABLE locations TO evergreen;
GRANT SELECT ON TABLE locations TO bbonner;


--
-- Name: messages; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE messages FROM PUBLIC;
REVOKE ALL ON TABLE messages FROM evergreen;
GRANT ALL ON TABLE messages TO evergreen;
GRANT SELECT ON TABLE messages TO bbonner;


--
-- Name: metabib_field; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_field FROM PUBLIC;
REVOKE ALL ON TABLE metabib_field FROM evergreen;
GRANT ALL ON TABLE metabib_field TO evergreen;
GRANT SELECT ON TABLE metabib_field TO bbonner;


--
-- Name: metabib_field_index_norm_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_field_index_norm_map FROM PUBLIC;
REVOKE ALL ON TABLE metabib_field_index_norm_map FROM evergreen;
GRANT ALL ON TABLE metabib_field_index_norm_map TO evergreen;
GRANT SELECT ON TABLE metabib_field_index_norm_map TO bbonner;


--
-- Name: metabib_search_alias; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE metabib_search_alias FROM PUBLIC;
REVOKE ALL ON TABLE metabib_search_alias FROM evergreen;
GRANT ALL ON TABLE metabib_search_alias TO evergreen;
GRANT SELECT ON TABLE metabib_search_alias TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: money_grocery_legacy; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery_legacy FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery_legacy FROM evergreen;
GRANT ALL ON TABLE money_grocery_legacy TO evergreen;
GRANT SELECT ON TABLE money_grocery_legacy TO bbonner;


--
-- Name: netlibrary_bib_ids; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE netlibrary_bib_ids FROM PUBLIC;
REVOKE ALL ON TABLE netlibrary_bib_ids FROM evergreen;
GRANT ALL ON TABLE netlibrary_bib_ids TO evergreen;
GRANT SELECT ON TABLE netlibrary_bib_ids TO bbonner;


--
-- Name: old2new; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE old2new FROM PUBLIC;
REVOKE ALL ON TABLE old2new FROM evergreen;
GRANT ALL ON TABLE old2new TO evergreen;
GRANT SELECT ON TABLE old2new TO bbonner;


--
-- Name: orig_notice_setting; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE orig_notice_setting FROM PUBLIC;
REVOKE ALL ON TABLE orig_notice_setting FROM evergreen;
GRANT ALL ON TABLE orig_notice_setting TO evergreen;
GRANT SELECT ON TABLE orig_notice_setting TO bbonner;


--
-- Name: orig_relevance; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE orig_relevance FROM PUBLIC;
REVOKE ALL ON TABLE orig_relevance FROM evergreen;
GRANT ALL ON TABLE orig_relevance TO evergreen;
GRANT SELECT ON TABLE orig_relevance TO bbonner;


--
-- Name: ou_patrons; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE ou_patrons FROM PUBLIC;
REVOKE ALL ON TABLE ou_patrons FROM evergreen;
GRANT ALL ON TABLE ou_patrons TO evergreen;
GRANT SELECT ON TABLE ou_patrons TO bbonner;


--
-- Name: patron_addr; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE patron_addr FROM PUBLIC;
REVOKE ALL ON TABLE patron_addr FROM evergreen;
GRANT ALL ON TABLE patron_addr TO evergreen;
GRANT SELECT ON TABLE patron_addr TO bbonner;


--
-- Name: patron_addr_compressed; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE patron_addr_compressed FROM PUBLIC;
REVOKE ALL ON TABLE patron_addr_compressed FROM evergreen;
GRANT ALL ON TABLE patron_addr_compressed TO evergreen;
GRANT SELECT ON TABLE patron_addr_compressed TO bbonner;


--
-- Name: patron_extras; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE patron_extras FROM PUBLIC;
REVOKE ALL ON TABLE patron_extras FROM evergreen;
GRANT ALL ON TABLE patron_extras TO evergreen;
GRANT SELECT ON TABLE patron_extras TO bbonner;


--
-- Name: patron_note; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE patron_note FROM PUBLIC;
REVOKE ALL ON TABLE patron_note FROM evergreen;
GRANT ALL ON TABLE patron_note TO evergreen;
GRANT SELECT ON TABLE patron_note TO bbonner;


--
-- Name: patrons_with_history; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE patrons_with_history FROM PUBLIC;
REVOKE ALL ON TABLE patrons_with_history FROM evergreen;
GRANT ALL ON TABLE patrons_with_history TO evergreen;
GRANT SELECT ON TABLE patrons_with_history TO bbonner;


--
-- Name: pcode3_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE pcode3_map FROM PUBLIC;
REVOKE ALL ON TABLE pcode3_map FROM evergreen;
GRANT ALL ON TABLE pcode3_map TO evergreen;
GRANT SELECT ON TABLE pcode3_map TO bbonner;


--
-- Name: ptype_map; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE ptype_map FROM PUBLIC;
REVOKE ALL ON TABLE ptype_map FROM evergreen;
GRANT ALL ON TABLE ptype_map TO evergreen;
GRANT SELECT ON TABLE ptype_map TO bbonner;


--
-- Name: rejected_circs; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_circs FROM PUBLIC;
REVOKE ALL ON TABLE rejected_circs FROM evergreen;
GRANT ALL ON TABLE rejected_circs TO evergreen;
GRANT SELECT ON TABLE rejected_circs TO bbonner;


--
-- Name: rejected_holds; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_holds FROM PUBLIC;
REVOKE ALL ON TABLE rejected_holds FROM evergreen;
GRANT ALL ON TABLE rejected_holds TO evergreen;
GRANT SELECT ON TABLE rejected_holds TO bbonner;


--
-- Name: relevance_adjustment; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE relevance_adjustment FROM PUBLIC;
REVOKE ALL ON TABLE relevance_adjustment FROM evergreen;
GRANT ALL ON TABLE relevance_adjustment TO evergreen;
GRANT SELECT ON TABLE relevance_adjustment TO bbonner;


--
-- Name: sources; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE sources FROM PUBLIC;
REVOKE ALL ON TABLE sources FROM evergreen;
GRANT ALL ON TABLE sources TO evergreen;
GRANT SELECT ON TABLE sources TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


--
-- Name: summer_patrons_to_delete; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE summer_patrons_to_delete FROM PUBLIC;
REVOKE ALL ON TABLE summer_patrons_to_delete FROM evergreen;
GRANT ALL ON TABLE summer_patrons_to_delete TO evergreen;
GRANT SELECT ON TABLE summer_patrons_to_delete TO bbonner;


--
-- Name: usr_not_migrated_per_ptype; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE usr_not_migrated_per_ptype FROM PUBLIC;
REVOKE ALL ON TABLE usr_not_migrated_per_ptype FROM evergreen;
GRANT ALL ON TABLE usr_not_migrated_per_ptype TO evergreen;
GRANT SELECT ON TABLE usr_not_migrated_per_ptype TO bbonner;


--
-- Name: vols_to_delete; Type: ACL; Schema: m_kcls; Owner: evergreen
--

REVOKE ALL ON TABLE vols_to_delete FROM PUBLIC;
REVOKE ALL ON TABLE vols_to_delete FROM evergreen;
GRANT ALL ON TABLE vols_to_delete TO evergreen;
GRANT SELECT ON TABLE vols_to_delete TO bbonner;


SET search_path = m_kcls2, pg_catalog;

--
-- Name: acq_fund; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_fund FROM PUBLIC;
REVOKE ALL ON TABLE acq_fund FROM evergreen;
GRANT ALL ON TABLE acq_fund TO evergreen;
GRANT SELECT ON TABLE acq_fund TO bbonner;


--
-- Name: acq_fund_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_fund_legacy FROM PUBLIC;
REVOKE ALL ON TABLE acq_fund_legacy FROM evergreen;
GRANT ALL ON TABLE acq_fund_legacy TO evergreen;
GRANT SELECT ON TABLE acq_fund_legacy TO bbonner;


--
-- Name: acq_provider; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider FROM evergreen;
GRANT ALL ON TABLE acq_provider TO evergreen;
GRANT SELECT ON TABLE acq_provider TO bbonner;


--
-- Name: acq_provider_address; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_address FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_address FROM evergreen;
GRANT ALL ON TABLE acq_provider_address TO evergreen;
GRANT SELECT ON TABLE acq_provider_address TO bbonner;


--
-- Name: acq_provider_address_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_address_legacy FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_address_legacy FROM evergreen;
GRANT ALL ON TABLE acq_provider_address_legacy TO evergreen;
GRANT SELECT ON TABLE acq_provider_address_legacy TO bbonner;


--
-- Name: acq_provider_contact; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_contact FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_contact FROM evergreen;
GRANT ALL ON TABLE acq_provider_contact TO evergreen;
GRANT SELECT ON TABLE acq_provider_contact TO bbonner;


--
-- Name: acq_provider_contact_address; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_contact_address FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_contact_address FROM evergreen;
GRANT ALL ON TABLE acq_provider_contact_address TO evergreen;
GRANT SELECT ON TABLE acq_provider_contact_address TO bbonner;


--
-- Name: acq_provider_contact_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_contact_legacy FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_contact_legacy FROM evergreen;
GRANT ALL ON TABLE acq_provider_contact_legacy TO evergreen;
GRANT SELECT ON TABLE acq_provider_contact_legacy TO bbonner;


--
-- Name: acq_provider_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_legacy FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_legacy FROM evergreen;
GRANT ALL ON TABLE acq_provider_legacy TO evergreen;
GRANT SELECT ON TABLE acq_provider_legacy TO bbonner;


--
-- Name: acq_provider_note; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE acq_provider_note FROM PUBLIC;
REVOKE ALL ON TABLE acq_provider_note FROM evergreen;
GRANT ALL ON TABLE acq_provider_note TO evergreen;
GRANT SELECT ON TABLE acq_provider_note TO bbonner;


--
-- Name: action_circulation; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_circulation_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation_legacy FROM evergreen;
GRANT ALL ON TABLE action_circulation_legacy TO evergreen;
GRANT SELECT ON TABLE action_circulation_legacy TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_dupe_barcodes; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE actor_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE actor_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE actor_dupe_barcodes TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_legacy FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_legacy FROM evergreen;
GRANT ALL ON TABLE actor_usr_legacy TO evergreen;
GRANT SELECT ON TABLE actor_usr_legacy TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: actor_usr_setting; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_setting FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_setting FROM evergreen;
GRANT ALL ON TABLE actor_usr_setting TO evergreen;
GRANT SELECT ON TABLE actor_usr_setting TO bbonner;


--
-- Name: alert_messages; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE alert_messages FROM PUBLIC;
REVOKE ALL ON TABLE alert_messages FROM evergreen;
GRANT ALL ON TABLE alert_messages TO evergreen;
GRANT SELECT ON TABLE alert_messages TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_legacy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_legacy FROM evergreen;
GRANT ALL ON TABLE asset_copy_legacy TO evergreen;
GRANT SELECT ON TABLE asset_copy_legacy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_location_backup; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location_backup FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location_backup FROM evergreen;
GRANT ALL ON TABLE asset_copy_location_backup TO evergreen;
GRANT SELECT ON TABLE asset_copy_location_backup TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: container_biblio_record_entry_bucket; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE container_biblio_record_entry_bucket FROM PUBLIC;
REVOKE ALL ON TABLE container_biblio_record_entry_bucket FROM evergreen;
GRANT ALL ON TABLE container_biblio_record_entry_bucket TO evergreen;
GRANT SELECT ON TABLE container_biblio_record_entry_bucket TO bbonner;


--
-- Name: bookbag; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE bookbag FROM PUBLIC;
REVOKE ALL ON TABLE bookbag FROM evergreen;
GRANT ALL ON TABLE bookbag TO evergreen;
GRANT SELECT ON TABLE bookbag TO bbonner;


--
-- Name: container_biblio_record_entry_bucket_item; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE container_biblio_record_entry_bucket_item FROM PUBLIC;
REVOKE ALL ON TABLE container_biblio_record_entry_bucket_item FROM evergreen;
GRANT ALL ON TABLE container_biblio_record_entry_bucket_item TO evergreen;
GRANT SELECT ON TABLE container_biblio_record_entry_bucket_item TO bbonner;


--
-- Name: bookbag_entry; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE bookbag_entry FROM PUBLIC;
REVOKE ALL ON TABLE bookbag_entry FROM evergreen;
GRANT ALL ON TABLE bookbag_entry TO evergreen;
GRANT SELECT ON TABLE bookbag_entry TO bbonner;


--
-- Name: circ_rule_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE circ_rule_map FROM PUBLIC;
REVOKE ALL ON TABLE circ_rule_map FROM evergreen;
GRANT ALL ON TABLE circ_rule_map TO evergreen;
GRANT SELECT ON TABLE circ_rule_map TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: copy_dupe_barcodes; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes TO bbonner;


--
-- Name: copy_name_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE copy_name_map FROM PUBLIC;
REVOKE ALL ON TABLE copy_name_map FROM evergreen;
GRANT ALL ON TABLE copy_name_map TO evergreen;
GRANT SELECT ON TABLE copy_name_map TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: int_notes; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE int_notes FROM PUBLIC;
REVOKE ALL ON TABLE int_notes FROM evergreen;
GRANT ALL ON TABLE int_notes TO evergreen;
GRANT SELECT ON TABLE int_notes TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: item_status_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE item_status_map FROM PUBLIC;
REVOKE ALL ON TABLE item_status_map FROM evergreen;
GRANT ALL ON TABLE item_status_map TO evergreen;
GRANT SELECT ON TABLE item_status_map TO bbonner;


--
-- Name: messages; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE messages FROM PUBLIC;
REVOKE ALL ON TABLE messages FROM evergreen;
GRANT ALL ON TABLE messages TO evergreen;
GRANT SELECT ON TABLE messages TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: money_grocery_legacy; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery_legacy FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery_legacy FROM evergreen;
GRANT ALL ON TABLE money_grocery_legacy TO evergreen;
GRANT SELECT ON TABLE money_grocery_legacy TO bbonner;


--
-- Name: old2new; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE old2new FROM PUBLIC;
REVOKE ALL ON TABLE old2new FROM evergreen;
GRANT ALL ON TABLE old2new TO evergreen;
GRANT SELECT ON TABLE old2new TO bbonner;


--
-- Name: ou_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE ou_map FROM PUBLIC;
REVOKE ALL ON TABLE ou_map FROM evergreen;
GRANT ALL ON TABLE ou_map TO evergreen;
GRANT SELECT ON TABLE ou_map TO bbonner;


--
-- Name: patron_addr; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE patron_addr FROM PUBLIC;
REVOKE ALL ON TABLE patron_addr FROM evergreen;
GRANT ALL ON TABLE patron_addr TO evergreen;
GRANT SELECT ON TABLE patron_addr TO bbonner;


--
-- Name: patron_addr_compressed; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE patron_addr_compressed FROM PUBLIC;
REVOKE ALL ON TABLE patron_addr_compressed FROM evergreen;
GRANT ALL ON TABLE patron_addr_compressed TO evergreen;
GRANT SELECT ON TABLE patron_addr_compressed TO bbonner;


--
-- Name: patron_extras; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE patron_extras FROM PUBLIC;
REVOKE ALL ON TABLE patron_extras FROM evergreen;
GRANT ALL ON TABLE patron_extras TO evergreen;
GRANT SELECT ON TABLE patron_extras TO bbonner;


--
-- Name: patron_note; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE patron_note FROM PUBLIC;
REVOKE ALL ON TABLE patron_note FROM evergreen;
GRANT ALL ON TABLE patron_note TO evergreen;
GRANT SELECT ON TABLE patron_note TO bbonner;


--
-- Name: ptype_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE ptype_map FROM PUBLIC;
REVOKE ALL ON TABLE ptype_map FROM evergreen;
GRANT ALL ON TABLE ptype_map TO evergreen;
GRANT SELECT ON TABLE ptype_map TO bbonner;


--
-- Name: rejected_circs; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_circs FROM PUBLIC;
REVOKE ALL ON TABLE rejected_circs FROM evergreen;
GRANT ALL ON TABLE rejected_circs TO evergreen;
GRANT SELECT ON TABLE rejected_circs TO bbonner;


--
-- Name: rejected_holds; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_holds FROM PUBLIC;
REVOKE ALL ON TABLE rejected_holds FROM evergreen;
GRANT ALL ON TABLE rejected_holds TO evergreen;
GRANT SELECT ON TABLE rejected_holds TO bbonner;


--
-- Name: rename_loc_map; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE rename_loc_map FROM PUBLIC;
REVOKE ALL ON TABLE rename_loc_map FROM evergreen;
GRANT ALL ON TABLE rename_loc_map TO evergreen;
GRANT SELECT ON TABLE rename_loc_map TO bbonner;


--
-- Name: root; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE root FROM PUBLIC;
REVOKE ALL ON TABLE root FROM evergreen;
GRANT ALL ON TABLE root TO evergreen;
GRANT SELECT ON TABLE root TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


--
-- Name: transend; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE transend FROM PUBLIC;
REVOKE ALL ON TABLE transend FROM evergreen;
GRANT ALL ON TABLE transend TO evergreen;
GRANT SELECT ON TABLE transend TO bbonner;


--
-- Name: usr_not_migrated_per_ptype; Type: ACL; Schema: m_kcls2; Owner: evergreen
--

REVOKE ALL ON TABLE usr_not_migrated_per_ptype FROM PUBLIC;
REVOKE ALL ON TABLE usr_not_migrated_per_ptype FROM evergreen;
GRANT ALL ON TABLE usr_not_migrated_per_ptype TO evergreen;
GRANT SELECT ON TABLE usr_not_migrated_per_ptype TO bbonner;


SET search_path = m_kcls3, pg_catalog;

--
-- Name: acq_fund; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE acq_fund FROM PUBLIC;
REVOKE ALL ON TABLE acq_fund FROM evergreen;
GRANT ALL ON TABLE acq_fund TO evergreen;
GRANT SELECT ON TABLE acq_fund TO bbonner;


--
-- Name: acq_fund_2; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE acq_fund_2 FROM PUBLIC;
REVOKE ALL ON TABLE acq_fund_2 FROM evergreen;
GRANT ALL ON TABLE acq_fund_2 TO evergreen;
GRANT SELECT ON TABLE acq_fund_2 TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_call_fix, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: cn_with_one_item; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE cn_with_one_item FROM PUBLIC;
REVOKE ALL ON TABLE cn_with_one_item FROM evergreen;
GRANT ALL ON TABLE cn_with_one_item TO evergreen;
GRANT SELECT ON TABLE cn_with_one_item TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: item_calls; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE item_calls FROM PUBLIC;
REVOKE ALL ON TABLE item_calls FROM evergreen;
GRANT ALL ON TABLE item_calls TO evergreen;
GRANT SELECT ON TABLE item_calls TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_call_fix; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_circhist, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: circhist; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE circhist FROM PUBLIC;
REVOKE ALL ON TABLE circhist FROM evergreen;
GRANT ALL ON TABLE circhist TO evergreen;
GRANT SELECT ON TABLE circhist TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_circhist; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_gap, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: alert_messages; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE alert_messages FROM PUBLIC;
REVOKE ALL ON TABLE alert_messages FROM evergreen;
GRANT ALL ON TABLE alert_messages TO evergreen;
GRANT SELECT ON TABLE alert_messages TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_legacy; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_legacy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_legacy FROM evergreen;
GRANT ALL ON TABLE asset_copy_legacy TO evergreen;
GRANT SELECT ON TABLE asset_copy_legacy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: copy_dupe_barcodes; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: int_notes; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE int_notes FROM PUBLIC;
REVOKE ALL ON TABLE int_notes FROM evergreen;
GRANT ALL ON TABLE int_notes TO evergreen;
GRANT SELECT ON TABLE int_notes TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: messages; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE messages FROM PUBLIC;
REVOKE ALL ON TABLE messages FROM evergreen;
GRANT ALL ON TABLE messages TO evergreen;
GRANT SELECT ON TABLE messages TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_gap; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_holds, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: rejected_holds; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_holds FROM PUBLIC;
REVOKE ALL ON TABLE rejected_holds FROM evergreen;
GRANT ALL ON TABLE rejected_holds TO evergreen;
GRANT SELECT ON TABLE rejected_holds TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_holds; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_holdsall, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_holdsall; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_holdsall2, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_holdsall2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_holdsall3, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_holdsall3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_holdsfix, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: action_hold_request_legacy; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request_legacy FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request_legacy FROM evergreen;
GRANT ALL ON TABLE action_hold_request_legacy TO evergreen;
GRANT SELECT ON TABLE action_hold_request_legacy TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: all_prod_holds; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE all_prod_holds FROM PUBLIC;
REVOKE ALL ON TABLE all_prod_holds FROM evergreen;
GRANT ALL ON TABLE all_prod_holds TO evergreen;
GRANT SELECT ON TABLE all_prod_holds TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: holds_to_delete; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE holds_to_delete FROM PUBLIC;
REVOKE ALL ON TABLE holds_to_delete FROM evergreen;
GRANT ALL ON TABLE holds_to_delete TO evergreen;
GRANT SELECT ON TABLE holds_to_delete TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: rejected_holds; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE rejected_holds FROM PUBLIC;
REVOKE ALL ON TABLE rejected_holds FROM evergreen;
GRANT ALL ON TABLE rejected_holds TO evergreen;
GRANT SELECT ON TABLE rejected_holds TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


--
-- Name: to_keep; Type: ACL; Schema: m_kcls_holdsfix; Owner: evergreen
--

REVOKE ALL ON TABLE to_keep FROM PUBLIC;
REVOKE ALL ON TABLE to_keep FROM evergreen;
GRANT ALL ON TABLE to_keep TO evergreen;
GRANT SELECT ON TABLE to_keep TO bbonner;


SET search_path = m_kcls_items2, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_legacy; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_legacy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_legacy FROM evergreen;
GRANT ALL ON TABLE asset_copy_legacy TO evergreen;
GRANT SELECT ON TABLE asset_copy_legacy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: copy_dupe_barcodes; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes TO bbonner;


--
-- Name: copy_dupe_barcodes2; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes2 FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes2 FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes2 TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes2 TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


--
-- Name: volumes; Type: ACL; Schema: m_kcls_items2; Owner: evergreen
--

REVOKE ALL ON TABLE volumes FROM PUBLIC;
REVOKE ALL ON TABLE volumes FROM evergreen;
GRANT ALL ON TABLE volumes TO evergreen;
GRANT SELECT ON TABLE volumes TO bbonner;


SET search_path = m_kcls_items3, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_legacy; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_legacy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_legacy FROM evergreen;
GRANT ALL ON TABLE asset_copy_legacy TO evergreen;
GRANT SELECT ON TABLE asset_copy_legacy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: calls; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE calls FROM PUBLIC;
REVOKE ALL ON TABLE calls FROM evergreen;
GRANT ALL ON TABLE calls TO evergreen;
GRANT SELECT ON TABLE calls TO bbonner;


--
-- Name: cn_to_del; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE cn_to_del FROM PUBLIC;
REVOKE ALL ON TABLE cn_to_del FROM evergreen;
GRANT ALL ON TABLE cn_to_del TO evergreen;
GRANT SELECT ON TABLE cn_to_del TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: copy_dupe_barcodes; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE copy_dupe_barcodes FROM PUBLIC;
REVOKE ALL ON TABLE copy_dupe_barcodes FROM evergreen;
GRANT ALL ON TABLE copy_dupe_barcodes TO evergreen;
GRANT SELECT ON TABLE copy_dupe_barcodes TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_items3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_ord, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: item_exceptions; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE item_exceptions FROM PUBLIC;
REVOKE ALL ON TABLE item_exceptions FROM evergreen;
GRANT ALL ON TABLE item_exceptions TO evergreen;
GRANT SELECT ON TABLE item_exceptions TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: on_order_items; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE on_order_items FROM PUBLIC;
REVOKE ALL ON TABLE on_order_items FROM evergreen;
GRANT ALL ON TABLE on_order_items TO evergreen;
GRANT SELECT ON TABLE on_order_items TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_ord; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_ord2, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: on_order_items; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE on_order_items FROM PUBLIC;
REVOKE ALL ON TABLE on_order_items FROM evergreen;
GRANT ALL ON TABLE on_order_items TO evergreen;
GRANT SELECT ON TABLE on_order_items TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_ord2; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_ord3, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: on_order_items; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE on_order_items FROM PUBLIC;
REVOKE ALL ON TABLE on_order_items FROM evergreen;
GRANT ALL ON TABLE on_order_items TO evergreen;
GRANT SELECT ON TABLE on_order_items TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_kcls_ord3; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = m_kcls_xfr, pg_catalog;

--
-- Name: billing_type; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE billing_type FROM PUBLIC;
REVOKE ALL ON TABLE billing_type FROM evergreen;
GRANT ALL ON TABLE billing_type TO evergreen;
GRANT SELECT ON TABLE billing_type TO bbonner;


--
-- Name: circ_modifier; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE circ_modifier FROM PUBLIC;
REVOKE ALL ON TABLE circ_modifier FROM evergreen;
GRANT ALL ON TABLE circ_modifier TO evergreen;
GRANT SELECT ON TABLE circ_modifier TO bbonner;


--
-- Name: grp_change; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE grp_change FROM PUBLIC;
REVOKE ALL ON TABLE grp_change FROM evergreen;
GRANT ALL ON TABLE grp_change TO evergreen;
GRANT SELECT ON TABLE grp_change TO bbonner;


--
-- Name: grp_tree; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE grp_tree FROM PUBLIC;
REVOKE ALL ON TABLE grp_tree FROM evergreen;
GRANT ALL ON TABLE grp_tree TO evergreen;
GRANT SELECT ON TABLE grp_tree TO bbonner;


--
-- Name: org_unit; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit FROM PUBLIC;
REVOKE ALL ON TABLE org_unit FROM evergreen;
GRANT ALL ON TABLE org_unit TO evergreen;
GRANT SELECT ON TABLE org_unit TO bbonner;


--
-- Name: org_unit_type; Type: ACL; Schema: m_kcls_xfr; Owner: evergreen
--

REVOKE ALL ON TABLE org_unit_type FROM PUBLIC;
REVOKE ALL ON TABLE org_unit_type FROM evergreen;
GRANT ALL ON TABLE org_unit_type TO evergreen;
GRANT SELECT ON TABLE org_unit_type TO bbonner;


SET search_path = m_test, pg_catalog;

--
-- Name: action_circulation; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE action_circulation FROM PUBLIC;
REVOKE ALL ON TABLE action_circulation FROM evergreen;
GRANT ALL ON TABLE action_circulation TO evergreen;
GRANT SELECT ON TABLE action_circulation TO bbonner;


--
-- Name: action_hold_notification; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_notification FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_notification FROM evergreen;
GRANT ALL ON TABLE action_hold_notification TO evergreen;
GRANT SELECT ON TABLE action_hold_notification TO bbonner;


--
-- Name: action_hold_request; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE action_hold_request FROM PUBLIC;
REVOKE ALL ON TABLE action_hold_request FROM evergreen;
GRANT ALL ON TABLE action_hold_request TO evergreen;
GRANT SELECT ON TABLE action_hold_request TO bbonner;


--
-- Name: actor_card; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_card FROM PUBLIC;
REVOKE ALL ON TABLE actor_card FROM evergreen;
GRANT ALL ON TABLE actor_card TO evergreen;
GRANT SELECT ON TABLE actor_card TO bbonner;


--
-- Name: actor_stat_cat; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat TO bbonner;


--
-- Name: actor_stat_cat_entry; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry TO bbonner;


--
-- Name: actor_stat_cat_entry_usr_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM PUBLIC;
REVOKE ALL ON TABLE actor_stat_cat_entry_usr_map FROM evergreen;
GRANT ALL ON TABLE actor_stat_cat_entry_usr_map TO evergreen;
GRANT SELECT ON TABLE actor_stat_cat_entry_usr_map TO bbonner;


--
-- Name: actor_usr; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr FROM evergreen;
GRANT ALL ON TABLE actor_usr TO evergreen;
GRANT SELECT ON TABLE actor_usr TO bbonner;


--
-- Name: actor_usr_address; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_address FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_address FROM evergreen;
GRANT ALL ON TABLE actor_usr_address TO evergreen;
GRANT SELECT ON TABLE actor_usr_address TO bbonner;


--
-- Name: actor_usr_note; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE actor_usr_note FROM PUBLIC;
REVOKE ALL ON TABLE actor_usr_note FROM evergreen;
GRANT ALL ON TABLE actor_usr_note TO evergreen;
GRANT SELECT ON TABLE actor_usr_note TO bbonner;


--
-- Name: asset_call_number; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_call_number FROM PUBLIC;
REVOKE ALL ON TABLE asset_call_number FROM evergreen;
GRANT ALL ON TABLE asset_call_number TO evergreen;
GRANT SELECT ON TABLE asset_call_number TO bbonner;


--
-- Name: asset_copy; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy FROM evergreen;
GRANT ALL ON TABLE asset_copy TO evergreen;
GRANT SELECT ON TABLE asset_copy TO bbonner;


--
-- Name: asset_copy_location; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_location FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_location FROM evergreen;
GRANT ALL ON TABLE asset_copy_location TO evergreen;
GRANT SELECT ON TABLE asset_copy_location TO bbonner;


--
-- Name: asset_copy_note; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_copy_note FROM PUBLIC;
REVOKE ALL ON TABLE asset_copy_note FROM evergreen;
GRANT ALL ON TABLE asset_copy_note TO evergreen;
GRANT SELECT ON TABLE asset_copy_note TO bbonner;


--
-- Name: asset_stat_cat; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat TO bbonner;


--
-- Name: asset_stat_cat_entry; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry TO bbonner;


--
-- Name: asset_stat_cat_entry_copy_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM PUBLIC;
REVOKE ALL ON TABLE asset_stat_cat_entry_copy_map FROM evergreen;
GRANT ALL ON TABLE asset_stat_cat_entry_copy_map TO evergreen;
GRANT SELECT ON TABLE asset_stat_cat_entry_copy_map TO bbonner;


--
-- Name: base_circ_field_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE base_circ_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_circ_field_map FROM evergreen;
GRANT ALL ON TABLE base_circ_field_map TO evergreen;
GRANT SELECT ON TABLE base_circ_field_map TO bbonner;


--
-- Name: base_circ_field_map_id_seq; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_circ_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_circ_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_circ_field_map_id_seq TO bbonner;


--
-- Name: base_copy_location_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE base_copy_location_map FROM PUBLIC;
REVOKE ALL ON TABLE base_copy_location_map FROM evergreen;
GRANT ALL ON TABLE base_copy_location_map TO evergreen;
GRANT SELECT ON TABLE base_copy_location_map TO bbonner;


--
-- Name: base_copy_location_map_id_seq; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_copy_location_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_copy_location_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_copy_location_map_id_seq TO bbonner;


--
-- Name: base_item_dynamic_field_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE base_item_dynamic_field_map FROM PUBLIC;
REVOKE ALL ON TABLE base_item_dynamic_field_map FROM evergreen;
GRANT ALL ON TABLE base_item_dynamic_field_map TO evergreen;
GRANT SELECT ON TABLE base_item_dynamic_field_map TO bbonner;


--
-- Name: base_item_dynamic_field_map_id_seq; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_item_dynamic_field_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_item_dynamic_field_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_item_dynamic_field_map_id_seq TO bbonner;


--
-- Name: base_profile_map; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE base_profile_map FROM PUBLIC;
REVOKE ALL ON TABLE base_profile_map FROM evergreen;
GRANT ALL ON TABLE base_profile_map TO evergreen;
GRANT SELECT ON TABLE base_profile_map TO bbonner;


--
-- Name: base_profile_map_id_seq; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE base_profile_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE base_profile_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE base_profile_map_id_seq TO bbonner;


--
-- Name: circhist; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE circhist FROM PUBLIC;
REVOKE ALL ON TABLE circhist FROM evergreen;
GRANT ALL ON TABLE circhist TO evergreen;
GRANT SELECT ON TABLE circhist TO bbonner;


--
-- Name: config; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE config FROM PUBLIC;
REVOKE ALL ON TABLE config FROM evergreen;
GRANT ALL ON TABLE config TO evergreen;
GRANT SELECT ON TABLE config TO bbonner;


--
-- Name: fields_requiring_mapping; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE fields_requiring_mapping FROM PUBLIC;
REVOKE ALL ON TABLE fields_requiring_mapping FROM evergreen;
GRANT ALL ON TABLE fields_requiring_mapping TO evergreen;
GRANT SELECT ON TABLE fields_requiring_mapping TO bbonner;


--
-- Name: money_billing; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE money_billing FROM PUBLIC;
REVOKE ALL ON TABLE money_billing FROM evergreen;
GRANT ALL ON TABLE money_billing TO evergreen;
GRANT SELECT ON TABLE money_billing TO bbonner;


--
-- Name: money_cash_payment; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE money_cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_cash_payment FROM evergreen;
GRANT ALL ON TABLE money_cash_payment TO evergreen;
GRANT SELECT ON TABLE money_cash_payment TO bbonner;


--
-- Name: money_forgive_payment; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE money_forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE money_forgive_payment FROM evergreen;
GRANT ALL ON TABLE money_forgive_payment TO evergreen;
GRANT SELECT ON TABLE money_forgive_payment TO bbonner;


--
-- Name: money_grocery; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE money_grocery FROM PUBLIC;
REVOKE ALL ON TABLE money_grocery FROM evergreen;
GRANT ALL ON TABLE money_grocery TO evergreen;
GRANT SELECT ON TABLE money_grocery TO bbonner;


--
-- Name: sql_current; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE sql_current FROM PUBLIC;
REVOKE ALL ON TABLE sql_current FROM evergreen;
GRANT ALL ON TABLE sql_current TO evergreen;
GRANT SELECT ON TABLE sql_current TO bbonner;


--
-- Name: sql_log; Type: ACL; Schema: m_test; Owner: evergreen
--

REVOKE ALL ON TABLE sql_log FROM PUBLIC;
REVOKE ALL ON TABLE sql_log FROM evergreen;
GRANT ALL ON TABLE sql_log TO evergreen;
GRANT SELECT ON TABLE sql_log TO bbonner;


SET search_path = metabib, pg_catalog;

--
-- Name: author_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE author_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE author_field_entry FROM evergreen;
GRANT ALL ON TABLE author_field_entry TO evergreen;
GRANT ALL ON TABLE author_field_entry TO bbonner;


--
-- Name: author_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE author_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE author_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE author_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE author_field_entry_id_seq TO bbonner;


--
-- Name: bib_export_data; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE bib_export_data FROM PUBLIC;
REVOKE ALL ON TABLE bib_export_data FROM evergreen;
GRANT ALL ON TABLE bib_export_data TO evergreen;


--
-- Name: browse_author_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_author_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_author_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_author_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_author_entry_def_map TO bbonner;


--
-- Name: browse_call_number_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_call_number_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_call_number_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_call_number_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_call_number_entry_def_map TO bbonner;


--
-- Name: browse_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_entry FROM PUBLIC;
REVOKE ALL ON TABLE browse_entry FROM evergreen;
GRANT ALL ON TABLE browse_entry TO evergreen;
GRANT ALL ON TABLE browse_entry TO bbonner;


--
-- Name: browse_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_entry_def_map TO bbonner;


--
-- Name: browse_entry_def_map_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE browse_entry_def_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE browse_entry_def_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE browse_entry_def_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE browse_entry_def_map_id_seq TO bbonner;


--
-- Name: browse_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE browse_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE browse_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE browse_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE browse_entry_id_seq TO bbonner;


--
-- Name: browse_series_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_series_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_series_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_series_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_series_entry_def_map TO bbonner;


--
-- Name: browse_subject_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_subject_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_subject_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_subject_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_subject_entry_def_map TO bbonner;


--
-- Name: browse_title_entry_def_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE browse_title_entry_def_map FROM PUBLIC;
REVOKE ALL ON TABLE browse_title_entry_def_map FROM evergreen;
GRANT ALL ON TABLE browse_title_entry_def_map TO evergreen;
GRANT ALL ON TABLE browse_title_entry_def_map TO bbonner;


--
-- Name: call_number_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE call_number_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE call_number_field_entry FROM evergreen;
GRANT ALL ON TABLE call_number_field_entry TO evergreen;
GRANT ALL ON TABLE call_number_field_entry TO bbonner;
GRANT SELECT ON TABLE call_number_field_entry TO biblio;


--
-- Name: combined_author_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_author_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_author_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_author_field_entry TO evergreen;
GRANT ALL ON TABLE combined_author_field_entry TO bbonner;


--
-- Name: combined_identifier_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_identifier_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_identifier_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_identifier_field_entry TO evergreen;
GRANT ALL ON TABLE combined_identifier_field_entry TO bbonner;


--
-- Name: combined_keyword_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_keyword_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_keyword_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_keyword_field_entry TO evergreen;
GRANT ALL ON TABLE combined_keyword_field_entry TO bbonner;


--
-- Name: combined_series_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_series_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_series_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_series_field_entry TO evergreen;
GRANT ALL ON TABLE combined_series_field_entry TO bbonner;


--
-- Name: combined_subject_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_subject_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_subject_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_subject_field_entry TO evergreen;
GRANT ALL ON TABLE combined_subject_field_entry TO bbonner;


--
-- Name: combined_title_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE combined_title_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE combined_title_field_entry FROM evergreen;
GRANT ALL ON TABLE combined_title_field_entry TO evergreen;
GRANT ALL ON TABLE combined_title_field_entry TO bbonner;


--
-- Name: facet_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE facet_entry FROM PUBLIC;
REVOKE ALL ON TABLE facet_entry FROM evergreen;
GRANT ALL ON TABLE facet_entry TO evergreen;
GRANT ALL ON TABLE facet_entry TO bbonner;


--
-- Name: facet_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE facet_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE facet_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE facet_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE facet_entry_id_seq TO bbonner;


--
-- Name: identifier_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE identifier_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE identifier_field_entry FROM evergreen;
GRANT ALL ON TABLE identifier_field_entry TO evergreen;
GRANT ALL ON TABLE identifier_field_entry TO bbonner;


--
-- Name: identifier_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE identifier_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE identifier_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE identifier_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE identifier_field_entry_id_seq TO bbonner;


--
-- Name: keyword_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE keyword_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE keyword_field_entry FROM evergreen;
GRANT ALL ON TABLE keyword_field_entry TO evergreen;
GRANT ALL ON TABLE keyword_field_entry TO bbonner;


--
-- Name: keyword_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE keyword_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE keyword_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE keyword_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE keyword_field_entry_id_seq TO bbonner;


--
-- Name: language_filter; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE language_filter FROM PUBLIC;
REVOKE ALL ON TABLE language_filter FROM evergreen;
GRANT ALL ON TABLE language_filter TO evergreen;
GRANT ALL ON TABLE language_filter TO bbonner;


--
-- Name: language_filter_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE language_filter_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE language_filter_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE language_filter_id_seq TO evergreen;
GRANT ALL ON SEQUENCE language_filter_id_seq TO bbonner;


--
-- Name: metarecord; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE metarecord FROM PUBLIC;
REVOKE ALL ON TABLE metarecord FROM evergreen;
GRANT ALL ON TABLE metarecord TO evergreen;
GRANT ALL ON TABLE metarecord TO bbonner;


--
-- Name: metarecord_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metarecord_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metarecord_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metarecord_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metarecord_id_seq TO bbonner;


--
-- Name: metarecord_source_map; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE metarecord_source_map FROM PUBLIC;
REVOKE ALL ON TABLE metarecord_source_map FROM evergreen;
GRANT ALL ON TABLE metarecord_source_map TO evergreen;
GRANT ALL ON TABLE metarecord_source_map TO bbonner;


--
-- Name: metarecord_source_map_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE metarecord_source_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE metarecord_source_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE metarecord_source_map_id_seq TO evergreen;
GRANT ALL ON SEQUENCE metarecord_source_map_id_seq TO bbonner;


--
-- Name: normalized_author_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE normalized_author_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE normalized_author_field_entry FROM evergreen;
GRANT ALL ON TABLE normalized_author_field_entry TO evergreen;
GRANT ALL ON TABLE normalized_author_field_entry TO bbonner;


--
-- Name: normalized_keyword_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE normalized_keyword_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE normalized_keyword_field_entry FROM evergreen;
GRANT ALL ON TABLE normalized_keyword_field_entry TO evergreen;
GRANT ALL ON TABLE normalized_keyword_field_entry TO bbonner;


--
-- Name: normalized_series_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE normalized_series_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE normalized_series_field_entry FROM evergreen;
GRANT ALL ON TABLE normalized_series_field_entry TO evergreen;
GRANT ALL ON TABLE normalized_series_field_entry TO bbonner;


--
-- Name: normalized_subject_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE normalized_subject_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE normalized_subject_field_entry FROM evergreen;
GRANT ALL ON TABLE normalized_subject_field_entry TO evergreen;
GRANT ALL ON TABLE normalized_subject_field_entry TO bbonner;


--
-- Name: normalized_title_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE normalized_title_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE normalized_title_field_entry FROM evergreen;
GRANT ALL ON TABLE normalized_title_field_entry TO evergreen;
GRANT ALL ON TABLE normalized_title_field_entry TO bbonner;


--
-- Name: record_attr; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE record_attr FROM PUBLIC;
REVOKE ALL ON TABLE record_attr FROM evergreen;
GRANT ALL ON TABLE record_attr TO evergreen;
GRANT ALL ON TABLE record_attr TO bbonner;


--
-- Name: rec_descriptor; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE rec_descriptor FROM PUBLIC;
REVOKE ALL ON TABLE rec_descriptor FROM evergreen;
GRANT ALL ON TABLE rec_descriptor TO evergreen;
GRANT ALL ON TABLE rec_descriptor TO bbonner;


--
-- Name: record_attr_back; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE record_attr_back FROM PUBLIC;
REVOKE ALL ON TABLE record_attr_back FROM evergreen;
GRANT ALL ON TABLE record_attr_back TO evergreen;
GRANT ALL ON TABLE record_attr_back TO bbonner;


--
-- Name: series_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE series_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE series_field_entry FROM evergreen;
GRANT ALL ON TABLE series_field_entry TO evergreen;
GRANT ALL ON TABLE series_field_entry TO bbonner;


--
-- Name: series_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE series_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE series_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE series_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE series_field_entry_id_seq TO bbonner;


--
-- Name: subject_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE subject_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE subject_field_entry FROM evergreen;
GRANT ALL ON TABLE subject_field_entry TO evergreen;
GRANT ALL ON TABLE subject_field_entry TO bbonner;


--
-- Name: subject_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE subject_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE subject_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE subject_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE subject_field_entry_id_seq TO bbonner;


--
-- Name: title_field_entry; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON TABLE title_field_entry FROM PUBLIC;
REVOKE ALL ON TABLE title_field_entry FROM evergreen;
GRANT ALL ON TABLE title_field_entry TO evergreen;
GRANT ALL ON TABLE title_field_entry TO bbonner;
GRANT SELECT ON TABLE title_field_entry TO biblio;


--
-- Name: title_field_entry_id_seq; Type: ACL; Schema: metabib; Owner: evergreen
--

REVOKE ALL ON SEQUENCE title_field_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE title_field_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE title_field_entry_id_seq TO evergreen;
GRANT ALL ON SEQUENCE title_field_entry_id_seq TO bbonner;


SET search_path = migration_tools, pg_catalog;

--
-- Name: db_object_stash; Type: ACL; Schema: migration_tools; Owner: evergreen
--

REVOKE ALL ON TABLE db_object_stash FROM PUBLIC;
REVOKE ALL ON TABLE db_object_stash FROM evergreen;
GRANT ALL ON TABLE db_object_stash TO evergreen;
GRANT SELECT ON TABLE db_object_stash TO bbonner;


SET search_path = money, pg_catalog;

--
-- Name: materialized_billable_xact_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE materialized_billable_xact_summary FROM PUBLIC;
REVOKE ALL ON TABLE materialized_billable_xact_summary FROM evergreen;
GRANT ALL ON TABLE materialized_billable_xact_summary TO evergreen;
GRANT ALL ON TABLE materialized_billable_xact_summary TO bbonner;
GRANT SELECT ON TABLE materialized_billable_xact_summary TO biblio;


--
-- Name: billable_xact_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE billable_xact_summary FROM PUBLIC;
REVOKE ALL ON TABLE billable_xact_summary FROM evergreen;
GRANT ALL ON TABLE billable_xact_summary TO evergreen;
GRANT SELECT ON TABLE billable_xact_summary TO bbonner;


--
-- Name: grocery; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE grocery FROM PUBLIC;
REVOKE ALL ON TABLE grocery FROM evergreen;
GRANT ALL ON TABLE grocery TO evergreen;
GRANT SELECT ON TABLE grocery TO bbonner;


--
-- Name: billable_xact_summary_location_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE billable_xact_summary_location_view FROM PUBLIC;
REVOKE ALL ON TABLE billable_xact_summary_location_view FROM evergreen;
GRANT ALL ON TABLE billable_xact_summary_location_view TO evergreen;
GRANT SELECT ON TABLE billable_xact_summary_location_view TO bbonner;


--
-- Name: payment_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE payment_view FROM PUBLIC;
REVOKE ALL ON TABLE payment_view FROM evergreen;
GRANT ALL ON TABLE payment_view TO evergreen;
GRANT SELECT ON TABLE payment_view TO bbonner;


--
-- Name: billable_xact_with_void_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE billable_xact_with_void_summary FROM PUBLIC;
REVOKE ALL ON TABLE billable_xact_with_void_summary FROM evergreen;
GRANT ALL ON TABLE billable_xact_with_void_summary TO evergreen;
GRANT SELECT ON TABLE billable_xact_with_void_summary TO bbonner;


--
-- Name: bnm_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE bnm_payment FROM PUBLIC;
REVOKE ALL ON TABLE bnm_payment FROM evergreen;
GRANT ALL ON TABLE bnm_payment TO evergreen;
GRANT SELECT ON TABLE bnm_payment TO bbonner;


--
-- Name: bnm_desk_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE bnm_desk_payment FROM PUBLIC;
REVOKE ALL ON TABLE bnm_desk_payment FROM evergreen;
GRANT ALL ON TABLE bnm_desk_payment TO evergreen;
GRANT SELECT ON TABLE bnm_desk_payment TO bbonner;


--
-- Name: bnm_payment_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE bnm_payment_view FROM PUBLIC;
REVOKE ALL ON TABLE bnm_payment_view FROM evergreen;
GRANT ALL ON TABLE bnm_payment_view TO evergreen;
GRANT SELECT ON TABLE bnm_payment_view TO bbonner;


--
-- Name: cash_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE cash_payment FROM PUBLIC;
REVOKE ALL ON TABLE cash_payment FROM evergreen;
GRANT ALL ON TABLE cash_payment TO evergreen;
GRANT SELECT ON TABLE cash_payment TO bbonner;


--
-- Name: cashdrawer_payment_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE cashdrawer_payment_view FROM PUBLIC;
REVOKE ALL ON TABLE cashdrawer_payment_view FROM evergreen;
GRANT ALL ON TABLE cashdrawer_payment_view TO evergreen;
GRANT SELECT ON TABLE cashdrawer_payment_view TO bbonner;


--
-- Name: check_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE check_payment FROM PUBLIC;
REVOKE ALL ON TABLE check_payment FROM evergreen;
GRANT ALL ON TABLE check_payment TO evergreen;
GRANT SELECT ON TABLE check_payment TO bbonner;


--
-- Name: collections_tracker; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE collections_tracker FROM PUBLIC;
REVOKE ALL ON TABLE collections_tracker FROM evergreen;
GRANT ALL ON TABLE collections_tracker TO evergreen;
GRANT SELECT ON TABLE collections_tracker TO bbonner;


--
-- Name: collections_tracker_id_seq; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON SEQUENCE collections_tracker_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE collections_tracker_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE collections_tracker_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE collections_tracker_id_seq TO bbonner;


--
-- Name: credit_card_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE credit_card_payment FROM PUBLIC;
REVOKE ALL ON TABLE credit_card_payment FROM evergreen;
GRANT ALL ON TABLE credit_card_payment TO evergreen;
GRANT SELECT ON TABLE credit_card_payment TO bbonner;


--
-- Name: credit_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE credit_payment FROM PUBLIC;
REVOKE ALL ON TABLE credit_payment FROM evergreen;
GRANT ALL ON TABLE credit_payment TO evergreen;
GRANT SELECT ON TABLE credit_payment TO bbonner;


--
-- Name: desk_payment_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE desk_payment_view FROM PUBLIC;
REVOKE ALL ON TABLE desk_payment_view FROM evergreen;
GRANT ALL ON TABLE desk_payment_view TO evergreen;
GRANT SELECT ON TABLE desk_payment_view TO bbonner;


--
-- Name: forgive_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE forgive_payment FROM PUBLIC;
REVOKE ALL ON TABLE forgive_payment FROM evergreen;
GRANT ALL ON TABLE forgive_payment TO evergreen;
GRANT SELECT ON TABLE forgive_payment TO bbonner;


--
-- Name: goods_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE goods_payment FROM PUBLIC;
REVOKE ALL ON TABLE goods_payment FROM evergreen;
GRANT ALL ON TABLE goods_payment TO evergreen;
GRANT SELECT ON TABLE goods_payment TO bbonner;


--
-- Name: non_drawer_payment_view; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE non_drawer_payment_view FROM PUBLIC;
REVOKE ALL ON TABLE non_drawer_payment_view FROM evergreen;
GRANT ALL ON TABLE non_drawer_payment_view TO evergreen;
GRANT SELECT ON TABLE non_drawer_payment_view TO bbonner;


--
-- Name: open_circ_balance_by_circ_and_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_circ_balance_by_circ_and_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_circ_balance_by_circ_and_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_circ_balance_by_circ_and_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_circ_balance_by_circ_and_owning_lib TO bbonner;


--
-- Name: open_balance_by_circ_and_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_balance_by_circ_and_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_balance_by_circ_and_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_balance_by_circ_and_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_balance_by_circ_and_owning_lib TO bbonner;


--
-- Name: open_circ_balance_by_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_circ_balance_by_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_circ_balance_by_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_circ_balance_by_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_circ_balance_by_owning_lib TO bbonner;


--
-- Name: open_balance_by_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_balance_by_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_balance_by_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_balance_by_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_balance_by_owning_lib TO bbonner;


--
-- Name: open_circ_balance_by_usr_home_and_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_circ_balance_by_usr_home_and_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_circ_balance_by_usr_home_and_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_circ_balance_by_usr_home_and_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_circ_balance_by_usr_home_and_owning_lib TO bbonner;


--
-- Name: open_balance_by_usr_home_and_owning_lib; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_balance_by_usr_home_and_owning_lib FROM PUBLIC;
REVOKE ALL ON TABLE open_balance_by_usr_home_and_owning_lib FROM evergreen;
GRANT ALL ON TABLE open_balance_by_usr_home_and_owning_lib TO evergreen;
GRANT SELECT ON TABLE open_balance_by_usr_home_and_owning_lib TO bbonner;


--
-- Name: open_billable_xact_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_billable_xact_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_billable_xact_summary FROM evergreen;
GRANT ALL ON TABLE open_billable_xact_summary TO evergreen;
GRANT SELECT ON TABLE open_billable_xact_summary TO bbonner;


--
-- Name: open_transaction_billing_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_transaction_billing_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_transaction_billing_summary FROM evergreen;
GRANT ALL ON TABLE open_transaction_billing_summary TO evergreen;
GRANT SELECT ON TABLE open_transaction_billing_summary TO bbonner;


--
-- Name: open_transaction_billing_type_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_transaction_billing_type_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_transaction_billing_type_summary FROM evergreen;
GRANT ALL ON TABLE open_transaction_billing_type_summary TO evergreen;
GRANT SELECT ON TABLE open_transaction_billing_type_summary TO bbonner;


--
-- Name: open_transaction_payment_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_transaction_payment_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_transaction_payment_summary FROM evergreen;
GRANT ALL ON TABLE open_transaction_payment_summary TO evergreen;
GRANT SELECT ON TABLE open_transaction_payment_summary TO bbonner;


--
-- Name: open_usr_circulation_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_usr_circulation_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_usr_circulation_summary FROM evergreen;
GRANT ALL ON TABLE open_usr_circulation_summary TO evergreen;
GRANT SELECT ON TABLE open_usr_circulation_summary TO bbonner;


--
-- Name: open_usr_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE open_usr_summary FROM PUBLIC;
REVOKE ALL ON TABLE open_usr_summary FROM evergreen;
GRANT ALL ON TABLE open_usr_summary TO evergreen;
GRANT SELECT ON TABLE open_usr_summary TO bbonner;


--
-- Name: tmp_billable_xact_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE tmp_billable_xact_summary FROM PUBLIC;
REVOKE ALL ON TABLE tmp_billable_xact_summary FROM evergreen;
GRANT ALL ON TABLE tmp_billable_xact_summary TO evergreen;
GRANT SELECT ON TABLE tmp_billable_xact_summary TO bbonner;


--
-- Name: transaction_billing_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE transaction_billing_summary FROM PUBLIC;
REVOKE ALL ON TABLE transaction_billing_summary FROM evergreen;
GRANT ALL ON TABLE transaction_billing_summary TO evergreen;
GRANT SELECT ON TABLE transaction_billing_summary TO bbonner;


--
-- Name: transaction_billing_type_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE transaction_billing_type_summary FROM PUBLIC;
REVOKE ALL ON TABLE transaction_billing_type_summary FROM evergreen;
GRANT ALL ON TABLE transaction_billing_type_summary TO evergreen;
GRANT SELECT ON TABLE transaction_billing_type_summary TO bbonner;


--
-- Name: transaction_billing_with_void_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE transaction_billing_with_void_summary FROM PUBLIC;
REVOKE ALL ON TABLE transaction_billing_with_void_summary FROM evergreen;
GRANT ALL ON TABLE transaction_billing_with_void_summary TO evergreen;
GRANT SELECT ON TABLE transaction_billing_with_void_summary TO bbonner;


--
-- Name: transaction_payment_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE transaction_payment_summary FROM PUBLIC;
REVOKE ALL ON TABLE transaction_payment_summary FROM evergreen;
GRANT ALL ON TABLE transaction_payment_summary TO evergreen;
GRANT SELECT ON TABLE transaction_payment_summary TO bbonner;


--
-- Name: transaction_payment_with_void_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE transaction_payment_with_void_summary FROM PUBLIC;
REVOKE ALL ON TABLE transaction_payment_with_void_summary FROM evergreen;
GRANT ALL ON TABLE transaction_payment_with_void_summary TO evergreen;
GRANT SELECT ON TABLE transaction_payment_with_void_summary TO bbonner;


--
-- Name: usr_circulation_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE usr_circulation_summary FROM PUBLIC;
REVOKE ALL ON TABLE usr_circulation_summary FROM evergreen;
GRANT ALL ON TABLE usr_circulation_summary TO evergreen;
GRANT SELECT ON TABLE usr_circulation_summary TO bbonner;


--
-- Name: usr_summary; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE usr_summary FROM PUBLIC;
REVOKE ALL ON TABLE usr_summary FROM evergreen;
GRANT ALL ON TABLE usr_summary TO evergreen;
GRANT SELECT ON TABLE usr_summary TO bbonner;


--
-- Name: work_payment; Type: ACL; Schema: money; Owner: evergreen
--

REVOKE ALL ON TABLE work_payment FROM PUBLIC;
REVOKE ALL ON TABLE work_payment FROM evergreen;
GRANT ALL ON TABLE work_payment TO evergreen;
GRANT SELECT ON TABLE work_payment TO bbonner;


SET search_path = offline, pg_catalog;

--
-- Name: script; Type: ACL; Schema: offline; Owner: evergreen
--

REVOKE ALL ON TABLE script FROM PUBLIC;
REVOKE ALL ON TABLE script FROM evergreen;
GRANT ALL ON TABLE script TO evergreen;
GRANT ALL ON TABLE script TO bbonner;


--
-- Name: script_id_seq; Type: ACL; Schema: offline; Owner: evergreen
--

REVOKE ALL ON SEQUENCE script_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE script_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE script_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE script_id_seq TO bbonner;


--
-- Name: session; Type: ACL; Schema: offline; Owner: evergreen
--

REVOKE ALL ON TABLE session FROM PUBLIC;
REVOKE ALL ON TABLE session FROM evergreen;
GRANT ALL ON TABLE session TO evergreen;
GRANT ALL ON TABLE session TO bbonner;


SET search_path = permission, pg_catalog;

--
-- Name: grp_penalty_threshold; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE grp_penalty_threshold FROM PUBLIC;
REVOKE ALL ON TABLE grp_penalty_threshold FROM evergreen;
GRANT ALL ON TABLE grp_penalty_threshold TO evergreen;
GRANT SELECT ON TABLE grp_penalty_threshold TO bbonner;


--
-- Name: grp_penalty_threshold_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE grp_penalty_threshold_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE grp_penalty_threshold_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE grp_penalty_threshold_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE grp_penalty_threshold_id_seq TO bbonner;


--
-- Name: grp_perm_map; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE grp_perm_map FROM PUBLIC;
REVOKE ALL ON TABLE grp_perm_map FROM evergreen;
GRANT ALL ON TABLE grp_perm_map TO evergreen;
GRANT SELECT ON TABLE grp_perm_map TO bbonner;


--
-- Name: grp_perm_map_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE grp_perm_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE grp_perm_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE grp_perm_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE grp_perm_map_id_seq TO bbonner;


--
-- Name: grp_tree_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE grp_tree_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE grp_tree_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE grp_tree_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE grp_tree_id_seq TO bbonner;


--
-- Name: perm_list; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE perm_list FROM PUBLIC;
REVOKE ALL ON TABLE perm_list FROM evergreen;
GRANT ALL ON TABLE perm_list TO evergreen;
GRANT SELECT ON TABLE perm_list TO bbonner;


--
-- Name: perm_list_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE perm_list_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE perm_list_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE perm_list_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE perm_list_id_seq TO bbonner;


--
-- Name: usr_grp_map; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE usr_grp_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_grp_map FROM evergreen;
GRANT ALL ON TABLE usr_grp_map TO evergreen;
GRANT SELECT ON TABLE usr_grp_map TO bbonner;


--
-- Name: usr_grp_map_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_grp_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_grp_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_grp_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_grp_map_id_seq TO bbonner;


--
-- Name: usr_object_perm_map; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE usr_object_perm_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_object_perm_map FROM evergreen;
GRANT ALL ON TABLE usr_object_perm_map TO evergreen;
GRANT SELECT ON TABLE usr_object_perm_map TO bbonner;


--
-- Name: usr_object_perm_map_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_object_perm_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_object_perm_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_object_perm_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_object_perm_map_id_seq TO bbonner;


--
-- Name: usr_perm_map_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_perm_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_perm_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_perm_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_perm_map_id_seq TO bbonner;


--
-- Name: usr_work_ou_map; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON TABLE usr_work_ou_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_work_ou_map FROM evergreen;
GRANT ALL ON TABLE usr_work_ou_map TO evergreen;
GRANT SELECT ON TABLE usr_work_ou_map TO bbonner;


--
-- Name: usr_work_ou_map_id_seq; Type: ACL; Schema: permission; Owner: evergreen
--

REVOKE ALL ON SEQUENCE usr_work_ou_map_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE usr_work_ou_map_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE usr_work_ou_map_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE usr_work_ou_map_id_seq TO bbonner;


SET search_path = prod_staff_users, pg_catalog;

--
-- Name: card; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE card FROM PUBLIC;
REVOKE ALL ON TABLE card FROM evergreen;
GRANT ALL ON TABLE card TO evergreen;
GRANT SELECT ON TABLE card TO bbonner;


--
-- Name: save_source; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE save_source FROM PUBLIC;
REVOKE ALL ON TABLE save_source FROM evergreen;
GRANT ALL ON TABLE save_source TO evergreen;
GRANT SELECT ON TABLE save_source TO bbonner;


--
-- Name: save_these; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE save_these FROM PUBLIC;
REVOKE ALL ON TABLE save_these FROM evergreen;
GRANT ALL ON TABLE save_these TO evergreen;
GRANT SELECT ON TABLE save_these TO bbonner;


--
-- Name: usr; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE usr FROM PUBLIC;
REVOKE ALL ON TABLE usr FROM evergreen;
GRANT ALL ON TABLE usr TO evergreen;
GRANT SELECT ON TABLE usr TO bbonner;


--
-- Name: usr_address; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE usr_address FROM PUBLIC;
REVOKE ALL ON TABLE usr_address FROM evergreen;
GRANT ALL ON TABLE usr_address TO evergreen;
GRANT SELECT ON TABLE usr_address TO bbonner;


--
-- Name: usr_perm_map; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE usr_perm_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_perm_map FROM evergreen;
GRANT ALL ON TABLE usr_perm_map TO evergreen;
GRANT SELECT ON TABLE usr_perm_map TO bbonner;


--
-- Name: usr_setting; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE usr_setting FROM PUBLIC;
REVOKE ALL ON TABLE usr_setting FROM evergreen;
GRANT ALL ON TABLE usr_setting TO evergreen;
GRANT SELECT ON TABLE usr_setting TO bbonner;


--
-- Name: usr_work_ou_map; Type: ACL; Schema: prod_staff_users; Owner: evergreen
--

REVOKE ALL ON TABLE usr_work_ou_map FROM PUBLIC;
REVOKE ALL ON TABLE usr_work_ou_map FROM evergreen;
GRANT ALL ON TABLE usr_work_ou_map TO evergreen;
GRANT SELECT ON TABLE usr_work_ou_map TO bbonner;


SET search_path = query, pg_catalog;

--
-- Name: bind_variable; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE bind_variable FROM PUBLIC;
REVOKE ALL ON TABLE bind_variable FROM evergreen;
GRANT ALL ON TABLE bind_variable TO evergreen;
GRANT SELECT ON TABLE bind_variable TO bbonner;


--
-- Name: case_branch; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE case_branch FROM PUBLIC;
REVOKE ALL ON TABLE case_branch FROM evergreen;
GRANT ALL ON TABLE case_branch TO evergreen;
GRANT SELECT ON TABLE case_branch TO bbonner;


--
-- Name: case_branch_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE case_branch_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE case_branch_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE case_branch_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE case_branch_id_seq TO bbonner;


--
-- Name: datatype; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE datatype FROM PUBLIC;
REVOKE ALL ON TABLE datatype FROM evergreen;
GRANT ALL ON TABLE datatype TO evergreen;
GRANT SELECT ON TABLE datatype TO bbonner;


--
-- Name: datatype_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE datatype_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE datatype_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE datatype_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE datatype_id_seq TO bbonner;


--
-- Name: expression; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expression FROM PUBLIC;
REVOKE ALL ON TABLE expression FROM evergreen;
GRANT ALL ON TABLE expression TO evergreen;
GRANT SELECT ON TABLE expression TO bbonner;


--
-- Name: expr_xbet; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xbet FROM PUBLIC;
REVOKE ALL ON TABLE expr_xbet FROM evergreen;
GRANT ALL ON TABLE expr_xbet TO evergreen;
GRANT SELECT ON TABLE expr_xbet TO bbonner;


--
-- Name: expr_xbind; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xbind FROM PUBLIC;
REVOKE ALL ON TABLE expr_xbind FROM evergreen;
GRANT ALL ON TABLE expr_xbind TO evergreen;
GRANT SELECT ON TABLE expr_xbind TO bbonner;


--
-- Name: expr_xbool; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xbool FROM PUBLIC;
REVOKE ALL ON TABLE expr_xbool FROM evergreen;
GRANT ALL ON TABLE expr_xbool TO evergreen;
GRANT SELECT ON TABLE expr_xbool TO bbonner;


--
-- Name: expr_xcase; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xcase FROM PUBLIC;
REVOKE ALL ON TABLE expr_xcase FROM evergreen;
GRANT ALL ON TABLE expr_xcase TO evergreen;
GRANT SELECT ON TABLE expr_xcase TO bbonner;


--
-- Name: expr_xcast; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xcast FROM PUBLIC;
REVOKE ALL ON TABLE expr_xcast FROM evergreen;
GRANT ALL ON TABLE expr_xcast TO evergreen;
GRANT SELECT ON TABLE expr_xcast TO bbonner;


--
-- Name: expr_xcol; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xcol FROM PUBLIC;
REVOKE ALL ON TABLE expr_xcol FROM evergreen;
GRANT ALL ON TABLE expr_xcol TO evergreen;
GRANT SELECT ON TABLE expr_xcol TO bbonner;


--
-- Name: expr_xex; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xex FROM PUBLIC;
REVOKE ALL ON TABLE expr_xex FROM evergreen;
GRANT ALL ON TABLE expr_xex TO evergreen;
GRANT SELECT ON TABLE expr_xex TO bbonner;


--
-- Name: expr_xfunc; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xfunc FROM PUBLIC;
REVOKE ALL ON TABLE expr_xfunc FROM evergreen;
GRANT ALL ON TABLE expr_xfunc TO evergreen;
GRANT SELECT ON TABLE expr_xfunc TO bbonner;


--
-- Name: expr_xin; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xin FROM PUBLIC;
REVOKE ALL ON TABLE expr_xin FROM evergreen;
GRANT ALL ON TABLE expr_xin TO evergreen;
GRANT SELECT ON TABLE expr_xin TO bbonner;


--
-- Name: expr_xisnull; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xisnull FROM PUBLIC;
REVOKE ALL ON TABLE expr_xisnull FROM evergreen;
GRANT ALL ON TABLE expr_xisnull TO evergreen;
GRANT SELECT ON TABLE expr_xisnull TO bbonner;


--
-- Name: expr_xnull; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xnull FROM PUBLIC;
REVOKE ALL ON TABLE expr_xnull FROM evergreen;
GRANT ALL ON TABLE expr_xnull TO evergreen;
GRANT SELECT ON TABLE expr_xnull TO bbonner;


--
-- Name: expr_xnum; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xnum FROM PUBLIC;
REVOKE ALL ON TABLE expr_xnum FROM evergreen;
GRANT ALL ON TABLE expr_xnum TO evergreen;
GRANT SELECT ON TABLE expr_xnum TO bbonner;


--
-- Name: expr_xop; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xop FROM PUBLIC;
REVOKE ALL ON TABLE expr_xop FROM evergreen;
GRANT ALL ON TABLE expr_xop TO evergreen;
GRANT SELECT ON TABLE expr_xop TO bbonner;


--
-- Name: expr_xser; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xser FROM PUBLIC;
REVOKE ALL ON TABLE expr_xser FROM evergreen;
GRANT ALL ON TABLE expr_xser TO evergreen;
GRANT SELECT ON TABLE expr_xser TO bbonner;


--
-- Name: expr_xstr; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xstr FROM PUBLIC;
REVOKE ALL ON TABLE expr_xstr FROM evergreen;
GRANT ALL ON TABLE expr_xstr TO evergreen;
GRANT SELECT ON TABLE expr_xstr TO bbonner;


--
-- Name: expr_xsubq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE expr_xsubq FROM PUBLIC;
REVOKE ALL ON TABLE expr_xsubq FROM evergreen;
GRANT ALL ON TABLE expr_xsubq TO evergreen;
GRANT SELECT ON TABLE expr_xsubq TO bbonner;


--
-- Name: expression_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE expression_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE expression_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE expression_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE expression_id_seq TO bbonner;


--
-- Name: from_relation; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE from_relation FROM PUBLIC;
REVOKE ALL ON TABLE from_relation FROM evergreen;
GRANT ALL ON TABLE from_relation TO evergreen;
GRANT SELECT ON TABLE from_relation TO bbonner;


--
-- Name: from_relation_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE from_relation_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE from_relation_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE from_relation_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE from_relation_id_seq TO bbonner;


--
-- Name: function_param_def; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE function_param_def FROM PUBLIC;
REVOKE ALL ON TABLE function_param_def FROM evergreen;
GRANT ALL ON TABLE function_param_def TO evergreen;
GRANT SELECT ON TABLE function_param_def TO bbonner;


--
-- Name: function_param_def_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE function_param_def_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE function_param_def_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE function_param_def_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE function_param_def_id_seq TO bbonner;


--
-- Name: function_sig; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE function_sig FROM PUBLIC;
REVOKE ALL ON TABLE function_sig FROM evergreen;
GRANT ALL ON TABLE function_sig TO evergreen;
GRANT SELECT ON TABLE function_sig TO bbonner;


--
-- Name: function_sig_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE function_sig_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE function_sig_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE function_sig_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE function_sig_id_seq TO bbonner;


--
-- Name: order_by_item; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE order_by_item FROM PUBLIC;
REVOKE ALL ON TABLE order_by_item FROM evergreen;
GRANT ALL ON TABLE order_by_item TO evergreen;
GRANT SELECT ON TABLE order_by_item TO bbonner;


--
-- Name: order_by_item_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE order_by_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE order_by_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE order_by_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE order_by_item_id_seq TO bbonner;


--
-- Name: query_sequence; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE query_sequence FROM PUBLIC;
REVOKE ALL ON TABLE query_sequence FROM evergreen;
GRANT ALL ON TABLE query_sequence TO evergreen;
GRANT SELECT ON TABLE query_sequence TO bbonner;


--
-- Name: query_sequence_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE query_sequence_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE query_sequence_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE query_sequence_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE query_sequence_id_seq TO bbonner;


--
-- Name: record_column; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE record_column FROM PUBLIC;
REVOKE ALL ON TABLE record_column FROM evergreen;
GRANT ALL ON TABLE record_column TO evergreen;
GRANT SELECT ON TABLE record_column TO bbonner;


--
-- Name: record_column_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_column_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_column_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_column_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE record_column_id_seq TO bbonner;


--
-- Name: select_item; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE select_item FROM PUBLIC;
REVOKE ALL ON TABLE select_item FROM evergreen;
GRANT ALL ON TABLE select_item TO evergreen;
GRANT SELECT ON TABLE select_item TO bbonner;


--
-- Name: select_item_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE select_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE select_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE select_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE select_item_id_seq TO bbonner;


--
-- Name: stored_query; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE stored_query FROM PUBLIC;
REVOKE ALL ON TABLE stored_query FROM evergreen;
GRANT ALL ON TABLE stored_query TO evergreen;
GRANT SELECT ON TABLE stored_query TO bbonner;


--
-- Name: stored_query_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stored_query_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stored_query_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stored_query_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE stored_query_id_seq TO bbonner;


--
-- Name: subfield; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON TABLE subfield FROM PUBLIC;
REVOKE ALL ON TABLE subfield FROM evergreen;
GRANT ALL ON TABLE subfield TO evergreen;
GRANT SELECT ON TABLE subfield TO bbonner;


--
-- Name: subfield_id_seq; Type: ACL; Schema: query; Owner: evergreen
--

REVOKE ALL ON SEQUENCE subfield_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE subfield_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE subfield_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE subfield_id_seq TO bbonner;


SET search_path = reporter, pg_catalog;

--
-- Name: circ_type; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE circ_type FROM PUBLIC;
REVOKE ALL ON TABLE circ_type FROM evergreen;
GRANT ALL ON TABLE circ_type TO evergreen;
GRANT ALL ON TABLE circ_type TO bbonner;


--
-- Name: demographic; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE demographic FROM PUBLIC;
REVOKE ALL ON TABLE demographic FROM evergreen;
GRANT ALL ON TABLE demographic TO evergreen;
GRANT ALL ON TABLE demographic TO bbonner;


--
-- Name: classic_current_billing_summary; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE classic_current_billing_summary FROM PUBLIC;
REVOKE ALL ON TABLE classic_current_billing_summary FROM evergreen;
GRANT ALL ON TABLE classic_current_billing_summary TO evergreen;
GRANT ALL ON TABLE classic_current_billing_summary TO bbonner;


--
-- Name: classic_current_circ; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE classic_current_circ FROM PUBLIC;
REVOKE ALL ON TABLE classic_current_circ FROM evergreen;
GRANT ALL ON TABLE classic_current_circ TO evergreen;
GRANT ALL ON TABLE classic_current_circ TO bbonner;


--
-- Name: materialized_simple_record; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE materialized_simple_record FROM PUBLIC;
REVOKE ALL ON TABLE materialized_simple_record FROM evergreen;
GRANT ALL ON TABLE materialized_simple_record TO evergreen;
GRANT ALL ON TABLE materialized_simple_record TO bbonner;


--
-- Name: classic_item_list; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE classic_item_list FROM PUBLIC;
REVOKE ALL ON TABLE classic_item_list FROM evergreen;
GRANT ALL ON TABLE classic_item_list TO evergreen;
GRANT ALL ON TABLE classic_item_list TO bbonner;


--
-- Name: report; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE report FROM PUBLIC;
REVOKE ALL ON TABLE report FROM evergreen;
GRANT ALL ON TABLE report TO evergreen;
GRANT ALL ON TABLE report TO bbonner;


--
-- Name: schedule; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE schedule FROM PUBLIC;
REVOKE ALL ON TABLE schedule FROM evergreen;
GRANT ALL ON TABLE schedule TO evergreen;
GRANT ALL ON TABLE schedule TO bbonner;


--
-- Name: currently_running; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE currently_running FROM PUBLIC;
REVOKE ALL ON TABLE currently_running FROM evergreen;
GRANT ALL ON TABLE currently_running TO evergreen;
GRANT ALL ON TABLE currently_running TO bbonner;


SET search_path = serial, pg_catalog;

--
-- Name: issuance; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE issuance FROM PUBLIC;
REVOKE ALL ON TABLE issuance FROM evergreen;
GRANT ALL ON TABLE issuance TO evergreen;
GRANT SELECT ON TABLE issuance TO bbonner;


--
-- Name: subscription; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE subscription FROM PUBLIC;
REVOKE ALL ON TABLE subscription FROM evergreen;
GRANT ALL ON TABLE subscription TO evergreen;
GRANT SELECT ON TABLE subscription TO bbonner;


SET search_path = reporter, pg_catalog;

--
-- Name: hold_request_record; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE hold_request_record FROM PUBLIC;
REVOKE ALL ON TABLE hold_request_record FROM evergreen;
GRANT ALL ON TABLE hold_request_record TO evergreen;
GRANT ALL ON TABLE hold_request_record TO bbonner;


--
-- Name: legacy_cat1; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE legacy_cat1 FROM PUBLIC;
REVOKE ALL ON TABLE legacy_cat1 FROM evergreen;
GRANT ALL ON TABLE legacy_cat1 TO evergreen;
GRANT ALL ON TABLE legacy_cat1 TO bbonner;


--
-- Name: legacy_cat2; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE legacy_cat2 FROM PUBLIC;
REVOKE ALL ON TABLE legacy_cat2 FROM evergreen;
GRANT ALL ON TABLE legacy_cat2 TO evergreen;
GRANT ALL ON TABLE legacy_cat2 TO bbonner;


--
-- Name: old_super_simple_record; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE old_super_simple_record FROM PUBLIC;
REVOKE ALL ON TABLE old_super_simple_record FROM evergreen;
GRANT ALL ON TABLE old_super_simple_record TO evergreen;
GRANT ALL ON TABLE old_super_simple_record TO bbonner;


--
-- Name: output_folder; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE output_folder FROM PUBLIC;
REVOKE ALL ON TABLE output_folder FROM evergreen;
GRANT ALL ON TABLE output_folder TO evergreen;
GRANT ALL ON TABLE output_folder TO bbonner;


--
-- Name: output_folder_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE output_folder_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE output_folder_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE output_folder_id_seq TO evergreen;
GRANT ALL ON SEQUENCE output_folder_id_seq TO bbonner;


--
-- Name: overdue_circs; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE overdue_circs FROM PUBLIC;
REVOKE ALL ON TABLE overdue_circs FROM evergreen;
GRANT ALL ON TABLE overdue_circs TO evergreen;
GRANT ALL ON TABLE overdue_circs TO bbonner;


--
-- Name: overdue_reports; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE overdue_reports FROM PUBLIC;
REVOKE ALL ON TABLE overdue_reports FROM evergreen;
GRANT ALL ON TABLE overdue_reports TO evergreen;
GRANT ALL ON TABLE overdue_reports TO bbonner;


--
-- Name: pending_reports; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE pending_reports FROM PUBLIC;
REVOKE ALL ON TABLE pending_reports FROM evergreen;
GRANT ALL ON TABLE pending_reports TO evergreen;
GRANT ALL ON TABLE pending_reports TO bbonner;


--
-- Name: report_folder; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE report_folder FROM PUBLIC;
REVOKE ALL ON TABLE report_folder FROM evergreen;
GRANT ALL ON TABLE report_folder TO evergreen;
GRANT ALL ON TABLE report_folder TO bbonner;


--
-- Name: report_folder_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE report_folder_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE report_folder_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE report_folder_id_seq TO evergreen;
GRANT ALL ON SEQUENCE report_folder_id_seq TO bbonner;


--
-- Name: report_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE report_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE report_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE report_id_seq TO evergreen;
GRANT ALL ON SEQUENCE report_id_seq TO bbonner;


--
-- Name: schedule_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE schedule_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE schedule_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE schedule_id_seq TO evergreen;
GRANT ALL ON SEQUENCE schedule_id_seq TO bbonner;


--
-- Name: simple_record; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE simple_record FROM PUBLIC;
REVOKE ALL ON TABLE simple_record FROM evergreen;
GRANT ALL ON TABLE simple_record TO evergreen;
GRANT ALL ON TABLE simple_record TO bbonner;


--
-- Name: super_simple_record; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE super_simple_record FROM PUBLIC;
REVOKE ALL ON TABLE super_simple_record FROM evergreen;
GRANT ALL ON TABLE super_simple_record TO evergreen;
GRANT ALL ON TABLE super_simple_record TO bbonner;


--
-- Name: template; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE template FROM PUBLIC;
REVOKE ALL ON TABLE template FROM evergreen;
GRANT ALL ON TABLE template TO evergreen;
GRANT ALL ON TABLE template TO bbonner;


--
-- Name: template_folder; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE template_folder FROM PUBLIC;
REVOKE ALL ON TABLE template_folder FROM evergreen;
GRANT ALL ON TABLE template_folder TO evergreen;
GRANT ALL ON TABLE template_folder TO bbonner;


--
-- Name: template_folder_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE template_folder_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE template_folder_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE template_folder_id_seq TO evergreen;
GRANT ALL ON SEQUENCE template_folder_id_seq TO bbonner;


--
-- Name: template_id_seq; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON SEQUENCE template_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE template_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE template_id_seq TO evergreen;
GRANT ALL ON SEQUENCE template_id_seq TO bbonner;


--
-- Name: xact_billing_totals; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE xact_billing_totals FROM PUBLIC;
REVOKE ALL ON TABLE xact_billing_totals FROM evergreen;
GRANT ALL ON TABLE xact_billing_totals TO evergreen;
GRANT ALL ON TABLE xact_billing_totals TO bbonner;


--
-- Name: xact_paid_totals; Type: ACL; Schema: reporter; Owner: evergreen
--

REVOKE ALL ON TABLE xact_paid_totals FROM PUBLIC;
REVOKE ALL ON TABLE xact_paid_totals FROM evergreen;
GRANT ALL ON TABLE xact_paid_totals TO evergreen;
GRANT ALL ON TABLE xact_paid_totals TO bbonner;


SET search_path = search, pg_catalog;

--
-- Name: relevance_adjustment; Type: ACL; Schema: search; Owner: evergreen
--

REVOKE ALL ON TABLE relevance_adjustment FROM PUBLIC;
REVOKE ALL ON TABLE relevance_adjustment FROM evergreen;
GRANT ALL ON TABLE relevance_adjustment TO evergreen;
GRANT SELECT ON TABLE relevance_adjustment TO bbonner;


--
-- Name: relevance_adjustment_id_seq; Type: ACL; Schema: search; Owner: evergreen
--

REVOKE ALL ON SEQUENCE relevance_adjustment_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE relevance_adjustment_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE relevance_adjustment_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE relevance_adjustment_id_seq TO bbonner;


SET search_path = serial, pg_catalog;

--
-- Name: basic_summary; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE basic_summary FROM PUBLIC;
REVOKE ALL ON TABLE basic_summary FROM evergreen;
GRANT ALL ON TABLE basic_summary TO evergreen;
GRANT SELECT ON TABLE basic_summary TO bbonner;


--
-- Name: index_summary; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE index_summary FROM PUBLIC;
REVOKE ALL ON TABLE index_summary FROM evergreen;
GRANT ALL ON TABLE index_summary TO evergreen;
GRANT SELECT ON TABLE index_summary TO bbonner;


--
-- Name: supplement_summary; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE supplement_summary FROM PUBLIC;
REVOKE ALL ON TABLE supplement_summary FROM evergreen;
GRANT ALL ON TABLE supplement_summary TO evergreen;
GRANT SELECT ON TABLE supplement_summary TO bbonner;


--
-- Name: basic_summary_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE basic_summary_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE basic_summary_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE basic_summary_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE basic_summary_id_seq TO bbonner;


--
-- Name: caption_and_pattern; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE caption_and_pattern FROM PUBLIC;
REVOKE ALL ON TABLE caption_and_pattern FROM evergreen;
GRANT ALL ON TABLE caption_and_pattern TO evergreen;
GRANT SELECT ON TABLE caption_and_pattern TO bbonner;


--
-- Name: caption_and_pattern_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE caption_and_pattern_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE caption_and_pattern_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE caption_and_pattern_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE caption_and_pattern_id_seq TO bbonner;


--
-- Name: distribution; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE distribution FROM PUBLIC;
REVOKE ALL ON TABLE distribution FROM evergreen;
GRANT ALL ON TABLE distribution TO evergreen;
GRANT SELECT ON TABLE distribution TO bbonner;


--
-- Name: distribution_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE distribution_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE distribution_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE distribution_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE distribution_id_seq TO bbonner;


--
-- Name: distribution_note; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE distribution_note FROM PUBLIC;
REVOKE ALL ON TABLE distribution_note FROM evergreen;
GRANT ALL ON TABLE distribution_note TO evergreen;
GRANT SELECT ON TABLE distribution_note TO bbonner;


--
-- Name: distribution_note_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE distribution_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE distribution_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE distribution_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE distribution_note_id_seq TO bbonner;


--
-- Name: index_summary_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE index_summary_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE index_summary_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE index_summary_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE index_summary_id_seq TO bbonner;


--
-- Name: issuance_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE issuance_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE issuance_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE issuance_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE issuance_id_seq TO bbonner;


--
-- Name: item; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE item FROM PUBLIC;
REVOKE ALL ON TABLE item FROM evergreen;
GRANT ALL ON TABLE item TO evergreen;
GRANT SELECT ON TABLE item TO bbonner;


--
-- Name: item_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE item_id_seq TO bbonner;


--
-- Name: item_note; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE item_note FROM PUBLIC;
REVOKE ALL ON TABLE item_note FROM evergreen;
GRANT ALL ON TABLE item_note TO evergreen;
GRANT SELECT ON TABLE item_note TO bbonner;


--
-- Name: item_note_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE item_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE item_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE item_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE item_note_id_seq TO bbonner;


--
-- Name: record_entry; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE record_entry FROM PUBLIC;
REVOKE ALL ON TABLE record_entry FROM evergreen;
GRANT ALL ON TABLE record_entry TO evergreen;
GRANT SELECT ON TABLE record_entry TO bbonner;


--
-- Name: record_entry_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE record_entry_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE record_entry_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE record_entry_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE record_entry_id_seq TO bbonner;


--
-- Name: routing_list_user; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE routing_list_user FROM PUBLIC;
REVOKE ALL ON TABLE routing_list_user FROM evergreen;
GRANT ALL ON TABLE routing_list_user TO evergreen;
GRANT SELECT ON TABLE routing_list_user TO bbonner;


--
-- Name: routing_list_user_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE routing_list_user_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE routing_list_user_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE routing_list_user_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE routing_list_user_id_seq TO bbonner;


--
-- Name: stream; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE stream FROM PUBLIC;
REVOKE ALL ON TABLE stream FROM evergreen;
GRANT ALL ON TABLE stream TO evergreen;
GRANT SELECT ON TABLE stream TO bbonner;


--
-- Name: stream_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE stream_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE stream_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE stream_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE stream_id_seq TO bbonner;


--
-- Name: subscription_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE subscription_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE subscription_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE subscription_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE subscription_id_seq TO bbonner;


--
-- Name: subscription_note; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON TABLE subscription_note FROM PUBLIC;
REVOKE ALL ON TABLE subscription_note FROM evergreen;
GRANT ALL ON TABLE subscription_note TO evergreen;
GRANT SELECT ON TABLE subscription_note TO bbonner;


--
-- Name: subscription_note_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE subscription_note_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE subscription_note_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE subscription_note_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE subscription_note_id_seq TO bbonner;


--
-- Name: supplement_summary_id_seq; Type: ACL; Schema: serial; Owner: evergreen
--

REVOKE ALL ON SEQUENCE supplement_summary_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE supplement_summary_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE supplement_summary_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE supplement_summary_id_seq TO bbonner;


SET search_path = sip_temp, pg_catalog;

--
-- Name: user; Type: ACL; Schema: sip_temp; Owner: evergreen
--

REVOKE ALL ON TABLE "user" FROM PUBLIC;
REVOKE ALL ON TABLE "user" FROM evergreen;
GRANT ALL ON TABLE "user" TO evergreen;
GRANT SELECT ON TABLE "user" TO bbonner;


SET search_path = staging, pg_catalog;

--
-- Name: mailing_address_stage; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON TABLE mailing_address_stage FROM PUBLIC;
REVOKE ALL ON TABLE mailing_address_stage FROM evergreen;
GRANT ALL ON TABLE mailing_address_stage TO evergreen;
GRANT SELECT ON TABLE mailing_address_stage TO bbonner;


--
-- Name: mailing_address_stage_row_id_seq; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON SEQUENCE mailing_address_stage_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE mailing_address_stage_row_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE mailing_address_stage_row_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE mailing_address_stage_row_id_seq TO bbonner;


--
-- Name: billing_address_stage; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON TABLE billing_address_stage FROM PUBLIC;
REVOKE ALL ON TABLE billing_address_stage FROM evergreen;
GRANT ALL ON TABLE billing_address_stage TO evergreen;
GRANT SELECT ON TABLE billing_address_stage TO bbonner;


--
-- Name: card_stage; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON TABLE card_stage FROM PUBLIC;
REVOKE ALL ON TABLE card_stage FROM evergreen;
GRANT ALL ON TABLE card_stage TO evergreen;
GRANT SELECT ON TABLE card_stage TO bbonner;


--
-- Name: card_stage_row_id_seq; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON SEQUENCE card_stage_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE card_stage_row_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE card_stage_row_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE card_stage_row_id_seq TO bbonner;


--
-- Name: statcat_stage; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON TABLE statcat_stage FROM PUBLIC;
REVOKE ALL ON TABLE statcat_stage FROM evergreen;
GRANT ALL ON TABLE statcat_stage TO evergreen;
GRANT SELECT ON TABLE statcat_stage TO bbonner;


--
-- Name: statcat_stage_row_id_seq; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON SEQUENCE statcat_stage_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE statcat_stage_row_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE statcat_stage_row_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE statcat_stage_row_id_seq TO bbonner;


--
-- Name: user_stage; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON TABLE user_stage FROM PUBLIC;
REVOKE ALL ON TABLE user_stage FROM evergreen;
GRANT ALL ON TABLE user_stage TO evergreen;
GRANT SELECT ON TABLE user_stage TO bbonner;


--
-- Name: user_stage_row_id_seq; Type: ACL; Schema: staging; Owner: evergreen
--

REVOKE ALL ON SEQUENCE user_stage_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE user_stage_row_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE user_stage_row_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE user_stage_row_id_seq TO bbonner;


SET search_path = vandelay, pg_catalog;

--
-- Name: authority_attr_definition; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE authority_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE authority_attr_definition FROM evergreen;
GRANT ALL ON TABLE authority_attr_definition TO evergreen;
GRANT SELECT ON TABLE authority_attr_definition TO bbonner;


--
-- Name: authority_attr_definition_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE authority_attr_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE authority_attr_definition_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE authority_attr_definition_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE authority_attr_definition_id_seq TO bbonner;


--
-- Name: authority_match; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE authority_match FROM PUBLIC;
REVOKE ALL ON TABLE authority_match FROM evergreen;
GRANT ALL ON TABLE authority_match TO evergreen;
GRANT SELECT ON TABLE authority_match TO bbonner;


--
-- Name: authority_match_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE authority_match_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE authority_match_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE authority_match_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE authority_match_id_seq TO bbonner;


--
-- Name: queue; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queue FROM PUBLIC;
REVOKE ALL ON TABLE queue FROM evergreen;
GRANT ALL ON TABLE queue TO evergreen;
GRANT SELECT ON TABLE queue TO bbonner;


--
-- Name: authority_queue; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE authority_queue FROM PUBLIC;
REVOKE ALL ON TABLE authority_queue FROM evergreen;
GRANT ALL ON TABLE authority_queue TO evergreen;
GRANT SELECT ON TABLE authority_queue TO bbonner;


--
-- Name: bib_attr_definition; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE bib_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE bib_attr_definition FROM evergreen;
GRANT ALL ON TABLE bib_attr_definition TO evergreen;
GRANT SELECT ON TABLE bib_attr_definition TO bbonner;


--
-- Name: bib_attr_definition_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bib_attr_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bib_attr_definition_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE bib_attr_definition_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE bib_attr_definition_id_seq TO bbonner;


--
-- Name: bib_match; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE bib_match FROM PUBLIC;
REVOKE ALL ON TABLE bib_match FROM evergreen;
GRANT ALL ON TABLE bib_match TO evergreen;
GRANT SELECT ON TABLE bib_match TO bbonner;


--
-- Name: bib_match_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE bib_match_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bib_match_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE bib_match_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE bib_match_id_seq TO bbonner;


--
-- Name: bib_queue; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE bib_queue FROM PUBLIC;
REVOKE ALL ON TABLE bib_queue FROM evergreen;
GRANT ALL ON TABLE bib_queue TO evergreen;
GRANT SELECT ON TABLE bib_queue TO bbonner;


--
-- Name: import_bib_trash_fields; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE import_bib_trash_fields FROM PUBLIC;
REVOKE ALL ON TABLE import_bib_trash_fields FROM evergreen;
GRANT ALL ON TABLE import_bib_trash_fields TO evergreen;
GRANT SELECT ON TABLE import_bib_trash_fields TO bbonner;


--
-- Name: import_bib_trash_fields_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE import_bib_trash_fields_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE import_bib_trash_fields_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE import_bib_trash_fields_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE import_bib_trash_fields_id_seq TO bbonner;


--
-- Name: import_item_attr_definition; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE import_item_attr_definition FROM PUBLIC;
REVOKE ALL ON TABLE import_item_attr_definition FROM evergreen;
GRANT ALL ON TABLE import_item_attr_definition TO evergreen;
GRANT SELECT ON TABLE import_item_attr_definition TO bbonner;


--
-- Name: import_item_attr_definition_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE import_item_attr_definition_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE import_item_attr_definition_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE import_item_attr_definition_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE import_item_attr_definition_id_seq TO bbonner;


--
-- Name: import_item_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE import_item_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE import_item_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE import_item_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE import_item_id_seq TO bbonner;


--
-- Name: merge_profile; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE merge_profile FROM PUBLIC;
REVOKE ALL ON TABLE merge_profile FROM evergreen;
GRANT ALL ON TABLE merge_profile TO evergreen;
GRANT SELECT ON TABLE merge_profile TO bbonner;


--
-- Name: merge_profile_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE merge_profile_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE merge_profile_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE merge_profile_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE merge_profile_id_seq TO bbonner;


--
-- Name: queue_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE queue_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE queue_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE queue_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE queue_id_seq TO bbonner;


--
-- Name: queued_record; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queued_record FROM PUBLIC;
REVOKE ALL ON TABLE queued_record FROM evergreen;
GRANT ALL ON TABLE queued_record TO evergreen;
GRANT SELECT ON TABLE queued_record TO bbonner;


--
-- Name: queued_authority_record; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queued_authority_record FROM PUBLIC;
REVOKE ALL ON TABLE queued_authority_record FROM evergreen;
GRANT ALL ON TABLE queued_authority_record TO evergreen;
GRANT SELECT ON TABLE queued_authority_record TO bbonner;


--
-- Name: queued_authority_record_attr; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queued_authority_record_attr FROM PUBLIC;
REVOKE ALL ON TABLE queued_authority_record_attr FROM evergreen;
GRANT ALL ON TABLE queued_authority_record_attr TO evergreen;
GRANT SELECT ON TABLE queued_authority_record_attr TO bbonner;


--
-- Name: queued_authority_record_attr_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE queued_authority_record_attr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE queued_authority_record_attr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE queued_authority_record_attr_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE queued_authority_record_attr_id_seq TO bbonner;


--
-- Name: queued_bib_record; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queued_bib_record FROM PUBLIC;
REVOKE ALL ON TABLE queued_bib_record FROM evergreen;
GRANT ALL ON TABLE queued_bib_record TO evergreen;
GRANT SELECT ON TABLE queued_bib_record TO bbonner;


--
-- Name: queued_bib_record_attr; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON TABLE queued_bib_record_attr FROM PUBLIC;
REVOKE ALL ON TABLE queued_bib_record_attr FROM evergreen;
GRANT ALL ON TABLE queued_bib_record_attr TO evergreen;
GRANT SELECT ON TABLE queued_bib_record_attr TO bbonner;


--
-- Name: queued_bib_record_attr_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE queued_bib_record_attr_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE queued_bib_record_attr_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE queued_bib_record_attr_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE queued_bib_record_attr_id_seq TO bbonner;


--
-- Name: queued_record_id_seq; Type: ACL; Schema: vandelay; Owner: evergreen
--

REVOKE ALL ON SEQUENCE queued_record_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE queued_record_id_seq FROM evergreen;
GRANT ALL ON SEQUENCE queued_record_id_seq TO evergreen;
GRANT USAGE ON SEQUENCE queued_record_id_seq TO bbonner;


--
-- PostgreSQL database dump complete
--

